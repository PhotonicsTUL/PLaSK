## root element, includes sections which describe any aspects of experiment
start = element plask {
    materials?,
    geometry?,
    grids?,
    solvers?,
    connects?,
    script?
}


# ========== materials section ==========

materials =
## materials section, allows to define new materials
element materials {
(
    include_attr |
    ## define new material
    element material {
        ## name of defined material
        attribute name { text } &
        (
            ## base class of defined material, all undefined properties are inharited from this class
            attribute base { text } |
            ## kind of defined material
            attribute kind { text }
        ) &

	## Lattice constant [A]; parameters:
	## T - temperature [K],
	## x - lattice parameter [-].
	element (lattC) { text }?	&

	## Energy gap Eg [eV]; parameters:
	## T - temperature [K],
	## point - point in the Brillouin zone [-].
	element (Eg) { text }?		&

	## Conduction band offset CBO [eV]; parameters:
	## T - temperature [K],
	## point - point in the Brillouin zone [-].
	element (CBO) { text }?		&

	## Valance band offset VBO[eV]; parameters:
	## T - temperature [K],
	## valance - band offset VBO[eV].
	element (VBO) { text }?		&

	## Split-off energy Dso [eV]; parameters:
	## T - temperature [K].
	element (Dso) { text }?		&

	## Split-off mass Mso [m_0]; parameters:
	## T - temperature [K].
	element (Mso) { text }?		&

	## Electron effective mass Me in in-plane (lateral) and cross-plane (vertical) direction [m_0]; parameters:
	## T - temperature [K],
	## point - point in the Brillouin zone [-].
	element (Me) { text }?		&

	## Heavy hole effective mass Mhh in in-plane (lateral) and cross-plane (vertical) direction [m_0]; parameters:
	## T - temperature [K],
	## point - point in the Brillouin zone [-].
	element (Mhh) { text }?		&

	## Light hole effective mass Mlh in in-plane (lateral) and cross-plane (vertical) direction [m_0]; parameters:
	## T - temperature [K],
	## point - point in the Brillouin zone [-].
	element (Mlh) { text }?		&

	## Hole effective mass Mh in in-plane (lateral) and cross-plane (vertical) direction [m_0]; parameters:
	## T - temperature [K],
	## EqType - equation type [-].
	element (Mh) { text }?		&

	## Hydrostatic deformation potential for the conduction band ac [eV]; parameters:
	## T - temperature [K].
	element (ac) { text }?		&

	## Hydrostatic deformation potential for the valence band av [eV]; parameters:
	## T - temperature [K].
	element (av) { text }?		&

	## Shear deformation potential b [eV]; parameters:
	## T - temperature [K].
	element (b) { text }?		&

	## Elastic constant c11 [GPa]; parameters:
	## T - temperature [K].
	element (c11) { text }?		&

	## elastic constant c12 [GPa]; parameters:
	## T - temperature [K].
	element (c12) { text }?		&

	## Dielectric constant EpsR [-]; parameters:
	## T - temperature [K].
	element (eps) { text }?		&

	## Electron affinity Chi[eV]; parameters:
	## T - temperature [K],
	## point - point in the Brillouin zone [-].
	element (chi) { text }?		&

	## Effective density of states in the conduction band Nc [cm^(-3)]; parameters:
	## T - temperature [K],
	## point - point in the Brillouin zone [-].
	element (Nc) { text }?		&

	## Effective density of states in the valance band Nv [cm^(-3)]; parameters:
	## T - temperature [K].
	element (Nv) { text }?		&

	## Intrinsic carrier concentration Ni [cm^(-3)]; parameters:
	## T - temperature [K].
	element (Ni) { text }?		&

	## Free carrier concentration N [cm^(-3)]; parameters:
	## T - temperature [K].
	element (Nf) { text }?		&

	## Donor ionisation energy EactD [eV]; parameters:
	## T - temperature [K].
	element (EactD) { text }?	&

	## Acceptor ionisation energy EactA [eV]; parameters:
	## T - temperature [K].
	element (EactA) { text }?	&

	## Mobility in-plane (lateral) and cross-plane (vertical) direction [m^2/(V*s)]; parameters:
	## T - temperature [K].
	element (mob) { text }?		&

	## Electrical conductivity sigma in-plane (lateral) and cross-plane (vertical) direction [S/m]; parameters:
	## T - temperature [K].
	element (cond) { text }?	&

	## Electrical conductivity type. In semiconductors this indicates what type of carriers Nf refers to.
	element (condtype) { text }?	&

	## Monomolecular recombination coefficient A [1/s]; parameters:
	## T - temperature [K].
	element (A) { text }?		&

	## Radiative recombination coefficient B [m^3/s]; parameters:
	## T - temperature [K].
	element (B) { text }?		&

	## Auger recombination coefficient C [m^6/s]; parameters:
	## T - temperature [K].
	element (C) { text }?		&

	## Ambipolar diffusion coefficient D [m^2/s]; parameters:
	## T - temperature [K].
	element (D) { text }?		&

	## Thermal conductivity in in-plane (lateral) and cross-plane (vertical) direction k[W/(m*K)]; parameters:
	## T - temperature [K],
	## h - layer thickness [µm].
	element (thermk) { text }?	&

	## Density [kg/m^3]; parameters:
	## T - temperature [K].
	element (dens) { text }?	&

	## Specific heat at constant pressure [J/(kg*K)]; parameters:
	## T - temperature [K].
	element (cp) { text }?		&

	## Refractive index nR [-]; parameters:
	## wl - Wavelength [nm],
	## T - temperature [K].
	element (nr) { text }?		&

	## Absorption coefficient alpha [cm^(-1)]; parameters:
	## wl - Wavelength [nm],
	## T - temperature [K].
	element (absp) { text }?	&

	## Refractive index nR [-]; parameters:
	## wl - Wavelength [nm],
	## T - temperature [K].
	element (nR) { text }?		&

	## Anisotropic refractive index tensor nR [-]. Tensor must have the form [n_0, n_3, 0 / n_4, n_1, 0 / 0, 0, n_2] where n_i is i-th object of the returned tuple; parameters:
	## wl - Wavelength [nm],
	## T - temperature [K].
	element (nR_tensor) { text }?
    }*
)
}


# ========== geometry section ==========

geometry =
## geometry section, allows to describe structure of device
element geometry {
(
    include_attr |
    (
    ## cartesian geometry in 2D space
    element cartesian2d {
        name_attr?,
        (  (length_attr?, geometry_object2d) | extrusion  )
    } |
    ## cylindrical geometry in 2D space
    element (cylindrical|cylindrical2d) { name_attr?, geometry_object2d } |
    ## cartesian geometry in 3D space
    element cartesian3d { name_attr?, geometry_object3d }
    )*
)
}

again =
## insert again a previously defined named object
element again {
    ## name of earlier defined object which should be inserted here
    attribute ref { text }
}

geom_elem_common.attlist = name_attr?,
    ## change names of axes in subtree represented by this element
    attribute axes { text }?    #TODO enumerate values

geom_item_common.attlist =
    ## names of paths which should lies on edge represented by this element
    attribute path { text }?


length_attr =
	## length, size of object in 3rd dimension
	attribute length { xsd:double }

anyAxes_double_attr =
	## size/translation in given direction
	attribute (x|y|z|p|r|lon|tran|up) { xsd:double }

aligner_tran_attr =
	## location in tran. direction
	attribute (left|right|trancenter|rcenter|ycenter|xcenter|tran|r|y|x) { xsd:double }

aligner_long_attr =
	## location in long. direction
	attribute (front|back|longcenter|pcenter|xcenter|zcenter|long|p|x|z) { xsd:double }

aligner_vert_attr =
	## location in vert. direction
	attribute (top|bottom|vertcenter|zcenter|ycenter|vert|z|y) { xsd:double }

aligner_any_attr =
	aligner_tran_attr|aligner_long_attr|aligner_vert_attr

material_attr =
	## name (and composition) of material, e.g. "air", "AlN", "Al(0.2)GaN", "Al(0.2)GaN:Mg=7e18"
	attribute material { text }


# ====== extrusion ======

extrusion =
	## 3D geometry object which are extend of 2D object (item) in lon direction
	element extrusion { geom_elem_common.attlist, length_attr, geometry_object2d }


# ====== revolution ======

revolution =
	## 3D geometry object which is an effect of revolving a 2D object (item) around the up axis
	element revolution { geom_elem_common.attlist, geometry_object2d }


# ====== block ======

block.attlist = geom_elem_common.attlist, material_attr, anyAxes_double_attr*

block2d =
	## rectangle object filled with one material
	element (block2d|rectangle) { block.attlist }

block_as_2d =
	## rectangle object filled with one material
	element (block|block2d|rectangle) { block.attlist }

block3d =
	## cuboid object filled with one material
	element (block3d|cuboid) { block.attlist }

block_as_3d =
	## cuboid object filled with one material
	element (block|block3d|cuboid) { block.attlist }

# ====== cylinder ======

cylinder =
	## Cylinders with center of base at point (0.0, 0.0, 0.0)
	element(cylinder) { geom_elem_common.attlist, material_attr,
		## height of cylinder
		attribute (height) { xsd:double },
		## radius of cylinder base
		attribute (radius) { xsd:double }
	}

# ====== translation ======

translation.attlist = geom_elem_common.attlist, anyAxes_double_attr*
translation2d.content = translation.attlist, geometry_object2d

translation2d =
	## geometry object equal to its item (2D) translated by vector
	element translation2d { translation2d.content }

translation_as_2d =
	## geometry object equal to its item (2D) translated by vector
	element (translation|translation2d) { translation2d.content }

translation3d.content = translation.attlist, geometry_object3d

translation3d =
	## geometry object equal to its item (3D) translated by vector
	element translation3d { translation3d.content }

translation_as_3d =
	## geometry object equal to its item (3D) translated by vector
	element (translation|translation3d) { translation3d.content }


# ====== container (with translations) ======

container2d.content = geom_elem_common.attlist,
    (   element item { geom_item_common.attlist, aligner_any_attr*, geometry_object2d } | geometry_object2d   )*
container2d = element (container2d) { container2d.content }
container_as_2d = element (container|container2d) { container2d.content }
container3d.content = geom_elem_common.attlist,
    (   element item { geom_item_common.attlist, aligner_any_attr*, geometry_object3d } | geometry_object3d   )*
container3d = element (container3d) { container3d.content }
container_as_3d = element (container|container3d) { container3d.content }

# ====== align container ======
align_container2d.content = geom_elem_common.attlist, (aligner_tran_attr|aligner_vert_attr),
    (   element item { geom_item_common.attlist, (aligner_tran_attr|aligner_vert_attr)?, geometry_object2d } | geometry_object2d   )*
align_container2d = element (align2d) { align_container2d.content }
align_container_as_2d = element (align|align2d) { align_container2d.content }
align_container3d.content = geom_elem_common.attlist, aligner_any_attr,
    (   element item { geom_item_common.attlist, aligner_any_attr*, geometry_object2d } | geometry_object3d   )*
align_container3d = element (align3d) { align_container3d.content }
align_container_as_3d = element (align|align3d) { align_container3d.content }

# ====== stacks ======

geom_anystack_common.attlist = geom_elem_common.attlist,
    ## height where should start first object (default value is: 0)
    attribute shift { xsd:double }?

geom_stack_common.attlist = geom_anystack_common.attlist,
    ## how many times all stack should be repeated (default value is: 1)
    attribute repeat { xsd:integer }?

zero =
    ## set zero height to be in this place
    element zero { empty }

stack2d.content = geom_stack_common.attlist, aligner_tran_attr?,
	((  element item {geom_item_common.attlist, aligner_tran_attr?, geometry_object2d} | geometry_object2d  )* & zero?)

stack2d =
	## container which have itemren in stack/layers (2D)
	element (stack2d) { stack2d.content }

stack_as_2d =
	## container which have itemren in stack/layers (2D)
	element (stack|stack2d) { stack2d.content }
stack3d.content = geom_stack_common.attlist, aligner_tran_attr?, aligner_long_attr?,
 	((  element item {geom_item_common.attlist, aligner_tran_attr?, aligner_long_attr?, geometry_object3d} | geometry_object3d  )* & zero?)

## container which have itemren in stack/layers (3D)
stack3d = element (stack3d) { stack3d.content }

stack_as_3d =
	## container which have itemren in stack/layers (3D)
	element (stack|stack3d) { stack3d.content }

shelf =
## horizontal stack
element (shelf|shelf2d) {
    geom_anystack_common.attlist,
    ## if true reader will check if all elements have same heights and will throw exception if not (false by default)
    attribute flat { xsd:boolean }?,
    (
    	(  element item {geom_item_common.attlist, geometry_object2d} | geometry_object2d  )*		&
	zero?												&
	## gap with given size or witch allow to prevent given total size of shelf (only one gap of this type is allowed)
	element gap { name_attr?, attribute (size|total) { xsd:double } }*

	#should be, but is not supported by xsd: gap witch allow to prevent given total size of shelf (only one gap of this type is allowed)
	#element gap { name_attr?, attribute total { xsd:double } }?
    )
}

#TODO align container

# ====== copy ======

object_attr =
	## name of object to modify
	attribute object { text }

copy =
## modifed copy of chosen element
element copy {
    ## name of this object (name of copy)
    name_attr?,
    ## name of object to copy
    attribute from { text },
    (
        ## replace some objects in subtree of copy by solid blocks, preserve size (of bounding-box)
        element toblock {
            ## name of object to replace
            object_attr,
            ## material of block
            material_attr
        } |
        ## replace some objects in subtree of copy by another objects
        element replace {
            ## name of replaced object
            object_attr,
            (
                ## name of object which should replace choosen object
                attribute to { text } |
                geometry_object
            )
        } |
        ## delete some objects from subtree of copy
        element delete {object_attr}
    )*
}


# ====== groups of geometry elements ======

geometry_object2d =
	## geometry element in 2D space
	(block_as_2d|translation_as_2d|container_as_2d|align_container_as_2d|stack_as_2d|shelf|copy|again)

geometry_object3d =
	## geometry element in 3D space
	(block_as_3d|cylinder|translation_as_3d|container_as_3d|align_container_as_3d|stack_as_3d|extrusion|revolution|copy|again)

geometry_object =
	## any geometry element (often space must be provided as suffix)
	(block2d|block3d|translation2d|translation3d|container2d|container3d|align_container2d|align_container3d|stack2d|stack3d|shelf|extrusion|revolution|copy|again)



# ========== grids section ==========

grids =
## grids section, allows to describe meshes and generators of mashes
element grids {
(
    include_attr | (generator | mesh)*
)
}

generator.common =
	## name
	name_attr

generator =
## mesh generator
element generator {
	generator.common,
	type_attr,
	## method
	attribute method { text },
	anyAttribute*,
	anyElement*
}

mesh.common =
	## name of mesh instance
	name_attr

mesh =
## create mesh
element mesh {
	mesh.common,
	## mesh type
	type_attr,
	anyAttribute*,
	anyElement*
}


# ========== solvers section ==========

solver.geom = element geometry {
	## name of geometry
	attribute ref { text }
}

solver.mesh = element mesh {
	## name of mesh
	attribute ref { text }
}

solver.common =
	## name for solver instance
        name_attr &
	## library name
        attribute lib { text }? &
        ## name of solver type
        attribute solver { text }

solver.common.all =
	solver.common &
	solver.geom? &
	solver.mesh?

solver = element * {
	solver.common,
        anyAttribute,
        anyElement
    }

solvers =
## solvers section, allows create instances of solvers and includes solver-specyfic configuration
element solvers {
(
    include_attr |
    ## create solver instance
    solver*
)
}

# ========== connects section ==========

connects =
## connects section, describe initial connections between providers and receivers
element connects {
(
    include_attr |
    (
        ## create provider-receiver connection
        element connect {
            ## name of the receiver (in format: solver_name.provider_name)
            attribute in {text},
            ## name of the provider (in format: solver_name.provider_name)
            attribute out {text}
        }* &

        ## create constant field profile on some goemetry object
        element profile {
            ## name of the receiver (in format: solver_name.provider_name)
            attribute in { text } &
            ## default value of the field
            attribute default { text }? &

            ## step profile on some geometry object
            element step {
                attribute object { text } &
                attribute value { text } &
                attribute path { text }?
            }*
        }*
    )
)
}


# ========== script section ==========

script =
	## script section, includes python script which describe calculation's logic
	element script { (include_attr | text) }


# ========== utils, commons ==========

anyElement = element * {
    (anyAttribute | text | anyElement)*
}

anyAttribute = attribute * { text }

name_attr =
	## name
	attribute name { text }

type_attr =
	## type
	attribute type { text }

include_attr =
	## Allow to load section from external source: file with given name
	attribute external { text }

# content for boundary condition
boundary_cond = element condition {
	## Name of this place
	attribute placename { text }? &
	(
	  ## Place description (format depends on mesh type)
	  attribute place { text } |
	  ## Name of earlier defined place to use
	  attribute placeref { text } |
	  ## Place description (format depends on mesh type)
	  element place {
		name_attr? &
		anyAttribute* &
		anyElement*
	  }
	) &
	attribute value { text }
	anyAttribute*
}


# ========== includes ==========

include "solvers.rnc"
include "meshes.rnc"
