#ifndef GUI_GEOMETRY_WRAPPER_ELEMENT_H
#define GUI_GEOMETRY_WRAPPER_ELEMENT_H

/** @file
 * This file includes interface to plask geometry objects model extensions connected with Qt.
 *
 * Typically you should call ext() function with pointer to your geometry object object as argument.
 * This function return ObjectWrapper which provide methods which operates on your object, knowing its type.
 */

#include <QPainter>
#include <QGraphicsItem>
#include "../utils/propbrowser.h"
#include "../modelext/creator.h"

QT_BEGIN_NAMESPACE
class QPainter;
class QGraphicsItem;
class QRectF;
QT_END_NAMESPACE

#include <plask/geometry/object.h>

/**
 * Wrapper over plask::GeometryObject, which:
 * - has extra method used by Qt GUI,
 * - has extra data (like object name).
 *
 * Typically you should not create object of this class or subclasses of this directly,
 * but using ext function (defined in register.h).
 */
struct ObjectWrapper {

    typedef plask::GeometryObject WrappedType;

    plask::GeometryObject* wrappedObject;

    QString name;

    /// This is typically called once, just after constructor
    virtual void setWrappedObject(plask::shared_ptr<plask::GeometryObject> plaskObject) {
        if (this->wrappedObject) this->wrappedObject->changedDisconnectMethod(this, &ObjectWrapper::onWrappedChange);
        this->wrappedObject = plaskObject.get();
        if (this->wrappedObject) this->wrappedObject->changedConnectMethod(this, &ObjectWrapper::onWrappedChange);
    }

    /// Virtual destructor, diconnect from wrapped object.
    virtual ~ObjectWrapper();

    /**
     * Store information about event connected with geometry object or its wrapper.
     *
     * Subclasses of this can includes additional information about specific type of event.
     */
    struct Event: public EventWithSourceAndFlags<ObjectWrapper> {

        /// Event flags (which describes event properties).
        typedef plask::GeometryObject::Event::Flags Flags;

        /// Non-null if event is delegeted from wrapped object.
        plask::GeometryObject::Event* delegatedEvent;

        /**
         * Get object wrapped by source of event.
         * @return object wrapped by source of event
         */
        plask::shared_ptr<plask::GeometryObject> wrappedObject() {
            return this->source().wrappedObject->shared_from_this();
        }

        /**
         * Check if given @p flag is set.
         * @param flag flag to check
         * @return @c true only if @p flag is set
         */
        bool hasFlag(Flags flag) const { return hasAnyFlag(flag); }

        /**
         * Check if DELETE flag is set, which mean that source of event is deleted.
         * @return @c true only if DELETE flag is set
         */
        bool isDelete() const { return hasFlag(plask::GeometryObject::Event::DELETE); }

        /**
         * Check if RESIZE flag is set, which mean that source of event could be resized.
         * @return @c true only if RESIZE flag is set
         */
        bool isResize() const { return hasFlag(plask::GeometryObject::Event::RESIZE); }

        /**
         * Check if DELEGATED flag is set, which mean that source delegate event from its child.
         * @return @c true only if DELEGATED flag is set
         */
        bool isDelgatedFromChild() const { return hasFlag(plask::GeometryObject::Event::DELEGATED); }

        /**
         * Check if event is delegated from wrapped object.
         * @return @c true only if event is delegated from wrapped object
         */
        bool isDelgatedFromWrappedObject() const { return delegatedEvent != nullptr; }

        /**
         * Check if CHILD_LIST flag is set, which mean that children list of source could be changed.
         * @return @c true only if CHILD_LIST flag is set
         */
        bool hasChangedChildrenList() const { return hasAnyFlag(plask::GeometryObject::Event::CHILDREN_GENERIC | plask::GeometryObject::Event::CHILDREN_INSERT | plask::GeometryObject::Event::CHILDREN_REMOVE); }

        /**
         * Construct event.
         * @param source source of event
         * @param flags which describes event's properties
         */
        explicit Event(ObjectWrapper& source, unsigned char flags = 0):
            EventWithSourceAndFlags<ObjectWrapper>(source, flags), delegatedEvent(0) {}

        /**
         * Construct event which delegete event from wrapped object.
         * @param source source of event
         * @param evt event generated by wrapped object
         */
        Event(ObjectWrapper& source, plask::GeometryObject::Event& evt)
            : EventWithSourceAndFlags<ObjectWrapper>(source, evt.flags()), delegatedEvent(&evt) {}
    };

    /// Changed signal, fired when object was changed.
    boost::signals2::signal<void(Event&)> changed;

    /**
     * Connect a method to changed signal.
     * @param obj, method slot to connect, object and it's method
     * @param at specifies where the slot should be connected:
     *  - boost::signals2::at_front indicates that the slot will be connected at the front of the list or group of slots
     *  - boost::signals2::at_back (default) indicates that the slot will be connected at the back of the list or group of slots
     */
    template <typename ClassT, typename methodT>
    boost::signals2::connection changedConnectMethod(ClassT* obj, methodT method, boost::signals2::connect_position at = boost::signals2::at_back) {
        return changed.connect(boost::bind(method, obj, _1), at);
    }

    /// Disconnect a method from changed signal
    template <typename ClassT, typename methodT>
    void changedDisconnectMethod(ClassT* obj, methodT method) {
        changed.disconnect(boost::bind(method, obj, _1));
    }

    /**
     * Call changed with this as event source.
     * @param event_constructor_params_without_source parameters for event constructor (without first - source)
     */
    template<typename EventT = Event, typename ...Args>
    void fireChanged(Args&&... event_constructor_params_without_source) {
        EventT evt(*this, std::forward<Args>(event_constructor_params_without_source)...);
        changed(evt);
    }

protected:
    void onWrappedChange(plask::GeometryObject::Event& evt) {
        fireChanged(evt);
        if (evt.isDelete()) wrappedObject = nullptr;
    }

public:

    int getDimensionsCount() const { return wrappedObject->getDimensionsCount(); }

    /**
     * @return dimentions count of children, by default same as getDimensionsCount()
     */
    virtual int getChildrenDimensionsCount() const { return getDimensionsCount(); }

    /**
     * Set new name and inform observers about this.
     * @param new_name new name
     */
    void setName(const QString& new_name) {
        name = new_name;
        fireChanged();
    }

    QString& getNameQt() {
        return name;
    }

    const QString& getNameQt() const {
        return name;
    }

    std::string getName() const {
        return name.toStdString();
    }

    /**
     * Draw geometry object using given Qt @p painter.
     * @param painter where draw object
     */
    virtual void draw(QPainter& painter, bool paintBorders = true) const;

    /**
     * Draw miniature with size close to given.
     * @param painter where miniature shpuld be drawn
     * @param w, h requested miniature size
     */
    virtual void drawMiniature(QPainter& painter, qreal w, qreal h, bool saveProp = false) const;

    /**
     * Draw real part (real children only) of geometry object using given Qt @p painter.
     * @param painter where draw object
     */
    virtual void drawReal(QPainter& painter) const;

    /**
     * Get miniature image with size close to given.
     * @param w, h requested miniature size
     * @return miniature
     */
    QPixmap getMiniature(qreal w, qreal h, bool saveProp = false) const;

    /**
     * Get string representation of given object.
     * @return string representation of wrapped object, can have multiple lines of text
     */
    virtual QString toStr() const;

    /**
     * Fill property browser with properties of wrapped object.
     */
    virtual void setupPropertiesBrowser(BrowserWithManagers& managers, QtAbstractPropertyBrowser& dst);

    void setupPropertiesBrowser(BrowserWithManagers& managers) {
        setupPropertiesBrowser(managers, managers.browser);
    }

    /**
     * Fill property browser with properties of @p container child.
     *
     * This is called only for containers and default implementation call setupPropertiesBrowser for pointed child.
     * Typically, you can call ObjectExtensionImplBase::setupPropertiesBrowserForChild in subclasses.
     * @param index real child index
     */
    virtual void setupPropertiesBrowserForChild(std::size_t index, BrowserWithManagers& managers, QtAbstractPropertyBrowser& dst);

    void setupPropertiesBrowserForChild(std::size_t index, BrowserWithManagers& managers) {
        setupPropertiesBrowserForChild(index, managers, managers.browser);
    }

    /**
     * Check if @p to_insert can be insert to this at position @p index.
     *
     * Type of @p to_insert and possible loops are checked. Also @p index is checked.
     * @return @c true if @p to_insert can be insert to this at position @p index
     */
    virtual bool canInsert(plask::shared_ptr<plask::GeometryObject> to_insert, std::size_t index) const {
        return wrappedObject->isContainer() &&
                index <= wrappedObject->getRealChildrenCount() &&
                to_insert->getDimensionsCount() == getChildrenDimensionsCount() &&
                wrappedObject->canHasAsChild(*to_insert);
    }

    virtual bool canInsert(const GeometryObjectCreator& to_insert, std::size_t index) const {
        if (!to_insert.supportDimensionsCount(getChildrenDimensionsCount())) return false;
        return canInsert(to_insert.getObject(getChildrenDimensionsCount()), index);
    }

    /**
     * Insert @p to_insert at postion @p index to this.
     * @return @c true if @p to_insert can be insert to this at position @p index
     */
    virtual bool tryInsert(plask::shared_ptr<plask::GeometryObject> to_insert, std::size_t index) {
        return false;
    }

    /**
     * Insert @p to_insert at postion @p index to this.
     * @return @c true if @p to_insert can be insert to this at position @p index
     */
    virtual bool tryInsert(const GeometryObjectCreator& to_insert, std::size_t index) {
        if (!to_insert.supportDimensionsCount(getChildrenDimensionsCount())) return false;
        return tryInsert(to_insert.getObject(getChildrenDimensionsCount()), index);
    }

    /**
     * Get child creators for thie object.
     *
     * Default implementation returns empty vector, but sublasses redefine this.
     * @return vector of creators of child of this
     */
    std::vector<const GeometryObjectCreator*> getChildCreators() const {
        return std::vector<const GeometryObjectCreator*>();
    }

    /**
     * Get index where object should be insert to be near place pointed by @p point.
     * @param point point to place in this
     * @return value which will be returned by tryInsertNearPoint2D for given point
     * @see tryInsertNearPoint2D
     */
    virtual int getInsertionIndexForPoint(const plask::Vec<2, double>& point) {
        return -1;
    }

    /**
     * Insert object @p to_insert near place pointed by @p point.
     * @param to_insert object to insert
     * @param point point to place in this, near which object @p to_insert should be inserted
     * @return index of inserted object in this, or -1 if insertion wasn't succesed
     */
    virtual int tryInsertNearPoint2D(plask::shared_ptr<plask::GeometryObject> to_insert, const plask::Vec<2, double>& point) {
        int index = getInsertionIndexForPoint(point);
        if (index == -1) return -1;
        return this->tryInsert(to_insert, index) ? index : -1;
    }

    /**
     * Insert object created by @p to_insert near place pointed by @p point.
     * @param to_insert creator of object to insert
     * @param point point to place in this, near which object @p to_insert should be inserted
     * @return index of inserted object in this, or -1 if insertion wasn't succesed
     */
    virtual int tryInsertNearPoint2D(const GeometryObjectCreator& to_insert, const plask::Vec<2, double>& point) {
        if (!to_insert.supportDimensionsCount(getChildrenDimensionsCount())) return false;
        return tryInsertNearPoint2D(to_insert.getObject(getChildrenDimensionsCount()), point);
    }

    virtual plask::Box2D getInsertPlace2D(const GeometryObjectCreator &to_insert, const plask::Vec<2, double> &point) {
        return plask::Box2D::invalidInstance();
    }

};

template <typename WrappedT, typename BaseClass = ObjectWrapper>
struct ObjectWrapperFor: public BaseClass {

    typedef WrappedT WrappedType;

    WrappedType& c() const { return static_cast<WrappedType&>(*this->wrappedObject); }

};

#endif // GUI_GEOMETRY_WRAPPER_ELEMENT_H
