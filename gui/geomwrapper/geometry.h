#ifndef GUI_GEOMETRY_WRAPPER_GEOMETRY_H
#define GUI_GEOMETRY_WRAPPER_GEOMETRY_H

#include <plask/geometry/space.h>
#include <QString>


/** @file
 * This file includes interface to plask geometry model extensions connected with Qt.
 *
 * Typically you should call ext() function with pointer to your geometry object as argument.
 * This function return GeometryWrapper which provide methods which operates on your element, knowing its type.
 */

/**
 * Wrapper over plask::Geometry, which:
 * - has extra method used by Qt GUI,
 * - has extra data (like geometry name).
 *
 * Typically you should not create object of this class or subclasses of this directly,
 * but using ext function (defined in register.h).
 */
struct GeometryWrapper
{
    typedef plask::Geometry WrappedType;

    plask::shared_ptr<plask::Geometry> wrappedElement;

    /// This is typically called once, just after constructor
    virtual void setWrappedElement(plask::shared_ptr<plask::Geometry> plaskGeometry) {
        if (this->wrappedElement) this->wrappedElement->changedDisconnectMethod(this, &GeometryWrapper::onWrappedChange);
        this->wrappedElement = plaskGeometry;
        if (this->wrappedElement) this->wrappedElement->changedConnectMethod(this, &GeometryWrapper::onWrappedChange);
    }

    /// Virtual destructor, diconnect from wrapped element.
    virtual ~GeometryWrapper();

    /**
     * Store information about event connected with geometry or its wrapper.
     *
     * Subclasses of this can includes additional information about specific type of event.
     */
    struct Event: public EventWithSourceAndFlags<GeometryWrapper> {

        /// Event flags (which describes event properties).
        typedef plask::Geometry::Event::Flags Flags;

        /// Non-null if event is delegeted from wrapped element.
        plask::Geometry::Event* delegatedEvent;

        /**
         * Get geometry wrapped by source of event.
         * @return element wrapped by source of event
         */
        plask::shared_ptr<plask::Geometry> wrappedGeometry() {
            return this->source().wrappedElement;
        }

        /**
         * Check if given @p flag is set.
         * @param flag flag to check
         * @return @c true only if @p flag is set
         */
        bool hasFlag(Flags flag) const { return hasAnyFlag(flag); }

        /**
         * Check if DELETE flag is set, which mean that source of event is deleted.
         * @return @c true only if DELETE flag is set
         */
        bool isDelete() const { return hasFlag(plask::Geometry::Event::DELETE); }

        /**
         * Check if GEOMETRY flag is set, which mean that geometry connected with source could changed.
         * @return @c true only if GEOMETRY_CHANGED flag is set
         */
        bool hasChangedGeometry() const { return hasFlag(plask::Geometry::Event::GEOMETRY); }

        /**
         * Check if BORDERS flag is set, which mean that borders connected with source could changed.
         * @return @c true only if BORDERS flag is set
         */
        bool hasChangedBorders() const { return hasFlag(plask::Geometry::Event::BORDERS); }

        /**
         * Check if event is delegated from wrapped element.
         * @return @c true only if event is delegated from wrapped element
         */
        bool isDelgatedFromWrappedElement() const { return delegatedEvent != nullptr; }

        /**
         * Construct event.
         * @param source source of event
         * @param flags which describes event's properties
         */
        explicit Event(GeometryWrapper& source, unsigned char flags = 0):
            EventWithSourceAndFlags<GeometryWrapper>(source, flags), delegatedEvent(0) {}

        /**
         * Construct event which delegete event from wrapped element.
         * @param source source of event
         * @param evt event generated by wrapped element
         */
        Event(GeometryWrapper& source, plask::Geometry::Event& evt)
            : EventWithSourceAndFlags<GeometryWrapper>(source, evt.flags()), delegatedEvent(&evt) {}
    };

    /// Changed signal, fired when element was changed.
    boost::signals2::signal<void(Event&)> changed;

    /// Connect a method to changed signal
    template <typename ClassT, typename methodT>
    boost::signals2::connection changedConnectMethod(ClassT* obj, methodT method) {
        return changed.connect(boost::bind(method, obj, _1));
    }

    /// Disconnect a method from changed signal
    template <typename ClassT, typename methodT>
    void changedDisconnectMethod(ClassT* obj, methodT method) {
        changed.disconnect(boost::bind(method, obj, _1));
    }

    /**
     * Call changed with this as event source.
     * @param event_constructor_params_without_source parameters for event constructor (without first - source)
     */
    template<typename EventT = Event, typename ...Args>
    void fireChanged(Args&&... event_constructor_params_without_source) {
        EventT evt(*this, std::forward<Args>(event_constructor_params_without_source)...);
        changed(evt);
    }

protected:
    void onWrappedChange(plask::Geometry::Event& evt) {
        fireChanged(evt);
    }

public:

    QString name;

    /**
     * Set new name and inform observers about this.
     * @param new_name new name
     */
    void setName(const QString& new_name) {
        name = new_name;
        fireChanged();
    }

    QString& getName() {
        return name;
    }

    const QString& getName() const {
        return name;
    }


};

#endif // GEOMETRY_H
