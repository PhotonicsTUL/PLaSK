#ifndef PLASK__GEOMETRY_ELEMENT_H
#define PLASK__GEOMETRY_ELEMENT_H

/** @file
This file includes base class for geometries elements.
*/


#include <vector>
#include <tuple>
#include <functional>

#include "../material/material.h"
#include "../material/air.h"
#include "primitives.h"
#include "../utils/iterators.h"

#include <boost/signals2.hpp>
#include "../utils/event.h"

#include "../axes.h"
#include "../utils/xml/writer.h"

/// Value for expected suffix for names of 2D elements types, see GeometryReader::expectedSuffix.
#define PLASK_GEOMETRY_TYPE_NAME_SUFFIX_2D "2d"

/// Value for expected suffix for names of 3D elements types, see GeometryReader::expectedSuffix.
#define PLASK_GEOMETRY_TYPE_NAME_SUFFIX_3D "3d"

namespace plask {

struct PathHints;

struct Geometry;
template < int dimensions > struct GeometryElementD;

/**
 * Base class for all geometries.
 */
struct GeometryElement: public enable_shared_from_this<GeometryElement> {

    ///Type of geometry element.
    enum Type {
        TYPE_LEAF = 0,         ///< leaf element (has no child)
        TYPE_TRANSFORM = 1,    ///< transform element (has one child)
        TYPE_SPACE_CHANGER = 2,///< transform element which changing its space, typically changing number of dimensions (has one child)
        TYPE_CONTAINER = 3,    ///< container (can have more than one child)
        TYPE_GEOMETRY = 4      ///< geometry / space
    };

    /**
     * Store information about event connected with geometry element.
     *
     * Subclasses of this can includes additional information about specific type of event.
     *
     * Note: when element is being deleted (isDelete() returns @c true), source() can't be succesfully dynamic cast to subclasses of GeometryElement,
     * because source() is already partially deleted.
     */
    struct Event: public EventWithSourceAndFlags<GeometryElement> {

        /// Event flags (which describes event properties).
        enum Flags {
            DELETE = 1,             ///< is deleted
            RESIZE = 1<<1,          ///< size could be changed
            DELEGATED = 1<<2,       ///< delegated from child
            CHILDREN_INSERT = 1<<3, ///< children was insert
            CHILDREN_REMOVE = 1<<4, ///< children was removed
            CHILDREN_GENERIC = 1<<5,///< children list was changed (other or custom changes)
            BORDERS = 1<<6,         ///< borders was changed (only Geometries/calculation spaces emit events with this flags)
            USER_DEFINED = 1<<7     ///< user-defined flags could have ids: USER_DEFINED, USER_DEFINED<<1, USER_DEFINED<<2, ...
        };

        /**
         * Get event's flags for parent in tree of geometry
         * (useful to calculate flags for event which should be generated by parent of element which is a source of this event).
         * @return flags for parent in tree of geometry
         */
        unsigned char flagsForParent() const { return flagsWithout(DELETE | CHILDREN_INSERT | CHILDREN_REMOVE | CHILDREN_GENERIC) | DELEGATED | (hasFlag(DELETE) ? RESIZE : 0); }

        /**
         * Get event's flags for parent in tree of geometry, for parents which want to delegate information about changes of children list.
         * (uses mainly by parents of hidden child to calculate flags for event which should be generated by parent of element which is a source of this event).
         *
         * Note: In most cases You should use flagsForParent() instead.
         * @return flags for parent in tree of geometry
         */
        unsigned char flagsForParentWithChildrenWasChangedInformation() const {
            unsigned char result = flagsForParent();
            if (hasAnyFlag(CHILDREN_INSERT | CHILDREN_REMOVE | CHILDREN_GENERIC)) result |= CHILDREN_GENERIC;
            return result;
        }
        
        /**
         * Check if given @p flag is set.
         * @param flag flag to check
         * @return @c true only if @p flag is set
         */
        bool hasFlag(Flags flag) const { return hasAnyFlag(flag); }

        /**
         * Check if DELETE flag is set, which mean that source of event is deleted.
         * @return @c true only if DELETE flag is set
         */
        bool isDelete() const { return hasFlag(DELETE); }

        /**
         * Check if RESIZE flag is set, which mean that source of event could be resized.
         * @return @c true only if RESIZE flag is set
         */
        bool isResize() const { return hasFlag(RESIZE); }

        /**
         * Check if DELEGATED flag is set, which mean that source delegate event from its child.
         * @return @c true only if DELEGATED flag is set
         */
        bool isDelgatedFromChild() const { return hasFlag(DELEGATED); }

        /**
         * Check if CHILD_LIST flag is set, which mean that children list of source could be changed.
         * @return @c true only if CHILD_LIST flag is set
         */
        bool hasChangedChildrenList() const { return hasAnyFlag(CHILDREN_INSERT|CHILDREN_REMOVE|CHILDREN_GENERIC); }

        /**
         * Check if BORDERS flag is set, which mean that borders connected with source could changed.
         * @return @c true only if BORDERS flag is set
         */
        bool hasChangedBorders() const { return hasFlag(BORDERS); }

        /**
         * Construct event.
         * @param source source of event
         * @param flags which describes event's properties
         */
        explicit Event(GeometryElement& source, unsigned char flags = 0): EventWithSourceAndFlags<GeometryElement>(source, flags) {}
    };
    
    /**
     * Event class for events types: CHILDREN_INSERT and CHILDREN_REMOVE.
     * 
     * Provides extra information about changes: first and last index.
     */
    struct ChildrenListChangedEvent: public Event {
        
        ChildrenListChangedEvent(GeometryElement& source, unsigned char flags, const std::size_t beginIndex, const std::size_t endIndex)
            : Event(source, flags), beginIndex(beginIndex), endIndex(endIndex) {}
        
        /// Index of first child which was changed.
        const std::size_t beginIndex;
        
        /// Index of last children which was changed incremented by 1.
        const std::size_t endIndex;
        
    };

    /**
     * This structure can refer to part of geometry tree.
     */
    struct Subtree {

        /// Geometry element.
        shared_ptr<const GeometryElement> element;

        /// Some (but not necessary all) children of element.
        std::vector<Subtree> children;

        /**
         * Construct subtree witch is empty or has only one node.
         * @param element geometry element, or null pointer to construct empty Subtree
         */
        Subtree(shared_ptr<const GeometryElement> element = shared_ptr<const GeometryElement>()): element(element) {}

        /**
         * Construct subtree.
         * @param element geometry element
         * @param children some (but not necessary all) children of @p element
         */
        Subtree(shared_ptr<const GeometryElement> element, const std::vector<Subtree>& children): element(element), children(children) {}

        /**
         * Construct subtree.
         * @param element geometry element
         * @param children some (but not necessary all) children of @p element
         */
        Subtree(shared_ptr<const GeometryElement> element, std::vector<Subtree>&& children): element(element), children(std::forward< std::vector<Subtree> >(children)) {}

        /**
         * Construct subtree which consist with given @p root element and @p children or empty element if @p children vector is empty.
         *
         * This method is used to make set of paths (subtree) longer if this set is not empty.
         * @param root potential root of constructed subtree element
         * @param children potential children of @p root in constructed subtree
         * @return subtree which consist with given @p root element and @p children or empty element if @p children vector is empty
         */
        static Subtree extendIfNotEmpty(shared_ptr<const GeometryElement> root, Subtree&& children) {
            return children.empty() ? Subtree() : Subtree(root, std::vector<Subtree>{ std::forward< Subtree >(children) });
        }

        /**
         * Construct subtree which consist with given @p root element and @p children or empty element if @p children vector is empty.
         *
         * This method is used to make set of paths (subtree) longer if this set is not empty.
         * @param root potential root of constructed subtree element
         * @param children potential children of @p root in constructed subtree
         * @return subtree which consist with given @p root element and @p children or empty element if @p children vector is empty
         */
        static Subtree extendIfNotEmpty(const GeometryElement* root, Subtree&& children) {
            return children.empty() ? Subtree() : Subtree(root->shared_from_this(), std::vector<Subtree>{ std::forward< Subtree >(children) });
        }

        /**
         * Check if this subtree inludes more than one branch (has more than one children or has one child which has more than one branch).
         * @return @c true only if this subtree inludes branches, @c false if it is linear path
         */
        bool hasBranches() const;

        /**
         * Convert this subtree to linear path: element, child[0].element, child[0].child[0].element, ...
         *
         * Throw excpetion if this subtree is not linear path (inludes more than one branch).
         * @return linear path represented by this
         */
        std::vector<shared_ptr<const GeometryElement>> toLinearPath() const;

        /**
         * Get last (last child is chosen at each level), linear path from subtree.
         * @return last path from subtree
         */
        std::vector<shared_ptr<const GeometryElement>> getLastPath() const;

        /**
         * Check if this subtree is empty (its element points to null).
         * @return @c true only if this subtree is empty.
         */
        bool empty() const { return !element; }
    };

    /**
     * Base class for geometry changers.
     *
     * Geometry changer can change GeometryElement to another one.
     */
    struct Changer {

        virtual ~Changer() {}

        /**
         * Try to apply changes.
         * @param[in,out] to_change pointer to element which eventualy will be changed (in such case pointer after call can point to another geometry element)
         * @param[out] translation optional, extra translation for element after change (in case of 2d object caller reads only \a tran and \a up components of this vector)
         * @return @c true only if something was changed, @c false if nothing was changed (in such case changer doesn't change arguments)
         */
        virtual bool apply(shared_ptr<const GeometryElement>& to_change, Vec<3, double>* translation = 0) const = 0;

    };

    /**
     * Geometry changer which holds vector of changers and try to apply this changers sequently.
     *
     * Its apply method call: changers[0].apply(to_change, translation), changers[1].apply(to_change, translation), ...
     * up to time when one of this call returns @c true (and then it returns @c true) or
     * there are no mora changers in changes vector (and then it returns @c false).
     */
    struct CompositeChanger: public Changer {

        std::vector<const Changer*> changers;

        /**
         * Construct CompositeChanger and append @p changer to its changers list.
         * @param changer changer to append, will be deleted by destructor of @c this
         */
        CompositeChanger(const Changer* changer);

        /**
         * Append @p changer to changers list.
         * @param changer changer to append
         * @return @c *this
         */
        CompositeChanger& operator()(const Changer* changer);

        /**
         * Append @p changer to changers list.
         * @param changer changer to append
         * @return @c *this
         */
        CompositeChanger& append(const Changer* changer) { return operator ()(changer); }

        /**
         * Construct empty composit changer.
         */
        CompositeChanger() {}

        /// Delete all held changers (using delete operator).
        ~CompositeChanger();

        virtual bool apply(shared_ptr<const GeometryElement>& to_change, Vec<3, double>* translation = 0) const;

    };

    /**
     * Changer which replaces given geometry element @a from to given geometry element @a to.
     */
    struct ReplaceChanger: public Changer {

        shared_ptr<const GeometryElement> from, to;

        /// Translation to return by apply.
        Vec<3, double> translation;

        /// Construct uninitilized changer.
        ReplaceChanger() {}

        /**
         * Construct changer which change @p from to @p to and return given @p translation.
         * @param from, to, translation changer parameters
         */
        ReplaceChanger(shared_ptr<const GeometryElement> from, shared_ptr<const GeometryElement> to, Vec<3, double> translation)
            : from(from), to(to), translation(translation) {}

        /**
         * Construct changer which change @p from to calc_replace(to) and return zeroed translation.
         * @param from element which should be changed
         * @param calc_replace functor which is used to calculate change destination element
         */
        template <typename F>
        ReplaceChanger(const shared_ptr<const GeometryElement>& from, F calc_replace): from(from), translation(0.0, 0.0, 0.0) {
            this->to = calc_replace(this->from);
        }

        virtual bool apply(shared_ptr<const GeometryElement>& to_change, Vec<3, double>* translation = 0) const;

    };

    /**
     * Changer which replaces given geometry element @a toChange to block (2d or 3d, depents from @a toChange)
     * with size equals to @a toChange bounding box, and with given material.
     */
    struct ToBlockChanger: public ReplaceChanger {

        ToBlockChanger(shared_ptr<const GeometryElement> toChange, shared_ptr<Material> material);

    };

    /// Predicate on GeometryElement
    typedef std::function<bool(const GeometryElement&)> Predicate;

    /// Predicate which check if given element is leaf.
    static bool PredicateIsLeaf(const GeometryElement& el) { return el.isLeaf(); }

    /// Predicate which check if given element is another instance of some particular element (given in constructor).
    struct PredicateIsA {
        const GeometryElement& elementToBeEqual;
        PredicateIsA(const GeometryElement& elementToBeEqual): elementToBeEqual(elementToBeEqual) {}
        PredicateIsA(const shared_ptr<GeometryElement>& elementToBeEqual): elementToBeEqual(*elementToBeEqual) {}
        PredicateIsA(const shared_ptr<const GeometryElement>& elementToBeEqual): elementToBeEqual(*elementToBeEqual) {}
        bool operator()(const GeometryElement& el) const { return &el == &elementToBeEqual; }
    };
    
    /**
     * Base class for callbacks used by save() method to get names of elements and paths.
     *
     * Default implementation just returns empty names and list of names.
     * It is enaught to save geometry tree without any names or with all names auto-generated (see @ref prerareToAutonaming).
     *
     * Example (save vector of elements to dest XML in "geometry" section):
     * @code
     * //std::vector<const plask::GeomtryElement*> to_save; //root of trees to save
     * //XMLWriter dest;               //destination, output XML
     * WriteXMLCallback namer;         //or subclass of WriteXMLCallback
     * //this is required only if elments should have auto-generated names:
     * for (auto e: to_save) namer.prerareToAutonaming(*e);
     * //writting:
     * XMLWriter::Element geom_section(dest, "geometry");   //section tag
     * for (auto e: to_save)                                //all roots
     *  e->writeXML(geom_section, namer);
     * @endcode
     */
    class WriteXMLCallback {
        
        /**
         * Names of already saved elements.
         *
         * Used to contruct \<ref ...> tags.
         */
        std::map<const GeometryElement*, std::string> names_of_saved;
        
        std::map<const GeometryElement*, unsigned> counts;   ///< allow to count elements (used by auto-naming)

        unsigned nextAutoName;
        
        public:

        WriteXMLCallback(): nextAutoName(0) {}
        
        /**
         * Calling of this method allows for automatic name generation when saving some subtrees using this.
         *
         * This method must be called exactly once for root of each subtree which will be write to XML before any writes.
         */
        void prerareToAutonaming(const GeometryElement& subtree_root);
        
        /**
         * Get name of given @p element.
         * @param[in] element
         * @param[in, out] axesNames axes names which was used when saved parent of @p element, this can assign to it new value to use in branch rooted by @p element
         * @return name of @p element or empty string if @p element has no name
         */
        virtual std::string getName(const GeometryElement& element, AxisNames& axesNames) const;
        
        /**
         * Get names of path fragment from @p parent to @p child.
         * @param[in] parent container which includes @p child
         * @param[in] child element from a @p parent container
         * @param[in] index_of_child_in_parent index of @p child in @p parent real childrent list
         * @return names of path fragment from @p parent to @p child (can be empty)
         */
        virtual std::vector<std::string> getPathNames(const GeometryElement& parent, const GeometryElement& child, std::size_t index_of_child_in_parent) const;
        
        /**
         * Append to XML tag, with optional name (obtain by getName), and axes attribiute.
         *
         * It is also possible that this creates a reference tag, and this case should be checked by @ref isRef method.
         * @param parent_tag parent XML tag
         * @param element element to write
         * @param element_type_name name of @p element type used in XML
         * @param[in, out] axesNames axis names which was used when saved parent of @p element, this can assign to it new value to use in branch rooted by @p element
         *  (assigned pointer must be valid while branch will be saved, typically it is a pointer to object in register)
         * @return opened XML tag ready to add extra atribiutes of @p element or reference tag.
         */
        XMLWriter::Element makeTag(XMLElement& parent_tag, const GeometryElement& element, AxisNames& axesNames);
        
        XMLElement makeChildTag(XMLElement& container_tag, const GeometryElement& container, std::size_t index_of_child_in_parent) const;
        
        /**
         * Check if given XML element represents a reference to another geometry element.
         * @param el XML element
         * @return @c true only if @p el represents a reference
         */
        static bool isRef(const XMLElement& el) { return el.getName() == "ref"; }
        
    };

    /// Changed signal, fired when element was changed.
    boost::signals2::signal<void(Event&)> changed;

    /**
     * Connect a method to changed signal.
     * @param obj, method slot to connect, object and it's method
     * @param at specifies where the slot should be connected:
     *  - boost::signals2::at_front indicates that the slot will be connected at the front of the list or group of slots
     *  - boost::signals2::at_back (default) indicates that the slot will be connected at the back of the list or group of slots
     */
    template <typename ClassT, typename methodT>
    boost::signals2::connection changedConnectMethod(ClassT* obj, methodT method, boost::signals2::connect_position at = boost::signals2::at_back) {
        return changed.connect(boost::bind(method, obj, _1), at);
    }

    /// Disconnect a method from changed signal
    template <typename ClassT, typename methodT>
    void changedDisconnectMethod(ClassT* obj, methodT method) {
        changed.disconnect(boost::bind(method, obj, _1));
    }

    /*
     * Just call changed with given event data.
     * Subclasses can redefine this and do some extra actions.
     * @param evt event data
     */
    /*virtual void callChanged(Event& evt) {
        changed(evt);
    }*/

    /**
     * Call changed with this as event source.
     * @param event_constructor_params_without_source parameters for event constructor (without first - source)
     */
    template<typename EventT = Event, typename ...Args>
    void fireChanged(Args&&... event_constructor_params_without_source) {
        EventT evt(*this, std::forward<Args>(event_constructor_params_without_source)...);
        changed(evt);   //callChanged
    }

    /**
     * Initialize this to be the same as @p to_copy but doesn't have any changes observer.
     * @param to_copy object to copy
     */
    GeometryElement(const GeometryElement& to_copy) {}

    /**
     * Set this to be the same as @p to_copy but doesn't changed changes observer.
     * @param to_copy object to copy
     */
    GeometryElement& operator=(const GeometryElement& to_copy) { return *this; }

    GeometryElement() = default;

    //TODO

    /**
     * Virtual destructor. Inform all change listeners.
     */
    virtual ~GeometryElement();
    
    /**
     * Get name of element type (like: "block2d", "shelf", "stack3d", etc.).
     *
     * This name is used as tag name when element is serialized to XML.
     * @return name of element type
     */
    virtual std::string getTypeName() const = 0;
    
    /**
     * Write geometry tree branch rooted by this to XML.
     *
     * Default implementation write XML tag for this (with eventual name and axes attribiutes) call writeXMLAttr to append extra atribiutes, and write all real children.
     * Typically you should overwrite only writeXMLAttr method.
     * @param parent_xml_element destination, parent XML element
     * @param write_cb write callback, used to get names for elements and paths
     * @param parent_axes names of axes (typically used by parent of this)
     */
    virtual void writeXML(XMLWriter::Element& parent_xml_element, WriteXMLCallback& write_cb, AxisNames parent_axes) const;
    
    /**
     * Write geometry tree branch rooted by this to XML.
     *
     * Provides good default parameters.
     * @param parent_xml_element destination, parent XML element
     * @param write_cb write callback, used to get names for elements and paths
     */
    void writeXML(XMLWriter::Element& parent_xml_element, WriteXMLCallback& write_cb) const {
        writeXML(parent_xml_element, write_cb, AxisNames::getAbsoluteNames());
    }
    
    /**
     * Write geometry tree branch rooted by this to XML.
     *
     * Provides good default parameters.
     * @param parent_xml_element destination, parent XML element
     */
    void writeXML(XMLWriter::Element& parent_xml_element) const {
        WriteXMLCallback write_cb;
        writeXML(parent_xml_element, write_cb, AxisNames::getAbsoluteNames());
    }
    
    
    /**
     * Cast this to GeometryElementD<DIMS>.
     * @return this casted to GeometryElementD<DIMS> or nullptr if casting is not possible.
     */
    template<int DIMS>
    shared_ptr< GeometryElementD<DIMS> > asD();

    /**
     * Cast this to GeometryElementD<DIMS> (const version).
     * @return this casted to GeometryElementD<DIMS> or nullptr if casting is not possible.
     */
    template<int DIMS>
    shared_ptr< const GeometryElementD<DIMS> > asD() const;

    /**
     * Cast this to Geometry.
     * @return this casted to Geometry or nullptr if casting is not possible.
     */
    shared_ptr< Geometry > asGeometry();

    /**
     * Cast this to Geometry.
     * @return this casted to Geometry or nullptr if casting is not possible.
     */
    shared_ptr< const Geometry > asGeometry() const;

    /**
     * Check if geometry is: leaf, transform or container type element.
     * @return type of this element
     */
    virtual Type getType() const = 0;

    bool isLeaf() const { return getType() == TYPE_LEAF; }
    bool isTransform() const { return getType() == TYPE_TRANSFORM || getType() == TYPE_SPACE_CHANGER; }
    bool isSpaceChanger() const { return getType() == TYPE_SPACE_CHANGER; }
    bool isContainer() const { return getType() == TYPE_CONTAINER; }
    bool isGeometry() const { return getType() == TYPE_GEOMETRY; }

    /**
     * Get number of dimentions.
     * @return number of dimentions
     */
    virtual int getDimensionsCount() const = 0;

    /**
     * Check if element is ready for calculation.
     * Throw exception if element is in bad state and can't be used in calculations, for example has not required children, etc.
     * Default implementation do nothing, but inherited class can change this behavior.
     * @throw Exception if element is not ready for calculation
     */
    virtual void validate() const {}

    /**
     * Check if @a el is in subtree with @c this in root.
     * @param el element to search for
     * @return @c true only if @a el is in subtree with @c this in root
     */
    //TODO predicate, path
    virtual bool isInSubtree(const GeometryElement& el) const;

    /**
     * Find paths to @a el.
     * @param el element to search for
     * @param pathHints (optional) path hints which limits search space
     * @return sub-tree with paths to given element (@p el is in all leafs), empty sub-tree if @p el is not in subtree with @c this in root
     */
    //TODO predicate
    virtual Subtree getPathsTo(const GeometryElement& el, const PathHints* pathHints = 0) const = 0;

    /**
     * Append all elements from subtree with this in root, which fullfil predicate to vector @p dest.
     * @param predicate
     * @param dest destination vector
     * @param path (optional) path hints which limits search space
     */
    virtual void getElementsToVec(const Predicate& predicate, std::vector< shared_ptr<const GeometryElement> >& dest, const PathHints* path = 0) const = 0;

    /**
     * Append all elements from subtree with this in root, which fullfil predicate to vector @p dest.
     * @param predicate
     * @param dest destination vector
     * @param path path hints which limits search space
     */
    void getElementsToVec(const Predicate& predicate, std::vector< shared_ptr<const GeometryElement> >& dest, const PathHints& path) const {
        getElementsToVec(predicate, dest, &path);
    }

    /**
     * Append all leafs in subtree with this in root to vector @p dest.
     * @param dest leafs destination vector
     * @param path (optional) path hints which limits search space
     */
    void getLeafsToVec(std::vector< shared_ptr<const GeometryElement> >& dest, const PathHints* path = 0) const {
        getElementsToVec(&GeometryElement::PredicateIsLeaf, dest, path);
    }

    /**
     * Append all leafs in subtree with this in root to vector @p dest.
     * @param dest leafs destination vector
     * @param path path hints which limits search space
     */
    void getLeafsToVec(std::vector< shared_ptr<const GeometryElement> >& dest, const PathHints& path) const {
        getLeafsToVec(dest, &path);
    }

    /**
     * Get all leafs in subtree with this object as root.
     * @param path (optional) path hints which limits search space
     * @return all leafs in subtree with this object as root
     */
    std::vector< shared_ptr<const GeometryElement> > getLeafs(const PathHints* path = 0) const {
        std::vector< shared_ptr<const GeometryElement> > result;
        getLeafsToVec(result, path);
        return result;
    }

    /**
     * Get all leafs in subtree with this object as root.
     * @param path path hints which limits search space
     * @return all leafs in subtree with this object as root
     */
    std::vector< shared_ptr<const GeometryElement> > getLeafs(const PathHints& path) const {
        return getLeafs(&path);
    }

    /**
     * Get number of element children in geometry graph.
     * @return number of children
     */
    virtual std::size_t getChildrenCount() const = 0;

    /**
     * Get child with given index.
     * @param child_nr index of child to get
     * @return child with index @p child_nr
     */
    virtual shared_ptr<GeometryElement> getChildAt(std::size_t child_nr) const = 0;

    /**
     * Get number of real (physicaly stored) children in geometry graph.
     *
     * By default call getChildrenCount(), but elements of some types (like multi-stack) redefine this.
     * @return number of real children
     */
    virtual std::size_t getRealChildrenCount() const;

    /**
     * Get real (physicaly stored) child with given index.
     *
     * By default call getChildAt(child_nr), but elements of some types (like multi-stack) redefine this.
     * @param child_nr index of real child to get
     * @return child with index @p child_nr
     */
    virtual shared_ptr<GeometryElement> getRealChildAt(std::size_t child_nr) const;

    /**
     * Remove child at given @p index.
     *
     * This is unsafe but fast version, it doesn't check index and doesn't call fireChildrenChanged() to inform listeners about this object changes.
     * Caller should do this manually or call removeAt(std::size_t) instead.
     *
     * Default implementation throw excption but this method is overwritten in subclasses.
     * @param index index of real child to remove
     */
    virtual void removeAtUnsafe(std::size_t index);

    /**
     * Remove child at given @p index.
     *
     * Throw exception if given @p index is not valid, real child index.
     * @param index index of real child to remove
     */
    void removeAt(std::size_t index) {
        ensureIsValidChildNr(index, "removeAt", "index");
        removeAtUnsafe(index);
        fireChildrenRemoved(index, index+1);
    }

    void removeRangeUnsafe(std::size_t index_begin, std::size_t index_end) {
        while (index_begin < index_end) removeAtUnsafe(--index_end);
    }

    /**
     * Remove all children in given range [index_begin, index_end).
     * @param index_begin, index_end range of real children's indexes
     * @return true if something was delete
     */
    bool removeRange(std::size_t index_begin, std::size_t index_end) {
        if (index_begin >= index_end) return false;
        ensureIsValidChildNr(index_end-1, "removeRange", "index_end-1");
        removeRangeUnsafe(index_begin, index_end);
        fireChildrenRemoved(index_begin, index_end);
        return true;
    }

    /**
     * Call a @p callback for each element in subtree with @c this in root.
     *
     * Visit tree in pre-order.
     * @param callback call-back to call, should return @c true only if descendants of element given as parameter should be visited
     */
    virtual void forEachRealElementInSubtree(std::function<bool(const GeometryElement &)> callback) const;

private:
    struct ChildGetter {    //used by begin(), end()
        shared_ptr<const GeometryElement> el;
        ChildGetter(const shared_ptr<const GeometryElement>& el): el(el) {}
        shared_ptr<GeometryElement> operator()(std::size_t index) const { return el->getChildAt(index); }
    };

public:

    ///@return begin begin iterator over children
    FunctorIndexedIterator<ChildGetter> begin() const {
        return FunctorIndexedIterator<ChildGetter>(ChildGetter(this->shared_from_this()), 0);
    }

    ///@return end end iterator over children
    FunctorIndexedIterator<ChildGetter> end() const {
        return FunctorIndexedIterator<ChildGetter>(ChildGetter(this->shared_from_this()), getChildrenCount());
    }

    //virtual GeometryTransform getTransform()

    /**
     * Get this or copy of this with some changes in subtree.
     * @param[in] changer changer which will be aplied to subtree with this in root
     * @param[out] translation optional, if non-null, recommended translation of this after change will be stored
     * @return pointer to this (if nothing was change) or copy of this with some changes in subtree
     */
    virtual shared_ptr<const GeometryElement> changedVersion(const Changer& changer, Vec<3, double>* translation = 0) const = 0;

    bool canHasAsChild(const GeometryElement& potential_child) const { return !potential_child.isInSubtree(*this); }
    bool canHasAsParent(const GeometryElement& potential_parent) const { return !this->isInSubtree(potential_parent); }

    /**
     * Throw CyclicReferenceException if @p potential_parent is in subtree with this in root.
     * @param[in] potential_parent potential, new parent of this
     */
    void ensureCanHasAsParent(const GeometryElement& potential_parent) const;

    /**
     * Throw CyclicReferenceException if @p potential_child has this in subtree.
     * @param[in] potential_child potential, new child of this
     */
    void ensureCanHaveAsChild(const GeometryElement& potential_child) const { potential_child.ensureCanHasAsParent(*this); }

protected:

    /**
     * Append XML attribiutes of this to @p dest_xml_element.
     *
     * By default do nothing.
     * @param dest_xml_element XML tag where attribiutes should be append
     * @param axes choosen name of axes
     */
    virtual void writeXMLAttr(XMLWriter::Element& dest_xml_element, const AxisNames& axes) const;
    
    /**
     * Check if given @p index is valid child index and throw exception of it is not.
     * @param child_nr index to check
     * @param method_name caller method name which is used to format excption message
     * @param arg_name name of index argument in caller method, used to format excption message
     * @throw OutOfBoundException if index is not valid
     */
    void ensureIsValidChildNr(std::size_t child_nr, const char* method_name = "getChildAt", const char* arg_name = "child_nr") const {
        std::size_t children_count = getRealChildrenCount();
        if (child_nr >= children_count)
            throw OutOfBoundException(method_name, arg_name, child_nr, 0, children_count-1);
    }

    /// Inform observers that children list was changed (also that this is resized)
    void fireChildrenChanged() {
        this->fireChanged(GeometryElement::Event::RESIZE | GeometryElement::Event::CHILDREN_GENERIC);
    }
    
    void fireChildrenRemoved(std::size_t beginIndex, std::size_t endIndex) {
        this->fireChanged<ChildrenListChangedEvent>(GeometryElement::Event::RESIZE | GeometryElement::Event::CHILDREN_REMOVE, beginIndex, endIndex);
    }
    
    void fireChildrenInserted(std::size_t beginIndex, std::size_t endIndex) {
        this->fireChanged<ChildrenListChangedEvent>(GeometryElement::Event::RESIZE | GeometryElement::Event::CHILDREN_INSERT, beginIndex, endIndex);
    }

};

template <int dim> struct Translation;

/**
 * Template of base classes for geometry elements in space with given number of dimensions (2 or 3).
 * @tparam dimensions number of dimensions, 2 or 3
 */
template < int dimensions >
struct GeometryElementD: public GeometryElement {

    static const int dim = dimensions;
    typedef typename Primitive<dim>::Box Box;
    typedef typename Primitive<dim>::DVec DVec;

    int getDimensionsCount() const { return dimensions; }

    //virtual Box getBoundingBox() const;

    using GeometryElement::getPathsTo;

    /**
     * Find all paths to elements which lies at given @p point.
     * @param point point in coordinates of this
     * @return all paths, last one is on top and overlies rest
     */
    virtual Subtree getPathsTo(const DVec& point) const = 0;

    /**
     * Check if geometry includes point.
     * @param p point
     * @return true only if this geometry includes point @a p
     */
    virtual bool include(const DVec& p) const = 0;

    /**
     * Check if geometry includes some point from given @a area.
     * @param area rectangular area
     * @return true only if this geometry includes some points from @a area
     */
    virtual bool intersect(const Box& area) const = 0;

    /**
     * Calculate minimal rectangle which includes all points of geometry element.
     * @return calculated rectangle
     */
    virtual Box getBoundingBox() const = 0;

    virtual DVec getBoundingBoxSize() const { return getBoundingBox().size(); }

    /**
     * Calculate minimal rectangle which includes all points of real geometry element.
     *
     * This box can be diffrent from getBoundingBox() only for elements which have virtual children, like multple-stack.
     * Returned box is always included in (in most cases: equal to) box returned by getBoundingBox().
     *
     * Default implementation returns result of getBoundingBox() call.
     * @return calculated rectangle
     */
    virtual Box getRealBoundingBox() const { return getBoundingBox(); }

    /**
     * Return material in a given point inside the geometry element
     * @param p point
     * @return material in given point, or @c nullptr if this GeometryElement not includes point @a p
     */
    virtual shared_ptr<Material> getMaterial(const DVec& p) const = 0;

    /**
     * Return material in a given point inside the geometry element
     * @param p point
     * @return material in given point, or Air if this GeometryElement not includes point @a p
     */
    shared_ptr<Material> getMaterialOrAir(const DVec& p) const {
        auto real_mat = getMaterial(p);
        return real_mat ? real_mat : make_shared<Air>();
    }

    /**
     * Calculate and append to vector bounding boxes of all nodes which fulfill given @p predicate, optionally marked by path.
     * @param predicate
     * @param dest place to add result, bounding boxes will be added in the same order which is generated by GeometryElement::getElements
     * @param path path fragments, optional
     */
    virtual void getBoundingBoxesToVec(const GeometryElement::Predicate& predicate, std::vector<Box>& dest, const PathHints* path = 0) const = 0;

    /**
     * Calculate and append to vector bounding boxes of all nodes which fulfill given @p predicate, marked by path.
     * @param predicate
     * @param dest place to add result, bounding boxes will be added in the same order which is generated by GeometryElement::getElements
     * @param path path fragments
     */
    void getBoundingBoxesToVec(const GeometryElement::Predicate& predicate, std::vector<Box>& dest, const PathHints& path) const {
        getBoundingBoxesToVec(predicate, dest, &path);
    }

    /**
     * Calculate the vector of bounding boxes of all nodes which fulfill given @p predicate, optionally marked by path.
     * @param predicate
     * @param path path fragments, optional
     * @return vector of bounding boxes of all nodes which fulfill given @p predicate, optionally marked by path
     */
    std::vector<Box> getBoundingBoxes(const GeometryElement::Predicate& predicate, const PathHints* path = 0) const {
        std::vector<Box> result;
        getBoundingBoxesToVec(predicate, result, path);
        return result;
    }

    /**
     * Calculate the vector of bounding boxes of all nodes which fulfill given @p predicate, marked by path.
     * @param predicate
     * @param path path fragments
     * @return vector of bounding boxes of all nodes which fulfill given @p predicate, optionally marked by path
     */
    std::vector<Box> getBoundingBoxes(const GeometryElement::Predicate& predicate, const PathHints& path) {
        return getBoundingBoxes(predicate, &path);
    }

    /**
     * Calculate and append to vector bounding boxes of all leafs, optionally marked by path.
     * @param dest place to add result, bounding boxes will be added in the same order which is generated by GeometryElement::getLeafsToVec
     * @param path path fragments, optional
     */
    void getLeafsBoundingBoxesToVec(std::vector<Box>& dest, const PathHints* path = 0) const {
        getBoundingBoxesToVec(&GeometryElement::PredicateIsLeaf, dest, path);
    }

    /**
     * Calculate and append to vector bounding boxes of all leafs, marked by path.
     * @param dest place to add result, bounding boxes will be added in the same order which is generated by GeometryElement::getLeafsToVec
     * @param path path fragments
     */
    void getLeafsBoundingBoxesToVec(std::vector<Box>& dest, const PathHints& path) const {
        getLeafsBoundingBoxesToVec(dest, &path);
    }

    /**
     * Calculate bounding boxes of all leafs, optionally marked by path.
     * @param path path fragments, optional
     * @return bounding boxes of all leafs, in the same order which is generated by GeometryElement::getLeafs(const PathHints*)
     */
    std::vector<Box> getLeafsBoundingBoxes(const PathHints* path = 0) const {
        std::vector<Box> result;
        getLeafsBoundingBoxesToVec(result, path);
        return result;
    }

    /**
     * Calculate bounding boxes of all leafs, marked by path.
     * @param path path fragments
     * @return bounding boxes of all leafs, in the same order which is generated by GeometryElement::getLeafs(const PathHints&)
     */
    std::vector<Box> getLeafsBoundingBoxes(const PathHints& path) const {
        return getLeafsBoundingBoxes(&path);
    }

    /**
     * Calculate and append to vector bounding boxes of all instances of given \p element, optionally marked by path.
     * @param dest place to add result
     * @param path path fragments, optional
     */
    void getElementBoundingBoxesToVec(std::vector<Box>& dest, const GeometryElement& element, const PathHints* path = 0) const {
        getBoundingBoxesToVec(GeometryElement::PredicateIsA(element), dest, path);
    }

    /**
     * Calculate and append to vector bounding boxes of all instances of given \p element, marked by path.
     * @param dest place to add result
     * @param path path fragments
     */
    void getElementBoundingBoxesToVec(std::vector<Box>& dest, const GeometryElement& element, const PathHints& path) const {
        getElementBoundingBoxesToVec(dest, element, &path);
    }

    /**
     * Calculate bounding boxes of all instances of given \p element, optionally marked by path.
     * @param path path fragments, optional
     * @return bounding boxes of all instances of given \p element
     */
    std::vector<Box> getElementBoundingBoxes(const GeometryElement& element, const PathHints* path = 0) const {
        std::vector<Box> result;
        getElementBoundingBoxesToVec(result, element, path);
        return result;
    }

    /**
     * Calculate bounding boxes of all elements, marked by path.
     * @param path path fragments
     * @return bounding boxes of all elements, in the same order which is generated by GeometryElement::getElements(const PathHints&)
     */
    std::vector<Box> getElementBoundingBoxes(const GeometryElement& element, const PathHints& path) const {
        return getElementBoundingBoxes(element, &path);
    }


    /**
     * Calculate and append to vector positions of all nodes which fulfill given @p predicate, optionally marked by path.
     *
     * Some elements can have all vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     * @param predicate
     * @param dest place to add result, positions will be added in the same order which is generated by GeometryElement::getElementsToVec
     * @param path path fragments, optional
     */
    virtual void getPositionsToVec(const Predicate& predicate, std::vector<DVec>& dest, const PathHints* path = 0) const = 0;

    /**
     * Calculate and append to vector positions of all nodes which fulfill given @p predicate, marked by path.
     *
     * Some elements can have all vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     * @param predicate
     * @param dest place to add result, positions will be added in the same order which is generated by GeometryElement::getElementsToVec
     * @param path path fragments
     */
    void getPositionsToVec(const Predicate& predicate, std::vector<DVec>& dest, const PathHints& path) const {
        getPositionsToVec(predicate, dest, &path);
    }

    /**
     * Calculate and append to vector positions of all nodes which fulfill given @p predicate, optionally marked by path.
     * @param predicate
     * @param path path fragments, optional
     * @return positions of the pointed elements in the sub-tree with this element in the root, in the same order which is generated by GeometryElement::getElements
     *
     * Some elements can have all vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     */
    std::vector<DVec> getPositions(const Predicate& predicate, const PathHints* path = 0) const {
        std::vector<DVec> result;
        getPositionsToVec(predicate, result, path);
        return result;
    }

    /**
     * Calculate and append to vector positions of all nodes which fulfill given @p predicate, marked by path.
     * @param predicate
     * @param path path fragments
     * @return positions of the pointed elements in the sub-tree with this element in the root, in the same order which is generated by GeometryElement::getElements
     *
     * Some elements can have all vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     */
    std::vector<DVec> getPositions(const Predicate& predicate, const PathHints& path) const {
        return getPositions(predicate, &path);
    }

    /**
     * Calculate and append to vector positions of all leafs, optionally marked by path.
     *
     * Some leafs can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     * @param dest place to add result, positions will be added in the same order which is generated by GeometryElement::getLeafsToVec
     * @param path path fragments, optional
     */
    void getLeafsPositionsToVec(std::vector<DVec>& dest, const PathHints* path = 0) const {
        getPositionsToVec(&PredicateIsLeaf, dest, path);
    }

    /**
     * Calculate and append to vector positions of all leafs, marked by path.
     *
     * Some leafs can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     * @param dest place to add result, positions will be added in the same order which is generated by GeometryElement::getLeafsToVec
     * @param path path fragments
     */
    void getLeafsPositionsToVec(std::vector<DVec>& dest, const PathHints& path) const {
        getLeafsPositionsToVec(dest, &path);
    }

    /**
     * Calculate and return a vector of positions of all leafs, optionally marked by path.
     * @param path path fragments, optional
     * @return positions of leafs in the sub-tree with this element in the root, in the same order which is generated by GeometryElement::getLeafs
     *
     * Some leafs can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     */
    std::vector<DVec> getLeafsPositions(const PathHints* path = 0) const {
        std::vector<DVec> result;
        getLeafsPositionsToVec(result, path);
        return result;
    }

    /**
     * Calculate and return a vector of positions of all leafs, marked by path.
     * @param path path fragments
     * @return positions of leafs in the sub-tree with this element in the root, in the same order which is generated by GeometryElement::getLeafs
     *
     * Some leafs can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     */
    std::vector<DVec> getLeafsPositions(const PathHints& path) const {
        return getLeafsPositions(&path);
    }

    /**
     * Calculate and append to vector positions of all instances of given @p element, optionally marked by path.
     *
     * Some elements can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     * @param dest place to add result, positions will be added in the same order which is generated by GeometryElement::getElementsToVec
     * @param element element to which instances translations should be found
     * @param path path fragments, optional
     */
    void getElementPositionToVec(std::vector<DVec>& dest, const GeometryElement& element, const PathHints* path = 0) const {
        getPositionsToVec(PredicateIsA(element), dest, path);
    }

    /**
     * Calculate and append to vector positions of all instances of given @p element, marked by path.
     *
     * Some elements can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     * @param dest place to add result, positions will be added in the same order which is generated by GeometryElement::getElementsToVec
     * @param element element to which instances translations should be found
     * @param path path fragments
     */
    void getElementPositionToVec(std::vector<DVec>& dest, const GeometryElement& element, const PathHints& path) const {
        getElementPositionToVec(dest, element, &path);
    }

    /**
     * Calculate and return a vector of positions of all instances of given @p element, optionally marked by path.
     * @param element element to which instances translations should be found
     * @param path path fragments, optional
     * @return vector of positions
     *
     * Some elements can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     */
    std::vector<DVec> getElementPositions(const GeometryElement& element, const PathHints* path = 0) const {
        return getPositions(PredicateIsA(element), path);
    }

    /**
     * Calculate and return a vector of positions of all instances of given @p element, marked by path.
     * @param element element to which instances translations should be found
     * @param path path fragments
     * @return vector of positions
     *
     * Some elements can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     */
    std::vector<DVec> getElementPositions(const GeometryElement& element, const PathHints& path) const {
        return getElementPositions(element, &path);
    }

    /**
     * Get @p element wrapped with translation to be in coordinate space of this.
     *
     * @param element element which should be in subtree of this
     * @param path path fragments, optional
     * @return @p element wrapped with translation or shared_ptr< Translation<dimensions> >() if translation is not well-defined
     */
    shared_ptr< Translation<dimensions> > getElementInThisCoordinates(const shared_ptr< GeometryElementD<dimensions> >& element, const PathHints* path = 0) const;

    /**
     * Get @p element wrapped with translation to be in coordinate space of this.
     *
     * @param element element which should be in subtree of this
     * @param path path fragments
     * @return @p element wrapped with translation or shared_ptr< Translation<dimensions> >() if translation is not well-defined
     */
    shared_ptr< Translation<dimensions> > getElementInThisCoordinates(const shared_ptr< GeometryElementD<dimensions> >& element, const PathHints& path) const {
        return getElementInThisCoordinates(element, &path);
    }

    /**
     * Get @p element wrapped with translation to be in corrdinate space of this.
     *
     * Throw excpetion if element doesn't have well-defined, one translation.
     * @param element element which should be in subtree of this
     * @param path path fragments, optional
     * @return @p element wrapped with translation
     */
    shared_ptr< Translation<dimensions> > requireElementInThisCoordinates(const shared_ptr< GeometryElementD<dimensions> >& element, const PathHints* path = 0) const {
        shared_ptr< Translation<dimensions> > result = getElementInThisCoordinates(element, path);
        if (!result) throw Exception("Translation to element required in local coordinates is not well defined");
        return result;
    }

    /**
     * Get @p element wrapped with translation to be in corrdinate space of this.
     *
     * Throw excpetion if element doesn't have well-defined, one translation.
     * @param element element which should be in subtree of this
     * @param path path fragments
     * @return @p element wrapped with translation
     */
    shared_ptr< Translation<dimensions> > requireElementInThisCoordinates(const shared_ptr< GeometryElementD<dimensions> >& element, const PathHints& path) const {
        return requireElementInThisCoordinates(element, &path);
    }

};

} // namespace plask

#endif // PLASK__GEOMETRY_ELEMENT_H







