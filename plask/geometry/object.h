#ifndef PLASK__GEOMETRY_OBJECT_H
#define PLASK__GEOMETRY_OBJECT_H

/** @file
This file contains base class for geometries objects.
*/

/** @defgroup GEOMETRY_OBJ Geometry Objects
*/

#include <vector>
#include <tuple>
#include <functional>
#include <set>

#include "../material/material.h"
#include "../material/air.h"
#include "primitives.h"
#include "../utils/iterators.h"


#if defined(_WIN32) || defined(__WIN32__) || defined(WIN32)
#   define BOOST_USE_WINDOWS_H
#endif
#include <boost/signals2.hpp>
#include "../utils/event.h"

#include "../axes.h"
#include "../utils/xml/writer.h"

/// Value for expected suffix for names of 2D objects types, see GeometryReader::expectedSuffix.
#define PLASK_GEOMETRY_TYPE_NAME_SUFFIX_2D "2d"

/// Value for expected suffix for names of 3D objects types, see GeometryReader::expectedSuffix.
#define PLASK_GEOMETRY_TYPE_NAME_SUFFIX_3D "3d"

namespace plask {

class GeometryReader;

struct PathHints;
struct Path;

struct Geometry;
template < int dimensions > struct GeometryObjectD;
template < int dimensions > struct TranslationContainer;

/**
 * Base class for all geometries.
 * @ingroup GEOMETRY_OBJ
 */
struct PLASK_API GeometryObject: public enable_shared_from_this<GeometryObject> {

    ///Type of geometry object.
    enum Type {
        TYPE_LEAF = 0,         ///< leaf object (has no child)
        TYPE_TRANSFORM = 1,    ///< transform object (has one child)
        TYPE_SPACE_CHANGER = 2,///< transform object which changing its space, typically changing number of dimensions (has one child)
        TYPE_CONTAINER = 3,    ///< container (can have more than one child)
        TYPE_GEOMETRY = 4,     ///< geometry / space
        TYPE_SEPARATOR = 5     ///< objects of this type are used internaly, mainly as separators
    };

    /**
     * Store information about event connected with geometry object.
     *
     * Subroles of this can contains additional information about specific type of event.
     *
     * Note: when object is being deleted (isDelete() returns @c true), source() can't be succesfully dynamic cast to subroles of GeometryObject,
     * because source() is already partially deleted.
     */
    class PLASK_API Event: public EventWithSourceAndFlags<GeometryObject> {

        const GeometryObject& _originalSource;

    public:

        /// Event flags (which describes event properties).
        enum Flags {
            EVENT_DELETE = 1,             ///< is deleted
            EVENT_RESIZE = 1<<1,          ///< size could be changed
            EVENT_DELEGATED = 1<<2,       ///< delegated from child
            EVENT_CHILDREN_INSERT = 1<<3, ///< children was insert
            EVENT_CHILDREN_REMOVE = 1<<4, ///< children was removed
            EVENT_CHILDREN_GENERIC = 1<<5,///< children list was changed (other or custom changes)
            EVENT_BORDERS = 1<<6,         ///< borders was changed (only Geometries/calculation spaces emit events with this flags)
            EVENT_STEPS = 1<<7,           ///< step refining was changed
            EVENT_USER_DEFINED = 1<<8     ///< user-defined flags could have ids: EVENT_USER_DEFINED, EVENT_USER_DEFINED<<1, EVENT_USER_DEFINED<<2, ...
        };

        /**
         * Get event's flags for parent in tree of geometry
         * (useful to calculate flags for event which should be generated by parent of object which is a source of this event).
         * @return flags for parent in tree of geometry
         */
        unsigned char flagsForParent() const { return flagsWithout(EVENT_DELETE | EVENT_CHILDREN_INSERT | EVENT_CHILDREN_REMOVE | EVENT_CHILDREN_GENERIC) | EVENT_DELEGATED | (hasFlag(EVENT_DELETE) ? EVENT_RESIZE : 0); }

        /**
         * Get event's flags for parent in tree of geometry, for parents which want to delegate information about changes of children list.
         * (uses mainly by parents of hidden child to calculate flags for event which should be generated by parent of object which is a source of this event).
         *
         * Note: In most cases You should use flagsForParent() instead.
         * @return flags for parent in tree of geometry
         */
        unsigned char flagsForParentWithChildrenWasChangedInformation() const {
            unsigned char result = flagsForParent();
            if (hasAnyFlag(EVENT_CHILDREN_INSERT | EVENT_CHILDREN_REMOVE | EVENT_CHILDREN_GENERIC)) result |= EVENT_CHILDREN_GENERIC;
            return result;
        }

        /**
         * Check if given @p flag is set.
         * @param flag flag to check
         * @return @c true only if @p flag is set
         */
        bool hasFlag(Flags flag) const { return hasAnyFlag(flag); }

        /**
         * Check if EVENT_DELETE flag is set, which mean that source of event is deleted.
         * @return @c true only if EVENT_DELETE flag is set
         */
        bool isDelete() const { return hasFlag(EVENT_DELETE); }

        /**
         * Check if EVENT_RESIZE flag is set, which mean that source of event could be resized.
         * @return @c true only if EVENT_RESIZE flag is set
         */
        bool isResize() const { return hasFlag(EVENT_RESIZE); }

        /**
         * Check if EVENT_DELEGATED flag is set, which mean that source delegate event from its child.
         * @return @c true only if EVENT_DELEGATED flag is set
         */
        bool isDelgatedFromChild() const { return hasFlag(EVENT_DELEGATED); }

        /**
         * Check if CHILD_LIST flag is set, which mean that children list of source could be changed.
         * @return @c true only if CHILD_LIST flag is set
         */
        bool hasChangedChildrenList() const { return hasAnyFlag(EVENT_CHILDREN_INSERT|EVENT_CHILDREN_REMOVE|EVENT_CHILDREN_GENERIC); }

        /**
         * Check if EVENT_BORDERS flag is set, which mean that borders connected with source could changed.
         * @return @c true only if EVENT_BORDERS flag is set
         */
        bool hasChangedBorders() const { return hasFlag(EVENT_BORDERS); }

        /**
         * Get oryginal source of event which can differ from source if event was delegated.
         * @return oryginal source of event
         */
        const GeometryObject& oryginalSource() const { return _originalSource; }

        /**
         * Construct event.
         * @param source source and oryginal source of event
         * @param flags which describes event's properties
         */
        explicit Event(GeometryObject& source, unsigned char flags = 0): EventWithSourceAndFlags<GeometryObject>(source, flags), _originalSource(source) {}

        /**
         * Construct event.
         * @param source source of event
         * @param oryginalSource oryginal source of event
         * @param flags which describes event's properties
         */
        explicit Event(GeometryObject& source, const GeometryObject& oryginalSource, unsigned char flags = 0): EventWithSourceAndFlags<GeometryObject>(source, flags), _originalSource(oryginalSource) {}

    };

    /**
     * Event class for events types: EVENT_CHILDREN_INSERT and EVENT_CHILDREN_REMOVE.
     *
     * Provides extra information about changes: first and last index.
     */
    struct PLASK_API ChildrenListChangedEvent: public Event {

        ChildrenListChangedEvent(GeometryObject& source, unsigned char flags, const std::size_t beginIndex, const std::size_t endIndex)
            : Event(source, flags), beginIndex(beginIndex), endIndex(endIndex) {}

        /// Index of first child which was changed.
        const std::size_t beginIndex;

        /// Index of last children which was changed incremented by 1.
        const std::size_t endIndex;

    };

    /**
     * This structure can refer to part of geometry tree.
     */
    struct PLASK_API Subtree {

        /// Geometry object.
        shared_ptr<const GeometryObject> object;

        /// Some (but not necessary all) children of object.
        std::vector<Subtree> children;

        /**
         * Construct subtree witch is empty or has only one node.
         * @param object geometry object, or null pointer to construct empty Subtree
         */
        Subtree(shared_ptr<const GeometryObject> object = shared_ptr<const GeometryObject>()): object(object) {}

        /**
         * Construct subtree.
         * @param object geometry object
         * @param children some (but not necessary all) children of @p object
         */
        Subtree(shared_ptr<const GeometryObject> object, const std::vector<Subtree>& children): object(object), children(children) {}

        /**
         * Construct subtree.
         * @param object geometry object
         * @param children some (but not necessary all) children of @p object
         */
        Subtree(shared_ptr<const GeometryObject> object, std::vector<Subtree>&& children): object(object), children(std::forward< std::vector<Subtree> >(children)) {}

        /**
         * Construct subtree which consists of given @p root object and @p children or empty object if @p children vector is empty.
         *
         * This method is used to make set of paths (subtree) longer if this set is not empty.
         * @param root potential root of constructed subtree object
         * @param children potential children of @p root in constructed subtree
         * @return subtree which consists of given @p root object and @p children or empty object if @p children vector is empty
         */
        static Subtree extendIfNotEmpty(shared_ptr<const GeometryObject> root, Subtree&& children) {
            return children.empty() ? Subtree() : Subtree(root, std::vector<Subtree>{ std::forward< Subtree >(children) });
        }

        /**
         * Construct subtree which consists of given @p root object and @p children or empty object if @p children vector is empty.
         *
         * This method is used to make set of paths (subtree) longer if this set is not empty.
         * @param root potential root of constructed subtree object
         * @param children potential children of @p root in constructed subtree
         * @return subtree which consists of given @p root object and @p children or empty object if @p children vector is empty
         */
        static Subtree extendIfNotEmpty(const GeometryObject* root, Subtree&& children) {
            return children.empty() ? Subtree() : Subtree(root->shared_from_this(), std::vector<Subtree>{ std::forward< Subtree >(children) });
        }

        /**
         * Check if this subtree inludes more than one branch (has more than one children or has one child which has more than one branch).
         * @return @c true only if this subtree inludes branches, @c false if it is linear path
         */
        bool hasBranches() const;

        /**
         * Convert this subtree to linear path: object, child[0].object, child[0].child[0].object, ...
         *
         * Throw excpetion if this subtree is not linear path (inludes more than one branch).
         * @return linear path represented by this
         */
        Path toLinearPath() const;

        /**
         * Get last (last child is chosen at each level), linear path from subtree.
         * @return last path from subtree
         */
        Path getLastPath() const;

        /**
         * Check if this subtree is empty (its object points to null).
         * @return @c true only if this subtree is empty.
         */
        bool empty() const { return !object; }
    };

    /**
     * Base class for geometry changers.
     *
     * Geometry changer can change GeometryObject to another one.
     */
    struct PLASK_API Changer {

        /// Virtual destructor. Do nothing.
        virtual ~Changer() {}

        /**
         * Try to apply changes.
         * @param[in,out] to_change pointer to object which eventualy will be changed (in such case pointer after call can point to another geometry object)
         * @param[out] translation optional, extra translation for object after change (in case of 2d object caller reads only @a tran and @a up components of this vector)
         * @return @c true only if something was changed, @c false if nothing was changed (in such case changer doesn't change arguments)
         */
        virtual bool apply(shared_ptr<GeometryObject>& to_change, Vec<3, double>* translation = 0) const = 0;

    };

    /**
     * Geometry changer which holds vector of changers and try to apply this changers sequentially.
     *
     * Its apply method call: changers[0].apply(to_change, translation), changers[1].apply(to_change, translation), ...
     * up to time when one of this call returns @c true (and then it returns @c true) or
     * there are no mora changers in changes vector (and then it returns @c false).
     */
    struct PLASK_API CompositeChanger: public Changer {

        std::vector<const Changer*> changers;

        /**
         * Construct CompositeChanger and append @p changer to its changers list.
         * @param changer changer to append, will be deleted by destructor of @c this
         */
        CompositeChanger(const Changer* changer);

        /**
         * Append @p changer to changers list.
         * @param changer changer to append
         * @return @c *this
         */
        CompositeChanger& operator()(const Changer* changer);

        /**
         * Append @p changer to changers list.
         * @param changer changer to append
         * @return @c *this
         */
        CompositeChanger& append(const Changer* changer) { return operator ()(changer); }

        /**
         * Construct empty composit changer.
         */
        CompositeChanger() {}

        /// Delete all held changers (using delete operator).
        ~CompositeChanger();

        virtual bool apply(shared_ptr<GeometryObject>& to_change, Vec<3, double>* translation = 0) const override;

    };

    /**
     * Changer which replaces given geometry object @a from to given geometry object @a to.
     */
    struct PLASK_API ReplaceChanger: public Changer {

        shared_ptr<const GeometryObject> from;
        shared_ptr<GeometryObject> to;

        /// Translation to return by apply.
        Vec<3, double> translation;

        /// Construct uninitilized changer.
        ReplaceChanger() {}

        /**
         * Construct changer which change @p from to @p to and return given @p translation.
         * @param from, to, translation changer parameters
         */
        ReplaceChanger(shared_ptr<const GeometryObject> from, shared_ptr<GeometryObject> to, Vec<3, double> translation)
            : from(from), to(to), translation(translation) {}

        /**
         * Construct changer which change @p from to calc_replace(to) and return zeroed translation.
         * @param from object which should be changed
         * @param calc_replace functor which is used to calculate change destination object
         */
        template <typename F>
        ReplaceChanger(const shared_ptr<const GeometryObject>& from, F calc_replace): from(from), translation(0.0, 0.0, 0.0) {
            this->to = calc_replace(this->from);
        }

        virtual bool apply(shared_ptr<GeometryObject>& to_change, Vec<3, double>* translation = 0) const override;

    };

    /**
     * Changer which replaces given geometry object @a toChange to block (2d or 3d, depents from @a toChange)
     * with size equals to @a toChange bounding box, and with given material.
     */
    struct PLASK_API ToBlockChanger: public ReplaceChanger {

        ToBlockChanger(shared_ptr<const GeometryObject> toChange, shared_ptr<Material> material);

    };

    struct PLASK_API DeleteChanger: public Changer {

        shared_ptr<const GeometryObject> toDel;

        DeleteChanger(shared_ptr<const GeometryObject> toDel): toDel(toDel) {}

        virtual bool apply(shared_ptr<GeometryObject>& to_change, Vec<3, double>* translation = 0) const override;

    };

    /// Predicate on GeometryObject
    typedef std::function<bool(const GeometryObject&)> Predicate;

    /// Predicate which check if given object is leaf.
    static bool PredicateIsLeaf(const GeometryObject& el) { return el.isLeaf(); }

    /// Predicate which check if given object is another instance of some particular object (given in constructor).
    struct PLASK_API PredicateIsA {
        const GeometryObject& objectToBeEqual;
        PredicateIsA(const GeometryObject& objectToBeEqual): objectToBeEqual(objectToBeEqual) {}
        PredicateIsA(const shared_ptr<GeometryObject>& objectToBeEqual): objectToBeEqual(*objectToBeEqual) {}
        PredicateIsA(const shared_ptr<const GeometryObject>& objectToBeEqual): objectToBeEqual(*objectToBeEqual) {}
        bool operator()(const GeometryObject& el) const { return &el == &objectToBeEqual; }
    };

    /// Predicate which check if given object belong to class with given name.
    struct PLASK_API PredicateHasRole {
        std::string role_name;
        PredicateHasRole(const std::string& role_name): role_name(role_name) {};
        PredicateHasRole(std::string&& role_name): role_name(std::move(role_name)) {};
        bool operator()(const GeometryObject& obj) const { return obj.hasRole(role_name); }
    };

    /**
     * Base class for callbacks used by save() method to get names of objects and paths.
     *
     * Default implementation just returns empty names and list of names.
     * It is enought to save geometry tree without any names or with all names auto-generated (see @ref prerareToAutonaming).
     *
     * Example (save vector of objects to dest XML in "geometry" section):
     * @code
     * // std::vector<const plask::GeomtryObject*> to_save; //root of trees to save
     * // XMLWriter dest;               // destination, output XML
     * WriteXMLCallback namer;          // or subclass of WriteXMLCallback
     * // this is required only if elments should have auto-generated names:
     * for (auto e: to_save) namer.prerareToAutonaming(*e);
     * // writting:
     * XMLWriter::Element geom_section(dest, "geometry");   // section tag
     * for (auto e: to_save)                                // all roots
     *   e->writeXML(geom_section, namer);
     * @endcode
     */
    class PLASK_API WriteXMLCallback {

        /**
         * Names of already saved objects.
         *
         * Used to contruct \<again ...> tags.
         */
        std::map<const GeometryObject*, std::string> names_of_saved;

        std::map<const GeometryObject*, unsigned> counts;   ///< allow to count objects (used by auto-naming)

        unsigned nextAutoName;

        public:

        WriteXMLCallback(): nextAutoName(0) {}

        /**
         * Calling of this method allows for automatic name generation when saving some subtrees using this.
         *
         * This method must be called exactly once for root of each subtree which will be write to XML before any writes.
         */
        void prerareToAutonaming(const GeometryObject& subtree_root);

        /**
         * Get name of given @p object.
         * @param[in] object
         * @param[in, out] axesNames axes names which was used when saved parent of @p object, this can assign to it new value to use in branch rooted by @p object
         * @return name of @p object or empty string if @p object has no name
         */
        virtual std::string getName(const GeometryObject& object, AxisNames& axesNames) const;

        /**
         * Get names of path fragment from @p parent to @p child.
         * @param[in] parent container which contains @p child
         * @param[in] child object from a @p parent container
         * @param[in] index_of_child_in_parent index of @p child in @p parent real childrent list
         * @return names of path fragment from @p parent to @p child (can be empty)
         */
        virtual std::vector<std::string> getPathNames(const GeometryObject& parent, const GeometryObject& child, std::size_t index_of_child_in_parent) const;

        /**
         * Append to XML tag, with optional name (obtain by getName), and axes attribiute.
         *
         * It is also possible that this creates a reference tag, and this case should be checked by @ref isRef method.
         * @param parent_tag parent XML tag
         * @param object object to write
         * @param[in, out] axesNames axis names which was used when saved parent of @p object, this can assign to it new value to use in branch rooted by @p object
         *  (assigned pointer must be valid while branch will be saved, typically it is a pointer to object in register)
         * @return opened XML tag ready to add extra atribiutes of @p object or reference tag.
         */
        XMLWriter::Element makeTag(XMLElement& parent_tag, const GeometryObject& object, AxisNames& axesNames);

        XMLElement makeChildTag(XMLElement& container_tag, const GeometryObject& container, std::size_t index_of_child_in_parent) const;

        /**
         * Check if given XML object represents a reference to another geometry object.
         * @param el XML object
         * @return @c true only if @p el represents a reference
         */
        static bool isRef(const XMLElement& el) { return el.getName() == "again"; }

    };

    /// Maximum division if the object is not uniform
    unsigned long max_points;

    /// Minimum distance between division lines if the object is not uniform
    double min_ply;

    /// Set max_points
    void setMaxPoints(unsigned long value) {
        max_points = value;
        fireChanged(GeometryObject::Event::EVENT_STEPS);
    }

    /// Set min_ply
    void setMinPly(double value) {
        min_ply = value;
        fireChanged(GeometryObject::Event::EVENT_STEPS);
    }

    /// Roles/tags
    std::set<std::string> roles;

    /// Changed signal, fired when object was changed.
    boost::signals2::signal<void(Event&)> changed;

    /**
     * Connect a method to changed signal.
     * @param obj, method slot to connect, object and it's method
     * @param at specifies where the slot should be connected:
     *  - boost::signals2::at_front indicates that the slot will be connected at the front of the list or group of slots
     *  - boost::signals2::at_back (default) indicates that the slot will be connected at the back of the list or group of slots
     */
    template <typename ClassT, typename methodT>
    boost::signals2::connection changedConnectMethod(ClassT* obj, methodT method, boost::signals2::connect_position at = boost::signals2::at_back) {
        return changed.connect(boost::bind(method, obj, _1), at);
    }

    /// Disconnect a method from changed signal
    template <typename ClassT, typename methodT>
    void changedDisconnectMethod(ClassT* obj, methodT method) {
        changed.disconnect(boost::bind(method, obj, _1));
    }

    /*
     * Just call changed with given event data.
     * Subroles can redefine this and do some extra actions.
     * @param evt event data
     */
    /*virtual void callChanged(Event& evt) {
        changed(evt);
    }*/

    /**
     * Call changed with this as event source.
     * @param event_constructor_params_without_source parameters for event constructor (without first - source)
     */
    template<typename EventT = Event, typename ...Args>
    void fireChanged(Args&&... event_constructor_params_without_source) {
        EventT evt(*this, std::forward<Args>(event_constructor_params_without_source)...);
        changed(evt);   //callChanged
    }

    /**
     * Initialize this to be the same as @p to_copy but doesn't have any changes observer.
     * @param to_copy object to copy
     */
    GeometryObject(const GeometryObject& to_copy): max_points(to_copy.max_points), min_ply(to_copy.min_ply) {}

    /**
     * Set this to be the same as @p to_copy but doesn't change changes observer.
     * @param to_copy object to copy
     */
    GeometryObject& operator=(const GeometryObject& to_copy) {
        max_points = to_copy.max_points;
        min_ply = to_copy.min_ply;
        return *this;
    }

    GeometryObject(): max_points(10), min_ply(0.005) {}

    /**
     * Virtual destructor. Inform all change listeners.
     */
    virtual ~GeometryObject();

    /**
     * Get name of object type (like: "block2d", "shelf", "stack3d", etc.).
     *
     * This name is used as tag name when object is serialized to XML.
     * @return name of object type
     */
    virtual std::string getTypeName() const = 0;

    /**
     * Write geometry tree branch rooted by this to XML.
     *
     * Default implementation write XML tag for this (with eventual name and axes attribiutes) call writeXMLAttr to append extra atribiutes, and write all real children.
     * Typically you should overwrite only writeXMLAttr method.
     * @param parent_xml_object destination, parent XML object
     * @param write_cb write callback, used to get names for objects and paths
     * @param parent_axes names of axes (typically used by parent of this)
     */
    virtual void writeXML(XMLWriter::Element& parent_xml_object, WriteXMLCallback& write_cb, AxisNames parent_axes) const;

    /**
     * Write geometry tree branch rooted by this to XML.
     *
     * Provides good default parameters.
     * @param parent_xml_object destination, parent XML object
     * @param write_cb write callback, used to get names for objects and paths
     */
    void writeXML(XMLWriter::Element& parent_xml_object, WriteXMLCallback& write_cb) const {
        writeXML(parent_xml_object, write_cb, AxisNames::getAbsoluteNames());
    }

    /**
     * Write geometry tree branch rooted by this to XML.
     *
     * Provides good default parameters.
     * @param parent_xml_object destination, parent XML object
     */
    void writeXML(XMLWriter::Element& parent_xml_object) const {
        WriteXMLCallback write_cb;
        writeXML(parent_xml_object, write_cb, AxisNames::getAbsoluteNames());
    }

    /**
     * Cast this to GeometryObjectD<DIMS>.
     * @return this casted to GeometryObjectD<DIMS> or nullptr if casting is not possible.
     */
    template<int DIMS>
    shared_ptr< GeometryObjectD<DIMS> > asD();

    /**
     * Cast this to GeometryObjectD<DIMS> (const version).
     * @return this casted to GeometryObjectD<DIMS> or nullptr if casting is not possible.
     */
    template<int DIMS>
    shared_ptr< const GeometryObjectD<DIMS> > asD() const;

    /**
     * Cast this to Geometry.
     * @return this casted to Geometry or nullptr if casting is not possible.
     */
    shared_ptr< Geometry > asGeometry();

    /**
     * Cast this to Geometry.
     * @return this casted to Geometry or nullptr if casting is not possible.
     */
    shared_ptr< const Geometry > asGeometry() const;

    /**
     * Check if geometry is: leaf, transform or container type object.
     * @return type of this object
     */
    virtual Type getType() const = 0;

    bool isLeaf() const { return getType() == TYPE_LEAF; }
    bool isTransform() const { return getType() == TYPE_TRANSFORM || getType() == TYPE_SPACE_CHANGER; }
    bool isSpaceChanger() const { return getType() == TYPE_SPACE_CHANGER; }
    bool isContainer() const { return getType() == TYPE_CONTAINER; }
    bool isGeometry() const { return getType() == TYPE_GEOMETRY; }

    /*
     * Get material only if it this object is solid (has assign exactly one material).
     * @return material or nullptr if it is not solid
     *
     * Default implementation returns nullptr.
     */
    //virtual shared_ptr<Material> singleMaterial() const { return shared_ptr<Material>(); }

    /**
     * Get information if object is solid in its bouding-box in given @p direction.
     * @param direction direction
     * @return @c true only if object is solid in its bouding-box in given @p direction
     */
    virtual bool isUniform(Primitive<3>::Direction direction) const { return false; }

    /**
     * Check if this object belongs to class (has tag) with name @p role_name.
     * @param role_name name of class/tag to check
     * @return @c true only if this belongs to class @p role_name
     */
    bool hasRole(const std::string& role_name) const { return roles.find(role_name) != roles.end(); }

    /**
     * Add this to given class.
     * @param role_name name of class where this should be added
     */
    void addRole(const std::string& role_name) { roles.insert(role_name); }

    /**
     * Remove this from given class, do nothing if this is not in given class.
     * @param role_name name of class from where this should be removed
     */
    void removeRole(const std::string& role_name) { roles.erase(role_name); }

    /**
     * Clear set of roles of this.
     */
    void clearRoles() { roles.clear(); }

    /**
     * Get number of dimentions.
     * @return number of dimentions
     */
    virtual int getDimensionsCount() const = 0;

    /**
     * Check if object is ready for calculation.
     * Throw exception if object is in bad state and can't be used in calculations, for example has not required children, etc.
     * Default implementation do nothing, but inherited class can change this behavior.
     * @throw Exception if object is not ready for calculation
     */
    virtual void validate() const {}

    /**
     * Check if @a el is in subtree with @c this in root.
     * @param el object to search for
     * @return @c true only if @a el is in subtree with @c this in root
     */
    //TODO ? predicate, path
    virtual bool hasInSubtree(const GeometryObject& el) const;

    bool hasInSubtree(const GeometryObject& el, const PathHints* pathHints) const {
        return !getObjects(PredicateIsA(el), pathHints).empty();
    }

    bool hasInSubtree(shared_ptr<const GeometryObject> el, const PathHints* pathHints) const {
        return hasInSubtree(*el, pathHints);
    }

    /**
     * Find paths to @a el.
     * @param el object to search for
     * @param pathHints (optional) path hints which limits search space
     * @return sub-tree with paths to given object (@p el is in all leafs), empty sub-tree if @p el is not in subtree with @c this in root
     */
    //TODO ? predicate
    virtual Subtree getPathsTo(const GeometryObject& el, const PathHints* pathHints = 0) const = 0;

    /**
     * Append all objects from subtree with this in root, which fullfil predicate to vector @p dest.
     * @param predicate predicate required to match
     * @param dest destination vector
     * @param path (optional) path hints which limits search space
     */
    virtual void getObjectsToVec(const Predicate& predicate, std::vector< shared_ptr<const GeometryObject> >& dest, const PathHints* path = 0) const = 0;

    /**
     * Append all objects from subtree with this in root, which fullfil predicate to vector @p dest.
     * @param predicate predicate required to match
     * @param dest destination vector
     * @param path path hints which limits search space
     */
    void getObjectsToVec(const Predicate& predicate, std::vector< shared_ptr<const GeometryObject> >& dest, const PathHints& path) const {
        getObjectsToVec(predicate, dest, &path);
    }

    /**
     * Get vector of all objects from subtree with this in root, which fullfil predicate.
     * @param predicate predicate required to match
     * @param path (optional) path hints which limits search space
     * @return vector of all objects from subtree with this in root, which fullfil predicate
     */
    std::vector< shared_ptr<const GeometryObject> > getObjects(const Predicate& predicate, const PathHints* path = 0) const {
        std::vector< shared_ptr<const GeometryObject> > result;
        getObjectsToVec(predicate, result, path);
        return result;
    }

    /**
     * Get vector of all objects from subtree with this in root, which fullfil predicate.
     * @param predicate predicate required to match
     * @param path path hints which limits search space
     * @return vector of all objects from subtree with this in root, which fullfil predicate
     */
    std::vector< shared_ptr<const GeometryObject> > getObjects(const Predicate& predicate, const PathHints& path) const {
        return getObjects(predicate, &path);
    }

    /**
     * Append all leafs in subtree with this in root to vector @p dest.
     * @param dest leafs destination vector
     * @param path (optional) path hints which limits search space
     */
    void getLeafsToVec(std::vector< shared_ptr<const GeometryObject> >& dest, const PathHints* path = 0) const {
        getObjectsToVec(&GeometryObject::PredicateIsLeaf, dest, path);
    }

    /**
     * Append all leafs in subtree with this in root to vector @p dest.
     * @param dest leafs destination vector
     * @param path path hints which limits search space
     */
    void getLeafsToVec(std::vector< shared_ptr<const GeometryObject> >& dest, const PathHints& path) const {
        getLeafsToVec(dest, &path);
    }

    /**
     * Get all leafs in subtree with this object as root.
     * @param path (optional) path hints which limits search space
     * @return all leafs in subtree with this object as root
     */
    std::vector< shared_ptr<const GeometryObject> > getLeafs(const PathHints* path = 0) const {
        std::vector< shared_ptr<const GeometryObject> > result;
        getLeafsToVec(result, path);
        return result;
    }

    /**
     * Get all leafs in subtree with this object as root.
     * @param path path hints which limits search space
     * @return all leafs in subtree with this object as root
     */
    std::vector< shared_ptr<const GeometryObject> > getLeafs(const PathHints& path) const {
        return getLeafs(&path);
    }

    /**
     * Append all objects with a specified role in subtree with this in root to vector @p dest.
     * \param dest objects destination vector
     * \param role role to search objects with
     */
    void getObjectsWithRoleToVec(const std::string& role, std::vector<shared_ptr<const GeometryObject>>& dest) const {
        getObjectsToVec(PredicateHasRole(role), dest);
    }

    /**
     * Get all objects with a specified role in subtree with this object as root.
     * \param role role to search objects with
     * \return all objects in subtree with this object as root having a specified role
     */
    std::vector<shared_ptr<const GeometryObject>> getObjectsWithRole(const std::string& role) const {
        return getObjects(PredicateHasRole(role));
    }

    /**
     * Get number of all children of this in geometry graph.
     * @return number of children
     */
    virtual std::size_t getChildrenCount() const = 0;

    /**
     * Get child with given index.
     * @param child_no index of child to get
     * @return child with index @p child_no
     */
    virtual shared_ptr<GeometryObject> getChildNo(std::size_t child_no) const = 0;

    /**
     * Get number of real (physically stored) children in geometry graph.
     *
     * By default call getChildrenCount(), but objects of some types (like multi-stack) redefine this.
     * @return number of real children
     */
    virtual std::size_t getRealChildrenCount() const;

    /**
     * Get real (physically stored) child with given index.
     *
     * By default call getChildNo(child_no), but objects of some types (like multi-stack) redefine this.
     * @param child_no index of real child to get
     * @return child with index @p child_no
     */
    virtual shared_ptr<GeometryObject> getRealChildNo(std::size_t child_no) const;

    /**
     * Remove child at given @p index.
     *
     * This is unsafe but fast version, it doesn't check index and doesn't call fireChildrenChanged() to inform listeners about this object changes.
     * Caller should do this manually or call removeAt(std::size_t) instead.
     *
     * Default implementation throw excption but this method is overwritten in subroles.
     * @param index index of real child to remove
     */
    virtual void removeAtUnsafe(std::size_t index);

    /**
     * Remove child at given @p index.
     *
     * Throw exception if given @p index is not valid, real child index.
     * @param index index of real child to remove
     */
    void removeAt(std::size_t index) {
        ensureIsValidChildNr(index, "removeAt", "index");
        removeAtUnsafe(index);
        fireChildrenRemoved(index, index+1);
    }

    void removeRangeUnsafe(std::size_t index_begin, std::size_t index_end) {
        while (index_begin < index_end) removeAtUnsafe(--index_end);
    }

    /**
     * Remove all children in given range [index_begin, index_end).
     * @param index_begin, index_end range of real children's indexes
     * @return true if something was delete
     */
    bool removeRange(std::size_t index_begin, std::size_t index_end) {
        if (index_begin >= index_end) return false;
        ensureIsValidChildNr(index_end-1, "removeRange", "index_end-1");
        removeRangeUnsafe(index_begin, index_end);
        fireChildrenRemoved(index_begin, index_end);
        return true;
    }

    /**
     * Call a @p callback for each object in subtree with @c this in root.
     *
     * Visit tree in pre-order.
     * @param callback call-back to call, should return @c true only if descendants of object given as parameter should be visited
     */
    virtual void forEachRealObjectInSubtree(std::function<bool(const GeometryObject &)> callback) const;

private:
    struct ChildGetter {    //used by begin(), end()
        shared_ptr<const GeometryObject> el;
        ChildGetter(const shared_ptr<const GeometryObject>& el): el(el) {}
        shared_ptr<GeometryObject> operator()(std::size_t index) const { return el->getChildNo(index); }
    };

public:

    ///@return begin begin iterator over children
    FunctorIndexedIterator<ChildGetter> begin() const {
        return FunctorIndexedIterator<ChildGetter>(ChildGetter(this->shared_from_this()), 0);
    }

    ///@return end end iterator over children
    FunctorIndexedIterator<ChildGetter> end() const {
        return FunctorIndexedIterator<ChildGetter>(ChildGetter(this->shared_from_this()), getChildrenCount());
    }

    //virtual GeometryTransform getTransform()

    /**
     * Get this or copy of this with some changes in subtree.
     * @param[in] changer changer which will be aplied to subtree with this in root
     * @param[out] translation optional, if non-null, recommended translation of this after change will be stored
     * @return pointer to this (if nothing was change) or copy of this with some changes in subtree
     */
    virtual shared_ptr<const GeometryObject> changedVersion(const Changer& changer, Vec<3, double>* translation = 0) const = 0;

    bool canHasAsChild(const GeometryObject& potential_child) const { return !potential_child.hasInSubtree(*this); }
    bool canHasAsParent(const GeometryObject& potential_parent) const { return !this->hasInSubtree(potential_parent); }

    /**
     * Throw CyclicReferenceException if @p potential_parent is in subtree with this in root.
     * @param[in] potential_parent potential, new parent of this
     */
    void ensureCanHasAsParent(const GeometryObject& potential_parent) const;

    /**
     * Throw CyclicReferenceException if @p potential_child has this in subtree.
     * @param[in] potential_child potential, new child of this
     */
    void ensureCanHaveAsChild(const GeometryObject& potential_child) const { potential_child.ensureCanHasAsParent(*this); }

protected:

    /**
     * Append XML attribiutes of this to @p dest_xml_object.
     *
     * By default do nothing.
     * @param dest_xml_object XML tag where attribiutes should be append
     * @param axes choosen name of axes
     */
    virtual void writeXMLAttr(XMLWriter::Element& dest_xml_object, const AxisNames& axes) const;

    /**
     * Append all children of this to XML @p dest_xml_object..
     * @param dest_xml_object XML tag where attribiutes should be append
     * @param write_cb write callback, used to get names for objects and paths
     * @param axes chosen name of axes
     */
    virtual void writeXMLChildren(XMLWriter::Element& dest_xml_object, WriteXMLCallback& write_cb, const AxisNames &axes) const;

    /**
     * Check if given @p index is valid child index and throw exception of it is not.
     * @param child_no index to check
     * @param method_name caller method name which is used to format excption message
     * @param arg_name name of index argument in caller method, used to format excption message
     * @throw OutOfBoundsException if index is not valid
     */
    void ensureIsValidChildNr(std::size_t child_no, const char* method_name = "getChildNo", const char* arg_name = "child_no") const {
        std::size_t children_count = getRealChildrenCount();
        if (child_no >= children_count)
            throw OutOfBoundsException(method_name, arg_name, child_no, 0, children_count-1);
    }

    /**
     * Check if given @p index is valid insert index and throw exception of it is not.
     * @param child_no index to check
     * @param method_name caller method name which is used to format excption message
     * @param arg_name name of index argument in caller method, used to format excption message
     * @throw OutOfBoundsException if index is not valid
     */
    void ensureIsValidInsertPosition(std::size_t child_no, const char* method_name = "insert", const char* arg_name = "pos") const {
        std::size_t children_count = getRealChildrenCount();
        if (child_no > children_count)
            throw OutOfBoundsException(method_name, arg_name, child_no, 0, children_count-1);
    }

    /// Inform observers that children list was changed (also that this is resized)
    void fireChildrenChanged() {
        this->fireChanged(GeometryObject::Event::EVENT_RESIZE | GeometryObject::Event::EVENT_CHILDREN_GENERIC);
    }

    void fireChildrenRemoved(std::size_t beginIndex, std::size_t endIndex) {
        this->fireChanged<ChildrenListChangedEvent>(GeometryObject::Event::EVENT_RESIZE | GeometryObject::Event::EVENT_CHILDREN_REMOVE, beginIndex, endIndex);
    }

    void fireChildrenInserted(std::size_t beginIndex, std::size_t endIndex) {
        this->fireChanged<ChildrenListChangedEvent>(GeometryObject::Event::EVENT_RESIZE | GeometryObject::Event::EVENT_CHILDREN_INSERT, beginIndex, endIndex);
    }

};

template <int dim> struct Translation;

/**
 * Template of base roles for geometry objects in space with given number of dimensions (2 or 3).
 * @tparam dimensions number of dimensions, 2 or 3
 * @ingroup GEOMETRY_OBJ
 */
template <int dim>
struct GeometryObjectD: public GeometryObject {

    static const int DIM = dim;
    typedef typename Primitive<dim>::Box Box;
    typedef typename Primitive<dim>::DVec DVec;

    int getDimensionsCount() const { return dim; }

    using GeometryObject::getPathsTo;

    /**
     * Find all paths to objects which lies at given @p point.
     * @param point point in local coordinates
     * @param all if true then return all paths if branches overlap the point
     * @return all paths, last one is on top and overlies rest
     */
    virtual Subtree getPathsAt(const DVec& point, bool all=false) const = 0;

    /**
     * Check if this geometry object contains point.
     * @param point point in local coordinates
     * @return true only if this geometry contains point @a p
     */
    virtual bool contains(const DVec& point) const = 0;

    /*
     * Check if this geometry object contains some point from given @a area.
     * @param area rectangular area
     * @return true only if this geometry contains some points from @a area
     */
    //TODO unused - to use and implement in subclasses (most have impl.) or to remove
    //virtual bool intersects(const Box& area) const = 0;

    /**
     * Calculate minimal rectangle which contains all points of geometry object.
     * @return calculated rectangle
     */
    virtual Box getBoundingBox() const = 0;

    virtual DVec getBoundingBoxSize() const { return getBoundingBox().size(); }

    /**
     * Calculate minimal rectangle which contains all points of real geometry object.
     *
     * This box can be diffrent from getBoundingBox() only for objects which have virtual children, like multple-stack.
     * Returned box is always included in (in most cases: equal to) box returned by getBoundingBox().
     *
     * Default implementation returns result of getBoundingBox() call.
     * @return calculated rectangle
     */
    virtual Box getRealBoundingBox() const { return getBoundingBox(); }

    /**
     * Return material in a given point inside the geometry object
     * @param p point
     * @return material in given point, or @c nullptr if this GeometryObject not contains point @a p
     */
    virtual shared_ptr<Material> getMaterial(const DVec& p) const = 0;

    /**
     * Return material in a given point inside the geometry object
     * @param p point
     * @return material in given point, or Air if this GeometryObject not contains point @a p
     */
    shared_ptr<Material> getMaterialOrAir(const DVec& p) const {
        auto real_mat = getMaterial(p);
        return real_mat ? real_mat : plask::make_shared<materials::Air>();
    }

    /**
     * Calculate and append to vector bounding boxes of all nodes which fulfill given @p predicate, optionally marked by path.
     * @param predicate
     * @param dest place to add result, bounding boxes will be added in the same order which is generated by GeometryObject::getObjects
     * @param path path (optional) path hints which limits search space
     */
    virtual void getBoundingBoxesToVec(const GeometryObject::Predicate& predicate, std::vector<Box>& dest, const PathHints* path = 0) const = 0;

    /**
     * Calculate and append to vector bounding boxes of all nodes which fulfill given @p predicate, marked by path.
     * @param predicate
     * @param dest place to add result, bounding boxes will be added in the same order which is generated by GeometryObject::getObjects
     * @param path path hints which limits search space
     */
    void getBoundingBoxesToVec(const GeometryObject::Predicate& predicate, std::vector<Box>& dest, const PathHints& path) const {
        getBoundingBoxesToVec(predicate, dest, &path);
    }

    /**
     * Calculate the vector of bounding boxes of all nodes which fulfill given @p predicate, optionally marked by path.
     * @param predicate
     * @param path (optional) path hints which limits search space
     * @return vector of bounding boxes of all nodes which fulfill given @p predicate, optionally marked by path
     */
    std::vector<Box> getBoundingBoxes(const GeometryObject::Predicate& predicate, const PathHints* path = 0) const {
        std::vector<Box> result;
        getBoundingBoxesToVec(predicate, result, path);
        return result;
    }

    /**
     * Calculate the vector of bounding boxes of all nodes which fulfill given @p predicate, marked by path.
     * @param predicate
     * @param path path hints which limits search space
     * @return vector of bounding boxes of all nodes which fulfill given @p predicate, optionally marked by path
     */
    std::vector<Box> getBoundingBoxes(const GeometryObject::Predicate& predicate, const PathHints& path) {
        return getBoundingBoxes(predicate, &path);
    }

    /**
     * Calculate and append to vector bounding boxes of all leafs, optionally marked by path.
     * @param dest place to add result, bounding boxes will be added in the same order which is generated by GeometryObject::getLeafsToVec
     * @param path (optional) path hints which limits search space
     */
    void getLeafsBoundingBoxesToVec(std::vector<Box>& dest, const PathHints* path = 0) const {
        getBoundingBoxesToVec(&GeometryObject::PredicateIsLeaf, dest, path);
    }

    /**
     * Calculate and append to vector bounding boxes of all leafs, marked by path.
     * @param dest place to add result, bounding boxes will be added in the same order which is generated by GeometryObject::getLeafsToVec
     * @param path path hints which limits search space
     */
    void getLeafsBoundingBoxesToVec(std::vector<Box>& dest, const PathHints& path) const {
        getLeafsBoundingBoxesToVec(dest, &path);
    }

    /**
     * Calculate bounding boxes of all leafs, optionally marked by path.
     * @param path (optional) path hints which limits search space
     * @return bounding boxes of all leafs, in the same order which is generated by GeometryObject::getLeafs(const PathHints*)
     */
    std::vector<Box> getLeafsBoundingBoxes(const PathHints* path = 0) const {
        std::vector<Box> result;
        getLeafsBoundingBoxesToVec(result, path);
        return result;
    }

    /**
     * Calculate bounding boxes of all leafs, marked by path.
     * @param path path hints which limits search space
     * @return bounding boxes of all leafs, in the same order which is generated by GeometryObject::getLeafs(const PathHints&)
     */
    std::vector<Box> getLeafsBoundingBoxes(const PathHints& path) const {
        return getLeafsBoundingBoxes(&path);
    }

    /**
     * Calculate and append to vector bounding boxes of all instances of given \p object, optionally marked by path.
     * @param object object
     * @param dest place to add result
     * @param path (optional) path hints which limits search space
     */
    void getObjectBoundingBoxesToVec(std::vector<Box>& dest, const GeometryObject& object, const PathHints* path = 0) const {
        getBoundingBoxesToVec(GeometryObject::PredicateIsA(object), dest, path);
    }

    /**
     * Calculate and append to vector bounding boxes of all instances of given \p object, marked by path.
     * @param object object
     * @param dest place to add result
     * @param path path hints which limits search space
     */
    void getObjectBoundingBoxesToVec(std::vector<Box>& dest, const GeometryObject& object, const PathHints& path) const {
        getObjectBoundingBoxesToVec(dest, object, &path);
    }

    /**
     * Calculate bounding boxes of all instances of given \p object, optionally marked by path.
     * @param object object
     * @param path (optional) path hints which limits search space
     * @return bounding boxes of all instances of given \p object
     */
    std::vector<Box> getObjectBoundingBoxes(const GeometryObject& object, const PathHints* path = 0) const {
        std::vector<Box> result;
        getObjectBoundingBoxesToVec(result, object, path);
        return result;
    }

    /**
     * Calculate bounding boxes of all instances of given @p objects, marked by @p path.
     * @param object object
     * @param path path hints which limits search space
     * @return bounding boxes of all objects, in the same order which is generated by GeometryObject::getObjects(const PathHints&)
     */
    std::vector<Box> getObjectBoundingBoxes(const GeometryObject& object, const PathHints& path) const {
        return getObjectBoundingBoxes(object, &path);
    }


    /**
     * Calculate and append to vector positions of all nodes which fulfill given @p predicate, optionally marked by path.
     *
     * Some objects can have all vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     * @param predicate predicate required to match
     * @param dest place to add result, positions will be added in the same order which is generated by GeometryObject::getObjectsToVec
     * @param path (optional) path hints which limits search space
     */
    virtual void getPositionsToVec(const Predicate& predicate, std::vector<DVec>& dest, const PathHints* path = 0) const = 0;

    /**
     * Calculate and append to vector positions of all nodes which fulfill given @p predicate, marked by path.
     *
     * Some objects can have all vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     * @param predicate predicate required to match
     * @param dest place to add result, positions will be added in the same order which is generated by GeometryObject::getObjectsToVec
     * @param path path hints which limits search space
     */
    void getPositionsToVec(const Predicate& predicate, std::vector<DVec>& dest, const PathHints& path) const {
        getPositionsToVec(predicate, dest, &path);
    }

    /**
     * Calculate and append to vector positions of all nodes which fulfill given @p predicate, optionally marked by path.
     * @param predicate predicate required to match
     * @param path (optional) path hints which limits search space
     * @return positions of the pointed objects in the sub-tree with this object in the root, in the same order which is generated by GeometryObject::getObjects
     *
     * Some objects can have all vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     */
    std::vector<DVec> getPositions(const Predicate& predicate, const PathHints* path = 0) const {
        std::vector<DVec> result;
        getPositionsToVec(predicate, result, path);
        return result;
    }

    /**
     * Calculate and append to vector positions of all nodes which fulfill given @p predicate, marked by path.
     * @param predicate predicate required to match
     * @param path path hints which limits search space
     * @return positions of the pointed objects in the sub-tree with this object in the root, in the same order which is generated by GeometryObject::getObjects
     *
     * Some objects can have all vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     */
    std::vector<DVec> getPositions(const Predicate& predicate, const PathHints& path) const {
        return getPositions(predicate, &path);
    }

    /**
     * Calculate and append to vector positions of all leafs, optionally marked by path.
     *
     * Some leafs can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     * @param dest place to add result, positions will be added in the same order which is generated by GeometryObject::getLeafsToVec
     * @param path (optional) path hints which limits search space
     */
    void getLeafsPositionsToVec(std::vector<DVec>& dest, const PathHints* path = 0) const {
        getPositionsToVec(&GeometryObject::PredicateIsLeaf, dest, path);
    }

    /**
     * Calculate and append to vector positions of all leafs, marked by path.
     *
     * Some leafs can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     * @param dest place to add result, positions will be added in the same order which is generated by GeometryObject::getLeafsToVec
     * @param path path hints which limits search space
     */
    void getLeafsPositionsToVec(std::vector<DVec>& dest, const PathHints& path) const {
        getLeafsPositionsToVec(dest, &path);
    }

    /**
     * Calculate and return a vector of positions of all leafs, optionally marked by path.
     * @param path (optional) path hints which limits search space
     * @return positions of leafs in the sub-tree with this object in the root, in the same order which is generated by GeometryObject::getLeafs
     *
     * Some leafs can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     */
    std::vector<DVec> getLeafsPositions(const PathHints* path = 0) const {
        std::vector<DVec> result;
        getLeafsPositionsToVec(result, path);
        return result;
    }

    /**
     * Calculate and return a vector of positions of all leafs, marked by path.
     * @param path path hints which limits search space
     * @return positions of leafs in the sub-tree with this object in the root, in the same order which is generated by GeometryObject::getLeafs
     *
     * Some leafs can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     */
    std::vector<DVec> getLeafsPositions(const PathHints& path) const {
        return getLeafsPositions(&path);
    }

    /**
     * Calculate and append to vector positions of all instances of given @p object, optionally marked by path.
     *
     * Some objects can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     * @param dest place to add result, positions will be added in the same order which is generated by GeometryObject::getObjectsToVec
     * @param object object to which instances translations should be found
     * @param path (optional) path hints which limits search space
     */
    void getObjectPositionsToVec(std::vector<DVec>& dest, const GeometryObject& object, const PathHints* path = 0) const {
        getPositionsToVec(PredicateIsA(object), dest, path);
    }

    /**
     * Calculate and append to vector positions of all instances of given @p object, marked by path.
     *
     * Some objects can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     * @param dest place to add result, positions will be added in the same order which is generated by GeometryObject::getObjectsToVec
     * @param object object to which instances translations should be found
     * @param path path hints which limits search space
     */
    void getObjectPositionsToVec(std::vector<DVec>& dest, const GeometryObject& object, const PathHints& path) const {
        getObjectPositionsToVec(dest, object, &path);
    }

    /**
     * Calculate and return a vector of positions of all instances of given @p object, optionally marked by path.
     * @param object object to which instances translations should be found
     * @param path (optional) path hints which limits search space
     * @return vector of positions
     *
     * Some objects can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     */
    std::vector<DVec> getObjectPositions(const GeometryObject& object, const PathHints* path = 0) const {
        return getPositions(PredicateIsA(object), path);
    }

    /**
     * Calculate and return a vector of positions of all instances of given @p object, marked by path.
     * @param object object to which instances translations should be found
     * @param path path hints which limits search space
     * @return vector of positions
     *
     * Some objects can have vector of NaNs as translations.
     * This mean that translation is not well defined (some space changer on path).
     */
    std::vector<DVec> getObjectPositions(const GeometryObject& object, const PathHints& path) const {
        return getObjectPositions(object, &path);
    }

    // /*
    //  * Get objects from the subtree with root in this, which fulfill predecate. Returned objects
    //  * are wrapped in transformations, which transform them to the root coordinates.
    //  * @param predicate
    //  * @param dest[out] place to append resulted objects
    //  * @param path
    //  */
    // virtual void extractToVec(const Predicate& predicate, std::vector< shared_ptr<const GeometryObjectD<dim> > >& dest, const PathHints* path = 0) const = 0;

    // /*
    //  * Get objects from the subtree with root in this, which fulfill predecate. Returned objects
    //  * are wrapped in transformations, which transform them to the root coordinates.
    //  * @param predicate
    //  * @param dest[out] place to append resulted objects
    //  * @param path
    //  */
    // void extractToVec(const Predicate& predicate, std::vector< shared_ptr<const GeometryObjectD<dim> > >& dest, const PathHints& path) const {
    //     extractToVec(predicate, dest, &path);
    // }

    // /*
    //  * Get objects from the subtree with root in this, which fulfill predecate. Returned objects
    //  * are wrapped in transformations, which transform them to the root coordinates.
    //  * @param predicate
    //  * @param path
    //  * @return resulted objects
    //  */
    // std::vector< shared_ptr<const GeometryObjectD<dim> > > extract(const Predicate& predicate, const PathHints* path = 0) const {
    //     std::vector< shared_ptr<const GeometryObjectD<dim> > > dest;
    //     extractToVec(predicate, dest, path);
    //     return dest;
    // }

    // /*
    //  * Get objects from the subtree with root in this, which fulfill predecate. Returned objects
    //  * are wrapped in transformations, which transform them to the root coordinates.
    //  * @param predicate
    //  * @param path
    //  * @return resulted objects
    //  */
    // std::vector<shared_ptr<const GeometryObjectD<dim>>> extract(const Predicate& predicate, const PathHints& path) const {
    //     return extract(predicate, &path);
    // }

    // /*
    //  * Get instances of the object withing subtree with root in this. Returned intances
    //  * are wrapped in transformations, which transform them to the root coordinates.
    //  * @param object object to extract
    //  * @param path
    //  * @return resulted objects
    //  */
    // std::vector<shared_ptr<const GeometryObjectD<dim>>> extractObject(const GeometryObjectD<dim>& object, const PathHints* path = 0) {
    //     return extract(PredicateIsA(object), path);
    // }

    // /*
    //  * Get instances of the object withing subtree with root in this. Returned intances
    //  * are wrapped in transformations, which transform them to the root coordinates.
    //  * @param object object to extract
    //  * @param path
    //  * @return resulted objects
    //  */
    // std::vector<shared_ptr<const GeometryObjectD<dim>>> extractObject(const GeometryObjectD<dim>& object, const PathHints& path) {
    //     return extractObject(object, &path);
    // }

    // /*
    //  * Get leafs withing subtree with root in this, wrapped in transformations, which transform them to the root coordinates.
    //  * @param path
    //  * @return resulted objects
    //  */
    // std::vector<shared_ptr<const GeometryObjectD<dim>>> extractLeafs(const PathHints* path = 0) {
    //     return extract(&GeometryObject::PredicateIsLeaf, path);
    // }

    // /*
    //  * Get leafs withing subtree with root in this, wrapped in transformations, which transform them to the root coordinates.
    //  * @param path
    //  * @return resulted objects
    //  */
    // std::vector<shared_ptr<const GeometryObjectD<dim>>> extractLeafs(const PathHints& path) {
    //     return extractLeafs(&path);
    // }

    // //TODO
    // //shared_ptr<const TranslationContainer<dim>> extractIntoContainer(const Predicate& predicate, const PathHints* path = 0) const;
    // //shared_ptr<const TranslationContainer<dim>> extractIntoContainer(const Predicate& predicate, const PathHints& path) const;

    //Path getMatchingPathToObjectAt(const DVec& point, const Predicate& predicate, const PathHints* path = 0) const;

    /**
     * Get object closest to the root, which contains specific point and fulfills the predicate
     * \param point point to test
     * \param predicate predicate required to match, called for each object on path to point, in order from root to leaf
     * \param path optional path hints filtering out some objects
     * \return resulted object or empty pointer
     */
    shared_ptr<const GeometryObject> getMatchingAt(const DVec& point, const Predicate& predicate, const PathHints* path = 0) const;

    /**
     * Get object closest to the root, which contains specific point and fulfills the predicate
     * \param point point to test
     * \param predicate predicate required to match, called for each object on path to point, in order from root to leaf
     * \param path path hints filtering out some objects
     * \return resulted object or empty pointer
     */
    inline shared_ptr<const GeometryObject> getMatchingAt(const DVec& point, const Predicate& predicate, const PathHints& path) const {
        return getMatchingAt(point, predicate, &path);
    }

    /**
     * Check if specified geometry object contains a point @a point.
     * \param object object to test
     * \param path path hints specifying the object
     * \param point point
     * \return true only if this geometry contains the point @a point
     */
    inline bool objectIncludes(const GeometryObject& object, const PathHints* path, const DVec& point) const {
        return getMatchingAt(point, PredicateIsA(object), path) != nullptr;
    }

    /**
     * Check if specified geometry object contains a point @a point.
     * \param object object to test
     * \param path path hints specifying the object
     * \param point point
     * \return true only if this geometry contains the point @a point
     */
    inline bool objectIncludes(const GeometryObject& object, const PathHints& path, const DVec& point) const {
        return objectIncludes(object, &path, point);
    }

    /**
     * Check if specified geometry object contains a point @a point.
     * \param object object to test
     * \param point point
     * \return true only if this geometry contains the point @a point
     */
    inline bool objectIncludes(const GeometryObject& object, const DVec& point) const {
        return objectIncludes(object, nullptr, point);
    }

    /**
     * Get a sum of roles sets of all objects which lies on path from this to leaf at given @p point.
     * @param point point
     * @param path optional path hints filtering out some objects
     * @return calculated set
     */
    std::set<std::string> getRolesAt(const DVec& point, const plask::PathHints* path = 0) const;

    /**
     * Get a sum of roles sets of all objects which lies on path from this to leaf at given @p point.
     * @param point point
     * @param path path hints filtering out some objects
     * @return calculated set
     */
    std::set<std::string> getRolesAt(const DVec& point, const plask::PathHints& path) const {
        return getRolesAt(point, &path);
    }

    /**
     * Check if any object at given @p point, not hidden by another object, plays role with given name @p role_name
     * (if so, returns non-nullptr).
     * @param role_name name of class
     * @param point point
     * @param path optional path hints filtering out some objects
     * @return object which is at given @p point, is not hidden by another object and plays role with name @p role_name,
     *          @c nullptr if there is not such object
     */
    shared_ptr<const GeometryObject> hasRoleAt(const std::string& role_name, const DVec& point, const plask::PathHints* path = 0) const {
        return getMatchingAt(point, GeometryObject::PredicateHasRole(role_name), path);
    }

    /**
     * Check if any object at given @p point, not hidden by another object, plays role with given name @p role_name
     * (if so, returns non-nullptr).
     * @param role_name name of class
     * @param point point
     * @param path optional path hints filtering out some objects
     * @return object which is at given @p point, is not hidden by another object and plays role with name @p role_name,
     *          nullptr if there is not such object
     */
    shared_ptr<const GeometryObject> hasRoleAt(const std::string& role_name, const DVec& point, const plask::PathHints& path) const {
        return hasRoleAt(role_name, point, &path);
    }
};

template <int dims>
shared_ptr<const GeometryObject> GeometryObjectD<dims>::getMatchingAt(const DVec& point, const Predicate& predicate, const plask::PathHints* path) const;

PLASK_API_EXTERN_TEMPLATE_STRUCT(GeometryObjectD<2>)
PLASK_API_EXTERN_TEMPLATE_STRUCT(GeometryObjectD<3>)

} // namespace plask

#endif // PLASK__GEOMETRY_OBJECT_H







