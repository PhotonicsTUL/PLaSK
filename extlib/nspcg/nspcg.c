/* nspcg.f -- translated by f2c (version 20200916).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/
#include <time.h>
#include "libf2c/f2c.h"

/* Common Block Declarations */

struct {
    integer method, iscale, iperm, nstore, ifact, kblsz, lvfill, ltrunc, ndeg,
	     ipropa, isymm, ifctv;
} itcom6_;

#define itcom6_1 itcom6_

struct {
    integer ndim, mdim, maxnz;
} dscons_;

#define dscons_1 dscons_

struct {
    integer lenr, irpnt, irmax, leni, iipnt, iimax;
} cwkcon_;

#define cwkcon_1 cwkcon_

struct {
    integer nfactr, nfacti, ifactr, ifacti;
    doublereal timfac;
} cfactr_;

#define cfactr_1 cfactr_

struct {
    integer mpstrt, mpart;
} cmpart_;

#define cmpart_1 cmpart_

struct {
    integer iptscl, iwkpt1, iwkpt2, iwkpt3;
} point_;

#define point_1 point_

struct {
    integer in, itmax, level, nout, ns1, ns2, ns3, iplr, iqlr, ntest, is,
	    iacel, idgts, nbl1d, nbl2d;
} itcom1_;

#define itcom1_1 itcom1_

union {
    struct {
	logical propa;
	integer ncolor, maxd, nc, ipt, maxnew, jcnew, lbhb, iblock, ncmax;
    } _1;
    struct {
	logical propa;
	integer ncolor, maxd, nc, ipt, maxnew, jcnew, lbhb, iblk, ncmax;
    } _2;
    struct {
	logical propa;
	integer ncol, maxd, nc, ipt, maxnew, jcnew, lbhb, iblk, ncmax;
    } _3;
} cblock_;

#define cblock_1 (cblock_._1)
#define cblock_2 (cblock_._2)
#define cblock_3 (cblock_._3)

struct {
    integer ndt, ndb, maxt, maxb, ivers, irwise;
} intern_;

#define intern_1 intern_

struct {
    integer ndimrs, mdimrs, maxzrs;
} rscons_;

#define rscons_1 rscons_

struct {
    doublereal srelpr;
    integer keyzer, keygs;
} itcom4_;

#define itcom4_1 itcom4_

struct {
    doublereal ainf;
} itcom8_;

#define itcom8_1 itcom8_

struct {
    doublereal omega, alphab, betab, fff, specr;
    logical omgadp;
} itcom5_;

#define itcom5_1 itcom5_

struct {
    integer nblk, nband, ictac, ieta, ivcgcr;
} ccgcr_;

#define ccgcr_1 ccgcr_

struct {
    doublereal alpha, beta, zeta, emax, emin, pap, alphao, gamma, sigma, rr,
	    rho, dkq, dkm1, ff, rqmin, rqmax, stptst, udnm, ubarnm, bnorm,
	    bnorm1;
} itcom3_;

#define itcom3_1 itcom3_

struct {
    logical halt, maxadp, minadp, maxadd, minadd;
} itcom2_;

#define itcom2_1 itcom2_

struct {
    doublereal rdot, rzdot, rztdot, zdot, zztdot, ztdot;
    logical rhave, zhave, zthave, rcalp, zcalp, ztcalp, udhav, rdhav, rzhav,
	    rzthav, zdhav, zzthav, ztdhav;
} itcom9_;

#define itcom9_1 itcom9_

/* Table of constant values */

static integer c__1 = 1;
static integer c__2 = 2;
static integer c__0 = 0;
static doublereal c_b121 = 0.;
static integer c__3 = 3;
static integer c__4 = 4;
static integer c__5 = 5;
static doublereal c_b922 = 1.;
static doublereal c_b4207 = .1;

/* Subroutine */ int nspcg_(S_fp precon, U_fp accel, integer *ndimm, integer *
	mdimm, integer *nn, integer *maxnzz, doublereal *coef, integer *jcoef,
	 integer *p, integer *ip, doublereal *u, doublereal *ubar, doublereal
	*rhs, doublereal *wksp, integer *iwksp, integer *nw, integer *inw,
	integer *iparm, doublereal *rparm, integer *ier)
{
    static integer n;
    static doublereal t1, t2, tol;
    extern /* Subroutine */ int elim_(integer *, integer *, doublereal *,
	    doublereal *, doublereal *, integer *, doublereal *), prep_(
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    integer *, integer *), scale_(doublereal *, integer *, doublereal
	    *, integer *, integer *, doublereal *, doublereal *, doublereal *,
	     integer *);
    static integer ielim;
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *), adjust_(integer *, integer *,
	    integer *, integer *, integer *), detsym_(integer *, integer *,
	    doublereal *, integer *, integer *, integer *), ershow_(integer *,
	     char *, ftnlen), pointr_(integer *, doublereal *, integer *,
	    integer *), permut_(doublereal *, integer *, integer *, integer *,
	     doublereal *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, integer *);
    static doublereal timtot;


/* ... nspcg is the driver for the nspcg package. */

/* ... parameters -- */

/*       precon    preconditioning module */
/*       accel     acceleration module */
/*       coef      floating point matrix data array */
/*       jcoef     integer matrix data array */
/*       n         input integer.  order of the system (= nn) */
/*       u         input/output vector.  on input, u contains the */
/*                 initial guess to the solution.  on output, it */
/*                 contains the latest estimate to the solution. */
/*       ubar      input vector containing the true solution */
/*                  (optional) */
/*       rhs       input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*       wksp      floating point workspace vector of length nw */
/*       iwksp     integer workspace vector of length inw */
/*       nw        length of wksp upon input, amount used upon */
/*                  output */
/*       inw       length of iwksp upon input, amount used upon */
/*                  output */
/*       iparm     integer vector of length 30.  allows user to */
/*                 specify some integer parameters which affect */
/*                 the method. */
/*       rparm     floating point vector of length 30.  allows user to */
/*                 specify some floating point parameters which affect */
/*                 the method. */
/*       ier       output integer.  error flag. */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --ip;
    --p;
    --jcoef;
    --coef;

    /* Function Body */
    *ier = 0;
    dscons_1.ndim = *ndimm;
    dscons_1.mdim = *mdimm;
    n = *nn;
    dscons_1.maxnz = *maxnzz;
    cwkcon_1.lenr = *nw;
    cwkcon_1.leni = *inw;
    cwkcon_1.irmax = 0;
    cwkcon_1.iimax = 0;
    t1 = timer_(&dummy);
    echall_(&n, &iparm[1], &rparm[1], &c__1, &c__1, ier);
    if (*ier < 0) {
	return 0;
    }
    cfactr_1.timfac = 0.;
    pointr_(&c__1, &wksp[1], &iwksp[1], ier);

/* ... call preparatory routines. */

/* ... remove zeros from jcoef for purdue data structure. */

    if (itcom6_1.nstore == 1) {
	adjust_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &c__1);
    }
    prep_(&coef[1], &jcoef[1], &wksp[cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt],
	    &n, &itcom6_1.nstore, ier);
    if (*ier < 0) {
	ershow_(ier, "nspcg", (ftnlen)5);
	goto L20;
    }

/* ... eliminate penalty-method dirichlet points, if requested. */

    ielim = iparm[24];
    tol = rparm[15];
    if (ielim == 1) {
	elim_(&n, &jcoef[1], &coef[1], &rhs[1], &wksp[1], &iwksp[1], &tol);
    }

/* ... determine symmetry of matrix. */

    if (itcom6_1.nstore == 1 && itcom6_1.isymm == 2) {
	detsym_(&dscons_1.ndim, &dscons_1.maxnz, &coef[1], &jcoef[1], &n, &
		itcom6_1.isymm);
    }

/* ... scale matrix. */

    scale_(&coef[1], &jcoef[1], &wksp[1], &c__1, &n, &u[1], &ubar[1], &rhs[1],
	     ier);
    if (*ier < 0) {
	goto L20;
    }

/* ... permute matrix. */

    permut_(&coef[1], &jcoef[1], &p[1], &ip[1], &wksp[1], &iwksp[1], &c__1, &
	    n, &u[1], &ubar[1], &rhs[1], ier);
    if (*ier < 0) {
	goto L15;
    }

/* ... call iterative routine. */

    (*precon)((U_fp)accel, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1],
	    &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);

/* ... unpermute matrix. */

    permut_(&coef[1], &jcoef[1], &p[1], &ip[1], &wksp[1], &iwksp[1], &c__2, &
	    n, &u[1], &ubar[1], &rhs[1], ier);

/* ... unscale matrix. */

L15:
    scale_(&coef[1], &jcoef[1], &wksp[1], &c__2, &n, &u[1], &ubar[1], &rhs[1],
	     ier);

/* ... restore zeros to jcoef for purdue data structure. */

L20:
    if (itcom6_1.nstore == 1) {
	adjust_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &c__2);
    }
    t2 = timer_(&dummy);
    timtot = t2 - t1;
    iparm[18] = itcom6_1.ipropa;
    iparm[23] = itcom6_1.isymm;
    rparm[13] = cfactr_1.timfac;
    rparm[14] = timtot;
    echall_(&n, &iparm[1], &rparm[1], &c__2, &c__1, ier);

    pointr_(&c__2, &wksp[1], &iwksp[1], ier);
    *nw = cwkcon_1.irmax;
    *inw = cwkcon_1.iimax;
    *maxnzz = dscons_1.maxnz;
    return 0;
} /* nspcg_ */

/* Subroutine */ int rsnsp_(S_fp precon, U_fp accel, integer *ndimm, integer *
	mdimm, integer *nn, integer *maxnzz, doublereal *coef, integer *jcoef,
	 integer *p, integer *ip, doublereal *u, doublereal *ubar, doublereal
	*rhs, doublereal *wksp, integer *iwksp, integer *nw, integer *inw,
	integer *iparm, doublereal *rparm, integer *ier)
{
    static integer n;
    static doublereal t1, t2;
    static integer nr;
    static doublereal tol;
    static integer irs;
    extern /* Subroutine */ int elim_(integer *, integer *, doublereal *,
	    doublereal *, doublereal *, integer *, doublereal *), prep_(
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    integer *, integer *), scale_(doublereal *, integer *, doublereal
	    *, integer *, integer *, doublereal *, doublereal *, doublereal *,
	     integer *);
    static integer ielim, ijcrs;
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *), adjust_(integer *, integer *,
	    integer *, integer *, integer *), detsym_(integer *, integer *,
	    doublereal *, integer *, integer *, integer *), ershow_(integer *,
	     char *, ftnlen), pointr_(integer *, doublereal *, integer *,
	    integer *), rsprep_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *);
    static integer irsrhs;
    static doublereal timtot;
    extern /* Subroutine */ int rspost_(doublereal *, integer *, doublereal *,
	     integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *, integer *, integer *, integer *, integer *, integer *);


/* ... rsnsp is the driver for the nspcg package for methods */
/*     applied to the explicitly computed reduced system. */

/* ... parameters -- */

/*       precon    preconditioning module */
/*       accel     acceleration module */
/*       coef      floating point matrix data array */
/*       jcoef     integer matrix data array */
/*       n         input integer.  order of the system (= nn) */
/*       u         input/output vector.  on input, u contains the */
/*                 initial guess to the solution.  on output, it */
/*                 contains the latest estimate to the solution. */
/*       ubar      input vector containing the true solution */
/*                  (optional) */
/*       rhs       input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*       wksp      floating point workspace of length nw */
/*       iwksp     integer workspace of length inw */
/*       nw        length of wksp upon input, amount used upon */
/*                  output */
/*       inw       length of iwksp upon input, amount used upon */
/*                  output */
/*       iparm     integer vector of length 30.  allows user to */
/*                 specify some integer parameters which affect */
/*                 the method. */
/*       rparm     floating point vector of length 30.  allows user to */
/*                 specify some floating point parameters which affect */
/*                 the method. */
/*       ier       output integer.  error flag. */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --ip;
    --p;
    --jcoef;
    --coef;

    /* Function Body */
    *ier = 0;
    dscons_1.ndim = *ndimm;
    dscons_1.mdim = *mdimm;
    n = *nn;
    dscons_1.maxnz = *maxnzz;
    cwkcon_1.lenr = *nw;
    cwkcon_1.leni = *inw;
    cwkcon_1.irmax = 0;
    cwkcon_1.iimax = 0;
    t1 = timer_(&dummy);
    echall_(&n, &iparm[1], &rparm[1], &c__1, &c__1, ier);
    cfactr_1.timfac = 0.;
    pointr_(&c__1, &wksp[1], &iwksp[1], ier);

/* ... call preparatory routines. */

/* ... remove zeros from jcoef for purdue data structure. */

    if (itcom6_1.nstore == 1) {
	adjust_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &c__1);
    }
    prep_(&coef[1], &jcoef[1], &wksp[cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt],
	    &n, &itcom6_1.nstore, ier);
    if (*ier < 0) {
	ershow_(ier, "rsnsp", (ftnlen)5);
	goto L20;
    }

/* ... eliminate penalty-method dirichlet points, if requested. */

    ielim = iparm[24];
    tol = rparm[15];
    if (ielim == 1) {
	elim_(&n, &jcoef[1], &coef[1], &rhs[1], &wksp[1], &iwksp[1], &tol);
    }

/* ... determine symmetry of matrix. */

    if (itcom6_1.nstore == 1 && itcom6_1.isymm == 2) {
	detsym_(&dscons_1.ndim, &dscons_1.maxnz, &coef[1], &jcoef[1], &n, &
		itcom6_1.isymm);
    }

/* ... form reduced system matrix. */

    rsprep_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], &n, &rhs[1], &u[1], &
	    ubar[1], &p[1], &ip[1], &nr, &irs, &ijcrs, &irsrhs, ier);

/* ... scale matrix. */

    scale_(&wksp[irs], &iwksp[ijcrs], &wksp[1], &c__1, &nr, &u[1], &ubar[1], &
	    wksp[irsrhs], ier);
    if (*ier < 0) {
	goto L20;
    }

/* ... call iterative routine. */

    (*precon)((U_fp)accel, &wksp[irs], &iwksp[ijcrs], &nr, &u[1], &ubar[1], &
	    wksp[irsrhs], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);

/* ... unscale matrix. */

    scale_(&wksp[irs], &iwksp[ijcrs], &wksp[1], &c__2, &nr, &u[1], &ubar[1], &
	    wksp[irsrhs], ier);

/* ... restore to original system. */

    rspost_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], &n, &rhs[1], &u[1], &
	    ubar[1], &p[1], &ip[1], &nr, &irs, &ijcrs, ier);

/* ... restore zeros to jcoef for purdue data structure. */

L20:
    if (itcom6_1.nstore == 1) {
	adjust_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &c__2);
    }
    t2 = timer_(&dummy);
    timtot = t2 - t1;
    iparm[18] = itcom6_1.ipropa;
    iparm[23] = itcom6_1.isymm;
    rparm[13] = cfactr_1.timfac;
    rparm[14] = timtot;
    echall_(&n, &iparm[1], &rparm[1], &c__2, &c__1, ier);

    pointr_(&c__2, &wksp[1], &iwksp[1], ier);
    *nw = cwkcon_1.irmax;
    *inw = cwkcon_1.iimax;
    *maxnzz = dscons_1.maxnz;
    return 0;
} /* rsnsp_ */

/* Subroutine */ int prep_(doublereal *coef, integer *jcoef, doublereal *wksp,
	 integer *iwksp, integer *nn, integer *nstore, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n;
    extern /* Subroutine */ int prep1_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *), prep2_(integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *),
	    prep3_(integer *, integer *, integer *, integer *, doublereal *,
	    integer *, integer *, integer *), needw_(char *, integer *,
	    integer *, integer *, integer *, ftnlen);


/* ... prep puts the diagonal entries of the matrix into column */
/*     one of coef. */

/* ... parameters -- */

/*         n       dimension of matrix */
/*         jcoef   integer matrix representation array */
/*         coef    matrix representation array */
/*         wksp    workspace array of size n */
/*         iwksp   integer workspace */
/*         ier     error flag -- on return, values mean */
/*                      0 -- no errors detected */
/*                     -5 -- nonexistent diagonal element */

/* ... specifications for parameters */


/* ... data common blocks */


    /* Parameter adjustments */
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    switch (*nstore) {
	case 1:  goto L5;
	case 2:  goto L10;
	case 3:  goto L10;
	case 4:  goto L15;
	case 5:  goto L15;
    }
L5:
    prep1_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], ier);
    return 0;
L10:
    prep2_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &wksp[1],
	     ier);
    return 0;
L15:
    i__1 = (n << 1) + 1;
    needw_("prep", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    prep3_(&n, &dscons_1.maxnz, &jcoef[1], &jcoef[dscons_1.ndim + 1], &coef[1]
	    , &cmpart_1.mpart, &iwksp[1], &iwksp[n + 2]);
    cmpart_1.mpstrt = cwkcon_1.iipnt;
    cwkcon_1.iipnt = cwkcon_1.iipnt + cmpart_1.mpart + 1;
    return 0;
} /* prep_ */

/* Subroutine */ int pointr_(integer *icall, doublereal *wksp, integer *iwksp,
	 integer *ier)
{
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *),
	     vicopy_(integer *, integer *, integer *);


/* ... pointr adjusts pointers according to ifact. */

/* ... parameters -- */

/*       icall     indicates beginning or ending call */
/*                  = 1  for beginning */
/*                  = 2  for ending */
/*       wksp      floating point workspace vector */
/*       iwksp     integer workspace vector */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... data common blocks */


    /* Parameter adjustments */
    --iwksp;
    --wksp;

    /* Function Body */
    if (*icall == 2) {
	goto L15;
    }

/* ... initialize pointers. */

    if (itcom6_1.ifact == 0) {
	return 0;
    }
    cwkcon_1.iipnt = 1;
    cwkcon_1.irpnt = 1;
    cfactr_1.nfactr = 0;
    cfactr_1.nfacti = 0;
    cfactr_1.ifactr = 1;
    cfactr_1.ifacti = 1;
    return 0;

/* ... reset pointers for return */

L15:
    if (*ier < 0) {
	return 0;
    }
    if (cfactr_1.nfacti == 0) {
	goto L20;
    }
    vicopy_(&cfactr_1.nfacti, &iwksp[cfactr_1.ifacti], &iwksp[1]);
    cwkcon_1.iipnt = cfactr_1.nfacti + 1;
    cfactr_1.ifacti = 1;
L20:
    if (cfactr_1.nfactr == 0) {
	return 0;
    }
    vcopy_(&cfactr_1.nfactr, &wksp[cfactr_1.ifactr], &wksp[1]);
    point_1.iwkpt2 = point_1.iwkpt2 - cfactr_1.ifactr + 1;
    cwkcon_1.irpnt = cfactr_1.nfactr + 1;
    cfactr_1.ifactr = 1;
    return 0;
} /* pointr_ */

/* Subroutine */ int needw_(char *subnam, integer *isw, integer *istart,
	integer *length, integer *ier, ftnlen subnam_len)
{
    static integer newlen;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen);


/* ... needw determines if enough integer or floating point */
/*     workspace is available. */

/* ... parameters -- */

/*        subnam  name of calling routine */
/*        isw     switch for floating point or integer workspace check */
/*                 = 0     floating point */
/*                 = 1     integer */
/*        istart  starting address */
/*        length  length desired */
/*        ier     error indicator (output) */
/*                 = -2    insufficient floating point workspace */
/*                 = -3    insufficient integer workspace */

/* ... specifications for parameters */


    newlen = *istart + *length - 1;
    if (*isw == 1) {
	goto L10;
    }
    if (cwkcon_1.lenr >= newlen) {
	goto L5;
    }
    *ier = -2;
    ershow_(ier, subnam, (ftnlen)10);
L5:
    cwkcon_1.irmax = max(cwkcon_1.irmax,newlen);
    return 0;
L10:
    if (cwkcon_1.leni >= newlen) {
	goto L15;
    }
    *ier = -3;
    ershow_(ier, subnam, (ftnlen)10);
L15:
    cwkcon_1.iimax = max(cwkcon_1.iimax,newlen);
    return 0;
} /* needw_ */

/* Subroutine */ int scale_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *icall, integer *n, doublereal *u, doublereal *ubar,
	doublereal *rhs, integer *ier)
{
    extern /* Subroutine */ int scaled_(doublereal *, integer *, doublereal *,
	     integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *), scalep_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *), scales_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *);


/* ... scale scales the matrix, u, ubar, and rhs. */

/* ... parameters -- */

/*       icall     key to indicate whether scaling (icall=1) or */
/*                  unscaling (icall=2) is to be done */
/*       n         order of system */
/*       u         current solution estimate */
/*       ubar      input vector containing the true solution */
/*                  (optional) */
/*       rhs       input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*       ier       error flag */
/*                  =   0   no errors detected */
/*                  =  -4   nonpositive diagonal element */

/* ... specifications for parameters */


/* ... data common blocks */


    /* Parameter adjustments */
    --rhs;
    --ubar;
    --u;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    if (itcom6_1.iscale != 1) {
	return 0;
    }
    switch (itcom6_1.nstore) {
	case 1:  goto L5;
	case 2:  goto L10;
	case 3:  goto L10;
	case 4:  goto L15;
	case 5:  goto L15;
    }
L5:
    scalep_(&coef[1], &jcoef[1], &wksp[1], icall, n, &u[1], &ubar[1], &rhs[1],
	     ier);
    return 0;
L10:
    scaled_(&coef[1], &jcoef[1], &wksp[1], icall, n, &u[1], &ubar[1], &rhs[1],
	     ier);
    return 0;
L15:
    scales_(&coef[1], &jcoef[1], &wksp[1], icall, n, &u[1], &ubar[1], &rhs[1],
	     ier);
    return 0;
} /* scale_ */

/* Subroutine */ int permut_(doublereal *coef, integer *jcoef, integer *p,
	integer *ip, doublereal *wksp, integer *iwksp, integer *icall,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs, integer
	*ier)
{
    extern /* Subroutine */ int permd_(doublereal *, integer *, integer *,
	    integer *, doublereal *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, integer *), permp_(
	    doublereal *, integer *, integer *, integer *, doublereal *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, integer *), perms_(doublereal *, integer *, integer
	    *, integer *, doublereal *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, integer *);


/* ... permut permutes the matrix, u, ubar, and rhs. */

/* ... parameters -- */

/*       icall     key to indicate whether permuting (icall=1) or */
/*                  unpermuting (icall=2) is to be done */
/*       n         order of system */
/*       u         current solution estimate */
/*       ubar      input vector containing the true solution */
/*                  (optional) */
/*       rhs       input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*       ier       error flag */
/*                  =   0   no errors detected */
/*                  =  -2   insufficient floating point space to permute system */
/*                  =  -3   insufficient integer space to permute */
/*                          system */

/* ... specifications for parameters */


/* ... data common blocks */


    /* Parameter adjustments */
    --rhs;
    --ubar;
    --u;
    --iwksp;
    --wksp;
    --ip;
    --p;
    --jcoef;
    --coef;

    /* Function Body */
    if (itcom6_1.iperm != 1) {
	return 0;
    }
    switch (itcom6_1.nstore) {
	case 1:  goto L5;
	case 2:  goto L10;
	case 3:  goto L10;
	case 4:  goto L15;
	case 5:  goto L15;
    }
L5:
    permp_(&coef[1], &jcoef[1], &p[1], &ip[1], &wksp[1], &iwksp[1], icall, n,
	    &u[1], &ubar[1], &rhs[1], ier);
    return 0;
L10:
    permd_(&coef[1], &jcoef[1], &p[1], &ip[1], &wksp[1], &iwksp[1], icall, n,
	    &u[1], &ubar[1], &rhs[1], ier);
    return 0;
L15:
    perms_(&coef[1], &jcoef[1], &p[1], &ip[1], &wksp[1], &iwksp[1], icall, n,
	    &u[1], &ubar[1], &rhs[1], ier);
    return 0;
} /* permut_ */

/* Subroutine */ int elim_(integer *n, integer *jcoef, doublereal *coef,
	doublereal *rhs, doublereal *wksp, integer *iwksp, doublereal *toll)
{
    static doublereal tol;
    extern /* Subroutine */ int elim1_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    , elim2_(integer *, integer *, integer *, integer *, doublereal *,
	     doublereal *, doublereal *, doublereal *), elim3_(integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *), elim4_(integer *, integer *, integer
	    *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), elim5_(integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *);


/* ... elim removes rows of the matrix for which the ratio of the */
/*     sum of off-diagonal elements to the diagonal element is */
/*     small (less than tol) in absolute value. */
/*     this is to take care of matrices arising from finite */
/*     element discretizations of partial differential equations */
/*     with dirichlet boundary conditions implemented by penalty */
/*     methods.  any such rows and corresponding columns are then */
/*     eliminated (set to the identity after correcting the rhs). */

/* ... parameter list -- */

/*         n       dimension of matrix */
/*         jcoef   integer array of matrix representation */
/*         coef    array of sparse matrix representation */
/*         rhs     right hand side of matrix problem */
/*         wksp    wksp array of length n */
/*         tol     tolerance factor  (= toll) */

/* ... specifications for arguments */


    /* Parameter adjustments */
    --iwksp;
    --wksp;
    --rhs;
    --coef;
    --jcoef;

    /* Function Body */
    tol = *toll;
    switch (itcom6_1.nstore) {
	case 1:  goto L5;
	case 2:  goto L10;
	case 3:  goto L15;
	case 4:  goto L20;
	case 5:  goto L25;
    }
L5:
    elim1_(n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &rhs[1], &
	    wksp[cwkcon_1.irpnt], &tol);
    return 0;
L10:
    elim2_(n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &rhs[1], &
	    wksp[cwkcon_1.irpnt], &tol);
    return 0;
L15:
    elim3_(n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &rhs[1], &
	    wksp[cwkcon_1.irpnt], &tol);
    return 0;
L20:
    elim4_(&cmpart_1.mpart, &iwksp[cmpart_1.mpstrt], &jcoef[1], &jcoef[
	    dscons_1.ndim + 1], &coef[1], &rhs[1], &wksp[cwkcon_1.irpnt], &
	    tol);
    return 0;
L25:
    elim5_(&cmpart_1.mpart, &iwksp[cmpart_1.mpstrt], &jcoef[1], &jcoef[
	    dscons_1.ndim + 1], &coef[1], &rhs[1], &wksp[cwkcon_1.irpnt], &
	    tol);
    return 0;
} /* elim_ */

/* Subroutine */ int scaled_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *icall, integer *nn, doublereal *u, doublereal *ubar,
	doublereal *rhs, integer *ier)
{
    static integer n;
    extern /* Subroutine */ int scal2_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *, integer *, integer *);
    static integer iflag;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), uscal2_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *, integer *), ershow_(integer *, char *, ftnlen);


/* ... scaled scales the matrix, u, ubar, and rhs. */
/*     (symmetric or nonsymmetric diagonal format) */

/* ... parameters -- */

/*       icall     key to indicate whether scaling (icall=1) or */
/*                  unscaling (icall=2) is to be done */
/*       n         order of system */
/*       u         current solution estimate */
/*       ubar      input vector containing the true solution */
/*                  (optional) */
/*       rhs       input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*       ier       error flag */
/*                  =   0   no errors detected */
/*                  =  -4   nonpositive diagonal element */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... data common blocks */


    /* Parameter adjustments */
    --rhs;
    --ubar;
    --u;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    iflag = 0;
    if (itcom1_1.ntest == 6) {
	iflag = 1;
    }
    if (*icall == 2) {
	goto L20;
    }

/* ... scale system. */

/* ... check for sufficient room. */

    needw_("scaled", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    point_1.iptscl = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    scal2_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &rhs[1],
	    &u[1], &ubar[1], &wksp[point_1.iptscl], &iflag, ier);
    if (*ier < 0) {
	ershow_(ier, "scaled", (ftnlen)6);
    }
    return 0;

/* ... unscale system. */

L20:
    uscal2_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &rhs[1],
	     &u[1], &ubar[1], &wksp[point_1.iptscl], &iflag);
    return 0;
} /* scaled_ */

/* Subroutine */ int scalep_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *icall, integer *nn, doublereal *u, doublereal *ubar,
	doublereal *rhs, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n;
    extern /* Subroutine */ int scal1_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *, integer *);
    static integer iflag;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), uscal1_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *), ershow_(integer *, char *
	    , ftnlen);


/* ... scalep scales the matrix, u, ubar, and rhs. */
/*     (purdue format) */

/* ... parameters -- */

/*       icall     key to indicate whether scaling (icall=1) or */
/*                  unscaling (icall=2) is to be done */
/*       n         order of system */
/*       u         current solution estimate */
/*       ubar      input vector containing the true solution */
/*                  (optional) */
/*       rhs       input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*       ier       error flag */
/*                  =   0   no errors detected */
/*                  =  -4   nonpositive diagonal element */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... data common blocks */


    /* Parameter adjustments */
    --rhs;
    --ubar;
    --u;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    iflag = 0;
    if (itcom1_1.ntest == 6) {
	iflag = 1;
    }
    if (*icall == 2) {
	goto L20;
    }

/* ... scale system. */

/* ... check for sufficient room. */

    i__1 = n << 1;
    needw_("scalep", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    point_1.iptscl = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    scal1_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &rhs[1],
	    &u[1], &ubar[1], &wksp[point_1.iptscl], &wksp[cwkcon_1.irpnt], &
	    iflag, ier);
    if (*ier < 0) {
	ershow_(ier, "scalep", (ftnlen)6);
    }
    return 0;

/* ... unscale system. */

L20:
    uscal1_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &rhs[1],
	     &u[1], &ubar[1], &wksp[point_1.iptscl], &wksp[cwkcon_1.irpnt], &
	    iflag);
    return 0;
} /* scalep_ */

/* Subroutine */ int scales_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *icall, integer *nn, doublereal *u, doublereal *ubar,
	doublereal *rhs, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n;
    extern /* Subroutine */ int scal3_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *, integer *);
    static integer iflag;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), uscal3_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *), ershow_(integer *, char *
	    , ftnlen);


/* ... scales scales the matrix, u, ubar, and rhs. */
/*     (sparse format) */

/* ... parameters -- */

/*       icall     key to indicate whether scaling (icall=1) or */
/*                  unscaling (icall=2) is to be done */
/*       n         order of system */
/*       u         current solution estimate */
/*       ubar      input vector containing the true solution */
/*                  (optional) */
/*       rhs       input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*       ier       error flag */
/*                  =   0   no errors detected */
/*                  =  -4   nonpositive diagonal element */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... data common blocks */


    /* Parameter adjustments */
    --rhs;
    --ubar;
    --u;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    iflag = 0;
    if (itcom1_1.ntest == 6) {
	iflag = 1;
    }
    if (*icall == 2) {
	goto L10;
    }

/* ... scale system. */

/* ... check for sufficient room. */

    i__1 = n << 1;
    needw_("scales", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    point_1.iptscl = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    scal3_(&n, &dscons_1.maxnz, &jcoef[1], &jcoef[dscons_1.ndim + 1], &coef[1]
	    , &rhs[1], &u[1], &ubar[1], &wksp[point_1.iptscl], &wksp[
	    cwkcon_1.irpnt], &iflag, ier);
    if (*ier < 0) {
	ershow_(ier, "scales", (ftnlen)6);
    }
    return 0;

/* ... unscale system. */

L10:
    uscal3_(&n, &dscons_1.maxnz, &jcoef[1], &jcoef[dscons_1.ndim + 1], &coef[
	    1], &rhs[1], &u[1], &ubar[1], &wksp[point_1.iptscl], &wksp[
	    cwkcon_1.irpnt], &iflag);
    return 0;
} /* scales_ */

/* Subroutine */ int permd_(doublereal *coef, integer *jcoef, integer *p,
	integer *ip, doublereal *wksp, integer *iwksp, integer *icall,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, j, n, is1, is2;
    extern /* Subroutine */ int pgen_(integer *, integer *, integer *,
	    integer *, integer *), pmdg_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, integer *, integer
	    *, integer *, integer *, integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static integer isym;
    extern /* Subroutine */ int move4_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    integer *);
    static integer lbhbm;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), define_(integer *, integer *, integer *,
	    doublereal *, integer *, integer *, integer *, integer *),
	    prbblk_(integer *, integer *, integer *, integer *, integer *,
	    integer *, logical *), pervec_(integer *, integer *, doublereal *,
	     doublereal *), iptgen_(integer *, integer *, integer *), unpmdg_(
	    integer *, integer *, integer *, integer *, doublereal *, integer
	    *, integer *, integer *, integer *, integer *, integer *, integer
	    *, doublereal *, integer *, integer *), ershow_(integer *, char *,
	     ftnlen);


/* ... permd permutes the matrix, u, ubar, and rhs. */
/*     (diagonal format) */

/* ... parameters -- */

/*       icall     key to indicate whether permuting (icall=1) or */
/*                  unpermuting (icall=2) is to be done */
/*       n         order of system */
/*       u         current solution estimate */
/*       ubar      input vector containing the true solution */
/*                  (optional) */
/*       rhs       input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*       ier       error flag */
/*                  =   0   no errors detected */
/*                  =  -2   insufficient floating point space to permute system */
/*                  =  -3   insufficient integer space to permute */
/*                          system */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... data common blocks */


    /* Parameter adjustments */
    --rhs;
    --ubar;
    --u;
    --iwksp;
    --wksp;
    --ip;
    --p;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    if (*icall == 2) {
	goto L65;
    }

/* ... permute system. */

/* ... check for sufficient storage to permute matrix */

    needw_("permd", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    cblock_1.nc = cwkcon_1.iipnt;
    needw_("permd", &c__1, &cblock_1.nc, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    pgen_(&n, &p[1], &ip[1], &iwksp[cblock_1.nc], &cblock_1.ncolor);
    cblock_1.ipt = cblock_1.nc + cblock_1.ncolor;
    cblock_1.ncmax = 0;
    i__1 = cblock_1.ipt - 1;
    for (i__ = cblock_1.nc; i__ <= i__1; ++i__) {
	if (cblock_1.ncmax < iwksp[i__]) {
	    cblock_1.ncmax = iwksp[i__];
	}
/* L16: */
    }
    i__1 = cblock_1.ncolor + 1;
    needw_("permd", &c__1, &cblock_1.ipt, &i__1, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    iptgen_(&cblock_1.ncolor, &iwksp[cblock_1.ipt], &iwksp[cblock_1.nc]);
    cblock_1.maxnew = cblock_1.ipt + cblock_1.ncolor + 1;
    cblock_1.jcnew = cblock_1.maxnew + cblock_1.ncolor;
    cblock_1.lbhb = cblock_1.jcnew + cblock_1.ncolor * dscons_1.mdim;
    i__1 = cblock_1.ncolor + cblock_1.ncolor * dscons_1.mdim + n;
    needw_("permd", &c__1, &cblock_1.maxnew, &i__1, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    isym = itcom6_1.nstore - 2;
    pmdg_(&dscons_1.ndim, &dscons_1.mdim, &n, &dscons_1.maxnz, &jcoef[1], &
	    coef[1], &cblock_1.ncolor, &iwksp[cblock_1.nc], &p[1], &ip[1], &
	    cblock_1.maxd, &iwksp[cblock_1.maxnew], &iwksp[cblock_1.jcnew], &
	    wksp[cwkcon_1.irpnt], &iwksp[cblock_1.lbhb], &isym, ier);
    if (*ier < 0) {
	ershow_(ier, "permd", (ftnlen)5);
	return 0;
    }
    cblock_1.lbhb = cblock_1.jcnew + cblock_1.ncolor * cblock_1.maxd;
    cblock_1.iblock = cblock_1.lbhb + cblock_1.ncolor;
    move4_(&dscons_1.ndim, &n, &iwksp[cblock_1.maxnew], &iwksp[cblock_1.jcnew]
	    , &coef[1], &cblock_1.ncolor, &iwksp[cblock_1.nc], &wksp[
	    cwkcon_1.irpnt], &iwksp[cblock_1.lbhb]);
    i__1 = cblock_1.ncolor + cblock_1.ncolor * 3 * (cblock_1.maxd + 1);
    needw_("permd", &c__1, &cblock_1.lbhb, &i__1, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    define_(&dscons_1.ndim, &iwksp[cblock_1.maxnew], &iwksp[cblock_1.jcnew], &
	    coef[1], &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
	    cblock_1.iblock], &iwksp[cblock_1.lbhb]);
    lbhbm = iwksp[cblock_1.lbhb];
    i__1 = cblock_1.ncolor - 1;
    for (j = 1; j <= i__1; ++j) {
	if (lbhbm < iwksp[cblock_1.lbhb + j]) {
	    lbhbm = iwksp[cblock_1.lbhb + j];
	}
/* L45: */
    }
    is1 = cblock_1.iblock + cblock_1.ncolor * 3 * lbhbm;
    is2 = is1 + cblock_1.ncolor;
    i__1 = cblock_1.ncolor << 1;
    needw_("permd", &c__1, &is1, &i__1, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    prbblk_(&cblock_1.ncolor, &cblock_1.ncolor, &iwksp[cblock_1.iblock], &
	    iwksp[cblock_1.lbhb], &iwksp[is1], &iwksp[is2], &cblock_1.propa);
    if (cblock_1.propa) {
	itcom6_1.ipropa = 1;
    }
    if (! cblock_1.propa) {
	itcom6_1.ipropa = 0;
    }
    cwkcon_1.iipnt = is1;
    pervec_(&n, &p[1], &rhs[1], &wksp[cwkcon_1.irpnt]);
    pervec_(&n, &p[1], &u[1], &wksp[cwkcon_1.irpnt]);
    if (itcom1_1.ntest == 6) {
	pervec_(&n, &p[1], &ubar[1], &wksp[cwkcon_1.irpnt]);
    }
    return 0;

/* ... unpermute system. */

L65:
    i__1 = n << 1;
    needw_("permd", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    isym = itcom6_1.nstore - 2;
    unpmdg_(&dscons_1.ndim, &n, &dscons_1.maxnz, &jcoef[1], &coef[1], &
	    cblock_1.ncolor, &iwksp[cblock_1.nc], &p[1], &ip[1], &
	    cblock_1.maxd, &iwksp[cblock_1.maxnew], &iwksp[cblock_1.jcnew], &
	    wksp[cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt], &isym);
    pervec_(&n, &ip[1], &rhs[1], &wksp[cwkcon_1.irpnt]);
    pervec_(&n, &ip[1], &u[1], &wksp[cwkcon_1.irpnt]);
    if (itcom1_1.ntest == 6) {
	pervec_(&n, &ip[1], &ubar[1], &wksp[cwkcon_1.irpnt]);
    }
    return 0;
} /* permd_ */

/* Subroutine */ int permp_(doublereal *coef, integer *jcoef, integer *p,
	integer *ip, doublereal *wksp, integer *iwksp, integer *icall,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int pgen_(integer *, integer *, integer *,
	    integer *, integer *), move3_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, integer *, integer
	    *, integer *, integer *), needw_(char *, integer *, integer *,
	    integer *, integer *, ftnlen), pervec_(integer *, integer *,
	    doublereal *, doublereal *), iptgen_(integer *, integer *,
	    integer *), permat_(integer *, integer *, doublereal *, integer *,
	     doublereal *, integer *, integer *, integer *), ershow_(integer *
	    , char *, ftnlen);


/* ... permp permutes the matrix, u, ubar, and rhs. */
/*     (purdue format) */

/* ... parameters -- */

/*       icall     key to indicate whether permuting (icall=1) or */
/*                  unpermuting (icall=2) is to be done */
/*       n         order of system */
/*       u         current solution estimate */
/*       ubar      input vector containing the true solution */
/*                  (optional) */
/*       rhs       input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*       ier       error flag */
/*                  =   0   no errors detected */
/*                  =  -2   insufficient floating point space to permute */
/*                          system */
/*                  =  -3   insufficient integer space to permute */
/*                          system */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... data common blocks */


    /* Parameter adjustments */
    --rhs;
    --ubar;
    --u;
    --iwksp;
    --wksp;
    --ip;
    --p;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    if (*icall == 2) {
	goto L40;
    }

/* ... permute system. */

/* ... check for sufficient storage to permute matrix */

    needw_("permp", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    cblock_1.nc = cwkcon_1.iipnt;
    needw_("permp", &c__1, &cblock_1.nc, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    pgen_(&n, &p[1], &ip[1], &iwksp[cblock_1.nc], &cblock_1.ncolor);
    cblock_1.ipt = cblock_1.nc + cblock_1.ncolor;
    cblock_1.ncmax = 0;
    i__1 = cblock_1.ipt - 1;
    for (i__ = cblock_1.nc; i__ <= i__1; ++i__) {
	if (cblock_1.ncmax < iwksp[i__]) {
	    cblock_1.ncmax = iwksp[i__];
	}
/* L20: */
    }
    i__1 = cblock_1.ncolor + 1;
    needw_("permp", &c__1, &cblock_1.ipt, &i__1, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    iptgen_(&cblock_1.ncolor, &iwksp[cblock_1.ipt], &iwksp[cblock_1.nc]);
    cwkcon_1.iipnt = cwkcon_1.iipnt + (cblock_1.ncolor << 1) + 1;
    needw_("permp", &c__1, &cwkcon_1.iipnt, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    permat_(&dscons_1.ndim, &dscons_1.maxnz, &coef[1], &jcoef[1], &wksp[
	    cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt], &n, &p[1]);
    i__1 = cblock_1.ncolor << 1;
    needw_("permp", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    intern_1.ndt = cwkcon_1.iipnt;
    intern_1.ndb = cwkcon_1.iipnt + cblock_1.ncolor;
    move3_(&dscons_1.ndim, &dscons_1.mdim, &n, &dscons_1.maxnz, &jcoef[1], &
	    coef[1], &iwksp[intern_1.ndt], &iwksp[intern_1.ndb], &
	    cblock_1.ncolor, &iwksp[cblock_1.nc], ier);
    cwkcon_1.iipnt += cblock_1.ncolor << 1;
    if (*ier < 0) {
	ershow_(ier, "permp", (ftnlen)5);
	return 0;
    }
    pervec_(&n, &p[1], &rhs[1], &wksp[cwkcon_1.irpnt]);
    pervec_(&n, &p[1], &u[1], &wksp[cwkcon_1.irpnt]);
    if (itcom1_1.ntest == 6) {
	pervec_(&n, &p[1], &ubar[1], &wksp[cwkcon_1.irpnt]);
    }
    return 0;

/* ... unpermute system. */

L40:
    needw_("permp", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    needw_("permp", &c__1, &cwkcon_1.iipnt, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    permat_(&dscons_1.ndim, &dscons_1.maxnz, &coef[1], &jcoef[1], &wksp[
	    cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt], &n, &ip[1]);
    pervec_(&n, &ip[1], &rhs[1], &wksp[cwkcon_1.irpnt]);
    pervec_(&n, &ip[1], &u[1], &wksp[cwkcon_1.irpnt]);
    if (itcom1_1.ntest == 6) {
	pervec_(&n, &ip[1], &ubar[1], &wksp[cwkcon_1.irpnt]);
    }
    return 0;
} /* permp_ */

/* Subroutine */ int perms_(doublereal *coef, integer *jcoef, integer *p,
	integer *ip, doublereal *wksp, integer *iwksp, integer *icall,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	integer *ier)
{
    static integer n;
    extern /* Subroutine */ int pgen_(integer *, integer *, integer *,
	    integer *, integer *);
    static integer isym;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), pervec_(integer *, integer *, doublereal *,
	    doublereal *), permas_(integer *, integer *, integer *, integer *,
	     integer *, doublereal *, doublereal *, integer *);
    static integer ncolor;


/* ... perms permutes the matrix, u, ubar, and rhs. */
/*     (sparse format) */

/* ... parameters -- */

/*       icall     key to indicate whether permuting (icall=1) or */
/*                  unpermuting (icall=2) is to be done */
/*       n         order of system */
/*       u         current solution estimate */
/*       ubar      input vector containing the true solution */
/*                  (optional) */
/*       rhs       input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*       ier       error flag */
/*                  =   0   no errors detected */
/*                  =  -2   insufficient floating point space to permute */
/*                          system */
/*                  =  -3   insufficient integer space to permute */
/*                          system */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... data common blocks */


    /* Parameter adjustments */
    --rhs;
    --ubar;
    --u;
    --iwksp;
    --wksp;
    --ip;
    --p;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    isym = 0;
    if (itcom6_1.nstore == 5) {
	isym = 1;
    }
    if (*icall == 2) {
	goto L10;
    }

/* ... permute system. */

/* ... check for sufficient storage to permute matrix */

    needw_("perms", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    needw_("perms", &c__1, &cwkcon_1.iipnt, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    pgen_(&n, &p[1], &ip[1], &iwksp[cwkcon_1.iipnt], &ncolor);
    permas_(&isym, &n, &dscons_1.maxnz, &jcoef[1], &jcoef[dscons_1.ndim + 1],
	    &coef[1], &wksp[cwkcon_1.irpnt], &p[1]);
    pervec_(&n, &p[1], &rhs[1], &wksp[cwkcon_1.irpnt]);
    pervec_(&n, &p[1], &u[1], &wksp[cwkcon_1.irpnt]);
    if (itcom1_1.ntest == 6) {
	pervec_(&n, &p[1], &ubar[1], &wksp[cwkcon_1.irpnt]);
    }
    return 0;

/* ... unpermute system. */

L10:
    needw_("perms", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    needw_("perms", &c__1, &cwkcon_1.iipnt, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    permas_(&isym, &n, &dscons_1.maxnz, &jcoef[1], &jcoef[dscons_1.ndim + 1],
	    &coef[1], &wksp[cwkcon_1.irpnt], &ip[1]);
    pervec_(&n, &ip[1], &rhs[1], &wksp[cwkcon_1.irpnt]);
    pervec_(&n, &ip[1], &u[1], &wksp[cwkcon_1.irpnt]);
    if (itcom1_1.ntest == 6) {
	pervec_(&n, &ip[1], &ubar[1], &wksp[cwkcon_1.irpnt]);
    }
    return 0;
} /* perms_ */

/* Subroutine */ int rsprep_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *rhs, doublereal *u,
	doublereal *ubar, integer *p, integer *ip, integer *nrr, integer *irs,
	 integer *ijcrs, integer *irsrhs, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n, nb, nr, ip1, ip2, lim1, lim2, isym;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), vfill_(integer *, doublereal *, doublereal *
	    );
    static integer maxrs, length;
    extern /* Subroutine */ int rsbegp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *);
    static integer maxlim;
    extern /* Subroutine */ int rsmatd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *, doublereal *, integer *,
	    integer *, integer *), rsrhsd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), rsmatp_(integer *, integer *, integer *, integer *,
	     doublereal *, integer *, integer *, doublereal *, integer *,
	    doublereal *, integer *, integer *), ershow_(integer *, char *,
	    ftnlen), permut_(doublereal *, integer *, integer *, integer *,
	    doublereal *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, integer *);


/* ... rsprep is the preprocessor for methods using the */
/*     explicitly-computed reduced system. */

/* ... parameters -- */

/*       coef      floating point matrix data array */
/*       jcoef     integer matrix data array */
/*       n         input integer.  order of the system (= nn) */
/*       rhs       input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*       u         current solution estimate */
/*       ubar      exact solution vector (if known) */
/*       nr        order of the reduced system upon output */
/*       irs       pointer into wksp for reduced system matrix */
/*       ijcrs     pointer into wksp for reduced system integer */
/*                  array */
/*       irsrhs    pointer into wksp for reduced system rhs */
/*       ier       output integer.  error flag. */

/* ... specifications for parameters */


/* ... data common blocks */


    /* Parameter adjustments */
    --ip;
    --p;
    --ubar;
    --u;
    --rhs;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;

/* ... permute matrix. */

    permut_(&coef[1], &jcoef[1], &p[1], &ip[1], &wksp[1], &iwksp[1], &c__1, &
	    n, &u[1], &ubar[1], &rhs[1], ier);
    if (*ier < 0) {
	return 0;
    }

/* ... form reduced system matrix. */

    nr = iwksp[cblock_1.nc];
    nb = iwksp[cblock_1.nc + 1];
    *irs = cwkcon_1.irpnt;
    *ijcrs = cwkcon_1.iipnt;
    length = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    vfill_(&length, &wksp[cwkcon_1.irpnt], &c_b121);
    if (itcom6_1.nstore >= 2) {
	goto L30;
    }

/* ... purdue storage. */

    i__1 = nr * 3;
    needw_("rsprep", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    i__1 = nr << 1;
    needw_("rsprep", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    lim1 = (cwkcon_1.lenr - (nr << 1) - cwkcon_1.irpnt + 1) / nr;
    lim2 = (cwkcon_1.leni - nr - cwkcon_1.iipnt + 1) / nr;
    maxlim = min(lim1,lim2);
    ip1 = cwkcon_1.irpnt + nr * maxlim;
    ip2 = cwkcon_1.iipnt + nr * maxlim;
    rsmatp_(&dscons_1.ndim, &nr, &dscons_1.maxnz, &jcoef[1], &coef[1], &maxrs,
	     &iwksp[*ijcrs], &wksp[*irs], &maxlim, &wksp[ip1], &iwksp[ip2],
	    ier);
    if (*ier < 0) {
	ershow_(ier, "rsprep", (ftnlen)6);
	return 0;
    }
    cwkcon_1.irpnt += nr * maxrs;
    cwkcon_1.iipnt += nr * maxrs;
    goto L45;

/* ... diagonal storage. */

L30:
    needw_("rsprep", &c__0, &cwkcon_1.irpnt, &nr, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    needw_("rsprep", &c__1, &cwkcon_1.iipnt, &nr, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    maxlim = length / nr;
    isym = 0;
    if (itcom6_1.nstore == 3) {
	isym = 1;
    }
    rsmatd_(&dscons_1.ndim, &nr, &nb, &iwksp[cblock_1.maxnew], &iwksp[
	    cblock_1.jcnew], &coef[1], &coef[dscons_1.ndim + 1], &coef[nr +
	    dscons_1.ndim + 1], &coef[nr + 1], &maxrs, &iwksp[*ijcrs], &wksp[*
	    irs], &maxlim, &isym, ier);
    if (*ier < 0) {
	ershow_(ier, "rsprep", (ftnlen)6);
	return 0;
    }
    cwkcon_1.irpnt += nr * maxrs;
    cwkcon_1.iipnt += maxrs;

/* ... form reduced system rhs. */

L45:
    *irsrhs = cwkcon_1.irpnt;
    ip1 = cwkcon_1.irpnt + nr;
    i__1 = n + nr;
    needw_("rsprep", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    if (itcom6_1.nstore == 1) {
	rsbegp_(&n, &nr, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1],
		 &wksp[*irsrhs], &rhs[1], &wksp[ip1]);
    }
    if (itcom6_1.nstore >= 2) {
	rsrhsd_(&n, &nr, &dscons_1.ndim, &iwksp[cblock_1.maxnew], &iwksp[
		cblock_1.jcnew], &coef[1], &wksp[*irsrhs], &rhs[1], &wksp[ip1]
		);
    }
    cwkcon_1.irpnt += nr;

/* ... update constants. */

    rscons_1.ndimrs = dscons_1.ndim;
    rscons_1.mdimrs = dscons_1.mdim;
    rscons_1.maxzrs = dscons_1.maxnz;
    dscons_1.ndim = nr;
    dscons_1.mdim = maxrs;
    dscons_1.maxnz = maxrs;
    *nrr = nr;
    return 0;
} /* rsprep_ */

/* Subroutine */ int rspost_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *rhs, doublereal *u,
	doublereal *ubar, integer *p, integer *ip, integer *nrr, integer *irs,
	 integer *ijcrs, integer *ier)
{
    static integer n, nb, nr;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), rsxbd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *),
	    rsendp_(integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *), permut_(
	    doublereal *, integer *, integer *, integer *, doublereal *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, integer *);


/* ... rspost is the postprocessor for methods using the */
/*     explicitly-computed reduced system. */

/* ... parameters -- */

/*       coef      floating point matrix data array */
/*       jcoef     integer matrix data array */
/*       n         input integer.  order of the system (= nn) */
/*       rhs       input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*       u         current solution estimate */
/*       ubar      exact solution vector (if known) */
/*       nr        order of the reduced system upon input */
/*       irs       pointer into wksp for reduced system matrix */
/*       ijcrs     pointer into wksp for reduced system integer */
/*                  array */
/*       ier       output integer.  error flag. */

/* ... specifications for parameters */


/* ... data common blocks */


    /* Parameter adjustments */
    --ip;
    --p;
    --ubar;
    --u;
    --rhs;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    nr = *nrr;
    nb = n - nr;

/* ... update constants. */

    dscons_1.ndim = rscons_1.ndimrs;
    dscons_1.mdim = rscons_1.mdimrs;
    dscons_1.maxnz = rscons_1.maxzrs;
    cwkcon_1.irpnt = *irs;
    cwkcon_1.iipnt = *ijcrs;

/* ... compute xb. */

    needw_("rspost", &c__0, &cwkcon_1.irpnt, &nb, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    if (itcom6_1.nstore == 1) {
	rsendp_(&n, &nr, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1],
		 &u[1], &rhs[1], &wksp[cwkcon_1.irpnt]);
    }
    if (itcom6_1.nstore >= 2) {
	rsxbd_(&n, &nr, &dscons_1.ndim, &iwksp[cblock_1.maxnew], &iwksp[
		cblock_1.jcnew], &coef[1], &u[1], &rhs[1]);
    }

/* ... unpermute matrix. */

    permut_(&coef[1], &jcoef[1], &p[1], &ip[1], &wksp[1], &iwksp[1], &c__2, &
	    n, &u[1], &ubar[1], &rhs[1], ier);
    if (*ier < 0) {
	return 0;
    }
    return 0;
} /* rspost_ */

/* Subroutine */ int redblk_(integer *ndim, integer *n, integer *maxnz,
	doublereal *coef, integer *jcoef, integer *p, integer *ip, integer *
	nstore, integer *iwksp, integer *ier)
{
    extern /* Subroutine */ int bicol_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, logical *);
    static logical propal;
    extern /* Subroutine */ int prbndx_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, integer *, logical *, integer
	    *), ershow_(integer *, char *, ftnlen);


/* ... redblk determines if the matrix has property a. */

/* ... parameters -- */

/*        n        problem size */
/*        nstore   storage mode */
/*                  = 1  purdue format */
/*                  = 2  symmetric diagonal format */
/*                  = 3  nonsymmetric diagonal format */
/*                  = 4  symmetric sparse format */
/*                  = 5  nonsymmetric sparse format */
/*        iwksp    integer workspace vector of length n */
/*        ier      error code */
/*                  =  0   no errors detected */
/*                  = -8   matrix does not have property a */

/* ... common blocks */


    /* Parameter adjustments */
    --iwksp;
    --ip;
    --p;
    --jcoef;
    --coef;

    /* Function Body */
    switch (*nstore) {
	case 1:  goto L5;
	case 2:  goto L5;
	case 3:  goto L5;
	case 4:  goto L10;
	case 5:  goto L10;
    }
L5:
    prbndx_(n, ndim, maxnz, &jcoef[1], &coef[1], &p[1], &ip[1], &propal,
	    nstore);
    goto L15;
L10:
    bicol_(n, maxnz, &jcoef[1], &jcoef[*ndim + 1], &p[1], &ip[1], &iwksp[1], &
	    propal);
L15:
    if (propal) {
	*ier = 0;
    }
    if (! propal) {
	*ier = -8;
    }
    if (propal) {
	return 0;
    }
    ershow_(ier, "redblk", (ftnlen)6);
    return 0;
} /* redblk_ */

/* Subroutine */ int noadp_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *p, doublereal *r__,
	doublereal *pdp, doublereal *pldup)
{

/* ... noadp is a dummy routine to do no adaption. */

/* ... specifications for parameters */



    /* Parameter adjustments */
    --r__;
    --p;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    return 0;
} /* noadp_ */

/* Subroutine */ int copy_(doublereal *coef, integer *jcoef, doublereal *wksp,
	 integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;


/* ... copy does a vector copy (null preconditioner) */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	z__[i__] = r__[i__];
    }
    return 0;
} /* copy_ */

/* Subroutine */ int split_(S_fp accel, U_fp suba, U_fp subat, S_fp subq,
	S_fp subqt, S_fp subql, S_fp subqlt, S_fp subqr, S_fp subqrt, U_fp
	subadp, doublereal *coef, integer *jcoef, integer *n, doublereal *u,
	doublereal *ubar, doublereal *rhs, doublereal *wksp, integer *iwksp,
	integer *iparm, doublereal *rparm, integer *ier)
{
    static integer jer;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);


/* ... split determines how to apply the splitting based on */
/*     iqlr. */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    if (itcom1_1.iqlr == 0) {
	(*accel)((U_fp)suba, (U_fp)subat, (S_fp)copy_, (S_fp)copy_, (S_fp)
		copy_, (S_fp)copy_, (U_fp)subadp, &coef[1], &jcoef[1], n, &u[
		1], &ubar[1], &rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[
		1], &jer);
    }
    if (itcom1_1.iqlr == 1) {
	(*accel)((U_fp)suba, (U_fp)subat, (S_fp)subq, (S_fp)subqt, (S_fp)
		copy_, (S_fp)copy_, (U_fp)subadp, &coef[1], &jcoef[1], n, &u[
		1], &ubar[1], &rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[
		1], &jer);
    }
    if (itcom1_1.iqlr == 2) {
	(*accel)((U_fp)suba, (U_fp)subat, (S_fp)copy_, (S_fp)copy_, (S_fp)
		subq, (S_fp)subqt, (U_fp)subadp, &coef[1], &jcoef[1], n, &u[1]
		, &ubar[1], &rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1]
		, &jer);
    }
    if (itcom1_1.iqlr == 3) {
	(*accel)((U_fp)suba, (U_fp)subat, (S_fp)subql, (S_fp)subqlt, (S_fp)
		subqr, (S_fp)subqrt, (U_fp)subadp, &coef[1], &jcoef[1], n, &u[
		1], &ubar[1], &rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[
		1], &jer);
    }
    if (jer != 0) {
	*ier = jer;
    }
    return 0;
} /* split_ */

/* Subroutine */ int rich1_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba8_(), suba9_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, doublereal *, integer *, integer *, doublereal *
	    , doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);


/* ... rich1 drives the richardson preconditioner. */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    point_1.iwkpt1 = cwkcon_1.irpnt;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt += *n;
    }
    split_((S_fp)accel, (U_fp)suba8_, (U_fp)suba9_, (S_fp)copy_, (S_fp)copy_,
	    (S_fp)copy_, (S_fp)copy_, (S_fp)copy_, (S_fp)copy_, (S_fp)noadp_,
	    &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &wksp[1], &
	    iwksp[1], &iparm[1], &rparm[1], ier);
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt -= *n;
    }
    return 0;
} /* rich1_ */

/* Subroutine */ int jac1_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba8_(), suba9_();
    extern /* Subroutine */ int subq1_(), noadp_(doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *), split_(S_fp, U_fp, U_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... jac1 drives the jacobi preconditioner. */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    point_1.iwkpt1 = cwkcon_1.irpnt;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt += *n;
    }
    split_((S_fp)accel, (U_fp)suba8_, (U_fp)suba9_, (S_fp)subq1_, (S_fp)
	    subq1_, (S_fp)subq1_, (S_fp)subq1_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt -= *n;
    }
    return 0;
} /* jac1_ */

/* Subroutine */ int sor1_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba8_(), suba9_();
    extern /* Subroutine */ int move1_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, integer *, integer
	    *), noadp_(doublereal *, integer *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    , subq78_(), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, doublereal *, integer *, integer *, doublereal *
	    , doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *), ershow_(integer *, char *, ftnlen);


/* ... sor1 drives the point sor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += *n;
    move1_(&dscons_1.ndim, &dscons_1.mdim, n, &dscons_1.maxnz, &jcoef[1], &
	    coef[1], &intern_1.maxt, &intern_1.maxb, ier);
    if (*ier < 0) {
	ershow_(ier, "sor1", (ftnlen)4);
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba8_, (U_fp)suba9_, (S_fp)subq78_, (S_fp)
	    subq78_, (S_fp)subq78_, (S_fp)subq78_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= *n;
    return 0;
} /* sor1_ */

/* Subroutine */ int ssor1_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    extern /* Subroutine */ int suba8_(), suba9_();
    extern /* Subroutine */ int move1_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, integer *, integer
	    *), subq80_(), subq81_(), subq82_(), subq83_(), subq84_(),
	    subq85_(), subq79_(), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), ershow_(integer *, char *,
	    ftnlen);


/* ... ssor1 drives the point ssor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    if (itcom6_1.isymm != 0) {
	cwkcon_1.irpnt += n;
    }
    move1_(&dscons_1.ndim, &dscons_1.mdim, &n, &dscons_1.maxnz, &jcoef[1], &
	    coef[1], &intern_1.maxt, &intern_1.maxb, ier);
    if (*ier < 0) {
	ershow_(ier, "ssor1", (ftnlen)5);
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba8_, (U_fp)suba9_, (S_fp)subq79_, (S_fp)
	    subq80_, (S_fp)subq81_, (S_fp)subq82_, (S_fp)subq83_, (S_fp)
	    subq84_, (S_fp)subq85_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1],
	    &rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    if (itcom6_1.isymm != 0) {
	cwkcon_1.irpnt -= n;
    }
    cwkcon_1.irpnt -= n;
    return 0;
} /* ssor1_ */

/* Subroutine */ int ic1_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int suba8_(), suba9_();
    extern /* Subroutine */ int move1_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, integer *, integer
	    *), noadp_(doublereal *, integer *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int subq90_(), subq91_(), subq86_(), subq87_(),
	    subq88_(), subq89_();
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), pfact1_(doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *, integer
	    *), ershow_(integer *, char *, ftnlen);


/* ... ic1 drives the ic preconditioner. */




    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    if (itcom6_1.ifact == 0 && itcom6_1.lvfill > 0) {
	goto L20;
    }
    move1_(&dscons_1.ndim, &dscons_1.mdim, &n, &dscons_1.maxnz, &jcoef[1], &
	    coef[1], &intern_1.maxt, &intern_1.maxb, ier);
    if (*ier < 0) {
	ershow_(ier, "ic1", (ftnlen)3);
	return 0;
    }
L20:
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	pfact1_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], &n, &c__1, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    split_((S_fp)accel, (U_fp)suba8_, (U_fp)suba9_, (S_fp)subq86_, (S_fp)
	    subq87_, (S_fp)subq88_, (S_fp)subq89_, (S_fp)subq90_, (S_fp)
	    subq91_, (S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n;
    return 0;
} /* ic1_ */

/* Subroutine */ int mic1_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int suba8_(), suba9_();
    extern /* Subroutine */ int move1_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, integer *, integer
	    *), noadp_(doublereal *, integer *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int subq90_(), subq91_(), subq86_(), subq87_(),
	    subq88_(), subq89_();
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), pfact1_(doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *, integer
	    *), ershow_(integer *, char *, ftnlen);


/* ... mic1 drives the mic preconditioner. */




    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    if (itcom6_1.ifact == 0 && itcom6_1.lvfill > 0) {
	goto L20;
    }
    move1_(&dscons_1.ndim, &dscons_1.mdim, &n, &dscons_1.maxnz, &jcoef[1], &
	    coef[1], &intern_1.maxt, &intern_1.maxb, ier);
    if (*ier < 0) {
	ershow_(ier, "mic1", (ftnlen)4);
	return 0;
    }
L20:
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	pfact1_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], &n, &c__2, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    split_((S_fp)accel, (U_fp)suba8_, (U_fp)suba9_, (S_fp)subq86_, (S_fp)
	    subq87_, (S_fp)subq88_, (S_fp)subq89_, (S_fp)subq90_, (S_fp)
	    subq91_, (S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n;
    return 0;
} /* mic1_ */

/* Subroutine */ int lsp1_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba8_(), suba9_();
    extern /* Subroutine */ int ainfn_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *),
	    noadp_(doublereal *, integer *, doublereal *, integer *, integer *
	    , doublereal *, doublereal *, doublereal *, doublereal *), needw_(
	    char *, integer *, integer *, integer *, integer *, ftnlen),
	    subq92_(), subq93_(), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... lsp1 drives the least squares polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    i__1 = n << 1;
    needw_("lsp1", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    ainfn_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &c__1, &
	    itcom8_1.ainf, &wksp[cwkcon_1.irpnt]);
    point_1.iwkpt2 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n << 1;
    point_1.iwkpt1 = cwkcon_1.irpnt;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt += n;
    }
    split_((S_fp)accel, (U_fp)suba8_, (U_fp)suba9_, (S_fp)subq92_, (S_fp)
	    subq93_, (S_fp)subq92_, (S_fp)subq93_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n << 1;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt -= n;
    }
    return 0;
} /* lsp1_ */

/* Subroutine */ int neu1_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba8_(), suba9_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), subq94_(), subq95_(), split_(S_fp, U_fp, U_fp,
	     S_fp, S_fp, S_fp, S_fp, S_fp, S_fp, S_fp, doublereal *, integer *
	    , integer *, doublereal *, doublereal *, doublereal *, doublereal
	    *, integer *, integer *, doublereal *, integer *);


/* ... neu1 drives the neumann polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    needw_("neu1", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt2 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    point_1.iwkpt1 = cwkcon_1.irpnt;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt += n;
    }
    split_((S_fp)accel, (U_fp)suba8_, (U_fp)suba9_, (S_fp)subq94_, (S_fp)
	    subq95_, (S_fp)subq94_, (S_fp)subq95_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt -= n;
    }
    return 0;
} /* neu1_ */

/* Subroutine */ int rich2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, doublereal *, integer *, integer *, doublereal *
	    , doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);


/* ... rich2 drives the richardson preconditioner. */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)copy_, (S_fp)copy_,
	    (S_fp)copy_, (S_fp)copy_, (S_fp)copy_, (S_fp)copy_, (S_fp)noadp_,
	    &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &wksp[1], &
	    iwksp[1], &iparm[1], &rparm[1], ier);
    return 0;
} /* rich2_ */

/* Subroutine */ int jac2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int subq1_(), noadp_(doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *), split_(S_fp, U_fp, U_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... jac2 drives the jacobi preconditioner. */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq1_, (S_fp)
	    subq1_, (S_fp)subq1_, (S_fp)subq1_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    return 0;
} /* jac2_ */

/* Subroutine */ int ljac2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int subq2_(), lfact_(doublereal *, integer *,
	    doublereal *, integer *, integer *), noadp_(doublereal *, integer
	    *, doublereal *, integer *, integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *);
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... ljac2 drives the line jacobi preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	lfact_(&coef[1], &jcoef[1], &wksp[1], n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq2_, (S_fp)
	    subq2_, (S_fp)subq2_, (S_fp)subq2_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    return 0;
} /* ljac2_ */

/* Subroutine */ int ljacx2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int linv_(doublereal *, integer *, doublereal *,
	    integer *, integer *), copy_(doublereal *, integer *, doublereal *
	    , integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int subq4_(), noadp_(doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *);
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... ljacx2 drives the line jacobi preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	linv_(&coef[1], &jcoef[1], &wksp[1], n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq4_, (S_fp)
	    subq4_, (S_fp)subq4_, (S_fp)subq4_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    return 0;
} /* ljacx2_ */

/* Subroutine */ int sor2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int subq6_(), noadp_(doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *), needw_(char *, integer *, integer *,
	    integer *, integer *, ftnlen), split_(S_fp, U_fp, U_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, S_fp, S_fp, doublereal *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *, integer *), rowise_(integer *
	    , integer *, integer *);


/* ... sor2 drives the point sor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    rowise_(&dscons_1.maxnz, &jcoef[1], &intern_1.irwise);
    needw_("sor2", &c__1, &cwkcon_1.iipnt, &dscons_1.maxnz, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.iipnt;
    cwkcon_1.iipnt += dscons_1.maxnz;
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq6_, (S_fp)
	    subq6_, (S_fp)subq6_, (S_fp)subq6_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.iipnt -= dscons_1.maxnz;
    return 0;
} /* sor2_ */

/* Subroutine */ int ssor2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int subq7_(), subq8_(), subq9_(), needw_(char *,
	    integer *, integer *, integer *, integer *, ftnlen), subq10_(),
	    subq11_(), subq12_(), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), rowise_(integer *, integer *
	    , integer *);


/* ... ssor2 drives the point ssor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    rowise_(&dscons_1.maxnz, &jcoef[1], &intern_1.irwise);
    needw_("ssor2", &c__1, &cwkcon_1.iipnt, &dscons_1.maxnz, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.iipnt;
    cwkcon_1.iipnt += dscons_1.maxnz;
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq7_, (S_fp)
	    subq7_, (S_fp)subq8_, (S_fp)subq9_, (S_fp)subq10_, (S_fp)subq11_,
	    (S_fp)subq12_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.iipnt -= dscons_1.maxnz;
    return 0;
} /* ssor2_ */

/* Subroutine */ int ic2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), subq13_(), subq14_(), subq15_(), subq16_(),
	    subq17_();
    extern doublereal timer_(doublereal *);
    static integer leniw;
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), pfact2_(doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *, integer
	    *);


/* ... ic2 drives the symmetric ic preconditioner. */




    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	pfact2_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, &c__1, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    leniw = max(dscons_1.maxnz,cfactr_1.nfacti);
    point_1.iwkpt1 = cwkcon_1.iipnt;
    cwkcon_1.iipnt += leniw;
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq13_, (S_fp)
	    subq13_, (S_fp)subq14_, (S_fp)subq15_, (S_fp)subq16_, (S_fp)
	    subq17_, (S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.iipnt -= leniw;
    return 0;
} /* ic2_ */

/* Subroutine */ int mic2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), subq13_(), subq14_(), subq15_(), subq16_(),
	    subq17_();
    extern doublereal timer_(doublereal *);
    static integer leniw;
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), pfact2_(doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *, integer
	    *);


/* ... mic2 drives the symmetric mic preconditioner. */




    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	pfact2_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, &c__2, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    leniw = max(dscons_1.maxnz,cfactr_1.nfacti);
    point_1.iwkpt1 = cwkcon_1.iipnt;
    cwkcon_1.iipnt += leniw;
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq13_, (S_fp)
	    subq13_, (S_fp)subq14_, (S_fp)subq15_, (S_fp)subq16_, (S_fp)
	    subq17_, (S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.iipnt -= leniw;
    return 0;
} /* mic2_ */

/* Subroutine */ int lsp2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int ainfn_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *),
	    noadp_(doublereal *, integer *, doublereal *, integer *, integer *
	    , doublereal *, doublereal *, doublereal *, doublereal *), needw_(
	    char *, integer *, integer *, integer *, integer *, ftnlen),
	    subq18_(), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);


/* ... lsp2 drives the least squares polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    i__1 = n << 1;
    needw_("lsp2", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    ainfn_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &c__2, &
	    itcom8_1.ainf, &wksp[cwkcon_1.irpnt]);
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n << 1;
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq18_, (S_fp)
	    subq18_, (S_fp)subq18_, (S_fp)subq18_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n << 1;
    return 0;
} /* lsp2_ */

/* Subroutine */ int neu2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), subq19_(), split_(S_fp, U_fp, U_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, S_fp, S_fp, doublereal *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *, integer *);


/* ... neu2 drives the neumann polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    needw_("neu2", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq19_, (S_fp)
	    subq19_, (S_fp)subq19_, (S_fp)subq19_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n;
    return 0;
} /* neu2_ */

/* Subroutine */ int lsor2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int lfact_(doublereal *, integer *, doublereal *,
	    integer *, integer *), noadp_(doublereal *, integer *, doublereal
	    *, integer *, integer *, doublereal *, doublereal *, doublereal *,
	     doublereal *), subq20_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), blkdef_(doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *);


/* ... lsor2 drives the line sor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    blkdef_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, ier);
    if (*ier < 0) {
	return 0;
    }
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	lfact_(&coef[1], &jcoef[1], &wksp[1], n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq20_, (S_fp)
	    subq20_, (S_fp)subq20_, (S_fp)subq20_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    return 0;
} /* lsor2_ */

/* Subroutine */ int lssor2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int lfact_(doublereal *, integer *, doublereal *,
	    integer *, integer *), subq21_(), subq22_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), blkdef_(doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *);


/* ... lssor2 drives the line ssor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    blkdef_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], &n, ier);
    if (*ier < 0) {
	return 0;
    }
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	lfact_(&coef[1], &jcoef[1], &wksp[1], &n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    if (*ier < 0) {
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq21_, (S_fp)
	    subq21_, (S_fp)subq21_, (S_fp)subq21_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)subq22_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n;
    return 0;
} /* lssor2_ */

/* Subroutine */ int bic2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int bfacs_(integer *, U_fp, doublereal *, integer
	    *, doublereal *, integer *, integer *, integer *), noadp_(
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *), subq25_()
	    ;
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);
    extern /* Subroutine */ int ibfcs1_();
    extern /* Subroutine */ int blkdef_(doublereal *, integer *, doublereal *,
	     integer *, integer *, integer *);


/* ... bic2 drives the block factorization (version 1) method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    blkdef_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, ier);
    if (*ier < 0) {
	return 0;
    }
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	bfacs_(&c__1, (U_fp)ibfcs1_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1],
		 n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += itcom6_1.kblsz;
    if (*ier < 0) {
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq25_, (S_fp)
	    subq25_, (S_fp)subq25_, (S_fp)subq25_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= itcom6_1.kblsz;
    return 0;
} /* bic2_ */

/* Subroutine */ int mbic2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int bfacs_(integer *, U_fp, doublereal *, integer
	    *, doublereal *, integer *, integer *, integer *), noadp_(
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *), subq25_()
	    ;
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);
    extern /* Subroutine */ int ibfcs3_();
    extern /* Subroutine */ int blkdef_(doublereal *, integer *, doublereal *,
	     integer *, integer *, integer *);


/* ... mbic2 drives the block factorization (version 1, modified) */
/*     method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    blkdef_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, ier);
    if (*ier < 0) {
	return 0;
    }
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	bfacs_(&c__2, (U_fp)ibfcs3_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1],
		 n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += itcom6_1.kblsz;
    if (*ier < 0) {
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq25_, (S_fp)
	    subq25_, (S_fp)subq25_, (S_fp)subq25_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= itcom6_1.kblsz;
    return 0;
} /* mbic2_ */

/* Subroutine */ int bicx2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int bfacs_(integer *, U_fp, doublereal *, integer
	    *, doublereal *, integer *, integer *, integer *), noadp_(
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *), subq25_()
	    ;
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);
    extern /* Subroutine */ int ibfcs2_();
    extern /* Subroutine */ int blkdef_(doublereal *, integer *, doublereal *,
	     integer *, integer *, integer *);


/* ... bicx2 drives the block factorization (version 2) method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    blkdef_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, ier);
    if (*ier < 0) {
	return 0;
    }
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	bfacs_(&c__3, (U_fp)ibfcs2_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1],
		 n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += itcom6_1.kblsz;
    if (*ier < 0) {
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq25_, (S_fp)
	    subq25_, (S_fp)subq25_, (S_fp)subq25_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= itcom6_1.kblsz;
    return 0;
} /* bicx2_ */

/* Subroutine */ int mbicx2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int bfacs_(integer *, U_fp, doublereal *, integer
	    *, doublereal *, integer *, integer *, integer *), noadp_(
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *), subq25_()
	    ;
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);
    extern /* Subroutine */ int ibfcs4_();
    extern /* Subroutine */ int blkdef_(doublereal *, integer *, doublereal *,
	     integer *, integer *, integer *);


/* ... mbicx2 drives the block factorization (version 2, modified) */
/*     method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    blkdef_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, ier);
    if (*ier < 0) {
	return 0;
    }
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	bfacs_(&c__4, (U_fp)ibfcs4_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1],
		 n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += itcom6_1.kblsz;
    if (*ier < 0) {
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq25_, (S_fp)
	    subq25_, (S_fp)subq25_, (S_fp)subq25_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= itcom6_1.kblsz;
    return 0;
} /* mbicx2_ */

/* Subroutine */ int llsp2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int lfact_(doublereal *, integer *, doublereal *,
	    integer *, integer *), noadp_(doublereal *, integer *, doublereal
	    *, integer *, integer *, doublereal *, doublereal *, doublereal *,
	     doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), subq23_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), adinfn_(integer *, integer *
	    , integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *);


/* ... llsp2 drives the line least squares polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    needw_("llsp2", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    adinfn_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &c__2, &
	    itcom8_1.ainf, &wksp[cwkcon_1.irpnt]);
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	lfact_(&coef[1], &jcoef[1], &wksp[1], &n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    i__1 = n << 1;
    needw_("llsp2", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n << 1;
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq23_, (S_fp)
	    subq23_, (S_fp)subq23_, (S_fp)subq23_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n << 1;
    return 0;
} /* llsp2_ */

/* Subroutine */ int lneu2_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba1_();
    extern /* Subroutine */ int lfact_(doublereal *, integer *, doublereal *,
	    integer *, integer *), noadp_(doublereal *, integer *, doublereal
	    *, integer *, integer *, doublereal *, doublereal *, doublereal *,
	     doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), subq24_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... lneu2 drives the line neumann polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	lfact_(&coef[1], &jcoef[1], &wksp[1], &n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    i__1 = n << 1;
    needw_("lneu2", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n << 1;
    split_((S_fp)accel, (U_fp)suba1_, (U_fp)suba1_, (S_fp)subq24_, (S_fp)
	    subq24_, (S_fp)subq24_, (S_fp)subq24_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n << 1;
    return 0;
} /* lneu2_ */

/* Subroutine */ int rich3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, doublereal *, integer *, integer *, doublereal *
	    , doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);


/* ... rich3 drives the richardson preconditioner. */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)copy_, (S_fp)copy_,
	    (S_fp)copy_, (S_fp)copy_, (S_fp)copy_, (S_fp)copy_, (S_fp)noadp_,
	    &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &wksp[1], &
	    iwksp[1], &iparm[1], &rparm[1], ier);
    return 0;
} /* rich3_ */

/* Subroutine */ int jac3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int subq1_(), noadp_(doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *), split_(S_fp, U_fp, U_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... jac3 drives the jacobi preconditioner. */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq1_, (S_fp)
	    subq1_, (S_fp)subq1_, (S_fp)subq1_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    return 0;
} /* jac3_ */

/* Subroutine */ int ljac3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int subq2_(), subq3_(), lfact_(doublereal *,
	    integer *, doublereal *, integer *, integer *), noadp_(doublereal
	    *, integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *);
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... ljac3 drives the line jacobi preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	lfact_(&coef[1], &jcoef[1], &wksp[1], n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq2_, (S_fp)
	    subq3_, (S_fp)subq2_, (S_fp)subq3_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    return 0;
} /* ljac3_ */

/* Subroutine */ int ljacx3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int linv_(doublereal *, integer *, doublereal *,
	    integer *, integer *), copy_(doublereal *, integer *, doublereal *
	    , integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int subq4_(), subq5_(), noadp_(doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *);
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... ljacx3 drives the line jacobi preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	linv_(&coef[1], &jcoef[1], &wksp[1], n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq4_, (S_fp)
	    subq5_, (S_fp)subq4_, (S_fp)subq5_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    return 0;
} /* ljacx3_ */

/* Subroutine */ int sor3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int move2_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *), noadp_(doublereal *, integer *, doublereal *, integer
	    *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), subq40_(), split_(S_fp, U_fp, U_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, S_fp, S_fp, doublereal *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *, integer *), rowise_(integer *
	    , integer *, integer *);


/* ... sor3 drives the point sor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    rowise_(&dscons_1.maxnz, &jcoef[1], &intern_1.irwise);
    needw_("sor3", &c__1, &cwkcon_1.iipnt, &dscons_1.maxnz, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    needw_("sor3", &c__0, &cwkcon_1.irpnt, n, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    move2_(&dscons_1.ndim, n, &dscons_1.maxnz, &jcoef[1], &coef[1], &wksp[
	    cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt], &intern_1.maxt, &
	    intern_1.maxb);
    point_1.iwkpt1 = cwkcon_1.iipnt;
    cwkcon_1.iipnt += dscons_1.maxnz;
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq40_, (S_fp)
	    subq40_, (S_fp)subq40_, (S_fp)subq40_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.iipnt -= dscons_1.maxnz;
    return 0;
} /* sor3_ */

/* Subroutine */ int ssor3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int move2_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), subq41_(), subq42_(), subq43_(), subq44_(),
	    subq45_(), subq46_(), subq47_(), split_(S_fp, U_fp, U_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, S_fp, S_fp, doublereal *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *, integer *), rowise_(integer *
	    , integer *, integer *);


/* ... ssor3 drives the point ssor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    rowise_(&dscons_1.maxnz, &jcoef[1], &intern_1.irwise);
    needw_("ssor3", &c__1, &cwkcon_1.iipnt, &dscons_1.maxnz, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    needw_("ssor3", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    move2_(&dscons_1.ndim, &n, &dscons_1.maxnz, &jcoef[1], &coef[1], &wksp[
	    cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt], &intern_1.maxt, &
	    intern_1.maxb);
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    point_1.iwkpt2 = cwkcon_1.iipnt;
    cwkcon_1.iipnt += dscons_1.maxnz;
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq41_, (S_fp)
	    subq42_, (S_fp)subq43_, (S_fp)subq44_, (S_fp)subq45_, (S_fp)
	    subq46_, (S_fp)subq47_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1],
	    &rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n;
    cwkcon_1.iipnt -= dscons_1.maxnz;
    return 0;
} /* ssor3_ */

/* Subroutine */ int ic3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int move2_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *), noadp_(doublereal *, integer *, doublereal *, integer
	    *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen);
    static integer leniw;
    extern /* Subroutine */ int subq50_(), subq51_(), subq52_(), subq53_(),
	    subq48_(), subq49_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), pfact3_(doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *, integer
	    *);


/* ... ic3 drives the nonsymmetric ic preconditioner. */




    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    needw_("ic3", &c__1, &cwkcon_1.iipnt, &dscons_1.maxnz, ier, (ftnlen)3);
    if (*ier < 0) {
	return 0;
    }
    needw_("ic3", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)3);
    if (*ier < 0) {
	return 0;
    }
    if (itcom6_1.ifact == 0 && itcom6_1.lvfill > 0) {
	goto L20;
    }
    move2_(&dscons_1.ndim, &n, &dscons_1.maxnz, &jcoef[1], &coef[1], &wksp[
	    cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt], &intern_1.maxt, &
	    intern_1.maxb);
L20:
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	pfact3_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], &n, &c__1, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    leniw = max(dscons_1.maxnz,cfactr_1.nfacti);
    point_1.iwkpt1 = cwkcon_1.iipnt;
    cwkcon_1.iipnt += leniw;
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq48_, (S_fp)
	    subq49_, (S_fp)subq50_, (S_fp)subq51_, (S_fp)subq52_, (S_fp)
	    subq53_, (S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.iipnt -= leniw;
    return 0;
} /* ic3_ */

/* Subroutine */ int mic3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int move2_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *), noadp_(doublereal *, integer *, doublereal *, integer
	    *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen);
    static integer leniw;
    extern /* Subroutine */ int subq50_(), subq51_(), subq52_(), subq53_(),
	    subq48_(), subq49_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), pfact3_(doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *, integer
	    *);


/* ... mic3 drives the nonsymmetric mic preconditioner. */




    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    needw_("mic3", &c__1, &cwkcon_1.iipnt, &dscons_1.maxnz, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    needw_("mic3", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    if (itcom6_1.ifact == 0 && itcom6_1.lvfill > 0) {
	goto L20;
    }
    move2_(&dscons_1.ndim, &n, &dscons_1.maxnz, &jcoef[1], &coef[1], &wksp[
	    cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt], &intern_1.maxt, &
	    intern_1.maxb);
L20:
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	pfact3_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], &n, &c__2, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    leniw = max(dscons_1.maxnz,cfactr_1.nfacti);
    point_1.iwkpt1 = cwkcon_1.iipnt;
    cwkcon_1.iipnt += leniw;
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq48_, (S_fp)
	    subq49_, (S_fp)subq50_, (S_fp)subq51_, (S_fp)subq52_, (S_fp)
	    subq53_, (S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.iipnt -= leniw;
    return 0;
} /* mic3_ */

/* Subroutine */ int lsp3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int ainfn_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *),
	    noadp_(doublereal *, integer *, doublereal *, integer *, integer *
	    , doublereal *, doublereal *, doublereal *, doublereal *), needw_(
	    char *, integer *, integer *, integer *, integer *, ftnlen),
	    subq54_(), subq55_(), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... lsp3 drives the least squares polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    i__1 = n << 1;
    needw_("lsp3", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    ainfn_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &c__3, &
	    itcom8_1.ainf, &wksp[cwkcon_1.irpnt]);
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n << 1;
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq54_, (S_fp)
	    subq55_, (S_fp)subq54_, (S_fp)subq55_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n << 1;
    return 0;
} /* lsp3_ */

/* Subroutine */ int neu3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), subq56_(), subq57_(), split_(S_fp, U_fp, U_fp,
	     S_fp, S_fp, S_fp, S_fp, S_fp, S_fp, S_fp, doublereal *, integer *
	    , integer *, doublereal *, doublereal *, doublereal *, doublereal
	    *, integer *, integer *, doublereal *, integer *);


/* ... neu3 drives the neumann polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    needw_("neu3", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq56_, (S_fp)
	    subq57_, (S_fp)subq56_, (S_fp)subq57_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n;
    return 0;
} /* neu3_ */

/* Subroutine */ int lsor3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int lfact_(doublereal *, integer *, doublereal *,
	    integer *, integer *), noadp_(doublereal *, integer *, doublereal
	    *, integer *, integer *, doublereal *, doublereal *, doublereal *,
	     doublereal *);
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int subq58_();
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), blkdef_(doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *);


/* ... lsor3 drives the line sor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    blkdef_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, ier);
    if (*ier < 0) {
	return 0;
    }
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	lfact_(&coef[1], &jcoef[1], &wksp[1], n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq58_, (S_fp)
	    subq58_, (S_fp)subq58_, (S_fp)subq58_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    return 0;
} /* lsor3_ */

/* Subroutine */ int lssor3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int lfact_(doublereal *, integer *, doublereal *,
	    integer *, integer *), subq60_(), subq61_(), subq62_(), subq63_(),
	     subq64_(), subq65_(), subq59_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), blkdef_(doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *);


/* ... lssor3 drives the line ssor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    blkdef_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], &n, ier);
    if (*ier < 0) {
	return 0;
    }
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	lfact_(&coef[1], &jcoef[1], &wksp[1], &n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    if (*ier < 0) {
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq59_, (S_fp)
	    subq60_, (S_fp)subq61_, (S_fp)subq62_, (S_fp)subq63_, (S_fp)
	    subq64_, (S_fp)subq65_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1],
	    &rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n;
    return 0;
} /* lssor3_ */

/* Subroutine */ int bic3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), subq70_(), subq71_(), subq72_(), subq73_(),
	    subq74_(), subq75_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);
    extern /* Subroutine */ int ibfcn1_();
    extern /* Subroutine */ int blkdef_(doublereal *, integer *, doublereal *,
	     integer *, integer *, integer *), bfacmz_(integer *, U_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    integer *);


/* ... bic3 drives the block factorization (version 1) method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    blkdef_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, ier);
    if (*ier < 0) {
	return 0;
    }
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	bfacmz_(&c__1, (U_fp)ibfcn1_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1]
		, n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += itcom6_1.kblsz << 1;
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq70_, (S_fp)
	    subq71_, (S_fp)subq72_, (S_fp)subq73_, (S_fp)subq74_, (S_fp)
	    subq75_, (S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= itcom6_1.kblsz << 1;
    return 0;
} /* bic3_ */

/* Subroutine */ int mbic3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), subq70_(), subq71_(), subq72_(), subq73_(),
	    subq74_(), subq75_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);
    extern /* Subroutine */ int ibfcn3_();
    extern /* Subroutine */ int blkdef_(doublereal *, integer *, doublereal *,
	     integer *, integer *, integer *), bfacmz_(integer *, U_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    integer *);


/* ... mbic3 drives the block factorization (version 1, modified) */
/*     method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    blkdef_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, ier);
    if (*ier < 0) {
	return 0;
    }
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	bfacmz_(&c__2, (U_fp)ibfcn3_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1]
		, n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += itcom6_1.kblsz << 1;
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq70_, (S_fp)
	    subq71_, (S_fp)subq72_, (S_fp)subq73_, (S_fp)subq74_, (S_fp)
	    subq75_, (S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= itcom6_1.kblsz << 1;
    return 0;
} /* mbic3_ */

/* Subroutine */ int bicx3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), subq70_(), subq71_(), subq72_(), subq73_(),
	    subq74_(), subq75_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);
    extern /* Subroutine */ int ibfcn2_();
    extern /* Subroutine */ int blkdef_(doublereal *, integer *, doublereal *,
	     integer *, integer *, integer *), bfacmz_(integer *, U_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    integer *);


/* ... bicx3 drives the block factorization (version 2) */
/*     method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    blkdef_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, ier);
    if (*ier < 0) {
	return 0;
    }
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	bfacmz_(&c__3, (U_fp)ibfcn2_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1]
		, n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += itcom6_1.kblsz << 1;
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq70_, (S_fp)
	    subq71_, (S_fp)subq72_, (S_fp)subq73_, (S_fp)subq74_, (S_fp)
	    subq75_, (S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= itcom6_1.kblsz << 1;
    return 0;
} /* bicx3_ */

/* Subroutine */ int mbicx3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), subq70_(), subq71_(), subq72_(), subq73_(),
	    subq74_(), subq75_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);
    extern /* Subroutine */ int ibfcn4_();
    extern /* Subroutine */ int blkdef_(doublereal *, integer *, doublereal *,
	     integer *, integer *, integer *), bfacmz_(integer *, U_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    integer *);


/* ... mbicx3 drives the block factorization (version 2, modified) */
/*     method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    blkdef_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, ier);
    if (*ier < 0) {
	return 0;
    }
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	bfacmz_(&c__4, (U_fp)ibfcn4_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1]
		, n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += itcom6_1.kblsz << 1;
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq70_, (S_fp)
	    subq71_, (S_fp)subq72_, (S_fp)subq73_, (S_fp)subq74_, (S_fp)
	    subq75_, (S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= itcom6_1.kblsz << 1;
    return 0;
} /* mbicx3_ */

/* Subroutine */ int llsp3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int lfact_(doublereal *, integer *, doublereal *,
	    integer *, integer *), noadp_(doublereal *, integer *, doublereal
	    *, integer *, integer *, doublereal *, doublereal *, doublereal *,
	     doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen);
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int subq66_(), subq67_();
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), adinfn_(integer *, integer *
	    , integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *);


/* ... llsp3 drives the line least squares polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    needw_("llsp3", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    adinfn_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &c__3, &
	    itcom8_1.ainf, &wksp[cwkcon_1.irpnt]);
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	lfact_(&coef[1], &jcoef[1], &wksp[1], &n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    i__1 = n << 1;
    needw_("llsp3", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n << 1;
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq66_, (S_fp)
	    subq67_, (S_fp)subq66_, (S_fp)subq67_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n << 1;
    return 0;
} /* llsp3_ */

/* Subroutine */ int lneu3_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba4_(), suba5_();
    extern /* Subroutine */ int lfact_(doublereal *, integer *, doublereal *,
	    integer *, integer *), noadp_(doublereal *, integer *, doublereal
	    *, integer *, integer *, doublereal *, doublereal *, doublereal *,
	     doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen);
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int subq68_(), subq69_();
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... lneu3 drives the line neumann polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	lfact_(&coef[1], &jcoef[1], &wksp[1], &n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    i__1 = n << 1;
    needw_("lneu3", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n << 1;
    split_((S_fp)accel, (U_fp)suba4_, (U_fp)suba5_, (S_fp)subq68_, (S_fp)
	    subq69_, (S_fp)subq68_, (S_fp)subq69_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n << 1;
    return 0;
} /* lneu3_ */

/* Subroutine */ int rich4_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba12_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, doublereal *, integer *, integer *, doublereal *
	    , doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);


/* ... rich4 drives the richardson preconditioner. */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    point_1.iwkpt1 = cwkcon_1.irpnt;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt += *n << 1;
    }
    split_((S_fp)accel, (U_fp)suba12_, (U_fp)suba12_, (S_fp)copy_, (S_fp)
	    copy_, (S_fp)copy_, (S_fp)copy_, (S_fp)copy_, (S_fp)copy_, (S_fp)
	    noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &wksp[1]
	    , &iwksp[1], &iparm[1], &rparm[1], ier);
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt -= *n << 1;
    }
    return 0;
} /* rich4_ */

/* Subroutine */ int jac4_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *), subq1_();
    extern /* Subroutine */ int suba12_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, doublereal *, integer *, integer *, doublereal *
	    , doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);


/* ... jac4 drives the jacobi preconditioner. */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    point_1.iwkpt1 = cwkcon_1.irpnt;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt += *n << 1;
    }
    split_((S_fp)accel, (U_fp)suba12_, (U_fp)suba12_, (S_fp)subq1_, (S_fp)
	    subq1_, (S_fp)subq1_, (S_fp)subq1_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt -= *n << 1;
    }
    return 0;
} /* jac4_ */

/* Subroutine */ int lsp4_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *), sub110_(),
	    ainfn_(integer *, integer *, integer *, integer *, doublereal *,
	    integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba12_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... lsp4 drives the least squares polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    i__1 = n << 1;
    needw_("lsp4", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    ainfn_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &c__4, &
	    itcom8_1.ainf, &wksp[cwkcon_1.irpnt]);
    point_1.iwkpt2 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n << 1;
    point_1.iwkpt1 = cwkcon_1.irpnt;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt += n << 1;
    }
    split_((S_fp)accel, (U_fp)suba12_, (U_fp)suba12_, (S_fp)sub110_, (S_fp)
	    sub110_, (S_fp)sub110_, (S_fp)sub110_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n << 1;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt -= n << 1;
    }
    return 0;
} /* lsp4_ */

/* Subroutine */ int neu4_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *), sub111_();
    extern /* Subroutine */ int suba12_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... neu4 drives the neumann polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    needw_("neu4", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt2 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    point_1.iwkpt1 = cwkcon_1.irpnt;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt += n << 1;
    }
    split_((S_fp)accel, (U_fp)suba12_, (U_fp)suba12_, (S_fp)sub111_, (S_fp)
	    sub111_, (S_fp)sub111_, (S_fp)sub111_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt -= n << 1;
    }
    return 0;
} /* neu4_ */

/* Subroutine */ int rich5_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba13_(), suba14_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, doublereal *, integer *, integer *, doublereal *
	    , doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);


/* ... rich5 drives the richardson preconditioner. */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    point_1.iwkpt1 = cwkcon_1.irpnt;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt += *n << 1;
    }
    split_((S_fp)accel, (U_fp)suba13_, (U_fp)suba14_, (S_fp)copy_, (S_fp)
	    copy_, (S_fp)copy_, (S_fp)copy_, (S_fp)copy_, (S_fp)copy_, (S_fp)
	    noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &wksp[1]
	    , &iwksp[1], &iparm[1], &rparm[1], ier);
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt -= *n << 1;
    }
    return 0;
} /* rich5_ */

/* Subroutine */ int jac5_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *), subq1_();
    extern /* Subroutine */ int suba13_(), suba14_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, doublereal *, integer *, integer *, doublereal *
	    , doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);


/* ... jac5 drives the jacobi preconditioner. */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    point_1.iwkpt1 = cwkcon_1.irpnt;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt += *n << 1;
    }
    split_((S_fp)accel, (U_fp)suba13_, (U_fp)suba14_, (S_fp)subq1_, (S_fp)
	    subq1_, (S_fp)subq1_, (S_fp)subq1_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt -= *n << 1;
    }
    return 0;
} /* jac5_ */

/* Subroutine */ int lsp5_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *), sub112_(),
	    sub113_(), ainfn_(integer *, integer *, integer *, integer *,
	    doublereal *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba13_(), suba14_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... lsp5 drives the least squares polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    i__1 = n << 1;
    needw_("lsp5", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    ainfn_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &c__5, &
	    itcom8_1.ainf, &wksp[cwkcon_1.irpnt]);
    point_1.iwkpt2 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n << 1;
    point_1.iwkpt1 = cwkcon_1.irpnt;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt += n << 1;
    }
    split_((S_fp)accel, (U_fp)suba13_, (U_fp)suba14_, (S_fp)sub112_, (S_fp)
	    sub113_, (S_fp)sub112_, (S_fp)sub113_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n << 1;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt -= n << 1;
    }
    return 0;
} /* lsp5_ */

/* Subroutine */ int neu5_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *), sub114_(),
	    sub115_();
    extern /* Subroutine */ int suba13_(), suba14_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... neu5 drives the neumann polynomial preconditioner. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    needw_("neu5", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt2 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    point_1.iwkpt1 = cwkcon_1.irpnt;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt += n << 1;
    }
    split_((S_fp)accel, (U_fp)suba13_, (U_fp)suba14_, (S_fp)sub114_, (S_fp)
	    sub115_, (S_fp)sub114_, (S_fp)sub115_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n;
    if (itcom4_1.keygs == 1) {
	cwkcon_1.irpnt -= n << 1;
    }
    return 0;
} /* neu5_ */

/* Subroutine */ int sor6_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba8_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), subq96_(), split_(S_fp, U_fp, U_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... sor6 drives the multi-color sor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += *n;
    split_((S_fp)accel, (U_fp)suba8_, (U_fp)suba8_, (S_fp)subq96_, (S_fp)
	    subq96_, (S_fp)subq96_, (S_fp)subq96_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= *n;
    return 0;
} /* sor6_ */

/* Subroutine */ int ssor6_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    extern /* Subroutine */ int sub100_(), sub101_(), sub102_(), sub103_();
    extern /* Subroutine */ int suba8_(), suba9_();
    extern /* Subroutine */ int subq97_(), subq98_(), subq99_(), split_(S_fp,
	    U_fp, U_fp, S_fp, S_fp, S_fp, S_fp, S_fp, S_fp, S_fp, doublereal *
	    , integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *, doublereal *, integer *);


/* ... ssor6 drives the multi-color ssor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt = cwkcon_1.irpnt + *n + cblock_1.ncmax;
    split_((S_fp)accel, (U_fp)suba8_, (U_fp)suba9_, (S_fp)subq97_, (S_fp)
	    subq98_, (S_fp)subq99_, (S_fp)sub100_, (S_fp)sub101_, (S_fp)
	    sub102_, (S_fp)sub103_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt = cwkcon_1.irpnt - *n - cblock_1.ncmax;
    return 0;
} /* ssor6_ */

/* Subroutine */ int ic6_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int sub104_(), sub105_(), sub106_(), sub107_();
    extern /* Subroutine */ int suba8_(), suba9_();
    extern /* Subroutine */ int sub108_(), sub109_(), noadp_(doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *);
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), pfactc_(doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *, integer
	    *);


/* ... ic6 drives the ic preconditioner. */
/*     (multi-color ordering) */




    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	pfactc_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], &n, &c__1, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    split_((S_fp)accel, (U_fp)suba8_, (U_fp)suba9_, (S_fp)sub104_, (S_fp)
	    sub105_, (S_fp)sub106_, (S_fp)sub107_, (S_fp)sub108_, (S_fp)
	    sub109_, (S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n;
    return 0;
} /* ic6_ */

/* Subroutine */ int mic6_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int sub104_(), sub105_(), sub106_(), sub107_();
    extern /* Subroutine */ int suba8_(), suba9_();
    extern /* Subroutine */ int sub108_(), sub109_(), noadp_(doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *);
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), pfactc_(doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *, integer
	    *);


/* ... mic6 drives the mic preconditioner. */
/*     (multi-color ordering) */




    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	pfactc_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], &n, &c__2, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    split_((S_fp)accel, (U_fp)suba8_, (U_fp)suba9_, (S_fp)sub104_, (S_fp)
	    sub105_, (S_fp)sub106_, (S_fp)sub107_, (S_fp)sub108_, (S_fp)
	    sub109_, (S_fp)noadp_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n;
    return 0;
} /* mic6_ */

/* Subroutine */ int rs6_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n, nb, nr, irhs;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *), subq1_();
    extern /* Subroutine */ int suba10_(), suba11_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), vfill_(integer *, doublereal *, doublereal *),
	     split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp, S_fp, S_fp, S_fp,
	    S_fp, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *), rsbegp_(integer *, integer *, integer *,
	     integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), rsendp_(integer *, integer *, integer *, integer *,
	     integer *, doublereal *, doublereal *, doublereal *, doublereal *
	    );


/* ... rs6 drives the reduced system method (purdue storage */
/*     with red-black coloring). */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;

/* ... compute red-black rhs. */

    nr = iwksp[cblock_1.nc];
    nb = n - nr;
    i__1 = n << 1;
    needw_("rs6", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)3);
    if (*ier < 0) {
	return 0;
    }
    irhs = cwkcon_1.irpnt;
    cwkcon_1.irpnt += nr;
    i__1 = n << 1;
    vfill_(&i__1, &wksp[irhs], &c_b121);
    rsbegp_(&n, &nr, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &
	    wksp[irhs], &rhs[1], &wksp[cwkcon_1.irpnt]);
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt = cwkcon_1.irpnt + n + nb;
    split_((S_fp)accel, (U_fp)suba10_, (U_fp)suba11_, (S_fp)subq1_, (S_fp)
	    subq1_, (S_fp)subq1_, (S_fp)subq1_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &nr, &u[1], &ubar[1], &wksp[
	    irhs], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    rsendp_(&n, &nr, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &u[
	    1], &rhs[1], &wksp[point_1.iwkpt1]);
    cwkcon_1.irpnt -= n << 1;
    return 0;
} /* rs6_ */

/* Subroutine */ int sor7_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba2_();
    extern /* Subroutine */ int mfact_(doublereal *, integer *, doublereal *,
	    integer *, integer *, integer *), noadp_(doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *), subq26_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... sor7 drives the multi-color sor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	mfact_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    split_((S_fp)accel, (U_fp)suba2_, (U_fp)suba2_, (S_fp)subq26_, (S_fp)
	    subq26_, (S_fp)subq26_, (S_fp)subq26_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &rhs[1], &
	    wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    return 0;
} /* sor7_ */

/* Subroutine */ int ssor7_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int suba2_(), suba3_();
    extern /* Subroutine */ int mfact_(doublereal *, integer *, doublereal *,
	    integer *, integer *, integer *), subq30_(), subq31_(), subq32_(),
	     subq33_(), subq27_(), subq28_(), subq29_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);


/* ... ssor7 drives the multi-color ssor method. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	mfact_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], &n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += n;
    split_((S_fp)accel, (U_fp)suba2_, (U_fp)suba3_, (S_fp)subq27_, (S_fp)
	    subq28_, (S_fp)subq29_, (S_fp)subq30_, (S_fp)subq31_, (S_fp)
	    subq32_, (S_fp)subq33_, &coef[1], &jcoef[1], &n, &u[1], &ubar[1],
	    &rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= n;
    return 0;
} /* ssor7_ */

/* Subroutine */ int bic7_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int suba2_(), suba3_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), subq34_(), subq35_(), subq36_(), subq37_(),
	    subq38_(), subq39_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);
    extern /* Subroutine */ int ibfcn1_();
    extern /* Subroutine */ int bfacmy_(integer *, U_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *);


/* ... bic7 drives the block factorization (version 1) method. */
/*     (multi-color ordering) */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	bfacmy_(&c__1, (U_fp)ibfcn1_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1]
		, n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += cblock_1.ncmax << 1;
    split_((S_fp)accel, (U_fp)suba2_, (U_fp)suba3_, (S_fp)subq34_, (S_fp)
	    subq35_, (S_fp)subq36_, (S_fp)subq37_, (S_fp)subq38_, (S_fp)
	    subq39_, (S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= cblock_1.ncmax << 1;
    return 0;
} /* bic7_ */

/* Subroutine */ int mbic7_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int suba2_(), suba3_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), subq34_(), subq35_(), subq36_(), subq37_(),
	    subq38_(), subq39_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);
    extern /* Subroutine */ int ibfcn3_();
    extern /* Subroutine */ int bfacmy_(integer *, U_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *);


/* ... mbic7 drives the block factorization (version 1, modified) */
/*     method (multi-color ordering) */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	bfacmy_(&c__2, (U_fp)ibfcn3_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1]
		, n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += cblock_1.ncmax << 1;
    split_((S_fp)accel, (U_fp)suba2_, (U_fp)suba3_, (S_fp)subq34_, (S_fp)
	    subq35_, (S_fp)subq36_, (S_fp)subq37_, (S_fp)subq38_, (S_fp)
	    subq39_, (S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= cblock_1.ncmax << 1;
    return 0;
} /* mbic7_ */

/* Subroutine */ int bicx7_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int suba2_(), suba3_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), subq34_(), subq35_(), subq36_(), subq37_(),
	    subq38_(), subq39_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);
    extern /* Subroutine */ int ibfcn2_();
    extern /* Subroutine */ int bfacmy_(integer *, U_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *);


/* ... bicx7 drives the block factorization (version 2) */
/*     method (multi-color ordering) */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	bfacmy_(&c__3, (U_fp)ibfcn2_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1]
		, n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += cblock_1.ncmax << 1;
    split_((S_fp)accel, (U_fp)suba2_, (U_fp)suba3_, (S_fp)subq34_, (S_fp)
	    subq35_, (S_fp)subq36_, (S_fp)subq37_, (S_fp)subq38_, (S_fp)
	    subq39_, (S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= cblock_1.ncmax << 1;
    return 0;
} /* bicx7_ */

/* Subroutine */ int mbicx7_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static doublereal t1, t2;
    extern /* Subroutine */ int suba2_(), suba3_();
    extern /* Subroutine */ int noadp_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), subq34_(), subq35_(), subq36_(), subq37_(),
	    subq38_(), subq39_();
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);
    extern /* Subroutine */ int ibfcn4_();
    extern /* Subroutine */ int bfacmy_(integer *, U_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, integer *);


/* ... mbicx7 drives the block factorization (version 2, modified) */
/*     method (multi-color ordering) */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	bfacmy_(&c__4, (U_fp)ibfcn4_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1]
		, n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += cblock_1.ncmax << 1;
    split_((S_fp)accel, (U_fp)suba2_, (U_fp)suba3_, (S_fp)subq34_, (S_fp)
	    subq35_, (S_fp)subq36_, (S_fp)subq37_, (S_fp)subq38_, (S_fp)
	    subq39_, (S_fp)noadp_, &coef[1], &jcoef[1], n, &u[1], &ubar[1], &
	    rhs[1], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    cwkcon_1.irpnt -= cblock_1.ncmax << 1;
    return 0;
} /* mbicx7_ */

/* Subroutine */ int rs7_(S_fp accel, doublereal *coef, integer *jcoef,
	integer *nn, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    static integer n;
    static doublereal t1, t2;
    static integer nb, nr, irhs;
    extern /* Subroutine */ int copy_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int suba6_(), suba7_();
    extern /* Subroutine */ int mfact_(doublereal *, integer *, doublereal *,
	    integer *, integer *, integer *), noadp_(doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *), needw_(char *, integer *, integer *,
	    integer *, integer *, ftnlen);
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int subq76_(), subq77_();
    static doublereal dummy;
    extern /* Subroutine */ int split_(S_fp, U_fp, U_fp, S_fp, S_fp, S_fp,
	    S_fp, S_fp, S_fp, S_fp, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *), rsbegd_(integer *, integer *
	    , integer *, integer *, integer *, integer *, integer *, integer *
	    , doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *), rsendd_(integer *, integer *, integer *, integer *,
	     integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *);


/* ... rs7 drives the reduced system method (diagonal storage */
/*     with red-black coloring). */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    t1 = timer_(&dummy);
    if (itcom6_1.ifact == 1) {
	mfact_(&coef[1], &jcoef[1], &wksp[1], &iwksp[1], &n, ier);
    }
    t2 = timer_(&dummy);
    cfactr_1.timfac = t2 - t1;
    if (*ier < 0) {
	return 0;
    }

/* ... compute red-black rhs. */

    nr = iwksp[cblock_1.nc];
    nb = n - nr;
    needw_("rs7", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)3);
    if (*ier < 0) {
	return 0;
    }
    irhs = cwkcon_1.irpnt;
    cwkcon_1.irpnt += nr;
    rsbegd_(&n, &n, &nr, &dscons_1.ndim, &iwksp[cblock_1.maxnew], &
	    intern_1.ndt, &intern_1.ndb, &iwksp[cblock_1.jcnew], &coef[1], &
	    wksp[irhs], &rhs[1], &wksp[cfactr_1.ifactr], &wksp[cwkcon_1.irpnt]
	    );
    point_1.iwkpt1 = cwkcon_1.irpnt;
    cwkcon_1.irpnt += nb;
    split_((S_fp)accel, (U_fp)suba6_, (U_fp)suba7_, (S_fp)subq76_, (S_fp)
	    subq77_, (S_fp)subq76_, (S_fp)subq77_, (S_fp)copy_, (S_fp)copy_, (
	    S_fp)noadp_, &coef[1], &jcoef[1], &nr, &u[1], &ubar[1], &wksp[
	    irhs], &wksp[1], &iwksp[1], &iparm[1], &rparm[1], ier);
    rsendd_(&n, &n, &nr, &dscons_1.ndim, &iwksp[cblock_1.maxnew], &
	    intern_1.ndt, &intern_1.ndb, &iwksp[cblock_1.jcnew], &coef[1], &u[
	    1], &rhs[1], &wksp[cfactr_1.ifactr]);
    cwkcon_1.irpnt -= n;
    return 0;
} /* rs7_ */

/* Subroutine */ int suba1_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    extern /* Subroutine */ int mult2s_(integer *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);


/* ... suba1 calls mult2s. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    mult2s_(&dscons_1.ndim, &dscons_1.maxnz, &coef[1], &jcoef[1], n, &x[1], &
	    y[1]);
    return 0;
} /* suba1_ */

/* Subroutine */ int suba2_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    extern /* Subroutine */ int muldc_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *);


/* ... suba2 calls muldc. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    muldc_(&dscons_1.ndim, n, &coef[1], &cblock_1.ncolor, &iwksp[cblock_1.nc],
	     &iwksp[cblock_1.maxnew], &iwksp[cblock_1.jcnew], &x[1], &y[1]);
    return 0;
} /* suba2_ */

/* Subroutine */ int suba3_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    extern /* Subroutine */ int muldct_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *);


/* ... suba3 calls muldct. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    muldct_(&dscons_1.ndim, n, &coef[1], &cblock_1.ncolor, &iwksp[cblock_1.nc]
	    , &iwksp[cblock_1.maxnew], &iwksp[cblock_1.jcnew], &x[1], &y[1]);
    return 0;
} /* suba3_ */

/* Subroutine */ int suba4_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    extern /* Subroutine */ int mult2n_(integer *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);


/* ... suba4 calls mult2n. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    mult2n_(&dscons_1.ndim, &dscons_1.maxnz, &coef[1], &jcoef[1], n, &x[1], &
	    y[1]);
    return 0;
} /* suba4_ */

/* Subroutine */ int suba5_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    extern /* Subroutine */ int mul2nt_(integer *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *);


/* ... suba5 calls mul2nt. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    mul2nt_(&dscons_1.ndim, &dscons_1.maxnz, &coef[1], &jcoef[1], n, &x[1], &
	    y[1]);
    return 0;
} /* suba5_ */

/* Subroutine */ int suba6_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    static integer nb, nr, nbig;
    extern /* Subroutine */ int rsad_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, doublereal
	    *, doublereal *, doublereal *, doublereal *, doublereal *);


/* ... suba6 calls rsad. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    nr = iwksp[cblock_1.nc];
    nb = iwksp[cblock_1.nc + 1];
    nbig = nr + nb;
    rsad_(&nbig, n, n, &dscons_1.ndim, &iwksp[cblock_1.maxnew], &intern_1.ndt,
	     &intern_1.ndb, &iwksp[cblock_1.jcnew], &coef[1], &y[1], &x[1], &
	    wksp[cfactr_1.ifactr], &wksp[point_1.iwkpt1]);
    return 0;
} /* suba6_ */

/* Subroutine */ int suba7_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    static integer nb, nr, nbig;
    extern /* Subroutine */ int rsatd_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, doublereal
	    *, doublereal *, doublereal *, doublereal *, doublereal *);


/* ... suba7 calls rsatd. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    nr = iwksp[cblock_1.nc];
    nb = iwksp[cblock_1.nc + 1];
    nbig = nr + nb;
    rsatd_(&nbig, n, n, &dscons_1.ndim, &iwksp[cblock_1.maxnew], &
	    intern_1.ndt, &intern_1.ndb, &iwksp[cblock_1.jcnew], &coef[1], &y[
	    1], &x[1], &wksp[cfactr_1.ifactr], &wksp[point_1.iwkpt1]);
    return 0;
} /* suba7_ */

/* Subroutine */ int suba8_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    extern /* Subroutine */ int mult1_(integer *, integer *, doublereal *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *);


/* ... suba8 calls mult1. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    mult1_(&dscons_1.ndim, &dscons_1.maxnz, &coef[1], &jcoef[1], &wksp[
	    point_1.iwkpt1], n, &x[1], &y[1]);
    return 0;
} /* suba8_ */

/* Subroutine */ int suba9_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    extern /* Subroutine */ int mul1t_(integer *, integer *, doublereal *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *);


/* ... suba9 calls mul1t. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    mul1t_(&dscons_1.ndim, &dscons_1.maxnz, &coef[1], &jcoef[1], &wksp[
	    point_1.iwkpt1], n, &x[1], &y[1]);
    return 0;
} /* suba9_ */

/* Subroutine */ int suba10_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    static integer nb, nr, nbig;
    extern /* Subroutine */ int rsap_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *);


/* ... suba10 calls rsap. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    nr = iwksp[cblock_1.nc];
    nb = iwksp[cblock_1.nc + 1];
    nbig = nr + nb;
    rsap_(&dscons_1.ndim, &nbig, n, &dscons_1.maxnz, &jcoef[1], &coef[1], &x[
	    1], &y[1], &wksp[point_1.iwkpt1]);
    return 0;
} /* suba10_ */

/* Subroutine */ int suba11_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    static integer nb, nr, nbig;
    extern /* Subroutine */ int rsap_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *), rsatp_(integer *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... suba11 calls rsatp. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    nr = iwksp[cblock_1.nc];
    nb = iwksp[cblock_1.nc + 1];
    nbig = nr + nb;
    if (itcom6_1.isymm == 0) {
	rsap_(&dscons_1.ndim, &nbig, n, &dscons_1.maxnz, &jcoef[1], &coef[1],
		&x[1], &y[1], &wksp[point_1.iwkpt1]);
    }
    if (itcom6_1.isymm == 1) {
	rsatp_(&dscons_1.ndim, &nbig, n, &dscons_1.maxnz, &jcoef[1], &coef[1],
		 &x[1], &y[1], &wksp[point_1.iwkpt1]);
    }
    return 0;
} /* suba11_ */

/* Subroutine */ int suba12_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    extern /* Subroutine */ int mult3_(integer *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *);


/* ... suba12 calls mult3. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    mult3_(&cmpart_1.mpart, &iwksp[cmpart_1.mpstrt], &coef[1], &jcoef[1], &
	    jcoef[dscons_1.ndim + 1], &wksp[point_1.iwkpt1], &x[1], &y[1]);
    return 0;
} /* suba12_ */

/* Subroutine */ int suba13_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    extern /* Subroutine */ int mult3n_(integer *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *);


/* ... suba13 calls mult3n. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    mult3n_(&cmpart_1.mpart, &iwksp[cmpart_1.mpstrt], &coef[1], &jcoef[1], &
	    jcoef[dscons_1.ndim + 1], &wksp[point_1.iwkpt1], &x[1], &y[1]);
    return 0;
} /* suba13_ */

/* Subroutine */ int suba14_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *x, doublereal *y)
{
    extern /* Subroutine */ int mul3nt_(integer *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *);


/* ... suba14 calls mul3nt. */


    /* Parameter adjustments */
    --y;
    --x;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    mul3nt_(&cmpart_1.mpart, &iwksp[cmpart_1.mpstrt], &coef[1], &jcoef[1], &
	    jcoef[dscons_1.ndim + 1], &wksp[point_1.iwkpt1], &x[1], &y[1]);
    return 0;
} /* suba14_ */

/* Subroutine */ int subq1_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int pjac_(doublereal *, integer *, doublereal *,
	    doublereal *);


/* ... subq1 calls pjac, for jacobi preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pjac_(&coef[1], n, &r__[1], &z__[1]);
    return 0;
} /* subq1_ */

/* Subroutine */ int subq2_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer isym;
    extern /* Subroutine */ int bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *);


/* ... subq2 calls bdsol, for line jacobi preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    if (itcom6_1.nstore == 2) {
	isym = 0;
    }
    if (itcom6_1.nstore == 3) {
	isym = 1;
    }
    bdsol_(n, n, &itcom6_1.kblsz, &intern_1.ndt, &intern_1.ndb, &wksp[
	    cfactr_1.ifactr], &r__[1], &z__[1], &isym);
    return 0;
} /* subq2_ */

/* Subroutine */ int subq3_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int bdsolt_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *);


/* ... subq3 calls bdsolt, for line jacobi preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    bdsolt_(n, n, &itcom6_1.kblsz, &intern_1.ndt, &intern_1.ndb, &wksp[
	    cfactr_1.ifactr], &r__[1], &z__[1]);
    return 0;
} /* subq3_ */

/* Subroutine */ int subq4_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ifb, ift;
    extern /* Subroutine */ int bmul_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *);
    static integer isym;
    extern /* Subroutine */ int bmuln_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *);


/* ... subq4 call bmul or bmuln, for line jacobi preconditioning */
/*     (approximate inverse) */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    if (itcom6_1.nstore == 2) {
	isym = 0;
    }
    if (itcom6_1.nstore == 3) {
	isym = 1;
    }
    ift = cfactr_1.ifactr + *n;
    ifb = cfactr_1.ifactr + *n * (intern_1.ndt + 1);
    if (isym == 0) {
	bmul_(n, n, &intern_1.ndt, &wksp[cfactr_1.ifactr], &wksp[ift], &r__[1]
		, &z__[1]);
    }
    if (isym == 1) {
	bmuln_(n, n, &intern_1.ndt, &intern_1.ndb, &wksp[cfactr_1.ifactr], &
		wksp[ift], &wksp[ifb], &r__[1], &z__[1]);
    }
    return 0;
} /* subq4_ */

/* Subroutine */ int subq5_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ifb, ift;
    extern /* Subroutine */ int bmul_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *);
    static integer isym;
    extern /* Subroutine */ int bmulnt_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *);


/* ... subq5 call bmul or bmulnt, for line jacobi preconditioning */
/*     (approximate inverse) */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    if (itcom6_1.nstore == 2) {
	isym = 0;
    }
    if (itcom6_1.nstore == 3) {
	isym = 1;
    }
    ift = cfactr_1.ifactr + *n;
    ifb = cfactr_1.ifactr + *n * (intern_1.ndt + 1);
    if (isym == 0) {
	bmul_(n, n, &intern_1.ndt, &wksp[cfactr_1.ifactr], &wksp[ift], &r__[1]
		, &z__[1]);
    }
    if (isym == 1) {
	bmulnt_(n, n, &intern_1.ndt, &intern_1.ndb, &wksp[cfactr_1.ifactr], &
		wksp[ift], &wksp[ifb], &r__[1], &z__[1]);
    }
    return 0;
} /* subq5_ */

/* Subroutine */ int subq6_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *u, doublereal *rhs,
	doublereal *unew)
{
    extern /* Subroutine */ int sords_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    doublereal *, doublereal *, doublereal *, integer *);


/* ... subq6 calls the basic sor iterative step */


    /* Parameter adjustments */
    --unew;
    --rhs;
    --u;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    intern_1.maxt = dscons_1.maxnz - 1;
    sords_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &coef[1], &coef[
	    dscons_1.ndim + 1], &itcom5_1.omega, &intern_1.irwise, &u[1], &
	    rhs[1], &unew[1], &iwksp[point_1.iwkpt1]);
    return 0;
} /* subq6_ */

/* Subroutine */ int subq7_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int srs_(integer *, integer *, integer *, integer
	    *, doublereal *, doublereal *, doublereal *, integer *, integer *,
	     doublereal *, doublereal *);


/* ... subq7 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    intern_1.maxt = dscons_1.maxnz - 1;
    srs_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &coef[1], &coef[
	    dscons_1.ndim + 1], &itcom5_1.omega, &intern_1.irwise, &iwksp[
	    point_1.iwkpt1], &r__[1], &z__[1]);
    return 0;
} /* subq7_ */

/* Subroutine */ int subq8_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int srs1_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *);


/* ... subq8 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    intern_1.maxt = dscons_1.maxnz - 1;
    srs1_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &coef[1], &coef[
	    dscons_1.ndim + 1], &itcom5_1.omega, &intern_1.irwise, &iwksp[
	    point_1.iwkpt1], &r__[1], &z__[1]);
    return 0;
} /* subq8_ */

/* Subroutine */ int subq9_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int srs3_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *);


/* ... subq9 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    intern_1.maxt = dscons_1.maxnz - 1;
    srs3_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &coef[1], &coef[
	    dscons_1.ndim + 1], &itcom5_1.omega, &intern_1.irwise, &iwksp[
	    point_1.iwkpt1], &r__[1], &z__[1]);
    return 0;
} /* subq9_ */

/* Subroutine */ int subq10_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int srs2_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *);


/* ... subq10 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    intern_1.maxt = dscons_1.maxnz - 1;
    srs2_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &coef[1], &coef[
	    dscons_1.ndim + 1], &itcom5_1.omega, &intern_1.irwise, &iwksp[
	    point_1.iwkpt1], &r__[1], &z__[1]);
    return 0;
} /* subq10_ */

/* Subroutine */ int subq11_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int srs4_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *);


/* ... subq11 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    intern_1.maxt = dscons_1.maxnz - 1;
    srs4_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &coef[1], &coef[
	    dscons_1.ndim + 1], &itcom5_1.omega, &intern_1.irwise, &iwksp[
	    point_1.iwkpt1], &r__[1], &z__[1]);
    return 0;
} /* subq11_ */

/* Subroutine */ int subq12_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *p, doublereal *r__,
	doublereal *pdp, doublereal *pldup)
{
    static integer maxt;
    extern /* Subroutine */ int ssord_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *);


/* ... subq12 calls the ssor adaption routine. */



    /* Parameter adjustments */
    --r__;
    --p;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    maxt = dscons_1.maxnz - 1;
    ssord_(&dscons_1.ndim, &maxt, &jcoef[2], &coef[1], &coef[dscons_1.ndim +
	    1], n, &p[1], &r__[1], pdp, pldup);
    return 0;
} /* subq12_ */

/* Subroutine */ int subq13_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int ics_(integer *, integer *, integer *, integer
	    *, doublereal *, doublereal *, integer *, integer *, integer *,
	    doublereal *, doublereal *);


/* ... subq13 calls ics, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    if (cblock_1.propa) {
	ics_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &wksp[
		cfactr_1.ifactr], &coef[dscons_1.ndim + 1], &c__1, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	ics_(n, n, &intern_1.maxt, &iwksp[cfactr_1.ifacti + 1], &wksp[
		cfactr_1.ifactr], &wksp[cfactr_1.ifactr + *n], &c__0, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    return 0;
} /* subq13_ */

/* Subroutine */ int subq14_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int ics1_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *, doublereal *);


/* ... subq14 calls ics1, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    if (cblock_1.propa) {
	ics1_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &wksp[
		cfactr_1.ifactr], &coef[dscons_1.ndim + 1], &c__1, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	ics1_(n, n, &intern_1.maxt, &iwksp[cfactr_1.ifacti + 1], &wksp[
		cfactr_1.ifactr], &wksp[cfactr_1.ifactr + *n], &c__0, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    return 0;
} /* subq14_ */

/* Subroutine */ int subq15_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int ics3_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *, doublereal *);


/* ... subq15 calls ics3, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    if (cblock_1.propa) {
	ics3_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &wksp[
		cfactr_1.ifactr], &coef[dscons_1.ndim + 1], &c__1, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	ics3_(n, n, &intern_1.maxt, &iwksp[cfactr_1.ifacti + 1], &wksp[
		cfactr_1.ifactr], &wksp[cfactr_1.ifactr + *n], &c__0, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    return 0;
} /* subq15_ */

/* Subroutine */ int subq16_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int ics2_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *, doublereal *);


/* ... subq16 calls ics2, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    if (cblock_1.propa) {
	ics2_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &wksp[
		cfactr_1.ifactr], &coef[dscons_1.ndim + 1], &c__1, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	ics2_(n, n, &intern_1.maxt, &iwksp[cfactr_1.ifacti + 1], &wksp[
		cfactr_1.ifactr], &wksp[cfactr_1.ifactr + *n], &c__0, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    return 0;
} /* subq16_ */

/* Subroutine */ int subq17_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int ics4_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *, doublereal *);


/* ... subq17 calls ics4, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    if (cblock_1.propa) {
	ics4_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &wksp[
		cfactr_1.ifactr], &coef[dscons_1.ndim + 1], &c__1, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	ics4_(n, n, &intern_1.maxt, &iwksp[cfactr_1.ifacti + 1], &wksp[
		cfactr_1.ifactr], &wksp[cfactr_1.ifactr + *n], &c__0, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    return 0;
} /* subq17_ */

/* Subroutine */ int subq18_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int ppii_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, doublereal *, doublereal *,
	     integer *, doublereal *, integer *, doublereal *, doublereal *),
	    suba1_(doublereal *, integer *, doublereal *, integer *, integer *
	    , doublereal *, doublereal *);


/* ... subq18 calls ppii, for lspoly preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ppii_((S_fp)suba1_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &
	    itcom8_1.ainf, &c_b121, &c_b121, &itcom6_1.ndeg, &wksp[
	    point_1.iwkpt1], n, &r__[1], &z__[1]);
    return 0;
} /* subq18_ */

/* Subroutine */ int subq19_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int pneu_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, integer *, doublereal *,
	    integer *, doublereal *, doublereal *), suba1_(doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *);


/* ... subq19 calls pneu, for neumann polynomial preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pneu_((S_fp)suba1_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &coef[1], &
	    itcom6_1.ndeg, &wksp[point_1.iwkpt1], n, &r__[1], &z__[1]);
    return 0;
} /* subq19_ */

/* Subroutine */ int subq20_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *u, doublereal *rhs,
	doublereal *unew)
{
    extern /* Subroutine */ int sordb_(integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *);


/* ... subq20 calls the basic lsor iterative step */


    /* Parameter adjustments */
    --unew;
    --rhs;
    --u;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    sordb_(n, &dscons_1.ndim, &itcom6_1.kblsz, &itcom6_1.kblsz, &iwksp[
	    cfactr_1.ifacti], &cblock_1.lbhb, &wksp[cfactr_1.ifactr], &coef[1]
	    , &jcoef[1], n, &itcom5_1.omega, &u[1], &rhs[1], &unew[1]);
    return 0;
} /* subq20_ */

/* Subroutine */ int subq21_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2;
    extern /* Subroutine */ int sbsl_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, integer *, doublereal *, doublereal *, doublereal *,
	     doublereal *);


/* ... subq21 calls the lssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim * iwksp[cfactr_1.ifacti + 2] + 1;
    ipt2 = iwksp[cfactr_1.ifacti + 2] + 1;
    sbsl_(n, &dscons_1.ndim, n, &itcom6_1.kblsz, &itcom6_1.kblsz, &
	    cblock_1.lbhb, &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &
	    coef[ipt1], &jcoef[ipt2], &r__[1], &z__[1], &itcom5_1.omega, &
	    wksp[point_1.iwkpt1]);
    return 0;
} /* subq21_ */

/* Subroutine */ int subq22_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *p, doublereal *r__,
	doublereal *pdp, doublereal *pldup)
{
    extern /* Subroutine */ int ssrcd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *);


/* ... subq22 calls the lssor adaption routine. */



    /* Parameter adjustments */
    --r__;
    --p;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ssrcd_(n, &dscons_1.ndim, &dscons_1.maxnz, &itcom6_1.kblsz, &iwksp[
	    cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &coef[1], &jcoef[1], n,
	    &p[1], &r__[1], &wksp[point_1.iwkpt1], pdp, pldup);
    return 0;
} /* subq22_ */

/* Subroutine */ int subq23_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int suba1_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *), subq2_(
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *), pbpii_(S_fp, S_fp, doublereal *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *);


/* ... subq23 calls pbpii, for line lspoly preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pbpii_((S_fp)suba1_, (S_fp)subq2_, &coef[1], &jcoef[1], &wksp[1], &iwksp[
	    1], &itcom8_1.ainf, &c_b121, &c_b121, &itcom6_1.ndeg, &wksp[
	    point_1.iwkpt1], n, &r__[1], &z__[1]);
    return 0;
} /* subq23_ */

/* Subroutine */ int subq24_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int suba1_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *), subq2_(
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *), pbneu_(S_fp, S_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    integer *, doublereal *, doublereal *);


/* ... subq24 calls pbneu, for line neumann polynomial */
/*     preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pbneu_((S_fp)suba1_, (S_fp)subq2_, &coef[1], &jcoef[1], &wksp[1], &iwksp[
	    1], &itcom6_1.ndeg, &wksp[point_1.iwkpt1], n, &r__[1], &z__[1]);
    return 0;
} /* subq24_ */

/* Subroutine */ int subq25_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, ipt1, ipt2;
    extern /* Subroutine */ int ibsl_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *);
    static integer nwdiag;


/* ... subq25 calls ibsl, for bic preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    ipt2 = cfactr_1.ifactr + n * iwksp[cfactr_1.ifacti + 2];
    if (itcom6_1.lvfill > 0) {
	goto L10;
    }
    nwdiag = iwksp[cfactr_1.ifacti + 2] - itcom6_1.ltrunc;
    if (cblock_1.propa) {
	ibsl_(&n, &dscons_1.ndim, &n, &itcom6_1.kblsz, &itcom6_1.kblsz, &
		cblock_1.lbhb, &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr]
		, &coef[dscons_1.ndim * nwdiag + 1], &jcoef[nwdiag + 1], &r__[
		1], &z__[1], &intern_1.ivers, &wksp[point_1.iwkpt1]);
    }
    if (! cblock_1.propa) {
	ibsl_(&n, &n, &n, &itcom6_1.kblsz, &itcom6_1.kblsz, &cblock_1.lbhb, &
		iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[ipt2], &
		jcoef[nwdiag + 1], &r__[1], &z__[1], &intern_1.ivers, &wksp[
		point_1.iwkpt1]);
    }
    return 0;
L10:
    ipt1 = cfactr_1.ifacti + cblock_1.lbhb * 3 + iwksp[cfactr_1.ifacti + 2];
    ibsl_(&n, &n, &n, &itcom6_1.kblsz, &itcom6_1.kblsz, &cblock_1.lbhb, &
	    iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[ipt2], &
	    iwksp[ipt1], &r__[1], &z__[1], &intern_1.ivers, &wksp[
	    point_1.iwkpt1]);
    return 0;
} /* subq25_ */

/* Subroutine */ int subq26_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *u, doublereal *rhs,
	doublereal *unew)
{
    extern /* Subroutine */ int sordmb_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, doublereal
	    *, doublereal *, integer *, integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *);


/* ... subq26 calls the basic multi-color sor iterative step */


    /* Parameter adjustments */
    --unew;
    --rhs;
    --u;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    sordmb_(n, &dscons_1.ndim, n, &iwksp[cblock_1.iblock], &iwksp[
	    cblock_1.lbhb], &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
	    cblock_1.ipt], &wksp[cfactr_1.ifactr], &coef[1], &iwksp[
	    cblock_1.jcnew], n, &itcom5_1.omega, &u[1], &rhs[1], &unew[1]);
    return 0;
} /* subq26_ */

/* Subroutine */ int subq27_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2;
    extern /* Subroutine */ int sbsln_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq27 calls the mssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    nwdiag = iwksp[cblock_1.iblock + 2] + iwksp[cblock_1.iblock +
	    cblock_1.ncolor * 3 + 2];
    ipt1 = dscons_1.ndim * nwdiag + 1;
    ipt2 = cblock_1.ncolor * nwdiag + cblock_1.jcnew;
    sbsln_(n, &dscons_1.ndim, n, n, &cblock_1.ncolor, &iwksp[cblock_1.nc], &
	    iwksp[cblock_1.ipt], &iwksp[cblock_1.lbhb], &iwksp[
	    cblock_1.iblock], &wksp[cfactr_1.ifactr], &coef[ipt1], &iwksp[
	    ipt2], &r__[1], &z__[1], &itcom5_1.omega, &c__0, &wksp[
	    point_1.iwkpt1]);
    return 0;
} /* subq27_ */

/* Subroutine */ int subq28_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2, nwdiag;
    extern /* Subroutine */ int sbslnt_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, integer *, doublereal *);


/* ... subq28 calls the mssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    nwdiag = iwksp[cblock_1.iblock + 2] + iwksp[cblock_1.iblock +
	    cblock_1.ncolor * 3 + 2];
    ipt1 = dscons_1.ndim * nwdiag + 1;
    ipt2 = cblock_1.ncolor * nwdiag + cblock_1.jcnew;
    sbslnt_(n, &dscons_1.ndim, n, n, &cblock_1.ncolor, &iwksp[cblock_1.nc], &
	    iwksp[cblock_1.ipt], &iwksp[cblock_1.lbhb], &iwksp[
	    cblock_1.iblock], &wksp[cfactr_1.ifactr], &coef[ipt1], &iwksp[
	    ipt2], &r__[1], &z__[1], &itcom5_1.omega, &c__0, &wksp[
	    point_1.iwkpt1]);
    return 0;
} /* subq28_ */

/* Subroutine */ int subq29_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2;
    extern /* Subroutine */ int sbsln1_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, integer *);
    static integer nwdiag;


/* ... subq29 calls the mssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    nwdiag = iwksp[cblock_1.iblock + 2] + iwksp[cblock_1.iblock +
	    cblock_1.ncolor * 3 + 2];
    ipt1 = dscons_1.ndim * nwdiag + 1;
    ipt2 = cblock_1.ncolor * nwdiag + cblock_1.jcnew;
    sbsln1_(n, &dscons_1.ndim, n, n, &cblock_1.ncolor, &iwksp[cblock_1.nc], &
	    iwksp[cblock_1.ipt], &iwksp[cblock_1.lbhb], &iwksp[
	    cblock_1.iblock], &wksp[cfactr_1.ifactr], &coef[ipt1], &iwksp[
	    ipt2], &r__[1], &z__[1], &itcom5_1.omega, &c__0);
    return 0;
} /* subq29_ */

/* Subroutine */ int subq30_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2;
    extern /* Subroutine */ int sbsln3_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, integer *);
    static integer nwdiag;


/* ... subq30 calls the mssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    nwdiag = iwksp[cblock_1.iblock + 2] + iwksp[cblock_1.iblock +
	    cblock_1.ncolor * 3 + 2];
    ipt1 = dscons_1.ndim * nwdiag + 1;
    ipt2 = cblock_1.ncolor * nwdiag + cblock_1.jcnew;
    sbsln3_(n, &dscons_1.ndim, n, n, &cblock_1.ncolor, &iwksp[cblock_1.nc], &
	    iwksp[cblock_1.ipt], &iwksp[cblock_1.lbhb], &iwksp[
	    cblock_1.iblock], &wksp[cfactr_1.ifactr], &coef[ipt1], &iwksp[
	    ipt2], &r__[1], &z__[1], &itcom5_1.omega, &c__0);
    return 0;
} /* subq30_ */

/* Subroutine */ int subq31_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2;
    extern /* Subroutine */ int sbsln2_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq31 calls the mssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    nwdiag = iwksp[cblock_1.iblock + 2] + iwksp[cblock_1.iblock +
	    cblock_1.ncolor * 3 + 2];
    ipt1 = dscons_1.ndim * nwdiag + 1;
    ipt2 = cblock_1.ncolor * nwdiag + cblock_1.jcnew;
    sbsln2_(n, &dscons_1.ndim, n, n, &cblock_1.ncolor, &iwksp[cblock_1.nc], &
	    iwksp[cblock_1.ipt], &iwksp[cblock_1.lbhb], &iwksp[
	    cblock_1.iblock], &wksp[cfactr_1.ifactr], &coef[ipt1], &iwksp[
	    ipt2], &r__[1], &z__[1], &itcom5_1.omega, &c__0, &wksp[
	    point_1.iwkpt1]);
    return 0;
} /* subq31_ */

/* Subroutine */ int subq32_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2;
    extern /* Subroutine */ int sbsln4_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq32 calls the mssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    nwdiag = iwksp[cblock_1.iblock + 2] + iwksp[cblock_1.iblock +
	    cblock_1.ncolor * 3 + 2];
    ipt1 = dscons_1.ndim * nwdiag + 1;
    ipt2 = cblock_1.ncolor * nwdiag + cblock_1.jcnew;
    sbsln4_(n, &dscons_1.ndim, n, n, &cblock_1.ncolor, &iwksp[cblock_1.nc], &
	    iwksp[cblock_1.ipt], &iwksp[cblock_1.lbhb], &iwksp[
	    cblock_1.iblock], &wksp[cfactr_1.ifactr], &coef[ipt1], &iwksp[
	    ipt2], &r__[1], &z__[1], &itcom5_1.omega, &c__0, &wksp[
	    point_1.iwkpt1]);
    return 0;
} /* subq32_ */

/* Subroutine */ int subq33_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *p, doublereal *r__,
	doublereal *pdp, doublereal *pldup)
{
    extern /* Subroutine */ int ssrcdm_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, doublereal
	    *, doublereal *, integer *, integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, doublereal *);


/* ... subq33 calls the mssor adaption routine. */



    /* Parameter adjustments */
    --r__;
    --p;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ssrcdm_(n, &dscons_1.ndim, &iwksp[cblock_1.lbhb], n, &cblock_1.ncolor, &
	    iwksp[cblock_1.nc], &iwksp[cblock_1.ipt], &iwksp[cblock_1.iblock],
	     &wksp[cfactr_1.ifactr], &coef[1], &iwksp[cblock_1.jcnew], n, &p[
	    1], &r__[1], &wksp[point_1.iwkpt1], pdp, pldup);
    return 0;
} /* subq33_ */

/* Subroutine */ int subq34_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n;
    extern /* Subroutine */ int ibsln_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq34 calls ibsln, for multi-color bic preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    nwdiag = iwksp[cblock_1.iblock + 2] + iwksp[cblock_1.iblock +
	    cblock_1.ncolor * 3 + 2] - (itcom6_1.ltrunc << 1);
    if (cblock_1.propa) {
	ibsln_(&n, &dscons_1.ndim, &n, &n, &cblock_1.ncolor, &iwksp[
		cblock_1.nc], &iwksp[cblock_1.ipt], &iwksp[cblock_1.lbhb], &
		iwksp[cblock_1.iblock], &wksp[cfactr_1.ifactr], &coef[
		dscons_1.ndim * nwdiag + 1], &iwksp[cblock_1.jcnew + nwdiag *
		cblock_1.ncolor], &r__[1], &z__[1], &intern_1.ivers, &c__0, &
		wksp[point_1.iwkpt1]);
    }
    if (! cblock_1.propa) {
	ibsln_(&n, &n, &n, &n, &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
		cblock_1.ipt], &iwksp[cblock_1.lbhb], &iwksp[cblock_1.iblock],
		 &wksp[cfactr_1.ifactr], &wksp[point_1.iwkpt2], &iwksp[
		cblock_1.jcnew + nwdiag * cblock_1.ncolor], &r__[1], &z__[1],
		&intern_1.ivers, &c__0, &wksp[point_1.iwkpt1]);
    }
    return 0;
} /* subq34_ */

/* Subroutine */ int subq35_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, nwdiag;
    extern /* Subroutine */ int ibslnt_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *);


/* ... subq35 calls ibslnt, for multi-color bic preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    nwdiag = iwksp[cblock_1.iblock + 2] + iwksp[cblock_1.iblock +
	    cblock_1.ncolor * 3 + 2] - (itcom6_1.ltrunc << 1);
    if (cblock_1.propa) {
	ibslnt_(&n, &dscons_1.ndim, &n, &n, &cblock_1.ncolor, &iwksp[
		cblock_1.nc], &iwksp[cblock_1.ipt], &iwksp[cblock_1.lbhb], &
		iwksp[cblock_1.iblock], &wksp[cfactr_1.ifactr], &coef[
		dscons_1.ndim * nwdiag + 1], &iwksp[cblock_1.jcnew + nwdiag *
		cblock_1.ncolor], &r__[1], &z__[1], &intern_1.ivers, &c__0, &
		wksp[point_1.iwkpt1]);
    }
    if (! cblock_1.propa) {
	ibslnt_(&n, &n, &n, &n, &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
		cblock_1.ipt], &iwksp[cblock_1.lbhb], &iwksp[cblock_1.iblock],
		 &wksp[cfactr_1.ifactr], &wksp[point_1.iwkpt2], &iwksp[
		cblock_1.jcnew + nwdiag * cblock_1.ncolor], &r__[1], &z__[1],
		&intern_1.ivers, &c__0, &wksp[point_1.iwkpt1]);
    }
    return 0;
} /* subq35_ */

/* Subroutine */ int subq36_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n;
    extern /* Subroutine */ int ibsln1_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq36 calls ibsln1, for multi-color bic preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    nwdiag = iwksp[cblock_1.iblock + 2] + iwksp[cblock_1.iblock +
	    cblock_1.ncolor * 3 + 2] - (itcom6_1.ltrunc << 1);
    if (cblock_1.propa) {
	ibsln1_(&n, &dscons_1.ndim, &n, &n, &cblock_1.ncolor, &iwksp[
		cblock_1.nc], &iwksp[cblock_1.ipt], &iwksp[cblock_1.lbhb], &
		iwksp[cblock_1.iblock], &wksp[cfactr_1.ifactr], &coef[
		dscons_1.ndim * nwdiag + 1], &iwksp[cblock_1.jcnew + nwdiag *
		cblock_1.ncolor], &r__[1], &z__[1], &intern_1.ivers, &c__0, &
		wksp[point_1.iwkpt1]);
    }
    if (! cblock_1.propa) {
	ibsln1_(&n, &n, &n, &n, &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
		cblock_1.ipt], &iwksp[cblock_1.lbhb], &iwksp[cblock_1.iblock],
		 &wksp[cfactr_1.ifactr], &wksp[point_1.iwkpt2], &iwksp[
		cblock_1.jcnew + nwdiag * cblock_1.ncolor], &r__[1], &z__[1],
		&intern_1.ivers, &c__0, &wksp[point_1.iwkpt1]);
    }
    return 0;
} /* subq36_ */

/* Subroutine */ int subq37_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n;
    extern /* Subroutine */ int ibsln3_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq37 calls ibsln3, for multi-color bic preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    nwdiag = iwksp[cblock_1.iblock + 2] + iwksp[cblock_1.iblock +
	    cblock_1.ncolor * 3 + 2] - (itcom6_1.ltrunc << 1);
    if (cblock_1.propa) {
	ibsln3_(&n, &dscons_1.ndim, &n, &n, &cblock_1.ncolor, &iwksp[
		cblock_1.nc], &iwksp[cblock_1.ipt], &iwksp[cblock_1.lbhb], &
		iwksp[cblock_1.iblock], &wksp[cfactr_1.ifactr], &coef[
		dscons_1.ndim * nwdiag + 1], &iwksp[cblock_1.jcnew + nwdiag *
		cblock_1.ncolor], &r__[1], &z__[1], &intern_1.ivers, &c__0, &
		wksp[point_1.iwkpt1]);
    }
    if (! cblock_1.propa) {
	ibsln3_(&n, &n, &n, &n, &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
		cblock_1.ipt], &iwksp[cblock_1.lbhb], &iwksp[cblock_1.iblock],
		 &wksp[cfactr_1.ifactr], &wksp[point_1.iwkpt2], &iwksp[
		cblock_1.jcnew + nwdiag * cblock_1.ncolor], &r__[1], &z__[1],
		&intern_1.ivers, &c__0, &wksp[point_1.iwkpt1]);
    }
    return 0;
} /* subq37_ */

/* Subroutine */ int subq38_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n;
    extern /* Subroutine */ int ibsln2_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq38 calls ibsln2, for multi-color bic preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    nwdiag = iwksp[cblock_1.iblock + 2] + iwksp[cblock_1.iblock +
	    cblock_1.ncolor * 3 + 2] - (itcom6_1.ltrunc << 1);
    if (cblock_1.propa) {
	ibsln2_(&n, &dscons_1.ndim, &n, &n, &cblock_1.ncolor, &iwksp[
		cblock_1.nc], &iwksp[cblock_1.ipt], &iwksp[cblock_1.lbhb], &
		iwksp[cblock_1.iblock], &wksp[cfactr_1.ifactr], &coef[
		dscons_1.ndim * nwdiag + 1], &iwksp[cblock_1.jcnew + nwdiag *
		cblock_1.ncolor], &r__[1], &z__[1], &intern_1.ivers, &c__0, &
		wksp[point_1.iwkpt1]);
    }
    if (! cblock_1.propa) {
	ibsln2_(&n, &n, &n, &n, &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
		cblock_1.ipt], &iwksp[cblock_1.lbhb], &iwksp[cblock_1.iblock],
		 &wksp[cfactr_1.ifactr], &wksp[point_1.iwkpt2], &iwksp[
		cblock_1.jcnew + nwdiag * cblock_1.ncolor], &r__[1], &z__[1],
		&intern_1.ivers, &c__0, &wksp[point_1.iwkpt1]);
    }
    return 0;
} /* subq38_ */

/* Subroutine */ int subq39_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n;
    extern /* Subroutine */ int ibsln4_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq39 calls ibsln4, for multi-color bic preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    nwdiag = iwksp[cblock_1.iblock + 2] + iwksp[cblock_1.iblock +
	    cblock_1.ncolor * 3 + 2] - (itcom6_1.ltrunc << 1);
    if (cblock_1.propa) {
	ibsln4_(&n, &dscons_1.ndim, &n, &n, &cblock_1.ncolor, &iwksp[
		cblock_1.nc], &iwksp[cblock_1.ipt], &iwksp[cblock_1.lbhb], &
		iwksp[cblock_1.iblock], &wksp[cfactr_1.ifactr], &coef[
		dscons_1.ndim * nwdiag + 1], &iwksp[cblock_1.jcnew + nwdiag *
		cblock_1.ncolor], &r__[1], &z__[1], &intern_1.ivers, &c__0, &
		wksp[point_1.iwkpt1]);
    }
    if (! cblock_1.propa) {
	ibsln4_(&n, &n, &n, &n, &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
		cblock_1.ipt], &iwksp[cblock_1.lbhb], &iwksp[cblock_1.iblock],
		 &wksp[cfactr_1.ifactr], &wksp[point_1.iwkpt2], &iwksp[
		cblock_1.jcnew + nwdiag * cblock_1.ncolor], &r__[1], &z__[1],
		&intern_1.ivers, &c__0, &wksp[point_1.iwkpt1]);
    }
    return 0;
} /* subq39_ */

/* Subroutine */ int subq40_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *u, doublereal *rhs,
	doublereal *unew)
{
    extern /* Subroutine */ int sordn_(integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, integer *);
    static integer maxtp1;


/* ... subq40 calls the basic sor iterative step */


    /* Parameter adjustments */
    --unew;
    --rhs;
    --u;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    maxtp1 = intern_1.maxt + 1;
    sordn_(&dscons_1.ndim, n, &intern_1.maxt, &intern_1.maxb, &jcoef[2], &
	    jcoef[intern_1.maxt + 2], &coef[1], &coef[dscons_1.ndim + 1], &
	    coef[maxtp1 * dscons_1.ndim + 1], &itcom5_1.omega, &
	    intern_1.irwise, &u[1], &rhs[1], &unew[1], &iwksp[point_1.iwkpt1])
	    ;
    return 0;
} /* subq40_ */

/* Subroutine */ int subq41_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int srsn_(integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *);
    static integer maxtp1;


/* ... subq41 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    maxtp1 = intern_1.maxt + 1;
    srsn_(&dscons_1.ndim, n, &intern_1.maxt, &intern_1.maxb, &jcoef[2], &
	    jcoef[intern_1.maxt + 2], &coef[1], &coef[dscons_1.ndim + 1], &
	    coef[dscons_1.ndim * maxtp1 + 1], &itcom5_1.omega, &
	    intern_1.irwise, &iwksp[point_1.iwkpt2], &r__[1], &z__[1]);
    return 0;
} /* subq41_ */

/* Subroutine */ int subq42_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int srsnt_(integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *);
    static integer maxtp1;


/* ... subq42 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    maxtp1 = intern_1.maxt + 1;
    srsnt_(&dscons_1.ndim, n, &intern_1.maxt, &intern_1.maxb, &jcoef[2], &
	    jcoef[intern_1.maxt + 2], &coef[1], &coef[dscons_1.ndim + 1], &
	    coef[dscons_1.ndim * maxtp1 + 1], &itcom5_1.omega, &
	    intern_1.irwise, &iwksp[point_1.iwkpt2], &r__[1], &z__[1]);
    return 0;
} /* subq42_ */

/* Subroutine */ int subq43_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int srsn1_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *);
    static integer maxtp1;


/* ... subq43 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    maxtp1 = intern_1.maxt + 1;
    srsn1_(&dscons_1.ndim, n, &intern_1.maxb, &jcoef[intern_1.maxt + 2], &
	    coef[1], &coef[dscons_1.ndim * maxtp1 + 1], &itcom5_1.omega, &
	    intern_1.irwise, &iwksp[point_1.iwkpt2], &r__[1], &z__[1]);
    return 0;
} /* subq43_ */

/* Subroutine */ int subq44_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int srsn3_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *);
    static integer maxtp1;


/* ... subq44 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    maxtp1 = intern_1.maxt + 1;
    srsn3_(&dscons_1.ndim, n, &intern_1.maxb, &jcoef[intern_1.maxt + 2], &
	    coef[1], &coef[dscons_1.ndim * maxtp1 + 1], &itcom5_1.omega, &
	    intern_1.irwise, &iwksp[point_1.iwkpt2], &r__[1], &z__[1]);
    return 0;
} /* subq44_ */

/* Subroutine */ int subq45_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int srsn2_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *);


/* ... subq45 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    srsn2_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &coef[1], &coef[
	    dscons_1.ndim + 1], &itcom5_1.omega, &intern_1.irwise, &iwksp[
	    point_1.iwkpt2], &r__[1], &z__[1]);
    return 0;
} /* subq45_ */

/* Subroutine */ int subq46_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int srsn4_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *);


/* ... subq46 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    srsn4_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &coef[1], &coef[
	    dscons_1.ndim + 1], &itcom5_1.omega, &intern_1.irwise, &iwksp[
	    point_1.iwkpt2], &r__[1], &z__[1]);
    return 0;
} /* subq46_ */

/* Subroutine */ int subq47_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *p, doublereal *r__,
	doublereal *pdp, doublereal *pldup)
{
    static integer maxtp1;
    extern /* Subroutine */ int ssordn_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *);


/* ... subq47 calls the ssor adaption routine. */



    /* Parameter adjustments */
    --r__;
    --p;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    maxtp1 = intern_1.maxt + 1;
    ssordn_(&dscons_1.ndim, &intern_1.maxt, &intern_1.maxb, &jcoef[2], &jcoef[
	    intern_1.maxt + 2], &coef[1], &coef[dscons_1.ndim + 1], &coef[
	    dscons_1.ndim * maxtp1 + 1], n, &p[1], &r__[1], &wksp[
	    point_1.iwkpt1], pdp, pldup);
    return 0;
} /* subq47_ */

/* Subroutine */ int subq48_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n;
    extern /* Subroutine */ int icsn_(integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *, integer *, doublereal *,
	    doublereal *);
    static integer maxtp1;


/* ... subq48 calls icsn, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    maxtp1 = intern_1.maxt + 1;
    if (cblock_1.propa) {
	icsn_(&dscons_1.ndim, &n, &intern_1.maxt, &intern_1.maxb, &jcoef[2], &
		jcoef[intern_1.maxt + 2], &wksp[cfactr_1.ifactr], &coef[
		dscons_1.ndim + 1], &coef[dscons_1.ndim * maxtp1 + 1], &c__1,
		&intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	icsn_(&n, &n, &intern_1.maxt, &intern_1.maxb, &iwksp[cfactr_1.ifacti
		+ 1], &iwksp[cfactr_1.ifacti + intern_1.maxt + 1], &wksp[
		cfactr_1.ifactr], &wksp[cfactr_1.ifactr + n], &wksp[
		cfactr_1.ifactr + n * maxtp1], &c__0, &intern_1.irwise, &
		iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    return 0;
} /* subq48_ */

/* Subroutine */ int subq49_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n;
    extern /* Subroutine */ int icsnt_(integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *, integer *, doublereal *,
	    doublereal *);
    static integer maxtp1;


/* ... subq49 calls icsnt, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    maxtp1 = intern_1.maxt + 1;
    if (cblock_1.propa) {
	icsnt_(&dscons_1.ndim, &n, &intern_1.maxt, &intern_1.maxb, &jcoef[2],
		&jcoef[intern_1.maxt + 2], &wksp[cfactr_1.ifactr], &coef[
		dscons_1.ndim + 1], &coef[dscons_1.ndim * maxtp1 + 1], &c__1,
		&intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	icsnt_(&n, &n, &intern_1.maxt, &intern_1.maxb, &iwksp[cfactr_1.ifacti
		+ 1], &iwksp[cfactr_1.ifacti + intern_1.maxt + 1], &wksp[
		cfactr_1.ifactr], &wksp[cfactr_1.ifactr + n], &wksp[
		cfactr_1.ifactr + n * maxtp1], &c__0, &intern_1.irwise, &
		iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    return 0;
} /* subq49_ */

/* Subroutine */ int subq50_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n;
    extern /* Subroutine */ int icsn1_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *, doublereal *);
    static integer maxtp1;


/* ... subq50 calls icsn1, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    maxtp1 = intern_1.maxt + 1;
    if (cblock_1.propa) {
	icsn1_(&dscons_1.ndim, &n, &intern_1.maxb, &jcoef[intern_1.maxt + 2],
		&wksp[cfactr_1.ifactr], &coef[dscons_1.ndim * maxtp1 + 1], &
		c__1, &intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[
		1]);
    }
    if (! cblock_1.propa) {
	icsn1_(&n, &n, &intern_1.maxb, &iwksp[cfactr_1.ifacti + intern_1.maxt
		+ 1], &wksp[cfactr_1.ifactr], &wksp[cfactr_1.ifactr + n *
		maxtp1], &c__0, &intern_1.irwise, &iwksp[point_1.iwkpt1], &
		r__[1], &z__[1]);
    }
    return 0;
} /* subq50_ */

/* Subroutine */ int subq51_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n;
    extern /* Subroutine */ int icsn3_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *, doublereal *);
    static integer maxtp1;


/* ... subq51 calls icsn3, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    maxtp1 = intern_1.maxt + 1;
    if (cblock_1.propa) {
	icsn3_(&dscons_1.ndim, &n, &intern_1.maxb, &jcoef[intern_1.maxt + 2],
		&wksp[cfactr_1.ifactr], &coef[dscons_1.ndim * maxtp1 + 1], &
		c__1, &intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[
		1]);
    }
    if (! cblock_1.propa) {
	icsn3_(&n, &n, &intern_1.maxb, &iwksp[cfactr_1.ifacti + intern_1.maxt
		+ 1], &wksp[cfactr_1.ifactr], &wksp[cfactr_1.ifactr + n *
		maxtp1], &c__0, &intern_1.irwise, &iwksp[point_1.iwkpt1], &
		r__[1], &z__[1]);
    }
    return 0;
} /* subq51_ */

/* Subroutine */ int subq52_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int icsn2_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *, doublereal *);


/* ... subq52 calls icsn2, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    if (cblock_1.propa) {
	icsn2_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &wksp[
		cfactr_1.ifactr], &coef[dscons_1.ndim + 1], &c__1, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	icsn2_(n, n, &intern_1.maxt, &iwksp[cfactr_1.ifacti + 1], &wksp[
		cfactr_1.ifactr], &wksp[cfactr_1.ifactr + *n], &c__0, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    return 0;
} /* subq52_ */

/* Subroutine */ int subq53_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int icsn4_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *, doublereal *);


/* ... subq53 calls icsn4, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    if (cblock_1.propa) {
	icsn4_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[2], &wksp[
		cfactr_1.ifactr], &coef[dscons_1.ndim + 1], &c__1, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	icsn4_(n, n, &intern_1.maxt, &iwksp[cfactr_1.ifacti + 1], &wksp[
		cfactr_1.ifactr], &wksp[cfactr_1.ifactr + *n], &c__0, &
		intern_1.irwise, &iwksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    return 0;
} /* subq53_ */

/* Subroutine */ int subq54_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int ppii_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, doublereal *, doublereal *,
	     integer *, doublereal *, integer *, doublereal *, doublereal *),
	    suba4_(doublereal *, integer *, doublereal *, integer *, integer *
	    , doublereal *, doublereal *);


/* ... subq54 calls ppii, for lspoly preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ppii_((S_fp)suba4_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &
	    itcom8_1.ainf, &c_b121, &c_b121, &itcom6_1.ndeg, &wksp[
	    point_1.iwkpt1], n, &r__[1], &z__[1]);
    return 0;
} /* subq54_ */

/* Subroutine */ int subq55_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int ppii_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, doublereal *, doublereal *,
	     integer *, doublereal *, integer *, doublereal *, doublereal *),
	    suba5_(doublereal *, integer *, doublereal *, integer *, integer *
	    , doublereal *, doublereal *);


/* ... subq55 calls ppii, for lspoly preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ppii_((S_fp)suba5_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &
	    itcom8_1.ainf, &c_b121, &c_b121, &itcom6_1.ndeg, &wksp[
	    point_1.iwkpt1], n, &r__[1], &z__[1]);
    return 0;
} /* subq55_ */

/* Subroutine */ int subq56_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int pneu_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, integer *, doublereal *,
	    integer *, doublereal *, doublereal *), suba4_(doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *);


/* ... subq56 calls pneu, for neumann polynomial preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pneu_((S_fp)suba4_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &coef[1], &
	    itcom6_1.ndeg, &wksp[point_1.iwkpt1], n, &r__[1], &z__[1]);
    return 0;
} /* subq56_ */

/* Subroutine */ int subq57_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int pneu_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, integer *, doublereal *,
	    integer *, doublereal *, doublereal *), suba5_(doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *);


/* ... subq57 calls pneu, for neumann polynomial preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pneu_((S_fp)suba5_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &coef[1], &
	    itcom6_1.ndeg, &wksp[point_1.iwkpt1], n, &r__[1], &z__[1]);
    return 0;
} /* subq57_ */

/* Subroutine */ int subq58_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *u, doublereal *rhs,
	doublereal *unew)
{
    extern /* Subroutine */ int sordnb_(integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *);


/* ... subq58 calls the basic lsor iterative step */


    /* Parameter adjustments */
    --unew;
    --rhs;
    --u;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    sordnb_(n, &dscons_1.ndim, &itcom6_1.kblsz, &itcom6_1.kblsz, &iwksp[
	    cfactr_1.ifacti], &cblock_1.lbhb, &wksp[cfactr_1.ifactr], &coef[1]
	    , &jcoef[1], n, &itcom5_1.omega, &u[1], &rhs[1], &unew[1]);
    return 0;
} /* subq58_ */

/* Subroutine */ int subq59_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2, idumb[3];
    extern /* Subroutine */ int sbsln_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq59 calls the lssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    idumb[0] = itcom6_1.kblsz;
    idumb[1] = 1;
    idumb[2] = cblock_1.lbhb;
    nwdiag = iwksp[cfactr_1.ifacti + 2] + iwksp[cfactr_1.ifacti + 5];
    ipt1 = dscons_1.ndim * nwdiag + 1;
    ipt2 = nwdiag + 1;
    sbsln_(n, &dscons_1.ndim, n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &
	    idumb[2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &coef[
	    ipt1], &jcoef[ipt2], &r__[1], &z__[1], &itcom5_1.omega, &c__1, &
	    wksp[point_1.iwkpt1]);
    return 0;
} /* subq59_ */

/* Subroutine */ int subq60_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2, idumb[3], nwdiag;
    extern /* Subroutine */ int sbslnt_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, integer *, doublereal *);


/* ... subq60 calls the lssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    idumb[0] = itcom6_1.kblsz;
    idumb[1] = 1;
    idumb[2] = cblock_1.lbhb;
    nwdiag = iwksp[cfactr_1.ifacti + 2] + iwksp[cfactr_1.ifacti + 5];
    ipt1 = dscons_1.ndim * nwdiag + 1;
    ipt2 = nwdiag + 1;
    sbslnt_(n, &dscons_1.ndim, n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &
	    idumb[2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &coef[
	    ipt1], &jcoef[ipt2], &r__[1], &z__[1], &itcom5_1.omega, &c__1, &
	    wksp[point_1.iwkpt1]);
    return 0;
} /* subq60_ */

/* Subroutine */ int subq61_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2, idumb[3];
    extern /* Subroutine */ int sbsln1_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, integer *);
    static integer nwdiag;


/* ... subq61 calls the lssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    idumb[0] = itcom6_1.kblsz;
    idumb[1] = 1;
    idumb[2] = cblock_1.lbhb;
    nwdiag = iwksp[cfactr_1.ifacti + 2] + iwksp[cfactr_1.ifacti + 5];
    ipt1 = dscons_1.ndim * nwdiag + 1;
    ipt2 = nwdiag + 1;
    sbsln1_(n, &dscons_1.ndim, n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &
	    idumb[2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &coef[
	    ipt1], &jcoef[ipt2], &r__[1], &z__[1], &itcom5_1.omega, &c__1);
    return 0;
} /* subq61_ */

/* Subroutine */ int subq62_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2, idumb[3];
    extern /* Subroutine */ int sbsln3_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, integer *);
    static integer nwdiag;


/* ... subq62 calls the lssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    idumb[0] = itcom6_1.kblsz;
    idumb[1] = 1;
    idumb[2] = cblock_1.lbhb;
    nwdiag = iwksp[cfactr_1.ifacti + 2] + iwksp[cfactr_1.ifacti + 5];
    ipt1 = dscons_1.ndim * nwdiag + 1;
    ipt2 = nwdiag + 1;
    sbsln3_(n, &dscons_1.ndim, n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &
	    idumb[2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &coef[
	    ipt1], &jcoef[ipt2], &r__[1], &z__[1], &itcom5_1.omega, &c__1);
    return 0;
} /* subq62_ */

/* Subroutine */ int subq63_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2, idumb[3];
    extern /* Subroutine */ int sbsln2_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq63 calls the lssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    idumb[0] = itcom6_1.kblsz;
    idumb[1] = 1;
    idumb[2] = cblock_1.lbhb;
    nwdiag = iwksp[cfactr_1.ifacti + 2] + iwksp[cfactr_1.ifacti + 5];
    ipt1 = dscons_1.ndim * nwdiag + 1;
    ipt2 = nwdiag + 1;
    sbsln2_(n, &dscons_1.ndim, n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &
	    idumb[2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &coef[
	    ipt1], &jcoef[ipt2], &r__[1], &z__[1], &itcom5_1.omega, &c__1, &
	    wksp[point_1.iwkpt1]);
    return 0;
} /* subq63_ */

/* Subroutine */ int subq64_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2, idumb[3];
    extern /* Subroutine */ int sbsln4_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq64 calls the lssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    idumb[0] = itcom6_1.kblsz;
    idumb[1] = 1;
    idumb[2] = cblock_1.lbhb;
    nwdiag = iwksp[cfactr_1.ifacti + 2] + iwksp[cfactr_1.ifacti + 5];
    ipt1 = dscons_1.ndim * nwdiag + 1;
    ipt2 = nwdiag + 1;
    sbsln4_(n, &dscons_1.ndim, n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &
	    idumb[2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &coef[
	    ipt1], &jcoef[ipt2], &r__[1], &z__[1], &itcom5_1.omega, &c__1, &
	    wksp[point_1.iwkpt1]);
    return 0;
} /* subq64_ */

/* Subroutine */ int subq65_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *p, doublereal *r__,
	doublereal *pdp, doublereal *pldup)
{
    extern /* Subroutine */ int ssrcdn_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *);


/* ... subq65 calls the lssor adaption routine. */



    /* Parameter adjustments */
    --r__;
    --p;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ssrcdn_(n, &dscons_1.ndim, &cblock_1.lbhb, &itcom6_1.kblsz, &iwksp[
	    cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &coef[1], &jcoef[1], n,
	    &p[1], &r__[1], &wksp[point_1.iwkpt1], pdp, pldup);
    return 0;
} /* subq65_ */

/* Subroutine */ int subq66_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int suba4_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *), subq2_(
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *), pbpii_(S_fp, S_fp, doublereal *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *);


/* ... subq66 calls pbpii, for line lspoly preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pbpii_((S_fp)suba4_, (S_fp)subq2_, &coef[1], &jcoef[1], &wksp[1], &iwksp[
	    1], &itcom8_1.ainf, &c_b121, &c_b121, &itcom6_1.ndeg, &wksp[
	    point_1.iwkpt1], n, &r__[1], &z__[1]);
    return 0;
} /* subq66_ */

/* Subroutine */ int subq67_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int suba5_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *), subq3_(
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *), pbpii_(S_fp, S_fp, doublereal *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *);


/* ... subq67 calls pbpii, for line lspoly preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pbpii_((S_fp)suba5_, (S_fp)subq3_, &coef[1], &jcoef[1], &wksp[1], &iwksp[
	    1], &itcom8_1.ainf, &c_b121, &c_b121, &itcom6_1.ndeg, &wksp[
	    point_1.iwkpt1], n, &r__[1], &z__[1]);
    return 0;
} /* subq67_ */

/* Subroutine */ int subq68_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int suba4_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *), subq2_(
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *), pbneu_(S_fp, S_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    integer *, doublereal *, doublereal *);


/* ... subq68 calls pbneu, for line neumann polynomial */
/*     preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pbneu_((S_fp)suba4_, (S_fp)subq2_, &coef[1], &jcoef[1], &wksp[1], &iwksp[
	    1], &itcom6_1.ndeg, &wksp[point_1.iwkpt1], n, &r__[1], &z__[1]);
    return 0;
} /* subq68_ */

/* Subroutine */ int subq69_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int suba5_(doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *), subq3_(
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *), pbneu_(S_fp, S_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    integer *, doublereal *, doublereal *);


/* ... subq69 calls pbneu, for line neumann polynomial */
/*     preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pbneu_((S_fp)suba5_, (S_fp)subq3_, &coef[1], &jcoef[1], &wksp[1], &iwksp[
	    1], &itcom6_1.ndeg, &wksp[point_1.iwkpt1], n, &r__[1], &z__[1]);
    return 0;
} /* subq69_ */

/* Subroutine */ int subq70_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, ipt1, ipt2, idumb[3];
    extern /* Subroutine */ int ibsln_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *);
    static integer nwnew, nwdiag;


/* ... subq70 calls ibsln, for bic preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    idumb[0] = itcom6_1.kblsz;
    idumb[1] = 1;
    idumb[2] = cblock_1.lbhb;

    n = *nn;
    nwnew = iwksp[cfactr_1.ifacti + 2] + iwksp[cfactr_1.ifacti + 5];
    ipt2 = cfactr_1.ifactr + n * nwnew;
    if (itcom6_1.lvfill > 0) {
	goto L10;
    }
    nwdiag = nwnew - (itcom6_1.ltrunc << 1);
    if (cblock_1.propa) {
	ibsln_(&n, &dscons_1.ndim, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[
		1], &idumb[2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr]
		, &coef[dscons_1.ndim * nwdiag + 1], &jcoef[nwdiag + 1], &r__[
		1], &z__[1], &intern_1.ivers, &c__1, &wksp[point_1.iwkpt1]);
    }
    if (! cblock_1.propa) {
	ibsln_(&n, &n, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &idumb[2]
		, &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[ipt2]
		, &jcoef[nwdiag + 1], &r__[1], &z__[1], &intern_1.ivers, &
		c__1, &wksp[point_1.iwkpt1]);
    }
    return 0;
L10:
    ipt1 = cfactr_1.ifacti + cblock_1.lbhb * 3 + nwnew;
    ibsln_(&n, &n, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &idumb[2], &
	    iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[ipt2], &
	    iwksp[ipt1], &r__[1], &z__[1], &intern_1.ivers, &c__1, &wksp[
	    point_1.iwkpt1]);
    return 0;
} /* subq70_ */

/* Subroutine */ int subq71_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, ipt1, ipt2, idumb[3], nwnew, nwdiag;
    extern /* Subroutine */ int ibslnt_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *);


/* ... subq71 calls ibslnt, for bic preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    idumb[0] = itcom6_1.kblsz;
    idumb[1] = 1;
    idumb[2] = cblock_1.lbhb;

    n = *nn;
    nwnew = iwksp[cfactr_1.ifacti + 2] + iwksp[cfactr_1.ifacti + 5];
    ipt2 = cfactr_1.ifactr + n * nwnew;
    if (itcom6_1.lvfill > 0) {
	goto L10;
    }
    nwdiag = nwnew - (itcom6_1.ltrunc << 1);
    if (cblock_1.propa) {
	ibslnt_(&n, &dscons_1.ndim, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[
		1], &idumb[2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr]
		, &coef[dscons_1.ndim * nwdiag + 1], &jcoef[nwdiag + 1], &r__[
		1], &z__[1], &intern_1.ivers, &c__1, &wksp[point_1.iwkpt1]);
    }
    if (! cblock_1.propa) {
	ibslnt_(&n, &n, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &idumb[
		2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[
		point_1.iwkpt2], &jcoef[nwdiag + 1], &r__[1], &z__[1], &
		intern_1.ivers, &c__1, &wksp[point_1.iwkpt1]);
    }
    return 0;
L10:
    ipt1 = cfactr_1.ifacti + cblock_1.lbhb * 3 + nwnew;
    ibslnt_(&n, &n, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &idumb[2], &
	    iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[ipt2], &
	    iwksp[ipt1], &r__[1], &z__[1], &intern_1.ivers, &c__1, &wksp[
	    point_1.iwkpt1]);
    return 0;
} /* subq71_ */

/* Subroutine */ int subq72_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, ipt1, ipt2, idumb[3], nwnew;
    extern /* Subroutine */ int ibsln1_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq72 calls ibsln1, for bic preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    idumb[0] = itcom6_1.kblsz;
    idumb[1] = 1;
    idumb[2] = cblock_1.lbhb;

    n = *nn;
    nwnew = iwksp[cfactr_1.ifacti + 2] + iwksp[cfactr_1.ifacti + 5];
    ipt2 = cfactr_1.ifactr + n * nwnew;
    if (itcom6_1.lvfill > 0) {
	goto L10;
    }
    nwdiag = nwnew - (itcom6_1.ltrunc << 1);
    if (cblock_1.propa) {
	ibsln1_(&n, &dscons_1.ndim, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[
		1], &idumb[2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr]
		, &coef[dscons_1.ndim * nwdiag + 1], &jcoef[nwdiag + 1], &r__[
		1], &z__[1], &intern_1.ivers, &c__1, &wksp[point_1.iwkpt1]);
    }
    if (! cblock_1.propa) {
	ibsln1_(&n, &n, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &idumb[
		2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[
		point_1.iwkpt2], &jcoef[nwdiag + 1], &r__[1], &z__[1], &
		intern_1.ivers, &c__1, &wksp[point_1.iwkpt1]);
    }
    return 0;
L10:
    ipt1 = cfactr_1.ifacti + cblock_1.lbhb * 3 + nwnew;
    ibsln1_(&n, &n, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &idumb[2], &
	    iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[ipt2], &
	    iwksp[ipt1], &r__[1], &z__[1], &intern_1.ivers, &c__1, &wksp[
	    point_1.iwkpt1]);
    return 0;
} /* subq72_ */

/* Subroutine */ int subq73_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, ipt1, ipt2, idumb[3], nwnew;
    extern /* Subroutine */ int ibsln3_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq73 calls ibsln3, for bic preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    idumb[0] = itcom6_1.kblsz;
    idumb[1] = 1;
    idumb[2] = cblock_1.lbhb;

    n = *nn;
    nwnew = iwksp[cfactr_1.ifacti + 2] + iwksp[cfactr_1.ifacti + 5];
    ipt2 = cfactr_1.ifactr + n * nwnew;
    if (itcom6_1.lvfill > 0) {
	goto L10;
    }
    nwdiag = nwnew - (itcom6_1.ltrunc << 1);
    if (cblock_1.propa) {
	ibsln3_(&n, &dscons_1.ndim, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[
		1], &idumb[2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr]
		, &coef[dscons_1.ndim * nwdiag + 1], &jcoef[nwdiag + 1], &r__[
		1], &z__[1], &intern_1.ivers, &c__1, &wksp[point_1.iwkpt1]);
    }
    if (! cblock_1.propa) {
	ibsln3_(&n, &n, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &idumb[
		2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[
		point_1.iwkpt2], &jcoef[nwdiag + 1], &r__[1], &z__[1], &
		intern_1.ivers, &c__1, &wksp[point_1.iwkpt1]);
    }
    return 0;
L10:
    ipt1 = cfactr_1.ifacti + cblock_1.lbhb * 3 + nwnew;
    ibsln3_(&n, &n, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &idumb[2], &
	    iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[ipt2], &
	    iwksp[ipt1], &r__[1], &z__[1], &intern_1.ivers, &c__1, &wksp[
	    point_1.iwkpt1]);
    return 0;
} /* subq73_ */

/* Subroutine */ int subq74_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, ipt1, ipt2, idumb[3], nwnew;
    extern /* Subroutine */ int ibsln2_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq74 calls ibsln2, for bic preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    idumb[0] = itcom6_1.kblsz;
    idumb[1] = 1;
    idumb[2] = cblock_1.lbhb;

    n = *nn;
    nwnew = iwksp[cfactr_1.ifacti + 2] + iwksp[cfactr_1.ifacti + 5];
    ipt2 = cfactr_1.ifactr + n * nwnew;
    if (itcom6_1.lvfill > 0) {
	goto L10;
    }
    nwdiag = nwnew - (itcom6_1.ltrunc << 1);
    if (cblock_1.propa) {
	ibsln2_(&n, &dscons_1.ndim, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[
		1], &idumb[2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr]
		, &coef[dscons_1.ndim * nwdiag + 1], &jcoef[nwdiag + 1], &r__[
		1], &z__[1], &intern_1.ivers, &c__1, &wksp[point_1.iwkpt1]);
    }
    if (! cblock_1.propa) {
	ibsln2_(&n, &n, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &idumb[
		2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[
		point_1.iwkpt2], &jcoef[nwdiag + 1], &r__[1], &z__[1], &
		intern_1.ivers, &c__1, &wksp[point_1.iwkpt1]);
    }
    return 0;
L10:
    ipt1 = cfactr_1.ifacti + cblock_1.lbhb * 3 + nwnew;
    ibsln2_(&n, &n, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &idumb[2], &
	    iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[ipt2], &
	    iwksp[ipt1], &r__[1], &z__[1], &intern_1.ivers, &c__1, &wksp[
	    point_1.iwkpt1]);
    return 0;
} /* subq74_ */

/* Subroutine */ int subq75_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, ipt1, ipt2, idumb[3], nwnew;
    extern /* Subroutine */ int ibsln4_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, integer *, doublereal *);
    static integer nwdiag;


/* ... subq75 calls ibsln4, for bic preconditioning. */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    idumb[0] = itcom6_1.kblsz;
    idumb[1] = 1;
    idumb[2] = cblock_1.lbhb;

    n = *nn;
    nwnew = iwksp[cfactr_1.ifacti + 2] + iwksp[cfactr_1.ifacti + 5];
    ipt2 = cfactr_1.ifactr + n * nwnew;
    if (itcom6_1.lvfill > 0) {
	goto L10;
    }
    nwdiag = nwnew - (itcom6_1.ltrunc << 1);
    if (cblock_1.propa) {
	ibsln4_(&n, &dscons_1.ndim, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[
		1], &idumb[2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr]
		, &coef[dscons_1.ndim * nwdiag + 1], &jcoef[nwdiag + 1], &r__[
		1], &z__[1], &intern_1.ivers, &c__1, &wksp[point_1.iwkpt1]);
    }
    if (! cblock_1.propa) {
	ibsln4_(&n, &n, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &idumb[
		2], &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[
		point_1.iwkpt2], &jcoef[nwdiag + 1], &r__[1], &z__[1], &
		intern_1.ivers, &c__1, &wksp[point_1.iwkpt1]);
    }
    return 0;
L10:
    ipt1 = cfactr_1.ifacti + cblock_1.lbhb * 3 + nwnew;
    ibsln4_(&n, &n, &n, &itcom6_1.kblsz, &c__1, idumb, &idumb[1], &idumb[2], &
	    iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &wksp[ipt2], &
	    iwksp[ipt1], &r__[1], &z__[1], &intern_1.ivers, &c__1, &wksp[
	    point_1.iwkpt1]);
    return 0;
} /* subq75_ */

/* Subroutine */ int subq76_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, nb, nr, nbig;
    extern /* Subroutine */ int bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *);


/* ... subq76 calls bdsol, for rs preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    nr = iwksp[cblock_1.nc];
    nb = iwksp[cblock_1.nc + 1];
    nbig = nr + nb;
    bdsol_(&nbig, &n, &n, &intern_1.ndt, &intern_1.ndb, &wksp[cfactr_1.ifactr]
	    , &r__[1], &z__[1], &c__1);
    return 0;
} /* subq76_ */

/* Subroutine */ int subq77_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, nb, nr, nbig;
    extern /* Subroutine */ int bdsolt_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *);


/* ... subq77 calls bdsolt, for rs preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    nr = iwksp[cblock_1.nc];
    nb = iwksp[cblock_1.nc + 1];
    nbig = nr + nb;
    bdsolt_(&nbig, &n, &n, &intern_1.ndt, &intern_1.ndb, &wksp[
	    cfactr_1.ifactr], &r__[1], &z__[1]);
    return 0;
} /* subq77_ */

/* Subroutine */ int subq78_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *u, doublereal *rhs,
	doublereal *unew)
{
    static integer ip1, ip2;
    extern /* Subroutine */ int sorp_(integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *);


/* ... subq78 calls the basic sor iterative step */


    /* Parameter adjustments */
    --unew;
    --rhs;
    --u;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    sorp_(&dscons_1.ndim, n, &intern_1.maxt, &intern_1.maxb, &jcoef[ip1], &
	    jcoef[ip2], &coef[1], &coef[ip1], &coef[ip2], &itcom5_1.omega, &u[
	    1], &rhs[1], &unew[1]);
    return 0;
} /* subq78_ */

/* Subroutine */ int subq79_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ip1, ip2;
    extern /* Subroutine */ int srsp_(integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *);


/* ... subq79 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    srsp_(&dscons_1.ndim, n, &intern_1.maxt, &intern_1.maxb, &jcoef[ip1], &
	    jcoef[ip2], &coef[1], &coef[ip1], &coef[ip2], &itcom5_1.omega, &
	    r__[1], &z__[1]);
    return 0;
} /* subq79_ */

/* Subroutine */ int subq80_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ip1, ip2;
    extern /* Subroutine */ int srsntp_(integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *);


/* ... subq80 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    srsntp_(&dscons_1.ndim, n, &intern_1.maxt, &intern_1.maxb, &jcoef[ip1], &
	    jcoef[ip2], &coef[1], &coef[ip1], &coef[ip2], &itcom5_1.omega, &
	    r__[1], &z__[1]);
    return 0;
} /* subq80_ */

/* Subroutine */ int subq81_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ip2;
    extern /* Subroutine */ int srsp1_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *);


/* ... subq81 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    srsp1_(&dscons_1.ndim, n, &intern_1.maxb, &jcoef[ip2], &coef[1], &coef[
	    ip2], &itcom5_1.omega, &r__[1], &z__[1]);
    return 0;
} /* subq81_ */

/* Subroutine */ int subq82_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ip2;
    extern /* Subroutine */ int srsp3_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *);


/* ... subq82 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    srsp3_(&dscons_1.ndim, n, &intern_1.maxb, &jcoef[ip2], &coef[1], &coef[
	    ip2], &itcom5_1.omega, &r__[1], &z__[1]);
    return 0;
} /* subq82_ */

/* Subroutine */ int subq83_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ip1;
    extern /* Subroutine */ int srsp2_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *);


/* ... subq83 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ip1 = dscons_1.ndim + 1;
    srsp2_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[ip1], &coef[1], &coef[
	    ip1], &itcom5_1.omega, &r__[1], &z__[1]);
    return 0;
} /* subq83_ */

/* Subroutine */ int subq84_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ip1;
    extern /* Subroutine */ int srsp4_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *);


/* ... subq84 calls the ssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ip1 = dscons_1.ndim + 1;
    srsp4_(&dscons_1.ndim, n, &intern_1.maxt, &jcoef[ip1], &coef[1], &coef[
	    ip1], &itcom5_1.omega, &r__[1], &z__[1]);
    return 0;
} /* subq84_ */

/* Subroutine */ int subq85_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *p, doublereal *r__,
	doublereal *pdp, doublereal *pldup)
{
    static integer ip1, ip2;
    extern /* Subroutine */ int ssorp_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, doublereal *), ssorpn_(integer *,
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, doublereal *);


/* ... subq85 calls the ssor adaption routine. */



    /* Parameter adjustments */
    --r__;
    --p;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    if (itcom6_1.isymm == 0) {
	ssorp_(&dscons_1.ndim, &intern_1.maxt, &jcoef[ip1], &coef[1], &coef[
		ip1], n, &p[1], &r__[1], &wksp[point_1.iwkpt1], pdp, pldup);
    }
    if (itcom6_1.isymm != 0) {
	ssorpn_(&dscons_1.ndim, &intern_1.maxt, &intern_1.maxb, &jcoef[ip1], &
		jcoef[ip2], &coef[1], &coef[ip1], &coef[ip2], n, &p[1], &r__[
		1], &wksp[point_1.iwkpt1], pdp, pldup);
    }
    return 0;
} /* subq85_ */

/* Subroutine */ int subq86_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, ip1, ip2, ip3, ip4;
    extern /* Subroutine */ int icsp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *, doublereal *);
    static logical symm;
    extern /* Subroutine */ int icsnp_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *)
	    ;


/* ... subq86 calls ics, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    symm = itcom6_1.isymm == 0;
    if (! cblock_1.propa) {
	goto L10;
    }
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    if (symm) {
	icsp_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1],
		 &wksp[cfactr_1.ifactr], &coef[ip1], &c__1, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsnp_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxt, &
		intern_1.maxb, &jcoef[ip1], &jcoef[ip2], &wksp[
		cfactr_1.ifactr], &coef[ip1], &coef[ip2], &c__1, &r__[1], &
		z__[1]);
    }
    return 0;
L10:
    if (itcom6_1.lvfill > 0) {
	goto L15;
    }
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    ip3 = cfactr_1.ifactr + n;
    ip4 = n * (intern_1.maxt + 1) + cfactr_1.ifactr;
    if (symm) {
	icsp_(&n, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1], &wksp[
		cfactr_1.ifactr], &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsnp_(&n, &dscons_1.ndim, &n, &intern_1.maxt, &intern_1.maxb, &jcoef[
		ip1], &jcoef[ip2], &wksp[cfactr_1.ifactr], &wksp[ip3], &wksp[
		ip4], &c__0, &r__[1], &z__[1]);
    }
    return 0;
L15:
    ip1 = cfactr_1.ifacti + n;
    ip2 = cfactr_1.ifacti + n * (intern_1.maxt + 1);
    ip3 = cfactr_1.ifactr + n;
    ip4 = n * (intern_1.maxt + 1) + cfactr_1.ifactr;
    if (symm) {
	icsp_(&n, &n, &n, &intern_1.maxt, &iwksp[ip1], &wksp[cfactr_1.ifactr],
		 &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsnp_(&n, &n, &n, &intern_1.maxt, &intern_1.maxb, &iwksp[ip1], &
		iwksp[ip2], &wksp[cfactr_1.ifactr], &wksp[ip3], &wksp[ip4], &
		c__0, &r__[1], &z__[1]);
    }
    return 0;
} /* subq86_ */

/* Subroutine */ int subq87_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, ip1, ip2, ip3, ip4;
    extern /* Subroutine */ int icsp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *, doublereal *);
    static logical symm;
    extern /* Subroutine */ int icsntp_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *)
	    ;


/* ... subq87 calls ics, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    symm = itcom6_1.isymm == 0;
    if (! cblock_1.propa) {
	goto L10;
    }
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    if (symm) {
	icsp_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1],
		 &wksp[cfactr_1.ifactr], &coef[ip1], &c__1, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsntp_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxt, &
		intern_1.maxb, &jcoef[ip1], &jcoef[ip2], &wksp[
		cfactr_1.ifactr], &coef[ip1], &coef[ip2], &c__1, &r__[1], &
		z__[1]);
    }
    return 0;
L10:
    if (itcom6_1.lvfill > 0) {
	goto L15;
    }
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    ip3 = cfactr_1.ifactr + n;
    ip4 = n * (intern_1.maxt + 1) + cfactr_1.ifactr;
    if (symm) {
	icsp_(&n, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1], &wksp[
		cfactr_1.ifactr], &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsntp_(&n, &dscons_1.ndim, &n, &intern_1.maxt, &intern_1.maxb, &
		jcoef[ip1], &jcoef[ip2], &wksp[cfactr_1.ifactr], &wksp[ip3], &
		wksp[ip4], &c__0, &r__[1], &z__[1]);
    }
    return 0;
L15:
    ip1 = cfactr_1.ifacti + n;
    ip2 = cfactr_1.ifacti + n * (intern_1.maxt + 1);
    ip3 = cfactr_1.ifactr + n;
    ip4 = n * (intern_1.maxt + 1) + cfactr_1.ifactr;
    if (symm) {
	icsp_(&n, &n, &n, &intern_1.maxt, &iwksp[ip1], &wksp[cfactr_1.ifactr],
		 &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsntp_(&n, &n, &n, &intern_1.maxt, &intern_1.maxb, &iwksp[ip1], &
		iwksp[ip2], &wksp[cfactr_1.ifactr], &wksp[ip3], &wksp[ip4], &
		c__0, &r__[1], &z__[1]);
    }
    return 0;
} /* subq87_ */

/* Subroutine */ int subq88_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, ip1, ip2, ip3, ip4;
    static logical symm;
    extern /* Subroutine */ int icsp1_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *, doublereal *), icsnp1_(integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    integer *, doublereal *, doublereal *);


/* ... subq88 calls ics, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    symm = itcom6_1.isymm == 0;
    if (! cblock_1.propa) {
	goto L10;
    }
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    if (symm) {
	icsp1_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1]
		, &wksp[cfactr_1.ifactr], &coef[ip1], &c__1, &r__[1], &z__[1])
		;
    }
    if (! symm) {
	icsnp1_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxb, &jcoef[
		ip2], &wksp[cfactr_1.ifactr], &coef[ip2], &c__1, &r__[1], &
		z__[1]);
    }
    return 0;
L10:
    if (itcom6_1.lvfill > 0) {
	goto L15;
    }
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    ip3 = cfactr_1.ifactr + n;
    ip4 = n * (intern_1.maxt + 1) + cfactr_1.ifactr;
    if (symm) {
	icsp1_(&n, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1], &wksp[
		cfactr_1.ifactr], &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsnp1_(&n, &dscons_1.ndim, &n, &intern_1.maxb, &jcoef[ip2], &wksp[
		cfactr_1.ifactr], &wksp[ip4], &c__0, &r__[1], &z__[1]);
    }
    return 0;
L15:
    ip1 = cfactr_1.ifacti + n;
    ip2 = cfactr_1.ifacti + n * (intern_1.maxt + 1);
    ip3 = cfactr_1.ifactr + n;
    ip4 = n * (intern_1.maxt + 1) + cfactr_1.ifactr;
    if (symm) {
	icsp1_(&n, &n, &n, &intern_1.maxt, &iwksp[ip1], &wksp[cfactr_1.ifactr]
		, &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsnp1_(&n, &n, &n, &intern_1.maxb, &iwksp[ip2], &wksp[
		cfactr_1.ifactr], &wksp[ip4], &c__0, &r__[1], &z__[1]);
    }
    return 0;
} /* subq88_ */

/* Subroutine */ int subq89_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, ip1, ip2, ip3, ip4;
    static logical symm;
    extern /* Subroutine */ int icsp3_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *, doublereal *), icsnp3_(integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    integer *, doublereal *, doublereal *);


/* ... subq89 calls ics, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    symm = itcom6_1.isymm == 0;
    if (! cblock_1.propa) {
	goto L10;
    }
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    if (symm) {
	icsp3_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1]
		, &wksp[cfactr_1.ifactr], &coef[ip1], &c__1, &r__[1], &z__[1])
		;
    }
    if (! symm) {
	icsnp3_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxb, &jcoef[
		ip2], &wksp[cfactr_1.ifactr], &coef[ip2], &c__1, &r__[1], &
		z__[1]);
    }
    return 0;
L10:
    if (itcom6_1.lvfill > 0) {
	goto L15;
    }
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    ip3 = cfactr_1.ifactr + n;
    ip4 = n * (intern_1.maxt + 1) + cfactr_1.ifactr;
    if (symm) {
	icsp3_(&n, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1], &wksp[
		cfactr_1.ifactr], &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsnp3_(&n, &dscons_1.ndim, &n, &intern_1.maxb, &jcoef[ip2], &wksp[
		cfactr_1.ifactr], &wksp[ip4], &c__0, &r__[1], &z__[1]);
    }
    return 0;
L15:
    ip1 = cfactr_1.ifacti + n;
    ip2 = cfactr_1.ifacti + n * (intern_1.maxt + 1);
    ip3 = cfactr_1.ifactr + n;
    ip4 = n * (intern_1.maxt + 1) + cfactr_1.ifactr;
    if (symm) {
	icsp3_(&n, &n, &n, &intern_1.maxt, &iwksp[ip1], &wksp[cfactr_1.ifactr]
		, &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsnp3_(&n, &n, &n, &intern_1.maxb, &iwksp[ip2], &wksp[
		cfactr_1.ifactr], &wksp[ip4], &c__0, &r__[1], &z__[1]);
    }
    return 0;
} /* subq89_ */

/* Subroutine */ int subq90_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, ip1, ip3;
    static logical symm;
    extern /* Subroutine */ int icsp2_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *, doublereal *), icsnp2_(integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    integer *, doublereal *, doublereal *);


/* ... subq90 calls ics, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    symm = itcom6_1.isymm == 0;
    if (! cblock_1.propa) {
	goto L10;
    }
    ip1 = dscons_1.ndim + 1;
    if (symm) {
	icsp2_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1]
		, &wksp[cfactr_1.ifactr], &coef[ip1], &c__1, &r__[1], &z__[1])
		;
    }
    if (! symm) {
	icsnp2_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[
		ip1], &wksp[cfactr_1.ifactr], &coef[ip1], &c__1, &r__[1], &
		z__[1]);
    }
    return 0;
L10:
    if (itcom6_1.lvfill > 0) {
	goto L15;
    }
    ip1 = dscons_1.ndim + 1;
    ip3 = cfactr_1.ifactr + n;
    if (symm) {
	icsp2_(&n, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1], &wksp[
		cfactr_1.ifactr], &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsnp2_(&n, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1], &wksp[
		cfactr_1.ifactr], &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    return 0;
L15:
    ip1 = cfactr_1.ifacti + n;
    ip3 = cfactr_1.ifactr + n;
    if (symm) {
	icsp2_(&n, &n, &n, &intern_1.maxt, &iwksp[ip1], &wksp[cfactr_1.ifactr]
		, &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsnp2_(&n, &n, &n, &intern_1.maxt, &iwksp[ip1], &wksp[
		cfactr_1.ifactr], &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    return 0;
} /* subq90_ */

/* Subroutine */ int subq91_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, doublereal *r__, doublereal *z__)
{
    static integer n, ip1, ip3;
    static logical symm;
    extern /* Subroutine */ int icsp4_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *, doublereal *), icsnp4_(integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    integer *, doublereal *, doublereal *);


/* ... subq91 calls ics, for ic(s) preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    symm = itcom6_1.isymm == 0;
    if (! cblock_1.propa) {
	goto L10;
    }
    ip1 = dscons_1.ndim + 1;
    if (symm) {
	icsp4_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1]
		, &wksp[cfactr_1.ifactr], &coef[ip1], &c__1, &r__[1], &z__[1])
		;
    }
    if (! symm) {
	icsnp4_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[
		ip1], &wksp[cfactr_1.ifactr], &coef[ip1], &c__1, &r__[1], &
		z__[1]);
    }
    return 0;
L10:
    if (itcom6_1.lvfill > 0) {
	goto L15;
    }
    ip1 = dscons_1.ndim + 1;
    ip3 = cfactr_1.ifactr + n;
    if (symm) {
	icsp4_(&n, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1], &wksp[
		cfactr_1.ifactr], &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsnp4_(&n, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1], &wksp[
		cfactr_1.ifactr], &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    return 0;
L15:
    ip1 = cfactr_1.ifacti + n;
    ip3 = cfactr_1.ifactr + n;
    if (symm) {
	icsp4_(&n, &n, &n, &intern_1.maxt, &iwksp[ip1], &wksp[cfactr_1.ifactr]
		, &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    if (! symm) {
	icsnp4_(&n, &n, &n, &intern_1.maxt, &iwksp[ip1], &wksp[
		cfactr_1.ifactr], &wksp[ip3], &c__0, &r__[1], &z__[1]);
    }
    return 0;
} /* subq91_ */

/* Subroutine */ int subq92_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int ppii_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, doublereal *, doublereal *,
	     integer *, doublereal *, integer *, doublereal *, doublereal *),
	    suba8_(doublereal *, integer *, doublereal *, integer *, integer *
	    , doublereal *, doublereal *);


/* ... subq92 calls ppii, for lspoly preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ppii_((S_fp)suba8_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &
	    itcom8_1.ainf, &c_b121, &c_b121, &itcom6_1.ndeg, &wksp[
	    point_1.iwkpt2], n, &r__[1], &z__[1]);
    return 0;
} /* subq92_ */

/* Subroutine */ int subq93_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int ppii_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, doublereal *, doublereal *,
	     integer *, doublereal *, integer *, doublereal *, doublereal *),
	    suba9_(doublereal *, integer *, doublereal *, integer *, integer *
	    , doublereal *, doublereal *);


/* ... subq93 calls ppii, for lspoly preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ppii_((S_fp)suba9_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &
	    itcom8_1.ainf, &c_b121, &c_b121, &itcom6_1.ndeg, &wksp[
	    point_1.iwkpt2], n, &r__[1], &z__[1]);
    return 0;
} /* subq93_ */

/* Subroutine */ int subq94_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int pneu_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, integer *, doublereal *,
	    integer *, doublereal *, doublereal *), suba8_(doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *);


/* ... subq94 calls pneu, for neumann polynomial preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pneu_((S_fp)suba8_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &coef[1], &
	    itcom6_1.ndeg, &wksp[point_1.iwkpt2], n, &r__[1], &z__[1]);
    return 0;
} /* subq94_ */

/* Subroutine */ int subq95_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int pneu_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, integer *, doublereal *,
	    integer *, doublereal *, doublereal *), suba9_(doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *);


/* ... subq95 calls pneu, for neumann polynomial preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pneu_((S_fp)suba9_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &coef[1], &
	    itcom6_1.ndeg, &wksp[point_1.iwkpt2], n, &r__[1], &z__[1]);
    return 0;
} /* subq95_ */

/* Subroutine */ int subq96_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *u, doublereal *rhs,
	doublereal *unew)
{
    extern /* Subroutine */ int sorcp_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... subq96 calls the basic multi-color sor iterative step */


    /* Parameter adjustments */
    --unew;
    --rhs;
    --u;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    sorcp_(&dscons_1.ndim, n, &jcoef[dscons_1.ndim + 1], &coef[1], &coef[
	    dscons_1.ndim + 1], &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
	    intern_1.ndt], &iwksp[intern_1.ndb], &itcom5_1.omega, &u[1], &rhs[
	    1], &unew[1]);
    return 0;
} /* subq96_ */

/* Subroutine */ int subq97_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1;
    extern /* Subroutine */ int srscp_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... subq97 calls the mssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim + 1;
    srscp_(&dscons_1.ndim, n, &jcoef[ipt1], &coef[1], &coef[ipt1], &
	    cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[intern_1.ndt], &
	    iwksp[intern_1.ndb], &itcom5_1.omega, &wksp[point_1.iwkpt1], &r__[
	    1], &z__[1]);
    return 0;
} /* subq97_ */

/* Subroutine */ int subq98_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1;
    extern /* Subroutine */ int srscpt_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... subq98 calls the mssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim + 1;
    srscpt_(&dscons_1.ndim, n, &jcoef[ipt1], &coef[1], &coef[ipt1], &
	    cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[intern_1.ndt], &
	    iwksp[intern_1.ndb], &itcom5_1.omega, &wksp[point_1.iwkpt1], &r__[
	    1], &z__[1]);
    return 0;
} /* subq98_ */

/* Subroutine */ int subq99_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1;
    extern /* Subroutine */ int srscp1_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... subq99 calls the mssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim + 1;
    srscp1_(&dscons_1.ndim, n, &jcoef[ipt1], &coef[1], &coef[ipt1], &
	    cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[intern_1.ndt], &
	    iwksp[intern_1.ndb], &itcom5_1.omega, &wksp[point_1.iwkpt1], &r__[
	    1], &z__[1]);
    return 0;
} /* subq99_ */

/* Subroutine */ int sub100_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1;
    extern /* Subroutine */ int srscp3_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... sub100 calls the mssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim + 1;
    srscp3_(&dscons_1.ndim, n, &jcoef[ipt1], &coef[1], &coef[ipt1], &
	    cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[intern_1.ndt], &
	    iwksp[intern_1.ndb], &itcom5_1.omega, &wksp[point_1.iwkpt1], &r__[
	    1], &z__[1]);
    return 0;
} /* sub100_ */

/* Subroutine */ int sub101_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1;
    extern /* Subroutine */ int srscp2_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *);


/* ... sub101 calls the mssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim + 1;
    srscp2_(&dscons_1.ndim, n, &jcoef[ipt1], &coef[1], &coef[ipt1], &
	    cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[intern_1.ndt], &
	    itcom5_1.omega, &wksp[point_1.iwkpt1], &r__[1], &z__[1]);
    return 0;
} /* sub101_ */

/* Subroutine */ int sub102_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1;
    extern /* Subroutine */ int srscp4_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *);


/* ... sub102 calls the mssor preconditioner. */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim + 1;
    srscp4_(&dscons_1.ndim, n, &jcoef[ipt1], &coef[1], &coef[ipt1], &
	    cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[intern_1.ndt], &
	    itcom5_1.omega, &wksp[point_1.iwkpt1], &r__[1], &z__[1]);
    return 0;
} /* sub102_ */

/* Subroutine */ int sub103_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *p, doublereal *r__,
	doublereal *pdp, doublereal *pldup)
{
    static integer ipt1;
    extern /* Subroutine */ int ssrcp_(integer *, integer *, doublereal *,
	    doublereal *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *), ssrcpn_(integer *, integer *, doublereal *,
	    doublereal *, integer *, integer *, integer *, integer *, integer
	    *, doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *);


/* ... sub103 calls the mssor adaption routine. */




    /* Parameter adjustments */
    --r__;
    --p;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim + 1;
    if (itcom6_1.isymm == 0) {
	ssrcp_(&dscons_1.ndim, &jcoef[ipt1], &coef[1], &coef[ipt1], n, &
		cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[intern_1.ndt], &
		p[1], &r__[1], &wksp[point_1.iwkpt1], pdp, pldup);
    }
    if (itcom6_1.isymm == 1) {
	ssrcpn_(&dscons_1.ndim, &jcoef[ipt1], &coef[1], &coef[ipt1], n, &
		cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[intern_1.ndt], &
		iwksp[intern_1.ndb], &p[1], &r__[1], &wksp[point_1.iwkpt1],
		pdp, pldup);
    }
    return 0;
} /* sub103_ */

/* Subroutine */ int sub104_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2;
    extern /* Subroutine */ int icscp_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... sub104 calls the ic preconditioner. */
/*     (multicolor purdue) */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim + 1;
    ipt2 = cfactr_1.ifactr + *n;
    if (cblock_1.propa) {
	icscp_(&dscons_1.ndim, &dscons_1.ndim, n, &jcoef[ipt1], &wksp[
		cfactr_1.ifactr], &coef[ipt1], &cblock_1.ncolor, &iwksp[
		cblock_1.nc], &iwksp[intern_1.ndt], &iwksp[intern_1.ndb], &
		c__1, &wksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	icscp_(n, &dscons_1.ndim, n, &jcoef[ipt1], &wksp[cfactr_1.ifactr], &
		wksp[ipt2], &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
		intern_1.ndt], &iwksp[intern_1.ndb], &c__0, &wksp[
		point_1.iwkpt1], &r__[1], &z__[1]);
    }
    return 0;
} /* sub104_ */

/* Subroutine */ int sub105_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2;
    extern /* Subroutine */ int icscpt_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... sub105 calls the ic preconditioner. */
/*     (multicolor purdue) */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim + 1;
    ipt2 = cfactr_1.ifactr + *n;
    if (cblock_1.propa) {
	icscpt_(&dscons_1.ndim, &dscons_1.ndim, n, &jcoef[ipt1], &wksp[
		cfactr_1.ifactr], &coef[ipt1], &cblock_1.ncolor, &iwksp[
		cblock_1.nc], &iwksp[intern_1.ndt], &iwksp[intern_1.ndb], &
		c__1, &wksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	icscpt_(n, &dscons_1.ndim, n, &jcoef[ipt1], &wksp[cfactr_1.ifactr], &
		wksp[ipt2], &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
		intern_1.ndt], &iwksp[intern_1.ndb], &c__0, &wksp[
		point_1.iwkpt1], &r__[1], &z__[1]);
    }
    return 0;
} /* sub105_ */

/* Subroutine */ int sub106_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2;
    extern /* Subroutine */ int icscp1_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... sub106 calls the ic preconditioner. */
/*     (multicolor purdue) */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim + 1;
    ipt2 = cfactr_1.ifactr + *n;
    if (cblock_1.propa) {
	icscp1_(&dscons_1.ndim, &dscons_1.ndim, n, &jcoef[ipt1], &wksp[
		cfactr_1.ifactr], &coef[ipt1], &cblock_1.ncolor, &iwksp[
		cblock_1.nc], &iwksp[intern_1.ndt], &iwksp[intern_1.ndb], &
		c__1, &wksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	icscp1_(n, &dscons_1.ndim, n, &jcoef[ipt1], &wksp[cfactr_1.ifactr], &
		wksp[ipt2], &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
		intern_1.ndt], &iwksp[intern_1.ndb], &c__0, &wksp[
		point_1.iwkpt1], &r__[1], &z__[1]);
    }
    return 0;
} /* sub106_ */

/* Subroutine */ int sub107_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2;
    extern /* Subroutine */ int icscp3_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... sub107 calls the ic preconditioner. */
/*     (multicolor purdue) */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim + 1;
    ipt2 = cfactr_1.ifactr + *n;
    if (cblock_1.propa) {
	icscp3_(&dscons_1.ndim, &dscons_1.ndim, n, &jcoef[ipt1], &wksp[
		cfactr_1.ifactr], &coef[ipt1], &cblock_1.ncolor, &iwksp[
		cblock_1.nc], &iwksp[intern_1.ndt], &iwksp[intern_1.ndb], &
		c__1, &wksp[point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	icscp3_(n, &dscons_1.ndim, n, &jcoef[ipt1], &wksp[cfactr_1.ifactr], &
		wksp[ipt2], &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
		intern_1.ndt], &iwksp[intern_1.ndb], &c__0, &wksp[
		point_1.iwkpt1], &r__[1], &z__[1]);
    }
    return 0;
} /* sub107_ */

/* Subroutine */ int sub108_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2;
    extern /* Subroutine */ int icscp2_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *);


/* ... sub104 calls the ic preconditioner. */
/*     (multicolor purdue) */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim + 1;
    ipt2 = cfactr_1.ifactr + *n;
    if (cblock_1.propa) {
	icscp2_(&dscons_1.ndim, &dscons_1.ndim, n, &jcoef[ipt1], &wksp[
		cfactr_1.ifactr], &coef[ipt1], &cblock_1.ncolor, &iwksp[
		cblock_1.nc], &iwksp[intern_1.ndt], &c__1, &wksp[
		point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	icscp2_(n, &dscons_1.ndim, n, &jcoef[ipt1], &wksp[cfactr_1.ifactr], &
		wksp[ipt2], &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
		intern_1.ndt], &c__0, &wksp[point_1.iwkpt1], &r__[1], &z__[1])
		;
    }
    return 0;
} /* sub108_ */

/* Subroutine */ int sub109_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    static integer ipt1, ipt2;
    extern /* Subroutine */ int icscp4_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *);


/* ... sub104 calls the ic preconditioner. */
/*     (multicolor purdue) */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ipt1 = dscons_1.ndim + 1;
    ipt2 = cfactr_1.ifactr + *n;
    if (cblock_1.propa) {
	icscp4_(&dscons_1.ndim, &dscons_1.ndim, n, &jcoef[ipt1], &wksp[
		cfactr_1.ifactr], &coef[ipt1], &cblock_1.ncolor, &iwksp[
		cblock_1.nc], &iwksp[intern_1.ndt], &c__1, &wksp[
		point_1.iwkpt1], &r__[1], &z__[1]);
    }
    if (! cblock_1.propa) {
	icscp4_(n, &dscons_1.ndim, n, &jcoef[ipt1], &wksp[cfactr_1.ifactr], &
		wksp[ipt2], &cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[
		intern_1.ndt], &c__0, &wksp[point_1.iwkpt1], &r__[1], &z__[1])
		;
    }
    return 0;
} /* sub109_ */

/* Subroutine */ int sub110_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int ppii_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, doublereal *, doublereal *,
	     integer *, doublereal *, integer *, doublereal *, doublereal *),
	    suba12_(doublereal *, integer *, doublereal *, integer *, integer
	    *, doublereal *, doublereal *);


/* ... sub110 calls ppii, for lspoly preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ppii_((S_fp)suba12_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &
	    itcom8_1.ainf, &c_b121, &c_b121, &itcom6_1.ndeg, &wksp[
	    point_1.iwkpt2], n, &r__[1], &z__[1]);
    return 0;
} /* sub110_ */

/* Subroutine */ int sub111_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int pneu_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, integer *, doublereal *,
	    integer *, doublereal *, doublereal *), suba12_(doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *);


/* ... sub111 calls pneu, for neumann polynomial preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pneu_((S_fp)suba12_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &coef[1], &
	    itcom6_1.ndeg, &wksp[point_1.iwkpt2], n, &r__[1], &z__[1]);
    return 0;
} /* sub111_ */

/* Subroutine */ int sub112_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int ppii_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, doublereal *, doublereal *,
	     integer *, doublereal *, integer *, doublereal *, doublereal *),
	    suba13_(doublereal *, integer *, doublereal *, integer *, integer
	    *, doublereal *, doublereal *);


/* ... sub112 calls ppii, for lspoly preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ppii_((S_fp)suba13_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &
	    itcom8_1.ainf, &c_b121, &c_b121, &itcom6_1.ndeg, &wksp[
	    point_1.iwkpt2], n, &r__[1], &z__[1]);
    return 0;
} /* sub112_ */

/* Subroutine */ int sub113_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int ppii_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, doublereal *, doublereal *,
	     integer *, doublereal *, integer *, doublereal *, doublereal *),
	    suba14_(doublereal *, integer *, doublereal *, integer *, integer
	    *, doublereal *, doublereal *);


/* ... sub113 calls ppii, for lspoly preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    ppii_((S_fp)suba14_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &
	    itcom8_1.ainf, &c_b121, &c_b121, &itcom6_1.ndeg, &wksp[
	    point_1.iwkpt2], n, &r__[1], &z__[1]);
    return 0;
} /* sub113_ */

/* Subroutine */ int sub114_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int pneu_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, integer *, doublereal *,
	    integer *, doublereal *, doublereal *), suba13_(doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *);


/* ... sub114 calls pneu, for neumann polynomial preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pneu_((S_fp)suba13_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &coef[1], &
	    itcom6_1.ndeg, &wksp[point_1.iwkpt2], n, &r__[1], &z__[1]);
    return 0;
} /* sub114_ */

/* Subroutine */ int sub115_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *n, doublereal *r__, doublereal *z__)
{
    extern /* Subroutine */ int pneu_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, doublereal *, integer *, doublereal *,
	    integer *, doublereal *, doublereal *), suba14_(doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *);


/* ... sub115 calls pneu, for neumann polynomial preconditioning. */



    /* Parameter adjustments */
    --z__;
    --r__;
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    pneu_((S_fp)suba14_, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], &coef[1], &
	    itcom6_1.ndeg, &wksp[point_1.iwkpt2], n, &r__[1], &z__[1]);
    return 0;
} /* sub115_ */

/* Subroutine */ int lfact_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *nn, integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer j, n, jd, ipt1, ipt2, isym;
    extern /* Subroutine */ int bdfac_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *), needw_(char *,
	    integer *, integer *, integer *, integer *, ftnlen), vcopy_(
	    integer *, doublereal *, doublereal *);


/* ... lfact computes a line factorization. */

/* ... parameters -- */

/*        n        problem size */
/*        nfactr   factorization size */

/* ... common blocks */


/* ... check for sufficient workspace to store factor. */

    /* Parameter adjustments */
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    if (itcom6_1.nstore == 2) {
	isym = 0;
    }
    if (itcom6_1.nstore == 3) {
	isym = 1;
    }
    intern_1.ndt = 0;
    intern_1.ndb = 0;
    i__1 = dscons_1.maxnz;
    for (jd = 1; jd <= i__1; ++jd) {
	i__2 = dscons_1.maxnz;
	for (j = 1; j <= i__2; ++j) {
	    if (jcoef[j] != jd) {
		goto L15;
	    }
	    ++intern_1.ndt;
	    goto L20;
L15:
	    ;
	}
	goto L25;
L20:
	;
    }
L25:
    if (isym == 0) {
	goto L40;
    }
    i__1 = dscons_1.maxnz;
    for (jd = 1; jd <= i__1; ++jd) {
	i__2 = dscons_1.maxnz;
	for (j = 1; j <= i__2; ++j) {
	    if (jcoef[j] != -jd) {
		goto L30;
	    }
	    ++intern_1.ndb;
	    goto L35;
L30:
	    ;
	}
	goto L40;
L35:
	;
    }
L40:
    cfactr_1.nfactr = (intern_1.ndt + intern_1.ndb + 1) * n;
    needw_("lfact", &c__0, &cwkcon_1.irpnt, &cfactr_1.nfactr, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }

    cfactr_1.ifactr = cwkcon_1.irpnt;
    vcopy_(&n, &coef[1], &wksp[cfactr_1.ifactr]);
    intern_1.ndt = 0;
    i__1 = dscons_1.maxnz;
    for (jd = 1; jd <= i__1; ++jd) {
	i__2 = dscons_1.maxnz;
	for (j = 1; j <= i__2; ++j) {
	    if (jcoef[j] != jd) {
		goto L50;
	    }
	    ++intern_1.ndt;
	    ipt1 = (j - 1) * dscons_1.ndim + 1;
	    ipt2 = intern_1.ndt * n + cfactr_1.ifactr;
	    vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
	    goto L55;
L50:
	    ;
	}
	goto L60;
L55:
	;
    }
L60:
    intern_1.ndb = 0;
    if (isym == 0) {
	goto L75;
    }
    i__1 = dscons_1.maxnz;
    for (jd = 1; jd <= i__1; ++jd) {
	i__2 = dscons_1.maxnz;
	for (j = 1; j <= i__2; ++j) {
	    if (jcoef[j] != -jd) {
		goto L65;
	    }
	    ++intern_1.ndb;
	    ipt1 = (j - 1) * dscons_1.ndim + 1;
	    ipt2 = (intern_1.ndt + intern_1.ndb) * n + cfactr_1.ifactr;
	    vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
	    goto L70;
L65:
	    ;
	}
	goto L75;
L70:
	;
    }

/* ... factor. */

L75:
    bdfac_(&n, &n, &itcom6_1.kblsz, &intern_1.ndt, &intern_1.ndb, &wksp[
	    cfactr_1.ifactr], &isym);
    cwkcon_1.irpnt += cfactr_1.nfactr;
    return 0;
} /* lfact_ */

/* Subroutine */ int linv_(doublereal *coef, integer *jcoef, doublereal *wksp,
	 integer *nn, integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer j, n, jd, it, ipt1, ipt2, isym;
    extern /* Subroutine */ int bdfac_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *), needw_(char *,
	    integer *, integer *, integer *, integer *, ftnlen), bdinv_(
	    integer *, integer *, integer *, integer *, integer *, doublereal
	    *, integer *), vfill_(integer *, doublereal *, doublereal *),
	    vcopy_(integer *, doublereal *, doublereal *);


/* ... linv computes a line approximate inverse. */

/* ... parameters -- */

/*        n        problem size */
/*        nfactr   factorization size */

/* ... common blocks */


/* ... check for sufficient workspace to store factor. */

    /* Parameter adjustments */
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    if (itcom6_1.nstore == 2) {
	isym = 0;
    }
    if (itcom6_1.nstore == 3) {
	isym = 1;
    }
    intern_1.ndt = 0;
    intern_1.ndb = 0;
    i__1 = dscons_1.maxnz;
    for (jd = 1; jd <= i__1; ++jd) {
	i__2 = dscons_1.maxnz;
	for (j = 1; j <= i__2; ++j) {
	    if (jcoef[j] != jd) {
		goto L15;
	    }
	    ++intern_1.ndt;
	    goto L20;
L15:
	    ;
	}
	goto L25;
L20:
	;
    }
L25:
    if (isym == 0) {
	goto L40;
    }
    i__1 = dscons_1.maxnz;
    for (jd = 1; jd <= i__1; ++jd) {
	i__2 = dscons_1.maxnz;
	for (j = 1; j <= i__2; ++j) {
	    if (jcoef[j] != -jd) {
		goto L30;
	    }
	    ++intern_1.ndb;
	    goto L35;
L30:
	    ;
	}
	goto L40;
L35:
	;
    }

L40:
    intern_1.ndt += itcom6_1.ltrunc;
    if (isym == 1) {
	intern_1.ndb += itcom6_1.ltrunc;
    }
    cfactr_1.nfactr = (intern_1.ndt + intern_1.ndb + 1) * n;
    needw_("linv", &c__0, &cwkcon_1.irpnt, &cfactr_1.nfactr, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }

    cfactr_1.ifactr = cwkcon_1.irpnt;
    vfill_(&cfactr_1.nfactr, &wksp[cfactr_1.ifactr], &c_b121);
    vcopy_(&n, &coef[1], &wksp[cfactr_1.ifactr]);
    it = 0;
    i__1 = dscons_1.maxnz;
    for (jd = 1; jd <= i__1; ++jd) {
	i__2 = dscons_1.maxnz;
	for (j = 1; j <= i__2; ++j) {
	    if (jcoef[j] != jd) {
		goto L50;
	    }
	    ++it;
	    ipt1 = (j - 1) * dscons_1.ndim + 1;
	    ipt2 = it * n + cfactr_1.ifactr;
	    vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
	    goto L55;
L50:
	    ;
	}
	goto L60;
L55:
	;
    }
L60:
    if (isym == 0) {
	goto L75;
    }
    it = intern_1.ndt;
    i__1 = dscons_1.maxnz;
    for (jd = 1; jd <= i__1; ++jd) {
	i__2 = dscons_1.maxnz;
	for (j = 1; j <= i__2; ++j) {
	    if (jcoef[j] != -jd) {
		goto L65;
	    }
	    ++it;
	    ipt1 = (j - 1) * dscons_1.ndim + 1;
	    ipt2 = it * n + cfactr_1.ifactr;
	    vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
	    goto L70;
L65:
	    ;
	}
	goto L75;
L70:
	;
    }

/* ... factor and invert. */

L75:
    bdfac_(&n, &n, &itcom6_1.kblsz, &intern_1.ndt, &intern_1.ndb, &wksp[
	    cfactr_1.ifactr], &isym);
    bdinv_(&n, &n, &itcom6_1.kblsz, &intern_1.ndt, &intern_1.ndb, &wksp[
	    cfactr_1.ifactr], &isym);
    cwkcon_1.irpnt += cfactr_1.nfactr;
    return 0;
} /* linv_ */

/* Subroutine */ int mfact_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer j, n, ipt1, ipt2;
    extern /* Subroutine */ int bdfac_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *), needw_(char *,
	    integer *, integer *, integer *, integer *, ftnlen), vcopy_(
	    integer *, doublereal *, doublereal *);
    static integer nwdiag;


/* ... mfact computes a line factorization of a multi-color matrix. */

/* ... parameters -- */

/*        n        problem size */
/*        nfactr   factorization size */

/* ... common blocks */


/* ... check for sufficient workspace to store factor. */

    /* Parameter adjustments */
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    intern_1.ndt = iwksp[cblock_1.iblock + 2] - 1;
    intern_1.ndb = iwksp[cblock_1.iblock + cblock_1.ncolor * 3 + 2];
    nwdiag = intern_1.ndt + intern_1.ndb + 1;
    cfactr_1.nfactr = n * nwdiag;
    needw_("mfact", &c__0, &cwkcon_1.irpnt, &cfactr_1.nfactr, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }

    cfactr_1.ifactr = cwkcon_1.irpnt;
    i__1 = nwdiag;
    for (j = 1; j <= i__1; ++j) {
	ipt1 = (j - 1) * dscons_1.ndim + 1;
	ipt2 = (j - 1) * n + cfactr_1.ifactr;
	vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
/* L15: */
    }

/* ... factor. */

    bdfac_(&n, &n, &n, &intern_1.ndt, &intern_1.ndb, &wksp[cfactr_1.ifactr], &
	    c__1);
    cwkcon_1.irpnt += cfactr_1.nfactr;
    return 0;
} /* mfact_ */

/* Subroutine */ int pfact1_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, integer *methh, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, j, n, ip1, ip2, ip3, ip4, mw1, mw2, len, ipt1, ipt2;
    extern /* Subroutine */ int icfp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *, integer *);
    static integer maxc, meth, jmax;
    extern /* Subroutine */ int move1_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, integer *, integer
	    *);
    static integer iflag;
    extern /* Subroutine */ int icfnp_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, integer *, integer *, doublereal *,
	    integer *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), vfill_(integer *, doublereal *, doublereal *),
	     vcopy_(integer *, doublereal *, doublereal *);
    static integer maxcp1;
    extern /* Subroutine */ int fillnp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, integer *), fillsp_(integer *,
	     integer *, integer *, integer *, doublereal *, integer *,
	    integer *), prbndx_(integer *, integer *, integer *, integer *,
	    doublereal *, integer *, integer *, logical *, integer *);
    static integer mwidth;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen), vicopy_(
	    integer *, integer *, integer *);


/* ... pfact1 computes a point incomplete factorization. */

/* ... parameters */

/*       n       order of system */
/*       meth    method of factorization */
/*                = 1   ic   (unmodified) */
/*                = 2   mic  (modified) */
/*       nfactr  amount of floating point workspace needed for factorization */
/*       nfacti  amount of integer workspace needed for factorization */
/*       ier     error flag */

/* ... specifications for parameters */



    /* Parameter adjustments */
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    meth = *methh;

/* ... if requested, find out if matrix has property a. */

    if (itcom6_1.ipropa == 0) {
	cblock_1.propa = FALSE_;
    }
    if (itcom6_1.ipropa == 1) {
	cblock_1.propa = TRUE_;
    }
    if (itcom6_1.lvfill > 0) {
	cblock_1.propa = FALSE_;
    }
    if (itcom6_1.lvfill > 0) {
	goto L55;
    }
    if (itcom6_1.ipropa != 2) {
	goto L15;
    }
    i__1 = n << 1;
    needw_("pfact1", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    prbndx_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &iwksp[
	    cwkcon_1.iipnt], &iwksp[cwkcon_1.iipnt + n], &cblock_1.propa, &
	    c__1);
    if (cblock_1.propa) {
	itcom6_1.ipropa = 1;
    }
    if (! cblock_1.propa) {
	itcom6_1.ipropa = 0;
    }

L15:
    if (! cblock_1.propa) {
	goto L35;
    }

/* ... propa = .true. */

    cfactr_1.ifactr = cwkcon_1.irpnt;
    cfactr_1.nfactr = n;
    cfactr_1.nfacti = 0;
    i__1 = cfactr_1.nfactr + n;
    needw_("pfact1", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    vcopy_(&n, &coef[1], &wksp[cfactr_1.ifactr]);
    cwkcon_1.irpnt += cfactr_1.nfactr;
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    if (itcom6_1.isymm == 0) {
	icfp_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1],
		 &wksp[cfactr_1.ifactr], &coef[ip1], &meth, &c__1, &
		itcom5_1.omega, &wksp[cwkcon_1.irpnt], &iflag);
    }
    if (itcom6_1.isymm != 0) {
	icfnp_(&dscons_1.ndim, &dscons_1.ndim, &n, &intern_1.maxt, &
		intern_1.maxb, &jcoef[ip1], &jcoef[ip2], &wksp[
		cfactr_1.ifactr], &coef[ip1], &coef[ip2], &meth, &c__1, &
		itcom5_1.omega, &iflag);
    }
    if (iflag == 1) {
	*ier = -12;
    }
    if (iflag == 2) {
	*ier = 5;
    }
    if (iflag == 0) {
	return 0;
    }
    ershow_(ier, "pfact1", (ftnlen)6);
    return 0;

/* ... propa = .false., lvfill = 0. */

L35:
    cfactr_1.ifactr = cwkcon_1.irpnt;
    jmax = intern_1.maxt + 1;
    if (itcom6_1.isymm != 0) {
	jmax = intern_1.maxt + 1 + intern_1.maxb;
    }
    cfactr_1.nfactr = n * jmax;
    cfactr_1.nfacti = 0;
    i__1 = cfactr_1.nfactr + n;
    needw_("pfact1", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    vfill_(&cfactr_1.nfactr, &wksp[cfactr_1.ifactr], &c_b121);
    i__1 = jmax;
    for (j = 1; j <= i__1; ++j) {
	ip1 = dscons_1.ndim * (j - 1) + 1;
	ip2 = n * (j - 1) + cfactr_1.ifactr;
	vcopy_(&n, &coef[ip1], &wksp[ip2]);
/* L45: */
    }
    cwkcon_1.irpnt += cfactr_1.nfactr;
    ip1 = dscons_1.ndim + 1;
    ip2 = dscons_1.ndim * (intern_1.maxt + 1) + 1;
    ip3 = cfactr_1.ifactr + n;
    ip4 = n * (intern_1.maxt + 1) + cfactr_1.ifactr;
    if (itcom6_1.isymm == 0) {
	icfp_(&n, &dscons_1.ndim, &n, &intern_1.maxt, &jcoef[ip1], &wksp[
		cfactr_1.ifactr], &wksp[ip3], &meth, &c__0, &itcom5_1.omega, &
		wksp[cwkcon_1.irpnt], &iflag);
    }
    if (itcom6_1.isymm != 0) {
	icfnp_(&n, &dscons_1.ndim, &n, &intern_1.maxt, &intern_1.maxb, &jcoef[
		ip1], &jcoef[ip2], &wksp[cfactr_1.ifactr], &wksp[ip3], &wksp[
		ip4], &meth, &c__0, &itcom5_1.omega, &iflag);
    }
    if (iflag == 1) {
	*ier = -12;
    }
    if (iflag == 2) {
	*ier = 5;
    }
    if (iflag == 0) {
	return 0;
    }
    ershow_(ier, "pfact1", (ftnlen)6);
    return 0;

/* ... propa = .false., lvfill .gt. 0 */

L55:
    len = n * (intern_1.maxt + 1);
    if (itcom6_1.isymm != 0) {
	len = n * (intern_1.maxt + 1 + intern_1.maxb);
    }
    needw_("pfact1", &c__1, &cwkcon_1.iipnt, &len, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    needw_("pfact1", &c__0, &cwkcon_1.irpnt, &len, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    jmax = intern_1.maxt + 1;
    if (itcom6_1.isymm != 0) {
	jmax = intern_1.maxt + 1 + intern_1.maxb;
    }
    i__1 = jmax;
    for (j = 1; j <= i__1; ++j) {
	ipt1 = (j - 1) * dscons_1.ndim + 1;
	ipt2 = (j - 1) * n + cwkcon_1.iipnt;
	vicopy_(&n, &jcoef[ipt1], &iwksp[ipt2]);
	ipt2 = (j - 1) * n + cwkcon_1.irpnt;
	vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
/* L70: */
    }
    mw1 = (cwkcon_1.leni - (cwkcon_1.iipnt + n) + 1) / n;
    mw2 = (cwkcon_1.lenr - (cwkcon_1.irpnt + n) + 1) / n;
    mwidth = min(mw1,mw2);
    maxc = intern_1.maxt + intern_1.maxb;
    i__1 = itcom6_1.lvfill;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (itcom6_1.isymm == 0) {
	    fillsp_(&n, &n, &intern_1.maxt, &iwksp[cwkcon_1.iipnt + n], &wksp[
		    cwkcon_1.irpnt + n], &mwidth, ier);
	}
	if (itcom6_1.isymm != 0) {
	    fillnp_(&n, &n, &maxc, &iwksp[cwkcon_1.iipnt + n], &wksp[
		    cwkcon_1.irpnt + n], &mwidth, ier);
	}
	if (*ier < 0) {
	    ershow_(ier, "pfact1", (ftnlen)6);
	    return 0;
	}
/* L75: */
    }
    maxcp1 = maxc + 1;
    if (itcom6_1.isymm != 0) {
	i__1 = mwidth + 1;
	move1_(&n, &i__1, &n, &maxcp1, &iwksp[cwkcon_1.iipnt], &wksp[
		cwkcon_1.irpnt], &intern_1.maxt, &intern_1.maxb, ier);
    }
    if (*ier < 0) {
	ershow_(ier, "pfact1", (ftnlen)6);
	return 0;
    }
    if (itcom6_1.isymm == 0) {
	cfactr_1.nfactr = n * (intern_1.maxt + 1);
    }
    if (itcom6_1.isymm != 0) {
	cfactr_1.nfactr = n * (intern_1.maxt + intern_1.maxb + 1);
    }
    cfactr_1.nfacti = cfactr_1.nfactr;
    i__1 = cfactr_1.nfactr + n;
    needw_("pfact1", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    needw_("pfact1", &c__1, &cwkcon_1.iipnt, &cfactr_1.nfacti, ier, (ftnlen)6)
	    ;
    if (*ier < 0) {
	return 0;
    }

    cfactr_1.ifactr = cwkcon_1.irpnt;
    cfactr_1.ifacti = cwkcon_1.iipnt;
    cwkcon_1.irpnt += cfactr_1.nfactr;
    cwkcon_1.iipnt += cfactr_1.nfacti;
    ip1 = cfactr_1.ifacti + n;
    ip2 = cfactr_1.ifacti + n * (intern_1.maxt + 1);
    ip3 = cfactr_1.ifactr + n;
    ip4 = cfactr_1.ifactr + n * (intern_1.maxt + 1);
    if (itcom6_1.isymm == 0) {
	icfp_(&n, &n, &n, &intern_1.maxt, &iwksp[ip1], &wksp[cfactr_1.ifactr],
		 &wksp[ip3], &meth, &c__0, &itcom5_1.omega, &wksp[
		cwkcon_1.irpnt], &iflag);
    }
    if (itcom6_1.isymm != 0) {
	icfnp_(&n, &n, &n, &intern_1.maxt, &intern_1.maxb, &iwksp[ip1], &
		iwksp[ip2], &wksp[cfactr_1.ifactr], &wksp[ip3], &wksp[ip4], &
		meth, &c__0, &itcom5_1.omega, &iflag);
    }
    if (iflag == 1) {
	*ier = -12;
    }
    if (iflag == 2) {
	*ier = 5;
    }
    if (iflag == 0) {
	return 0;
    }
    ershow_(ier, "pfact1", (ftnlen)6);
    return 0;
} /* pfact1_ */

/* Subroutine */ int pfact2_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, integer *methh, integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__, j, n, ip1, ip2;
    extern /* Subroutine */ int icf_(integer *, integer *, integer *, integer
	    *, doublereal *, doublereal *, integer *, integer *, doublereal *,
	     doublereal *, integer *, integer *), icfv_(integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *);
    static integer meth, iflag;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), fills_(integer *, integer *), vfill_(
	    integer *, doublereal *, doublereal *), vcopy_(integer *,
	    doublereal *, doublereal *), prbndx_(integer *, integer *,
	    integer *, integer *, doublereal *, integer *, integer *, logical
	    *, integer *), rowise_(integer *, integer *, integer *), ershow_(
	    integer *, char *, ftnlen), vicopy_(integer *, integer *, integer
	    *);


/* ... pfact2 computes a point incomplete factorization. */

/* ... parameters */

/*       n       order of system */
/*       meth    method of factorization */
/*                = 1   ic   (unmodified) */
/*                = 2   mic  (modified) */
/*       nfactr  amount of floating point workspace needed for factorization */
/*       ier     error flag */

/* ... specifications for parameters */



    /* Parameter adjustments */
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    meth = *methh;

/* ... if requested, find out if matrix has property a. */

    if (itcom6_1.ipropa == 0) {
	cblock_1.propa = FALSE_;
    }
    if (itcom6_1.ipropa == 1) {
	cblock_1.propa = TRUE_;
    }
    if (itcom6_1.lvfill > 0) {
	cblock_1.propa = FALSE_;
    }
    if (itcom6_1.lvfill > 0) {
	goto L20;
    }
    if (itcom6_1.ipropa != 2) {
	goto L15;
    }
    i__1 = n << 1;
    needw_("pfact2", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    prbndx_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &iwksp[
	    cwkcon_1.iipnt], &iwksp[cwkcon_1.iipnt + n], &cblock_1.propa, &
	    c__2);
    if (cblock_1.propa) {
	itcom6_1.ipropa = 1;
    }
    if (! cblock_1.propa) {
	itcom6_1.ipropa = 0;
    }

L15:
    if (! cblock_1.propa) {
	goto L20;
    }

/* ... propa = .true. */

    intern_1.maxt = dscons_1.maxnz - 1;
    intern_1.maxb = 0;
    cfactr_1.ifactr = cwkcon_1.irpnt;
    cfactr_1.nfactr = n;
    cfactr_1.nfacti = 0;
    i__1 = cfactr_1.nfactr + n;
    needw_("pfact2", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    rowise_(&dscons_1.maxnz, &jcoef[1], &intern_1.irwise);
/* Computing 2nd power */
    i__2 = intern_1.maxt;
    i__1 = dscons_1.maxnz + i__2 * i__2;
    needw_("pfact2", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    vfill_(&n, &wksp[cfactr_1.ifactr], &c_b121);
    vcopy_(&n, &coef[1], &wksp[cfactr_1.ifactr]);
    cwkcon_1.irpnt += cfactr_1.nfactr;
    if (itcom6_1.ifctv == 0) {
	icf_(&dscons_1.ndim, &n, &intern_1.maxt, &jcoef[2], &wksp[
		cfactr_1.ifactr], &coef[dscons_1.ndim + 1], &meth, &c__1, &
		itcom5_1.omega, &wksp[cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt],
		 &iflag);
    }
    if (itcom6_1.ifctv == 1) {
	icfv_(&dscons_1.ndim, &n, &intern_1.maxt, &jcoef[2], &wksp[
		cfactr_1.ifactr], &coef[dscons_1.ndim + 1], &meth, &c__1, &
		itcom5_1.omega, &wksp[cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt],
		 &iflag);
    }
    if (iflag == 1) {
	*ier = -12;
    }
    if (iflag == 2) {
	*ier = 5;
    }
    if (iflag == 0) {
	return 0;
    }
    ershow_(ier, "pfact2", (ftnlen)6);
    return 0;

/* ... propa = .false. */

L20:
    vicopy_(&dscons_1.maxnz, &jcoef[1], &iwksp[cwkcon_1.iipnt]);
    intern_1.maxt = dscons_1.maxnz - 1;
    intern_1.maxb = 0;
    if (itcom6_1.lvfill == 0) {
	goto L26;
    }
    i__1 = itcom6_1.lvfill;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	fills_(&intern_1.maxt, &iwksp[cwkcon_1.iipnt + 1]);
    }
L26:
    cfactr_1.nfactr = n * (intern_1.maxt + 1);
    cfactr_1.nfacti = intern_1.maxt + 1;
/* Computing 2nd power */
    i__2 = intern_1.maxt;
    i__1 = i__2 * i__2;
    needw_("pfact2", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    i__1 = cfactr_1.nfactr + n;
    needw_("pfact2", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }

    cfactr_1.ifactr = cwkcon_1.irpnt;
    cfactr_1.ifacti = cwkcon_1.iipnt;
    vfill_(&cfactr_1.nfactr, &wksp[cfactr_1.ifactr], &c_b121);
    i__1 = dscons_1.maxnz;
    for (j = 1; j <= i__1; ++j) {
	ip1 = dscons_1.ndim * (j - 1) + 1;
	ip2 = n * (j - 1) + cfactr_1.ifactr;
	vcopy_(&n, &coef[ip1], &wksp[ip2]);
/* L40: */
    }
    cwkcon_1.irpnt += cfactr_1.nfactr;
    cwkcon_1.iipnt = cwkcon_1.iipnt + intern_1.maxt + 1;
    i__1 = intern_1.maxt + 1;
    rowise_(&i__1, &iwksp[cfactr_1.ifacti], &intern_1.irwise);
    needw_("pfact2", &c__1, &cwkcon_1.iipnt, &intern_1.maxt, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    if (itcom6_1.ifctv == 0) {
	icf_(&n, &n, &intern_1.maxt, &iwksp[cfactr_1.ifacti + 1], &wksp[
		cfactr_1.ifactr], &wksp[cfactr_1.ifactr + n], &meth, &c__0, &
		itcom5_1.omega, &wksp[cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt],
		 &iflag);
    }
    if (itcom6_1.ifctv == 1) {
	icfv_(&n, &n, &intern_1.maxt, &iwksp[cfactr_1.ifacti + 1], &wksp[
		cfactr_1.ifactr], &wksp[cfactr_1.ifactr + n], &meth, &c__0, &
		itcom5_1.omega, &wksp[cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt],
		 &iflag);
    }
    if (iflag == 1) {
	*ier = -12;
    }
    if (iflag == 2) {
	*ier = 5;
    }
    if (iflag == 0) {
	return 0;
    }
    ershow_(ier, "pfact2", (ftnlen)6);
    return 0;
} /* pfact2_ */

/* Subroutine */ int pfact3_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, integer *meth, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, j, n, ip1, ip2, ipt1, ipt2;
    extern /* Subroutine */ int icfn_(integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    integer *, integer *);
    static integer maxz;
    extern /* Subroutine */ int move2_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *);
    static integer iflag;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), filln_(integer *, integer *), vfill_(
	    integer *, doublereal *, doublereal *), vcopy_(integer *,
	    doublereal *, doublereal *);
    static integer maxtp1;
    extern /* Subroutine */ int prbndx_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, integer *, logical *, integer
	    *), rowise_(integer *, integer *, integer *), ershow_(integer *,
	    char *, ftnlen), vicopy_(integer *, integer *, integer *);


/* ... pfact3 computes a point incomplete factorization. */

/* ... parameters */

/*       n       order of system */
/*       meth    method of factorization */
/*                = 1   ic   (unmodified) */
/*                = 2   mic  (modified) */
/*       nfactr  amount of floating point workspace needed for factorization */
/*       ier     error flag */

/* ... specifications for parameters */



    /* Parameter adjustments */
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;

/* ... if requested, find out if matrix has property a. */

    if (itcom6_1.ipropa == 0) {
	cblock_1.propa = FALSE_;
    }
    if (itcom6_1.ipropa == 1) {
	cblock_1.propa = TRUE_;
    }
    if (itcom6_1.lvfill > 0) {
	cblock_1.propa = FALSE_;
    }
    if (itcom6_1.lvfill > 0) {
	goto L20;
    }
    if (itcom6_1.ipropa != 2) {
	goto L15;
    }
    i__1 = n << 1;
    needw_("pfact3", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    prbndx_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &iwksp[
	    cwkcon_1.iipnt], &iwksp[cwkcon_1.iipnt + n], &cblock_1.propa, &
	    c__3);
    if (cblock_1.propa) {
	itcom6_1.ipropa = 1;
    }
    if (! cblock_1.propa) {
	itcom6_1.ipropa = 0;
    }

L15:
    if (! cblock_1.propa) {
	goto L20;
    }

/* ... propa = .true. */

    cfactr_1.ifactr = cwkcon_1.irpnt;
    cfactr_1.nfactr = n;
    cfactr_1.nfacti = 0;
    i__1 = cfactr_1.nfactr + n;
    needw_("pfact3", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    rowise_(&dscons_1.maxnz, &jcoef[1], &intern_1.irwise);
    i__1 = intern_1.maxt * intern_1.maxb;
    needw_("pfact3", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    vfill_(&n, &wksp[cfactr_1.ifactr], &c_b121);
    vcopy_(&n, &coef[1], &wksp[cfactr_1.ifactr]);
    cwkcon_1.irpnt += cfactr_1.nfactr;
    maxtp1 = intern_1.maxt + 1;
    icfn_(&dscons_1.ndim, &n, &intern_1.maxt, &intern_1.maxb, &jcoef[2], &
	    jcoef[intern_1.maxt + 2], &wksp[cfactr_1.ifactr], &coef[
	    dscons_1.ndim + 1], &coef[dscons_1.ndim * maxtp1 + 1], meth, &
	    c__1, &itcom5_1.omega, &wksp[cwkcon_1.irpnt], &iwksp[
	    cwkcon_1.iipnt], &iflag);
    if (iflag == 1) {
	*ier = -12;
    }
    if (iflag == 2) {
	*ier = 5;
    }
    if (iflag == 0) {
	return 0;
    }
    ershow_(ier, "pfact3", (ftnlen)6);
    return 0;

/* ... propa = .false. */

L20:
    vicopy_(&dscons_1.maxnz, &jcoef[1], &iwksp[cwkcon_1.iipnt]);
    maxz = dscons_1.maxnz;
    if (itcom6_1.lvfill == 0) {
	goto L26;
    }
    i__1 = itcom6_1.lvfill;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	filln_(&maxz, &iwksp[cwkcon_1.iipnt]);
    }
L26:
    cfactr_1.nfactr = n * maxz;
    cfactr_1.nfacti = maxz;
    needw_("pfact3", &c__1, &cwkcon_1.iipnt, &maxz, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    needw_("pfact3", &c__0, &cwkcon_1.irpnt, &cfactr_1.nfactr, ier, (ftnlen)6)
	    ;
    if (*ier < 0) {
	return 0;
    }

    cfactr_1.ifactr = cwkcon_1.irpnt;
    cfactr_1.ifacti = cwkcon_1.iipnt;
    vfill_(&cfactr_1.nfactr, &wksp[cfactr_1.ifactr], &c_b121);
    i__1 = dscons_1.maxnz;
    for (j = 1; j <= i__1; ++j) {
	ip1 = dscons_1.ndim * (j - 1) + 1;
	ip2 = n * (j - 1) + cfactr_1.ifactr;
	vcopy_(&n, &coef[ip1], &wksp[ip2]);
/* L40: */
    }
    cwkcon_1.irpnt += cfactr_1.nfactr;
    cwkcon_1.iipnt += maxz;
    rowise_(&maxz, &iwksp[cfactr_1.ifacti], &intern_1.irwise);
    needw_("pfact3", &c__0, &cwkcon_1.irpnt, &n, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    move2_(&n, &n, &maxz, &iwksp[cfactr_1.ifacti], &wksp[cfactr_1.ifactr], &
	    wksp[cwkcon_1.irpnt], &iwksp[cwkcon_1.iipnt], &intern_1.maxt, &
	    intern_1.maxb);
    i__1 = intern_1.maxt * intern_1.maxb;
    needw_("pfact3", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    ipt1 = cfactr_1.ifacti + intern_1.maxt + 1;
    ipt2 = cfactr_1.ifactr + n * (intern_1.maxt + 1);
    icfn_(&n, &n, &intern_1.maxt, &intern_1.maxb, &iwksp[cfactr_1.ifacti + 1],
	     &iwksp[ipt1], &wksp[cfactr_1.ifactr], &wksp[cfactr_1.ifactr + n],
	     &wksp[ipt2], meth, &c__0, &itcom5_1.omega, &wksp[cwkcon_1.irpnt],
	     &iwksp[cwkcon_1.iipnt], &iflag);
    if (iflag == 1) {
	*ier = -12;
    }
    if (iflag == 2) {
	*ier = 5;
    }
    if (iflag == 0) {
	return 0;
    }
    ershow_(ier, "pfact3", (ftnlen)6);
    return 0;
} /* pfact3_ */

/* Subroutine */ int pfactc_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, integer *methh, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer j, n, ip1, ip2, ip3, maxc, meth, iflag;
    extern /* Subroutine */ int icfcp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    integer *, integer *, integer *, integer *, integer *, doublereal
	    *, integer *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen), vfill_(integer *, doublereal *, doublereal *),
	     vcopy_(integer *, doublereal *, doublereal *), prbndx_(integer *,
	     integer *, integer *, integer *, doublereal *, integer *,
	    integer *, logical *, integer *), ershow_(integer *, char *,
	    ftnlen);


/* ... pfactc computes a point incomplete factorization. */
/*     (multicolor ordering) */

/* ... parameters */

/*       n       order of system */
/*       meth    method of factorization */
/*                = 1   ic   (unmodified) */
/*                = 2   mic  (modified) */
/*       ier     error flag */

/* ... specifications for parameters */



    /* Parameter adjustments */
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    meth = *methh;

/* ... if requested, find out if matrix has property a. */

    if (itcom6_1.ipropa == 0) {
	cblock_1.propa = FALSE_;
    }
    if (itcom6_1.ipropa == 1) {
	cblock_1.propa = TRUE_;
    }
    if (itcom6_1.ipropa != 2) {
	goto L15;
    }
    i__1 = n << 1;
    needw_("pfactc", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    prbndx_(&n, &dscons_1.ndim, &dscons_1.maxnz, &jcoef[1], &coef[1], &iwksp[
	    cwkcon_1.iipnt], &iwksp[cwkcon_1.iipnt + n], &cblock_1.propa, &
	    c__1);
    if (cblock_1.propa) {
	itcom6_1.ipropa = 1;
    }
    if (! cblock_1.propa) {
	itcom6_1.ipropa = 0;
    }

L15:
    if (! cblock_1.propa) {
	goto L30;
    }

/* ... propa = .true. */

    cfactr_1.ifactr = cwkcon_1.irpnt;
    cfactr_1.nfactr = n;
    cfactr_1.nfacti = 0;
    needw_("pfactc", &c__0, &cwkcon_1.irpnt, &cfactr_1.nfactr, ier, (ftnlen)6)
	    ;
    if (*ier < 0) {
	return 0;
    }
    vcopy_(&n, &coef[1], &wksp[cfactr_1.ifactr]);
    cwkcon_1.irpnt += cfactr_1.nfactr;
    ip1 = dscons_1.ndim + 1;
    maxc = dscons_1.maxnz - 1;
    icfcp_(&dscons_1.ndim, &dscons_1.ndim, &n, &maxc, &jcoef[ip1], &wksp[
	    cfactr_1.ifactr], &coef[ip1], &cblock_1.ncolor, &iwksp[
	    intern_1.ndt], &iwksp[intern_1.ndb], &meth, &c__1, &iwksp[
	    cblock_1.ipt], &itcom5_1.omega, &iflag);
    if (iflag == 1) {
	*ier = -12;
    }
    if (iflag == 2) {
	*ier = 5;
    }
    if (iflag == 0) {
	return 0;
    }
    ershow_(ier, "pfactc", (ftnlen)6);
    return 0;

/* ... propa = .false. */

L30:
    cfactr_1.ifactr = cwkcon_1.irpnt;
    cfactr_1.nfactr = n * dscons_1.maxnz;
    cfactr_1.nfacti = 0;
    needw_("pfactc", &c__0, &cwkcon_1.irpnt, &cfactr_1.nfactr, ier, (ftnlen)6)
	    ;
    if (*ier < 0) {
	return 0;
    }
    vfill_(&cfactr_1.nfactr, &wksp[cfactr_1.ifactr], &c_b121);
    i__1 = dscons_1.maxnz;
    for (j = 1; j <= i__1; ++j) {
	ip1 = dscons_1.ndim * (j - 1) + 1;
	ip2 = n * (j - 1) + cfactr_1.ifactr;
	vcopy_(&n, &coef[ip1], &wksp[ip2]);
/* L45: */
    }
    cwkcon_1.irpnt += cfactr_1.nfactr;
    ip1 = dscons_1.ndim + 1;
    ip3 = cfactr_1.ifactr + n;
    maxc = dscons_1.maxnz - 1;
    icfcp_(&n, &dscons_1.ndim, &n, &maxc, &jcoef[ip1], &wksp[cfactr_1.ifactr],
	     &wksp[ip3], &cblock_1.ncolor, &iwksp[intern_1.ndt], &iwksp[
	    intern_1.ndb], &meth, &c__0, &iwksp[cblock_1.ipt], &
	    itcom5_1.omega, &iflag);
    if (iflag == 1) {
	*ier = -12;
    }
    if (iflag == 2) {
	*ier = 5;
    }
    if (iflag == 0) {
	return 0;
    }
    ershow_(ier, "pfactc", (ftnlen)6);
    return 0;
} /* pfactc_ */

/* Subroutine */ int bfacmz_(integer *methf, S_fp factor, doublereal *coef,
	integer *jcoef, doublereal *wksp, integer *iwksp, integer *nn,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n, ipt1, ipt2, ncol, nwkp, idumb[3];
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen);
    static integer nwnew;
    extern /* Subroutine */ int fillbn_(integer *, doublereal *, integer *,
	    integer *, doublereal *, integer *, integer *);
    static integer nwdiag;
    extern /* Subroutine */ int prbblk_(integer *, integer *, integer *,
	    integer *, integer *, integer *, logical *);


/* ... bfacmz computes a block factorization. */
/*     (nonsymmetric diagonal) */

/* ... parameters */

/*       n       order of system */
/*       nfactr  amount of floating point workspace needed for factorization */
/*       ier     error flag */

/* ... specifications for parameters */



    /* Parameter adjustments */
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    if (*methf <= 2) {
	intern_1.ivers = 1;
    }
    if (*methf > 2) {
	intern_1.ivers = 2;
    }

/* ... if requested, find out if matrix has block property a. */

    ncol = n / itcom6_1.kblsz;
    if (itcom6_1.ipropa == 0) {
	cblock_1.propa = FALSE_;
    }
    if (itcom6_1.ipropa == 1) {
	cblock_1.propa = TRUE_;
    }
    if (itcom6_1.lvfill > 0) {
	cblock_1.propa = FALSE_;
    }
    if (itcom6_1.lvfill > 0) {
	goto L15;
    }
    if (itcom6_1.ipropa != 2) {
	goto L15;
    }
    i__1 = ncol << 1;
    needw_("bfacmz", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    iwksp[cwkcon_1.iipnt] = cblock_1.lbhb;
    prbblk_(&ncol, &c__1, &iwksp[cblock_1.iblock], &iwksp[cwkcon_1.iipnt], &
	    iwksp[cwkcon_1.iipnt + 1], &iwksp[cwkcon_1.iipnt + ncol + 1], &
	    cblock_1.propa);
    if (cblock_1.propa) {
	itcom6_1.ipropa = 1;
    }
    if (! cblock_1.propa) {
	itcom6_1.ipropa = 0;
    }

/* ... calculate fill-in and factor. */

L15:
    fillbn_(&n, &coef[1], &jcoef[1], &iwksp[cblock_1.iblock], &wksp[1], &
	    iwksp[1], ier);
    if (*ier < 0) {
	return 0;
    }
    nwnew = iwksp[cblock_1.iblock + 2] + iwksp[cblock_1.iblock + 5];
    nwdiag = nwnew - (itcom6_1.ltrunc << 1);
    if (*methf == 1) {
	nwkp = itcom6_1.kblsz * nwnew;
    }
    if (*methf == 2) {
	nwkp = itcom6_1.kblsz * (nwnew + 1);
    }
    if (*methf == 3) {
	nwkp = 0;
    }
    if (*methf == 4) {
	nwkp = n + (itcom6_1.kblsz << 1);
    }
    needw_("fillbn", &c__0, &cwkcon_1.irpnt, &nwkp, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    ipt1 = cblock_1.iblock + cblock_1.lbhb * 3;
    ipt2 = ipt1 + nwnew;
    idumb[0] = itcom6_1.kblsz;
    idumb[1] = 1;
    idumb[2] = cblock_1.lbhb;
    if (cblock_1.propa) {
	(*factor)(&n, &dscons_1.ndim, &n, &iwksp[cwkcon_1.iipnt], &jcoef[
		nwdiag + 1], &wksp[cfactr_1.ifactr], &coef[dscons_1.ndim *
		nwdiag + 1], &c__1, idumb, &iwksp[cblock_1.iblock], &idumb[2],
		 &c__1, &c__1, &idumb[1], &itcom5_1.omega, &wksp[
		cwkcon_1.irpnt], ier);
    }
    if (! cblock_1.propa && itcom6_1.lvfill == 0) {
	(*factor)(&n, &n, &n, &iwksp[cwkcon_1.iipnt], &jcoef[nwdiag + 1], &
		wksp[cfactr_1.ifactr], &wksp[point_1.iwkpt2], &c__1, idumb, &
		iwksp[cblock_1.iblock], &idumb[2], &c__1, &c__0, &idumb[1], &
		itcom5_1.omega, &wksp[cwkcon_1.irpnt], ier);
    }
    if (itcom6_1.lvfill > 0) {
	(*factor)(&n, &n, &n, &iwksp[ipt1], &iwksp[ipt2], &wksp[
		cfactr_1.ifactr], &wksp[point_1.iwkpt2], &c__1, idumb, &iwksp[
		cblock_1.iblock], &idumb[2], &c__1, &c__0, &idumb[1], &
		itcom5_1.omega, &wksp[cwkcon_1.irpnt], ier);
    }
    return 0;
} /* bfacmz_ */

/* Subroutine */ int bfacs_(integer *methf, S_fp factor, doublereal *coef,
	integer *jcoef, doublereal *wksp, integer *iwksp, integer *nn,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n, ipt1, ipt2, ncol, nwkp;
    extern /* Subroutine */ int fillb_(integer *, doublereal *, integer *,
	    integer *, doublereal *, integer *, integer *), needw_(char *,
	    integer *, integer *, integer *, integer *, ftnlen);
    static integer nwnew, nwdiag;
    extern /* Subroutine */ int prbblk_(integer *, integer *, integer *,
	    integer *, integer *, integer *, logical *);


/* ... bfacs computes a block factorization. */
/*     (symmetric diagonal) */

/* ... parameters */

/*       n       order of system */
/*       nfactr  amount of floating point workspace needed for factorization */
/*       ier     error flag */

/* ... specifications for parameters */



    /* Parameter adjustments */
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    if (*methf <= 2) {
	intern_1.ivers = 1;
    }
    if (*methf > 2) {
	intern_1.ivers = 2;
    }

/* ... if requested, find out if matrix has block property a. */

    ncol = n / itcom6_1.kblsz;
    if (itcom6_1.ipropa == 0) {
	cblock_1.propa = FALSE_;
    }
    if (itcom6_1.ipropa == 1) {
	cblock_1.propa = TRUE_;
    }
    if (itcom6_1.lvfill > 0) {
	cblock_1.propa = FALSE_;
    }
    if (itcom6_1.lvfill > 0) {
	goto L15;
    }
    if (itcom6_1.ipropa != 2) {
	goto L15;
    }
    i__1 = ncol << 1;
    needw_("bfacs", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    iwksp[cwkcon_1.iipnt] = cblock_1.lbhb;
    prbblk_(&ncol, &c__1, &iwksp[cblock_1.iblock], &iwksp[cwkcon_1.iipnt], &
	    iwksp[cwkcon_1.iipnt + 1], &iwksp[cwkcon_1.iipnt + ncol + 1], &
	    cblock_1.propa);
    if (cblock_1.propa) {
	itcom6_1.ipropa = 1;
    }
    if (! cblock_1.propa) {
	itcom6_1.ipropa = 0;
    }

/* ... calculate fill-in and factor. */

L15:
    fillb_(&n, &coef[1], &jcoef[1], &iwksp[cblock_1.iblock], &wksp[1], &iwksp[
	    1], ier);
    if (*ier < 0) {
	return 0;
    }
    nwnew = iwksp[cblock_1.iblock + 2];
    nwdiag = nwnew - itcom6_1.ltrunc;
    if (*methf == 1) {
	nwkp = itcom6_1.kblsz * nwnew;
    }
    if (*methf == 2) {
	nwkp = itcom6_1.kblsz * (nwnew + 1);
    }
    if (*methf == 3) {
	nwkp = 0;
    }
    if (*methf == 4) {
	nwkp = n + (itcom6_1.kblsz << 1);
    }
    needw_("fillb", &c__0, &cwkcon_1.irpnt, &nwkp, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    ipt1 = cblock_1.iblock + cblock_1.lbhb * 3;
    ipt2 = ipt1 + nwnew;
    if (cblock_1.propa) {
	(*factor)(&n, &dscons_1.ndim, &n, &iwksp[cwkcon_1.iipnt], &jcoef[
		nwdiag + 1], &wksp[cfactr_1.ifactr], &coef[dscons_1.ndim *
		nwdiag + 1], &itcom6_1.kblsz, &iwksp[cblock_1.iblock], &
		cblock_1.lbhb, &c__1, &itcom5_1.omega, &wksp[cwkcon_1.irpnt],
		ier);
    }
    if (! cblock_1.propa && itcom6_1.lvfill == 0) {
	(*factor)(&n, &n, &n, &iwksp[cwkcon_1.iipnt], &jcoef[nwdiag + 1], &
		wksp[cfactr_1.ifactr], &wksp[point_1.iwkpt2], &itcom6_1.kblsz,
		 &iwksp[cblock_1.iblock], &cblock_1.lbhb, &c__0, &
		itcom5_1.omega, &wksp[cwkcon_1.irpnt], ier);
    }
    if (itcom6_1.lvfill > 0) {
	(*factor)(&n, &n, &n, &iwksp[ipt1], &iwksp[ipt2], &wksp[
		cfactr_1.ifactr], &wksp[point_1.iwkpt2], &itcom6_1.kblsz, &
		iwksp[cblock_1.iblock], &cblock_1.lbhb, &c__0, &
		itcom5_1.omega, &wksp[cwkcon_1.irpnt], ier);
    }
    return 0;
} /* bfacs_ */

/* Subroutine */ int fillb_(integer *nn, doublereal *coef, integer *jcoef,
	integer *iblock, doublereal *wksp, integer *iwksp, integer *ier)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer j, n, j1, j2, j3, jd, mc, jj, lv, jjc, ndg, inc, nwk, lim1,
	     lim2, ipt1, ipt2, jcol, jmax, jstc, lbhbl, jblkc;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), vfill_(integer *, doublereal *, doublereal *
	    );
    static integer jnext, nwnew;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *);
    static integer lbhbsa, nwdiag;


/* ... fillb calculates block fill-in for block factorization methods. */
/*     (symmetric diagonal storage) */

/* ... parameters -- */

/*       n       order of system */
/*       coef    floating point matrix coefficient array */
/*       jcoef   integer matrix coefficient array */
/*       iblock  array for block information */
/*       wksp    floating point workspace array */
/*       iwksp   integer workspace array */
/*       ier     error flag */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --iwksp;
    --wksp;
    iblock -= 4;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;

/* ... determine block fill-in pattern. */

    if (itcom6_1.lvfill > 0) {
	lbhbsa = cblock_2.lbhb;
	i__1 = itcom6_1.lvfill;
	for (lv = 1; lv <= i__1; ++lv) {
	    lbhbl = cblock_2.lbhb;
	    i__2 = cblock_2.lbhb;
	    for (j1 = 3; j1 <= i__2; ++j1) {
		i__3 = cblock_2.lbhb;
		for (j2 = 3; j2 <= i__3; ++j2) {
		    jd = iblock[j1 * 3 + 1] - iblock[j2 * 3 + 1];
		    if (jd <= 0) {
			goto L15;
		    }
		    i__4 = lbhbl;
		    for (j3 = 3; j3 <= i__4; ++j3) {
			if (iblock[j3 * 3 + 1] == jd) {
			    goto L15;
			}
/* L10: */
		    }
		    ++lbhbl;
		    iblock[lbhbl * 3 + 1] = jd;
		    iblock[lbhbl * 3 + 3] = 0;
L15:
		    ;
		}
/* L20: */
	    }
	    cblock_2.lbhb = lbhbl;
/* L25: */
	}
    }

/* ... compute constants and check for sufficient workspace. */

    i__1 = cblock_2.lbhb * 3;
    needw_("fillb", &c__1, &cblock_2.iblk, &i__1, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    nwdiag = iblock[6];
    nwnew = nwdiag + itcom6_1.ltrunc;
    cwkcon_1.iipnt = cblock_2.iblk + cblock_2.lbhb * 3;
    cfactr_1.ifactr = cwkcon_1.irpnt;
    nwk = cblock_2.lbhb * 3 + dscons_1.maxnz + itcom6_1.ltrunc + (
	    cblock_2.lbhb - 2) * ((nwnew << 1) - 1);
    needw_("fillb", &c__1, &cblock_2.iblk, &nwk, ier, (ftnlen)5);
    if (*ier < 0) {
	return 0;
    }
    i__1 = nwnew;
    for (j = 1; j <= i__1; ++j) {
/* L30: */
	iwksp[cwkcon_1.iipnt + j - 1] = j - 1;
    }
    iblock[6] = nwnew;

/* ... determine diagonal numbers in filled-in block matrix. */

    if (itcom6_1.lvfill > 0) {
	jmax = 3;
	i__1 = lbhbsa;
	for (j = 3; j <= i__1; ++j) {
	    if (iblock[j * 3 + 1] > iblock[jmax * 3 + 1]) {
		jmax = j;
	    }
/* L32: */
	}
	jnext = cwkcon_1.iipnt + nwnew;
	i__1 = cblock_2.lbhb;
	for (jjc = 3; jjc <= i__1; ++jjc) {
	    if (jjc <= lbhbsa) {
		jstc = iblock[jjc * 3 + 2];
		mc = iblock[jjc * 3 + 3];
		j1 = jnext;
		i__2 = mc;
		for (j = 1; j <= i__2; ++j) {
		    iwksp[jnext] = jcoef[nwdiag + jstc + j - 1];
		    ++jnext;
/* L35: */
		}
		j2 = jnext - 1;
	    }
	    if (jjc == jmax) {
		goto L50;
	    }
	    jblkc = iblock[jjc * 3 + 1];
	    inc = jblkc * itcom6_1.kblsz;
	    lim1 = inc - (nwnew - 1);
	    lim2 = inc + (nwnew - 1);
	    i__2 = lim2;
	    for (j = lim1; j <= i__2; ++j) {
		if (jjc <= lbhbsa) {
		    i__3 = j2;
		    for (jj = j1; jj <= i__3; ++jj) {
			if (iwksp[jj] == j) {
			    goto L45;
			}
/* L40: */
		    }
		}
		iwksp[jnext] = j;
		++jnext;
		++iblock[jjc * 3 + 3];
L45:
		;
	    }
L50:
	    ;
	}
	if (cblock_2.lbhb >= 4) {
	    i__1 = cblock_2.lbhb;
	    for (jjc = 4; jjc <= i__1; ++jjc) {
/* L52: */
		iblock[jjc * 3 + 2] = iblock[(jjc - 1) * 3 + 2] + iblock[(jjc
			- 1) * 3 + 3];
	    }
	}
    }

/* ... copy matrix into wksp. */

    if (cblock_2.propa) {
	cfactr_1.nfactr = n * nwnew;
	cfactr_1.nfacti = cblock_2.lbhb * 3;
    }
    if (! cblock_2.propa && itcom6_1.lvfill == 0) {
	cfactr_1.nfactr = n * (dscons_1.maxnz + itcom6_1.ltrunc);
	cfactr_1.nfacti = cblock_2.lbhb * 3;
    }
    if (itcom6_1.lvfill > 0) {
	ndg = 0;
	i__1 = cblock_2.lbhb;
	for (j = 1; j <= i__1; ++j) {
/* L55: */
	    ndg += iblock[j * 3 + 3];
	}
	cfactr_1.nfactr = n * ndg;
	cfactr_1.nfacti = ndg + cblock_2.lbhb * 3;
    }
    needw_("fillb", &c__0, &cfactr_1.ifactr, &cfactr_1.nfactr, ier, (ftnlen)5)
	    ;
    if (*ier < 0) {
	return 0;
    }
    needw_("fillb", &c__1, &cfactr_1.ifacti, &cfactr_1.nfacti, ier, (ftnlen)5)
	    ;
    if (*ier < 0) {
	return 0;
    }
    vfill_(&cfactr_1.nfactr, &wksp[cfactr_1.ifactr], &c_b121);
    ipt1 = 1;
    ipt2 = cfactr_1.ifactr;
    i__1 = nwdiag;
    for (j = 1; j <= i__1; ++j) {
	vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
	ipt1 += dscons_1.ndim;
	ipt2 += n;
/* L60: */
    }
    point_1.iwkpt2 = cfactr_1.ifactr + n * nwnew;
    ipt2 = point_1.iwkpt2;
    if (! cblock_2.propa && itcom6_1.lvfill == 0) {
	i__1 = dscons_1.maxnz;
	for (j = nwdiag + 1; j <= i__1; ++j) {
	    vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
	    ipt1 += dscons_1.ndim;
	    ipt2 += n;
/* L62: */
	}
    }
    if (itcom6_1.lvfill > 0) {
	j1 = cwkcon_1.iipnt + nwnew;
	j2 = cwkcon_1.iipnt + ndg - 1;
	i__1 = dscons_1.maxnz;
	for (j = nwdiag + 1; j <= i__1; ++j) {
	    jcol = jcoef[j];
	    ipt1 = (j - 1) * dscons_1.ndim + 1;
	    i__2 = j2;
	    for (jj = j1; jj <= i__2; ++jj) {
		if (iwksp[jj] != jcol) {
		    goto L65;
		}
		ipt2 = point_1.iwkpt2 + (jj - j1) * n;
		vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
		goto L70;
L65:
		;
	    }
L70:
	    ;
	}
    }
    cwkcon_1.irpnt = cfactr_1.ifactr + cfactr_1.nfactr;
    cwkcon_1.iipnt = cfactr_1.ifacti + cfactr_1.nfacti;
    return 0;
} /* fillb_ */

/* Subroutine */ int fillbn_(integer *nn, doublereal *coef, integer *jcoef,
	integer *iblock, doublereal *wksp, integer *iwksp, integer *ier)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer j, n, j1, j2, j3, jd, mc, jj, lv, ndb, jjc, ndg, inc, ndt,
	    nwk, lim1, lim2, ipt1, ipt2, jcol, jmin, jmax, jstc, lbhbl, jblkc;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), vfill_(integer *, doublereal *, doublereal *
	    );
    static integer jnext, nwnew;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *);
    static integer lbhbsa, nwdiag;


/* ... fillbn calculates block fill-in for block factorization methods. */
/*     (nonsymmetric diagonal storage) */

/* ... parameters -- */

/*       n       order of system */
/*       coef    floating point matrix coefficient array */
/*       jcoef   integer matrix coefficient array */
/*       iblock  array for block information */
/*       wksp    floating point workspace array */
/*       iwksp   integer workspace array */
/*       ier     error flag */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --iwksp;
    --wksp;
    iblock -= 4;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;

/* ... determine block fill-in pattern. */

    if (itcom6_1.lvfill > 0) {
	lbhbsa = cblock_2.lbhb;
	i__1 = itcom6_1.lvfill;
	for (lv = 1; lv <= i__1; ++lv) {
	    lbhbl = cblock_2.lbhb;
	    i__2 = cblock_2.lbhb;
	    for (j1 = 3; j1 <= i__2; ++j1) {
		i__3 = cblock_2.lbhb;
		for (j2 = 3; j2 <= i__3; ++j2) {
		    jd = iblock[j1 * 3 + 1] + iblock[j2 * 3 + 1];
		    if (iblock[j1 * 3 + 1] * iblock[j2 * 3 + 1] >= 0) {
			goto L15;
		    }
		    i__4 = lbhbl;
		    for (j3 = 1; j3 <= i__4; ++j3) {
			if (iblock[j3 * 3 + 1] == jd) {
			    goto L15;
			}
/* L10: */
		    }
		    ++lbhbl;
		    iblock[lbhbl * 3 + 1] = jd;
		    iblock[lbhbl * 3 + 3] = 0;
L15:
		    ;
		}
/* L20: */
	    }
	    cblock_2.lbhb = lbhbl;
/* L25: */
	}
    }

/* ... compute constants and check for sufficient workspace. */

    i__1 = cblock_2.lbhb * 3;
    needw_("fillbn", &c__1, &cblock_2.iblk, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    ndt = iblock[6] - 1;
    ndb = iblock[9];
    nwdiag = ndt + ndb + 1;
    nwnew = nwdiag + (itcom6_1.ltrunc << 1);
    cwkcon_1.iipnt = cblock_2.iblk + cblock_2.lbhb * 3;
    cfactr_1.ifactr = cwkcon_1.irpnt;
    nwk = cblock_2.lbhb * 3 + dscons_1.maxnz + (itcom6_1.ltrunc << 1) + (
	    cblock_2.lbhb - 2) * nwnew;
    needw_("fillbn", &c__1, &cblock_2.iblk, &nwk, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    i__1 = ndt + itcom6_1.ltrunc + 1;
    for (j = 1; j <= i__1; ++j) {
/* L30: */
	iwksp[cwkcon_1.iipnt + j - 1] = j - 1;
    }
    i__1 = nwnew;
    for (j = ndt + itcom6_1.ltrunc + 2; j <= i__1; ++j) {
/* L31: */
	iwksp[cwkcon_1.iipnt + j - 1] = -(j - ndt - itcom6_1.ltrunc - 1);
    }
    iblock[6] = ndt + itcom6_1.ltrunc + 1;
    iblock[9] = ndb + itcom6_1.ltrunc;
    iblock[8] = iblock[5] + iblock[6];

/* ... determine diagonal numbers in filled-in block matrix. */

    if (itcom6_1.lvfill > 0) {
	jmax = 3;
	jmin = 3;
	i__1 = lbhbsa;
	for (j = 3; j <= i__1; ++j) {
	    if (iblock[j * 3 + 1] > iblock[jmax * 3 + 1]) {
		jmax = j;
	    }
	    if (iblock[j * 3 + 1] < iblock[jmin * 3 + 1]) {
		jmin = j;
	    }
/* L32: */
	}
	jnext = cwkcon_1.iipnt + nwnew;
	i__1 = cblock_2.lbhb;
	for (jjc = 3; jjc <= i__1; ++jjc) {
	    if (jjc <= lbhbsa) {
		jstc = iblock[jjc * 3 + 2];
		mc = iblock[jjc * 3 + 3];
		j1 = jnext;
		i__2 = mc;
		for (j = 1; j <= i__2; ++j) {
		    iwksp[jnext] = jcoef[nwdiag + jstc + j - 1];
		    ++jnext;
/* L35: */
		}
		j2 = jnext - 1;
	    }
	    if (jjc == jmax || jjc == jmin) {
		goto L50;
	    }
	    jblkc = iblock[jjc * 3 + 1];
	    inc = jblkc * itcom6_1.kblsz;
	    lim1 = inc - (ndb + itcom6_1.ltrunc);
	    lim2 = inc + (ndt + itcom6_1.ltrunc);
	    i__2 = lim2;
	    for (j = lim1; j <= i__2; ++j) {
		if (jjc <= lbhbsa) {
		    i__3 = j2;
		    for (jj = j1; jj <= i__3; ++jj) {
			if (iwksp[jj] == j) {
			    goto L45;
			}
/* L40: */
		    }
		}
		iwksp[jnext] = j;
		++jnext;
		++iblock[jjc * 3 + 3];
L45:
		;
	    }
L50:
	    ;
	}
	if (cblock_2.lbhb >= 4) {
	    i__1 = cblock_2.lbhb;
	    for (jjc = 4; jjc <= i__1; ++jjc) {
/* L52: */
		iblock[jjc * 3 + 2] = iblock[(jjc - 1) * 3 + 2] + iblock[(jjc
			- 1) * 3 + 3];
	    }
	}
    }

/* ... copy matrix into wksp. */

    if (cblock_2.propa) {
	cfactr_1.nfactr = n * nwnew;
	cfactr_1.nfacti = cblock_2.lbhb * 3;
    }
    if (! cblock_2.propa && itcom6_1.lvfill == 0) {
	cfactr_1.nfactr = n * (dscons_1.maxnz + (itcom6_1.ltrunc << 1));
	cfactr_1.nfacti = cblock_2.lbhb * 3;
    }
    if (itcom6_1.lvfill > 0) {
	ndg = 0;
	i__1 = cblock_2.lbhb;
	for (j = 1; j <= i__1; ++j) {
/* L55: */
	    ndg += iblock[j * 3 + 3];
	}
	cfactr_1.nfactr = n * ndg;
	cfactr_1.nfacti = ndg + cblock_2.lbhb * 3;
    }
    needw_("fillbn", &c__0, &cfactr_1.ifactr, &cfactr_1.nfactr, ier, (ftnlen)
	    6);
    if (*ier < 0) {
	return 0;
    }
    needw_("fillbn", &c__1, &cfactr_1.ifacti, &cfactr_1.nfacti, ier, (ftnlen)
	    6);
    if (*ier < 0) {
	return 0;
    }
    vfill_(&cfactr_1.nfactr, &wksp[cfactr_1.ifactr], &c_b121);
    ipt1 = 1;
    ipt2 = cfactr_1.ifactr;
    i__1 = ndt + 1;
    for (j = 1; j <= i__1; ++j) {
	vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
	ipt1 += dscons_1.ndim;
	ipt2 += n;
/* L60: */
    }
    ipt2 += n * itcom6_1.ltrunc;
    i__1 = nwdiag;
    for (j = ndt + 2; j <= i__1; ++j) {
	vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
	ipt1 += dscons_1.ndim;
	ipt2 += n;
/* L61: */
    }
    point_1.iwkpt2 = cfactr_1.ifactr + n * nwnew;
    ipt2 = point_1.iwkpt2;
    if (! cblock_2.propa && itcom6_1.lvfill == 0) {
	i__1 = dscons_1.maxnz;
	for (j = nwdiag + 1; j <= i__1; ++j) {
	    vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
	    ipt1 += dscons_1.ndim;
	    ipt2 += n;
/* L62: */
	}
    }
    if (itcom6_1.lvfill > 0) {
	j1 = cwkcon_1.iipnt + nwnew;
	j2 = cwkcon_1.iipnt + ndg - 1;
	i__1 = dscons_1.maxnz;
	for (j = nwdiag + 1; j <= i__1; ++j) {
	    jcol = jcoef[j];
	    ipt1 = (j - 1) * dscons_1.ndim + 1;
	    i__2 = j2;
	    for (jj = j1; jj <= i__2; ++jj) {
		if (iwksp[jj] != jcol) {
		    goto L65;
		}
		ipt2 = point_1.iwkpt2 + (jj - j1) * n;
		vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
		goto L70;
L65:
		;
	    }
L70:
	    ;
	}
    }
    cwkcon_1.irpnt = cfactr_1.ifactr + cfactr_1.nfactr;
    cwkcon_1.iipnt = cfactr_1.ifacti + cfactr_1.nfacti;
    return 0;
} /* fillbn_ */

/* Subroutine */ int bfacmy_(integer *methf, S_fp factor, doublereal *coef,
	integer *jcoef, doublereal *wksp, integer *iwksp, integer *nn,
	integer *ier)
{
    static integer n, nwkp;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen);
    static integer nwnew;
    extern /* Subroutine */ int fillbc_(integer *, integer *, doublereal *,
	    integer *, integer *, doublereal *, integer *, integer *);
    static integer nwdiag;


/* ... bfacmy computes a block factorization. */
/*     (multicolor nonsymmetric diagonal) */

/* ... parameters */

/*       n       order of system */
/*       nfactr  amount of floating point workspace needed for factorization */
/*       ier     error flag */

/* ... specifications for parameters */



    /* Parameter adjustments */
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    if (*methf <= 2) {
	intern_1.ivers = 1;
    }
    if (*methf > 2) {
	intern_1.ivers = 2;
    }

/* ... calculate constants. */

    if (itcom6_1.ipropa == 0) {
	cblock_1.propa = FALSE_;
    }
    if (itcom6_1.ipropa == 1) {
	cblock_1.propa = TRUE_;
    }

/* ... calculate fill-in and factor. */

    fillbc_(&n, &cblock_1.ncolor, &coef[1], &jcoef[1], &iwksp[cblock_1.iblock]
	    , &wksp[1], &iwksp[1], ier);
    if (*ier < 0) {
	return 0;
    }
    nwdiag = intern_1.ndt + intern_1.ndb + 1;
    nwnew = nwdiag + (itcom6_1.ltrunc << 1);
    if (*methf == 1) {
	nwkp = cblock_1.ncmax * nwnew;
    }
    if (*methf == 2) {
	nwkp = cblock_1.ncmax * (nwnew + 1);
    }
    if (*methf == 3) {
	nwkp = 0;
    }
    if (*methf == 4) {
	nwkp = n + (cblock_1.ncmax << 1);
    }
    needw_("bfacmy", &c__0, &cwkcon_1.irpnt, &nwkp, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    if (cblock_1.propa) {
	(*factor)(&n, &dscons_1.ndim, &n, &iwksp[cwkcon_1.iipnt], &iwksp[
		cblock_1.jcnew + cblock_1.ncolor * nwdiag], &wksp[
		cfactr_1.ifactr], &coef[dscons_1.ndim * nwdiag + 1], &
		cblock_1.ncolor, &iwksp[cblock_1.nc], &iwksp[cblock_1.iblock],
		 &iwksp[cblock_1.lbhb], &c__0, &c__1, &iwksp[cblock_1.ipt], &
		itcom5_1.omega, &wksp[cwkcon_1.irpnt], ier);
    }
    if (! cblock_1.propa) {
	(*factor)(&n, &n, &n, &iwksp[cwkcon_1.iipnt], &iwksp[cblock_1.jcnew +
		cblock_1.ncolor * nwdiag], &wksp[cfactr_1.ifactr], &wksp[
		point_1.iwkpt2], &cblock_1.ncolor, &iwksp[cblock_1.nc], &
		iwksp[cblock_1.iblock], &iwksp[cblock_1.lbhb], &c__0, &c__0, &
		iwksp[cblock_1.ipt], &itcom5_1.omega, &wksp[cwkcon_1.irpnt],
		ier);
    }
    return 0;
} /* bfacmy_ */

/* Subroutine */ int fillbc_(integer *nn, integer *ncolor, doublereal *coef,
	integer *jcoef, integer *iblock, doublereal *wksp, integer *iwksp,
	integer *ier)
{
    /* System generated locals */
    integer iblock_dim2, iblock_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer j, n, ico, ipt1, ipt2;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), vfill_(integer *, doublereal *, doublereal *
	    );
    static integer nwnew;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *);
    static integer nwdiag;


/* ... fillbc sets ups wksp for block factorization methods. */
/*     (multicolor nonsymmetric diagonal) */

/* ... parameters -- */

/*       n       order of system */
/*       coef    floating point matrix coefficient array */
/*       jcoef   integer matrix coefficient array */
/*       iblock  array for block information */
/*       wksp    floating point workspace array */
/*       iwksp   integer workspace array */
/*       ier     error flag */

/* ... specifications for parameters */


    /* Parameter adjustments */
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --coef;
    --jcoef;
    --wksp;
    --iwksp;

    /* Function Body */
    n = *nn;

/* ... compute constants and check for sufficient workspace. */

    intern_1.ndt = 0;
    intern_1.ndb = 0;
    i__1 = *ncolor;
    for (j = 1; j <= i__1; ++j) {
/* Computing MAX */
	i__2 = intern_1.ndt, i__3 = iblock[(j + iblock_dim2) * 3 + 3] - 1;
	intern_1.ndt = max(i__2,i__3);
/* Computing MAX */
	i__2 = intern_1.ndb, i__3 = iblock[(j + (iblock_dim2 << 1)) * 3 + 3];
	intern_1.ndb = max(i__2,i__3);
/* L10: */
    }
    nwdiag = intern_1.ndt + intern_1.ndb + 1;
    nwnew = nwdiag + (itcom6_1.ltrunc << 1);
    cfactr_1.ifactr = cwkcon_1.irpnt;

/* ... copy matrix into wksp. */

    if (cblock_3.propa) {
	cfactr_1.nfactr = n * nwnew;
    }
    if (! cblock_3.propa) {
	cfactr_1.nfactr = n * nwnew + n * (cblock_3.maxd - nwdiag);
    }
    needw_("fillbc", &c__0, &cfactr_1.ifactr, &cfactr_1.nfactr, ier, (ftnlen)
	    6);
    if (*ier < 0) {
	return 0;
    }
    i__1 = nwnew * *ncolor;
    needw_("fillbc", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    vfill_(&cfactr_1.nfactr, &wksp[cfactr_1.ifactr], &c_b121);
    ipt1 = 1;
    ipt2 = cfactr_1.ifactr;
    i__1 = intern_1.ndt + 1;
    for (j = 1; j <= i__1; ++j) {
	vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
	ipt1 += dscons_1.ndim;
	ipt2 += n;
/* L15: */
    }
    ipt2 += n * itcom6_1.ltrunc;
    i__1 = nwdiag;
    for (j = intern_1.ndt + 2; j <= i__1; ++j) {
	vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
	ipt1 += dscons_1.ndim;
	ipt2 += n;
/* L20: */
    }
    point_1.iwkpt2 = cfactr_1.ifactr + n * nwnew;
    ipt2 = point_1.iwkpt2;
    if (! cblock_3.propa) {
	i__1 = cblock_3.maxd;
	for (j = nwdiag + 1; j <= i__1; ++j) {
	    vcopy_(&n, &coef[ipt1], &wksp[ipt2]);
	    ipt1 += dscons_1.ndim;
	    ipt2 += n;
/* L25: */
	}
    }
    cwkcon_1.irpnt = cfactr_1.ifactr + cfactr_1.nfactr;
    i__1 = *ncolor;
    for (ico = 1; ico <= i__1; ++ico) {
	i__2 = intern_1.ndt + itcom6_1.ltrunc + 1;
	for (j = 1; j <= i__2; ++j) {
/* L30: */
	    iwksp[cwkcon_1.iipnt + (j - 1) * *ncolor + ico - 1] = j - 1;
	}
	i__2 = nwnew;
	for (j = intern_1.ndt + itcom6_1.ltrunc + 2; j <= i__2; ++j) {
/* L35: */
	    iwksp[cwkcon_1.iipnt + (j - 1) * *ncolor + ico - 1] = -(j -
		    intern_1.ndt - itcom6_1.ltrunc - 1);
	}
/* L40: */
    }
    i__1 = *ncolor;
    for (ico = 1; ico <= i__1; ++ico) {
	iblock[(ico + iblock_dim2) * 3 + 3] = intern_1.ndt + itcom6_1.ltrunc
		+ 1;
	iblock[(ico + (iblock_dim2 << 1)) * 3 + 3] = intern_1.ndb +
		itcom6_1.ltrunc;
	iblock[(ico + (iblock_dim2 << 1)) * 3 + 2] = iblock[(ico +
		iblock_dim2) * 3 + 2] + iblock[(ico + iblock_dim2) * 3 + 3];
/* L45: */
    }
    return 0;
} /* fillbc_ */

/* Subroutine */ int blkdef_(doublereal *coef, integer *jcoef, doublereal *
	wksp, integer *iwksp, integer *nn, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer n;
    extern /* Subroutine */ int move5_(integer *, integer *, integer *,
	    integer *, doublereal *), needw_(char *, integer *, integer *,
	    integer *, integer *, ftnlen), defcon_(integer *, integer *,
	    integer *, integer *, doublereal *, integer *, integer *, integer
	    *);


/* ... blkdef defines various block constants for a constant */
/*     block size matrix. */

/* ... parameters -- */

/*        n        problem size */

/* ... common blocks */


    /* Parameter adjustments */
    --iwksp;
    --wksp;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;

    i__1 = (dscons_1.maxnz + 1) * 3;
    needw_("blkdef", &c__1, &cwkcon_1.iipnt, &i__1, ier, (ftnlen)6);
    if (*ier < 0) {
	return 0;
    }
    move5_(&dscons_1.ndim, &n, &dscons_1.maxnz, &jcoef[1], &coef[1]);
    if (itcom6_1.ifact == 0) {
	return 0;
    }
    cfactr_1.ifacti = cwkcon_1.iipnt;
    cblock_1.iblock = cfactr_1.ifacti;
    defcon_(&dscons_1.ndim, &n, &dscons_1.maxnz, &jcoef[1], &coef[1], &
	    itcom6_1.kblsz, &iwksp[cfactr_1.ifacti], &cblock_1.lbhb);
    cfactr_1.nfacti = cblock_1.lbhb * 3;
    cwkcon_1.iipnt = cfactr_1.ifacti + cblock_1.lbhb * 3;
    return 0;
} /* blkdef_ */

/* Subroutine */ int cg_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt, U_fp
	subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int cgw_(U_fp, U_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *, integer *, doublereal *,
	    integer *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen);



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    *ier = 0;
    i__1 = *n * 3 + (itcom1_1.itmax << 1);
    needw_("cg", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)2);
    if (*ier < 0) {
	return 0;
    }
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    cgw_((U_fp)suba, (U_fp)subql, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], n,
	     &u[1], &ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &nw, &iparm[1],
	    &rparm[1], ier);
    cwkcon_1.irmax = cwkcon_1.irpnt + nw - 1;
    return 0;
} /* cg_ */

/* Subroutine */ int si_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt, U_fp
	subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int siw_(U_fp, U_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *, integer *, doublereal *,
	    integer *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen);



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    *ier = 0;
    i__1 = *n << 2;
    needw_("si", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)2);
    if (*ier < 0) {
	return 0;
    }
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    siw_((U_fp)suba, (U_fp)subql, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], n,
	     &u[1], &ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &nw, &iparm[1],
	    &rparm[1], ier);
    cwkcon_1.irmax = cwkcon_1.irpnt + nw - 1;
    return 0;
} /* si_ */

/* Subroutine */ int srcg_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), srcgw_(U_fp, U_fp, U_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    *ier = 0;
    i__1 = *n * 3 + (itcom1_1.itmax << 1);
    needw_("srcg", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    srcgw_((U_fp)suba, (U_fp)subql, (U_fp)subadp, &coef[1], &jcoef[1], &wksp[
	    1], &iwksp[1], n, &u[1], &ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt],
	     &nw, &iparm[1], &rparm[1], ier);
    cwkcon_1.irmax = cwkcon_1.irpnt + nw - 1;
    return 0;
} /* srcg_ */

/* Subroutine */ int srsi_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int needw_(char *, integer *, integer *, integer *
	    , integer *, ftnlen), srsiw_(U_fp, U_fp, U_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    *ier = 0;
    i__1 = *n << 2;
    needw_("srsi", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)4);
    if (*ier < 0) {
	return 0;
    }
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    srsiw_((U_fp)suba, (U_fp)subql, (U_fp)subadp, &coef[1], &jcoef[1], &wksp[
	    1], &iwksp[1], n, &u[1], &ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt],
	     &nw, &iparm[1], &rparm[1], ier);
    cwkcon_1.irmax = cwkcon_1.irpnt + nw - 1;
    return 0;
} /* srsi_ */

/* Subroutine */ int sor_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int sorw_(U_fp, U_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *, integer *, doublereal *,
	    integer *), needw_(char *, integer *, integer *, integer *,
	    integer *, ftnlen);



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    *ier = 0;
    i__1 = *n << 1;
    needw_("sor", &c__0, &cwkcon_1.irpnt, &i__1, ier, (ftnlen)3);
    if (*ier < 0) {
	return 0;
    }
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    sorw_((U_fp)suba, (U_fp)subql, &coef[1], &jcoef[1], &wksp[1], &iwksp[1],
	    n, &u[1], &ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &nw, &iparm[1]
	    , &rparm[1], ier);
    cwkcon_1.irmax = cwkcon_1.irpnt + nw - 1;
    return 0;
} /* sor_ */

/* Subroutine */ int basic_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int basicw_(U_fp, U_fp, U_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    basicw_((U_fp)suba, (U_fp)subql, (U_fp)subqr, &coef[1], &jcoef[1], &wksp[
	    1], &iwksp[1], n, &u[1], &ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt],
	     &nw, &iparm[1], &rparm[1], ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* basic_ */

/* Subroutine */ int me_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt, U_fp
	subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *jcoef,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int mew_(U_fp, U_fp, U_fp, doublereal *, integer *
	    , doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *, integer *, doublereal *,
	    integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    mew_((U_fp)suba, (U_fp)subql, (U_fp)subqr, &coef[1], &jcoef[1], &wksp[1],
	    &iwksp[1], n, &u[1], &ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &
	    nw, &iparm[1], &rparm[1], ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* me_ */

/* Subroutine */ int odir_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int odirw_(U_fp, U_fp, U_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    odirw_((U_fp)suba, (U_fp)subql, (U_fp)subqr, &coef[1], &jcoef[1], &wksp[1]
	    , &iwksp[1], n, &u[1], &ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &
	    nw, &iparm[1], &rparm[1], ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* odir_ */

/* Subroutine */ int omin_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int ominw_(U_fp, U_fp, U_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    ominw_((U_fp)suba, (U_fp)subql, (U_fp)subqr, &coef[1], &jcoef[1], &wksp[1]
	    , &iwksp[1], n, &u[1], &ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &
	    nw, &iparm[1], &rparm[1], ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* omin_ */

/* Subroutine */ int ores_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int oresw_(U_fp, U_fp, U_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    oresw_((U_fp)suba, (U_fp)subql, (U_fp)subqr, &coef[1], &jcoef[1], &wksp[1]
	    , &iwksp[1], n, &u[1], &ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &
	    nw, &iparm[1], &rparm[1], ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* ores_ */

/* Subroutine */ int iom_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int iomw_(U_fp, U_fp, U_fp, doublereal *, integer
	    *, doublereal *, integer *, integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *, integer *, doublereal *,
	    integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    iomw_((U_fp)suba, (U_fp)subql, (U_fp)subqr, &coef[1], &jcoef[1], &wksp[1],
	     &iwksp[1], n, &u[1], &ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &
	    nw, &iparm[1], &rparm[1], ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* iom_ */

/* Subroutine */ int gmres_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int gmresw_(U_fp, U_fp, U_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    gmresw_((U_fp)suba, (U_fp)subql, (U_fp)subqr, &coef[1], &jcoef[1], &wksp[
	    1], &iwksp[1], n, &u[1], &ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt],
	     &nw, &iparm[1], &rparm[1], ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* gmres_ */

/* Subroutine */ int cgnr_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int cgnrw_(U_fp, U_fp, U_fp, U_fp, U_fp, U_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    cgnrw_((U_fp)suba, (U_fp)subat, (U_fp)subql, (U_fp)subqlt, (U_fp)subqr, (
	    U_fp)subqrt, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, &u[1], &
	    ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &nw, &iparm[1], &rparm[1]
	    , ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* cgnr_ */

/* Subroutine */ int lsqr_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int lsqrw_(U_fp, U_fp, U_fp, U_fp, U_fp, U_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    lsqrw_((U_fp)suba, (U_fp)subat, (U_fp)subql, (U_fp)subqlt, (U_fp)subqr, (
	    U_fp)subqrt, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, &u[1], &
	    ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &nw, &iparm[1], &rparm[1]
	    , ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* lsqr_ */

/* Subroutine */ int usymlq_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int uslqw_(U_fp, U_fp, U_fp, U_fp, U_fp, U_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    uslqw_((U_fp)suba, (U_fp)subat, (U_fp)subql, (U_fp)subqlt, (U_fp)subqr, (
	    U_fp)subqrt, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, &u[1], &
	    ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &nw, &iparm[1], &rparm[1]
	    , ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* usymlq_ */

/* Subroutine */ int usymqr_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int usqrw_(U_fp, U_fp, U_fp, U_fp, U_fp, U_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    usqrw_((U_fp)suba, (U_fp)subat, (U_fp)subql, (U_fp)subqlt, (U_fp)subqr, (
	    U_fp)subqrt, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, &u[1], &
	    ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &nw, &iparm[1], &rparm[1]
	    , ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* usymqr_ */

/* Subroutine */ int landir_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int ldirw_(U_fp, U_fp, U_fp, U_fp, U_fp, U_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    ldirw_((U_fp)suba, (U_fp)subat, (U_fp)subql, (U_fp)subqlt, (U_fp)subqr, (
	    U_fp)subqrt, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, &u[1], &
	    ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &nw, &iparm[1], &rparm[1]
	    , ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* landir_ */

/* Subroutine */ int lanmin_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int lminw_(U_fp, U_fp, U_fp, U_fp, U_fp, U_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    lminw_((U_fp)suba, (U_fp)subat, (U_fp)subql, (U_fp)subqlt, (U_fp)subqr, (
	    U_fp)subqrt, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, &u[1], &
	    ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &nw, &iparm[1], &rparm[1]
	    , ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* lanmin_ */

/* Subroutine */ int lanres_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int lresw_(U_fp, U_fp, U_fp, U_fp, U_fp, U_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    lresw_((U_fp)suba, (U_fp)subat, (U_fp)subql, (U_fp)subqlt, (U_fp)subqr, (
	    U_fp)subqrt, &coef[1], &jcoef[1], &wksp[1], &iwksp[1], n, &u[1], &
	    ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &nw, &iparm[1], &rparm[1]
	    , ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* lanres_ */

/* Subroutine */ int cgcr_(S_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wk, integer *iwk, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw, iv2;
    static logical ipl, iql, ipr, iqr;
    static integer nwgb, nbl0d, ierpp;
    extern /* Subroutine */ int tmult_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *), getblk_(
	    doublereal *, integer *, integer *, integer *, integer *,
	    doublereal *, integer *, integer *);
    extern /* Subroutine */ int cgcrpr_();
    extern /* Subroutine */ int omingw_(S_fp, U_fp, U_fp, U_fp, U_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *,
	     integer *, doublereal *, integer *);
    static integer irpsav;
    extern /* Subroutine */ int nullpl_();
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen), vexopy_(
	    integer *, doublereal *, doublereal *, doublereal *, integer *);


/* this routine implements the constrained residual method of */
/* j. r. wallis, coupled with truncated/restarted orthomin.  for */
/* further information about the algorithm, see "constrained residual */
/* acceleration of conjugate residual methods", by j. r. wallis, */
/* r. p. kendall and t. e. little of j. s. nolen and assocs. inc.; */
/* report spe 13536, society of petroleum engineers, 1985. */

/* right preconditioning only is allowed in this algorithm. */

/* unfortunately, this routine is limited -- all blocks must be the */
/* same size.  but the idea can be easily generalized. */



/* ... data common blocks */

/* time to proceed ... */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwk;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    if (itcom6_1.nstore != 2 && itcom6_1.nstore != 3) {
	goto L998;
    }

    irpsav = cwkcon_1.irpnt;
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;
    if (iql) {
	goto L998;
    }

    ipl = FALSE_;
    ipr = TRUE_;
    itcom1_1.iplr = 0;
    if (ipl) {
	++itcom1_1.iplr;
    }
    if (ipr) {
	itcom1_1.iplr += 2;
    }

/* form the c**(t)*a*c matrix */

/* L1: */
    if (itcom1_1.nbl1d <= 0 || itcom1_1.nbl2d <= 0) {
	goto L998;
    }
    nbl0d = 1;
    if (itcom1_1.nbl2d % itcom1_1.nbl1d != 0 || itcom1_1.nbl1d % nbl0d != 0) {
	goto L998;
    }
    ccgcr_1.nblk = *n / itcom1_1.nbl2d;
    if (ccgcr_1.nblk == 1) {
	ccgcr_1.nblk = *n / itcom1_1.nbl1d;
    }
    ccgcr_1.ictac = cwkcon_1.irpnt;
    nwgb = cwkcon_1.lenr - ccgcr_1.ictac + 1;
    ierpp = 0;
    getblk_(&coef[1], &jcoef[1], n, &ccgcr_1.nblk, &ccgcr_1.nband, &wk[
	    ccgcr_1.ictac], &nwgb, &ierpp);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = ccgcr_1.ictac - 1 + nwgb;
    cwkcon_1.irmax = max(i__1,i__2);
    if (ierpp < 0) {
	goto L999;
    }
    cwkcon_1.irpnt = ccgcr_1.ictac + ccgcr_1.nblk * ccgcr_1.nband;

/* perform first-iterate calculations */

    ccgcr_1.ieta = cwkcon_1.irpnt;
    ccgcr_1.ivcgcr = ccgcr_1.ieta + ccgcr_1.nblk;
    iv2 = ccgcr_1.ivcgcr + *n;
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = iv2 - 1 + *n;
    cwkcon_1.irmax = max(i__1,i__2);
    if (cwkcon_1.irmax > cwkcon_1.lenr) {
	goto L997;
    }

    (*suba)(&coef[1], &jcoef[1], &wk[1], &iwk[1], n, &u[1], &wk[
	    ccgcr_1.ivcgcr]);
    vexopy_(n, &wk[ccgcr_1.ivcgcr], &rhs[1], &wk[ccgcr_1.ivcgcr], &c__2);
    tmult_(n, &ccgcr_1.nblk, &ccgcr_1.nband, &wk[ccgcr_1.ictac], &wk[
	    ccgcr_1.ieta], &wk[ccgcr_1.ivcgcr], &wk[ccgcr_1.ivcgcr]);
    vexopy_(n, &u[1], &u[1], &wk[ccgcr_1.ivcgcr], &c__1);

/* pass it on to orthomin ... */

    cwkcon_1.irpnt = iv2;
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    omingw_((S_fp)suba, (U_fp)subql, (U_fp)subqr, (U_fp)nullpl_, (U_fp)
	    cgcrpr_, &coef[1], &jcoef[1], &wk[1], &iwk[1], n, &u[1], &ubar[1],
	     &rhs[1], &wk[cwkcon_1.irpnt], &nw, &iparm[1], &rparm[1], ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);

    cwkcon_1.irpnt = irpsav;
    return 0;

/* error returns ... */

/* insuff. floating point workspace ... */
L997:
    *ier = -2;
    ershow_(ier, "cgcr", (ftnlen)4);
    return 0;

/* unimplemented option ... */
L998:
    *ier = -16;
    ershow_(ier, "cgcr", (ftnlen)4);
    return 0;

/* generic handler ... */
L999:
    *ier = ierpp;
    return 0;
} /* cgcr_ */

/* Subroutine */ int bcgs_(U_fp suba, U_fp subat, U_fp subql, U_fp subqlt,
	U_fp subqr, U_fp subqrt, U_fp subadp, doublereal *coef, integer *
	jcoef, integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *wksp, integer *iwksp, integer *iparm, doublereal *rparm,
	integer *ier)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer nw;
    extern /* Subroutine */ int bcgsw_(U_fp, U_fp, U_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *,
	    doublereal *, integer *);



/* ... data common blocks */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --iwksp;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jcoef;
    --coef;

    /* Function Body */
    nw = cwkcon_1.lenr - cwkcon_1.irpnt + 1;
    bcgsw_((U_fp)suba, (U_fp)subql, (U_fp)subqr, &coef[1], &jcoef[1], &wksp[1]
	    , &iwksp[1], n, &u[1], &ubar[1], &rhs[1], &wksp[cwkcon_1.irpnt], &
	    nw, &iparm[1], &rparm[1], ier);
/* Computing MAX */
    i__1 = cwkcon_1.irmax, i__2 = cwkcon_1.irpnt - 1 + nw;
    cwkcon_1.irmax = max(i__1,i__2);
/* Computing MAX */
    i__1 = cwkcon_1.iimax, i__2 = cwkcon_1.iipnt - 1;
    cwkcon_1.iimax = max(i__1,i__2);
    return 0;
} /* bcgs_ */

/* Subroutine */ int cgw_(U_fp suba, U_fp subq, doublereal *coef, integer *
	jcoef, doublereal *wfac, integer *jwfac, integer *nn, doublereal *u,
	doublereal *ubar, doublereal *rhs, doublereal *wksp, integer *nw,
	integer *iparm, doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_10[] = "(1x,\002cg\002)";
    static char fmt_20[] = "(/1x,\002cg  has converged in \002,i5,\002 itera"
	    "tions\002)";

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer n;
    static doublereal t1, t2;
    static integer iw1, iw2, iw3, iw4;
    extern /* Subroutine */ int itcg_(U_fp, U_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *), vfill_(integer *, doublereal *,
	    doublereal *);
    extern doublereal timer_(doublereal *);
    static doublereal timit, dummy;
    static integer nwksp;
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *), nmcalc_(doublereal *, integer *,
	     doublereal *, integer *, integer *, U_fp, integer *, doublereal *
	    , doublereal *, doublereal *, integer *), ershow_(integer *, char
	    *, ftnlen), perror1_(U_fp, doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___579 = { 0, 0, 0, fmt_10, 0 };
    static cilist io___585 = { 0, 0, 0, fmt_20, 0 };



/*     cgw drives the conjugate gradient algorithm. */

/* ... parameters -- */

/*          suba   matrix-vector multiplication routine */
/*          subq   preconditioning routine */
/*          n      input integer.  order of the system (= nn) */
/*          u      input/output vector.  on input, u contains the */
/*                 initial guess to the solution.  on output, it */
/*                 contains the latest estimate to the solution. */
/*          ubar   input vector containing the true solution */
/*                  (optional) */
/*          rhs    input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*          wksp   vector used for working space. */
/*          nw     length of wksp array.  if this length is less than */
/*                  the amount needed, nw will give the needed amount */
/*                  upon output. */
/*          iparm  integer vector of length 30.  allows user to */
/*                 specify some integer parameters which affect */
/*                 the method. */
/*          rparm  floating point vector of length 30.  allows user to */
/*                 specify some floating point parameters which affect */
/*                 the method. */
/*          ier    output integer.  error flag. */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... initialize common blocks */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    *ier = 0;
    n = *nn;
    t1 = timer_(&dummy);
    itcom1_1.iacel = 1;
    timit = 0.;
    digit1 = 0.;
    digit2 = 0.;
    echall_(&n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L35;
    }
    if (itcom1_1.level >= 2) {
	io___579.ciunit = itcom1_1.nout;
	s_wsfe(&io___579);
	e_wsfe();
    }

/* ... compute workspace base addresses and check for sufficient */
/* ... workspace. */

    iw1 = 1;
    iw2 = iw1 + n;
    iw3 = iw2 + n;
    iw4 = iw3 + n;
    nwksp = n * 3 + (itcom1_1.itmax << 1);
    if (*nw >= nwksp) {
	goto L15;
    }
    *ier = -2;
    ershow_(ier, "cgw", (ftnlen)3);
    goto L30;
L15:
    nmcalc_(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &c__1, (U_fp)subq, &n, &
	    rhs[1], &ubar[1], &wksp[1], ier);
    if (*ier < 0) {
	goto L30;
    }

/* ... zero out workspace */

    vfill_(&nwksp, &wksp[1], &c_b121);

/* ... iteration sequence */

    itcg_((U_fp)suba, (U_fp)subq, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], &
	    n, &u[1], &ubar[1], &rhs[1], &wksp[iw1], &wksp[iw2], &wksp[iw3], &
	    wksp[iw4], ier);

    if (*ier < 0 || *ier == 1) {
	goto L25;
    }

/* ... method has converged */

    if (itcom1_1.level >= 1) {
	io___585.ciunit = itcom1_1.nout;
	s_wsfe(&io___585);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

/* ... optional error analysis */

L25:
    if (itcom1_1.idgts < 0) {
	goto L30;
    }
    perror1_((U_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &u[1],
	    &rhs[1], &wksp[1], &digit1, &digit2, &itcom1_1.idgts);

/* ... set return parameters in iparm and rparm */

L30:
    t2 = timer_(&dummy);
    *nw = n * 3 + (itcom1_1.in << 1);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
    rparm[9] = itcom5_1.omega;
    rparm[10] = itcom5_1.alphab;
    rparm[11] = itcom5_1.betab;
    rparm[12] = itcom5_1.specr;

L35:
    if (itcom1_1.level >= 3) {
	echall_(&n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }

    return 0;
} /* cgw_ */

/* Subroutine */ int siw_(S_fp suba, S_fp subq, doublereal *coef, integer *
	jcoef, doublereal *wfac, integer *jwfac, integer *nn, doublereal *u,
	doublereal *ubar, doublereal *rhs, doublereal *wksp, integer *nw,
	integer *iparm, doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_10[] = "(1x,\002si\002)";
    static char fmt_20[] = "(/1x,\002si  has converged in \002,i5,\002 itera"
	    "tions \002)";

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer n;
    static doublereal t1, t2, rq;
    static integer iw1, iw2, iw3, iw4;
    extern /* Subroutine */ int itsi_(S_fp, S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *);
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int vfill_(integer *, doublereal *, doublereal *);
    extern doublereal timer_(doublereal *);
    static doublereal timit, dummy;
    static integer nwksp;
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *), nmcalc_(doublereal *, integer *,
	     doublereal *, integer *, integer *, S_fp, integer *, doublereal *
	    , doublereal *, doublereal *, integer *), ershow_(integer *, char
	    *, ftnlen), perror1_(S_fp, doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___593 = { 0, 0, 0, fmt_10, 0 };
    static cilist io___600 = { 0, 0, 0, fmt_20, 0 };



/*     siw drives the chebyshev acceleration algorithm. */

/* ... parameters -- */

/*          suba   matrix-vector multiplication routine */
/*          subq   preconditioning routine */
/*          n      input integer.  order of the system (= nn) */
/*          u      input/output vector.  on input, u contains the */
/*                 initial guess to the solution.  on output, it */
/*                 contains the latest estimate to the solution. */
/*          ubar   input vector containing the true solution */
/*                  (optional) */
/*          rhs    input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*          wksp   vector used for working space. */
/*          nw     length of wksp array.  if this length is less than */
/*                  the amount needed, nw will give the needed amount */
/*                  upon output. */
/*          iparm  integer vector of length 30.  allows user to */
/*                 specify some integer parameters which affect */
/*                 the method. */
/*          rparm  floating point vector of length 30.  allows user to */
/*                 specify some floating point parameters which affect */
/*                 the method. */
/*          ier    output integer.  error flag. */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... initialize common blocks */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    *ier = 0;
    n = *nn;
    t1 = timer_(&dummy);
    itcom1_1.iacel = 2;
    timit = 0.;
    digit1 = 0.;
    digit2 = 0.;
    echall_(&n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L35;
    }
    if (itcom1_1.level >= 2) {
	io___593.ciunit = itcom1_1.nout;
	s_wsfe(&io___593);
	e_wsfe();
    }

/* ... compute workspace base addresses and check for sufficient */
/* ... workspace. */

    iw1 = 1;
    iw2 = iw1 + n;
    iw3 = iw2 + n;
    iw4 = iw3 + n;
    nwksp = n << 2;
    if (*nw >= nwksp) {
	goto L15;
    }
    *ier = -2;
    ershow_(ier, "siw", (ftnlen)3);
    goto L30;
L15:
    nmcalc_(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &c__1, (S_fp)subq, &n, &
	    rhs[1], &ubar[1], &wksp[1], ier);
    if (*ier < 0) {
	goto L30;
    }

/* ... compute an initial rayleigh quotient and adjust emax, emin. */

    vfill_(&n, &wksp[1], &c_b922);
    (*subq)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &wksp[1], &wksp[iw2]
	    );
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &wksp[iw2], &wksp[
	    iw3]);
    rq = vdot_(&n, &wksp[iw2], &wksp[iw3]) / vdot_(&n, &wksp[iw2], &wksp[1]);
    itcom3_1.rqmax = rq;
    itcom3_1.rqmin = rq;
    if (itcom2_1.maxadd) {
	itcom3_1.emax = max(itcom3_1.emax,itcom3_1.rqmax);
    }
    if (itcom2_1.minadd) {
	itcom3_1.emin = min(itcom3_1.emin,itcom3_1.rqmin);
    }
    if (itcom2_1.minadd) {
	itcom3_1.emin = max(itcom3_1.emin,0.);
    }

/* ... zero out workspace */

    vfill_(&nwksp, &wksp[1], &c_b121);

/* ... iteration sequence */

    itsi_((S_fp)suba, (S_fp)subq, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], &
	    n, &u[1], &ubar[1], &rhs[1], &wksp[iw1], &wksp[iw2], &wksp[iw3], &
	    wksp[iw4], ier);

    if (*ier < 0 || *ier == 1) {
	goto L25;
    }

/* ... method has converged */

    if (itcom1_1.level >= 1) {
	io___600.ciunit = itcom1_1.nout;
	s_wsfe(&io___600);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

/* ... optional error analysis */

L25:
    if (itcom1_1.idgts < 0) {
	goto L30;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &u[1],
	    &rhs[1], &wksp[1], &digit1, &digit2, &itcom1_1.idgts);

/* ... set return parameters in iparm and rparm */

L30:
    t2 = timer_(&dummy);
    *nw = n << 2;
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
    rparm[9] = itcom5_1.omega;
    rparm[10] = itcom5_1.alphab;
    rparm[11] = itcom5_1.betab;
    rparm[12] = itcom5_1.specr;

L35:
    if (itcom1_1.level >= 3) {
	echall_(&n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }

    return 0;
} /* siw_ */

/* Subroutine */ int srcgw_(S_fp suba, U_fp subq, U_fp subadp, doublereal *
	coef, integer *jcoef, doublereal *wfac, integer *jwfac, integer *nn,
	doublereal *u, doublereal *ubar, doublereal *rhs, doublereal *wksp,
	integer *nw, integer *iparm, doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_10[] = "(1x,\002srcg\002)";
    static char fmt_20[] = "(/1x,\002srcg has converged in \002,i5,\002 iter"
	    "ations\002)";

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer n;
    static doublereal t1, t2;
    static integer iw1, iw2, iw3, iw4;
    extern /* Subroutine */ int vfill_(integer *, doublereal *, doublereal *);
    extern doublereal timer_(doublereal *);
    static doublereal timit, dummy;
    static integer nwksp;
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *), itsrcg_(S_fp, U_fp, U_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *), ershow_(
	    integer *, char *, ftnlen), perror1_(S_fp, doublereal *, integer *
	    , doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___608 = { 0, 0, 0, fmt_10, 0 };
    static cilist io___614 = { 0, 0, 0, fmt_20, 0 };



/*     srcgw drives the ssor conjugate gradient algorithm. */

/* ... parameters -- */

/*          suba   matrix-vector multiplication routine */
/*          subq   preconditioning routine */
/*          subadp adpation routine */
/*          n      input integer.  order of the system (= nn) */
/*          u      input/output vector.  on input, u contains the */
/*                 initial guess to the solution.  on output, it */
/*                 contains the latest estimate to the solution. */
/*          ubar   input vector containing the true solution */
/*                  (optional) */
/*          rhs    input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*          wksp   vector used for working space. */
/*          nw     length of wksp array.  if this length is less than */
/*                  the amount needed, nw will give the needed amount */
/*                  upon output. */
/*          iparm  integer vector of length 30.  allows user to */
/*                 specify some integer parameters which affect */
/*                 the method. */
/*          rparm  floating point vector of length 30.  allows user to */
/*                 specify some floating point parameters which affect */
/*                 the method. */
/*          ier    output integer.  error flag. */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... initialize common blocks */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    *ier = 0;
    n = *nn;
    t1 = timer_(&dummy);
    itcom1_1.iacel = 1;
    timit = 0.;
    digit1 = 0.;
    digit2 = 0.;
    echall_(&n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L35;
    }
    if (itcom1_1.level >= 2) {
	io___608.ciunit = itcom1_1.nout;
	s_wsfe(&io___608);
	e_wsfe();
    }

/* ... compute workspace base addresses and check for sufficient */
/* ... workspace. */

    iw1 = 1;
    iw2 = iw1 + n;
    iw3 = iw2 + n;
    iw4 = iw3 + n;
    nwksp = n * 3 + (itcom1_1.itmax << 1);
    if (*nw >= nwksp) {
	goto L15;
    }
    *ier = -2;
    ershow_(ier, "srcgw", (ftnlen)5);
    goto L30;
L15:

/* ... zero out workspace */

    vfill_(&nwksp, &wksp[1], &c_b121);

/* ... iteration sequence */

    itsrcg_((S_fp)suba, (U_fp)subq, (U_fp)subadp, &coef[1], &jcoef[1], &wfac[
	    1], &jwfac[1], &n, &u[1], &ubar[1], &rhs[1], &wksp[iw1], &wksp[
	    iw2], &wksp[iw3], &wksp[iw4], ier);

    if (*ier < 0 || *ier == 1) {
	goto L25;
    }

/* ... method has converged */

    if (itcom1_1.level >= 1) {
	io___614.ciunit = itcom1_1.nout;
	s_wsfe(&io___614);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

/* ... optional error analysis */

L25:
    if (itcom1_1.idgts < 0) {
	goto L30;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &u[1],
	    &rhs[1], &wksp[1], &digit1, &digit2, &itcom1_1.idgts);

/* ... set return parameters in iparm and rparm */

L30:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    *nw = n * 3 + (itcom1_1.in << 1);
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
    rparm[9] = itcom5_1.omega;
    rparm[10] = itcom5_1.alphab;
    rparm[11] = itcom5_1.betab;
    rparm[12] = itcom5_1.specr;

L35:
    if (itcom1_1.level >= 3) {
	echall_(&n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }

    return 0;
} /* srcgw_ */

/* Subroutine */ int srsiw_(S_fp suba, S_fp subq, U_fp subadp, doublereal *
	coef, integer *jcoef, doublereal *wfac, integer *jwfac, integer *nn,
	doublereal *u, doublereal *ubar, doublereal *rhs, doublereal *wksp,
	integer *nw, integer *iparm, doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_10[] = "(1x,\002srsi\002)";
    static char fmt_20[] = "(/1x,\002srsi  has converged in \002,i5,\002 ite"
	    "rations \002)";

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer n;
    static doublereal t1, t2, rq;
    static integer iw1, iw2, iw3, iw4;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int vfill_(integer *, doublereal *, doublereal *);
    extern doublereal timer_(doublereal *);
    static doublereal timit, dummy;
    static integer nwksp;
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *), ershow_(integer *, char *,
	    ftnlen), itsrsi_(S_fp, S_fp, U_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *), perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___622 = { 0, 0, 0, fmt_10, 0 };
    static cilist io___629 = { 0, 0, 0, fmt_20, 0 };



/*     srsiw drives the ssor chebyshev acceleration algorithm. */

/* ... parameters -- */

/*          suba   matrix-vector multiplication routine */
/*          subq   preconditioning routine */
/*          subadp adpation routine */
/*          n      input integer.  order of the system (= nn) */
/*          u      input/output vector.  on input, u contains the */
/*                 initial guess to the solution.  on output, it */
/*                 contains the latest estimate to the solution. */
/*          ubar   input vector containing the true solution */
/*                  (optional) */
/*          rhs    input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*          wksp   vector used for working space. */
/*          nw     length of wksp array.  if this length is less than */
/*                  the amount needed, nw will give the needed amount */
/*                  upon output. */
/*          iparm  integer vector of length 30.  allows user to */
/*                 specify some integer parameters which affect */
/*                 the method. */
/*          rparm  floating point vector of length 30.  allows user to */
/*                 specify some floating point parameters which affect */
/*                 the method. */
/*          ier    output integer.  error flag. */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... initialize common blocks */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    *ier = 0;
    n = *nn;
    t1 = timer_(&dummy);
    itcom1_1.iacel = 2;
    timit = 0.;
    digit1 = 0.;
    digit2 = 0.;
    echall_(&n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L35;
    }
    if (itcom1_1.level >= 2) {
	io___622.ciunit = itcom1_1.nout;
	s_wsfe(&io___622);
	e_wsfe();
    }

/* ... compute workspace base addresses and check for sufficient */
/* ... workspace. */

    iw1 = 1;
    iw2 = iw1 + n;
    iw3 = iw2 + n;
    iw4 = iw3 + n;
    nwksp = n << 2;
    if (*nw >= nwksp) {
	goto L15;
    }
    *ier = -2;
    ershow_(ier, "srsiw", (ftnlen)5);
    goto L30;
L15:

/* ... compute an initial rayleigh quotient and adjust emax, emin. */

    vfill_(&n, &wksp[1], &c_b922);
    (*subq)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &wksp[1], &wksp[iw2]
	    );
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &wksp[iw2], &wksp[
	    iw3]);
    rq = vdot_(&n, &wksp[iw2], &wksp[iw3]) / vdot_(&n, &wksp[iw2], &wksp[1]);
    itcom3_1.rqmax = 1.;
    itcom3_1.rqmin = rq;

/* ... adjust emax, emin. */

    itcom3_1.emax = 1.;
    itcom2_1.maxadd = FALSE_;
    if (itcom2_1.minadd) {
	itcom3_1.emin = min(itcom3_1.emin,itcom3_1.rqmin);
    }
    if (itcom2_1.minadd) {
	itcom3_1.emin = max(itcom3_1.emin,0.);
    }

/* ... zero out workspace */

    vfill_(&nwksp, &wksp[1], &c_b121);

/* ... iteration sequence */

    itsrsi_((S_fp)suba, (S_fp)subq, (U_fp)subadp, &coef[1], &jcoef[1], &wfac[
	    1], &jwfac[1], &n, &u[1], &ubar[1], &rhs[1], &wksp[iw1], &wksp[
	    iw2], &wksp[iw3], &wksp[iw4], ier);

    if (*ier < 0 || *ier == 1) {
	goto L25;
    }

/* ... method has converged */

    if (itcom1_1.level >= 1) {
	io___629.ciunit = itcom1_1.nout;
	s_wsfe(&io___629);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

/* ... optional error analysis */

L25:
    if (itcom1_1.idgts < 0) {
	goto L30;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &u[1],
	    &rhs[1], &wksp[1], &digit1, &digit2, &itcom1_1.idgts);

/* ... set return parameters in iparm and rparm */

L30:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    *nw = n << 2;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
    rparm[9] = itcom5_1.omega;
    rparm[10] = itcom5_1.alphab;
    rparm[11] = itcom5_1.betab;
    rparm[12] = itcom5_1.specr;

L35:
    if (itcom1_1.level >= 3) {
	echall_(&n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }

    return 0;
} /* srsiw_ */

/* Subroutine */ int sorw_(S_fp suba, U_fp subq, doublereal *coef, integer *
	jcoef, doublereal *wfac, integer *jwfac, integer *nn, doublereal *u,
	doublereal *ubar, doublereal *rhs, doublereal *wksp, integer *nw,
	integer *iparm, doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_10[] = "(1x,\002sor\002)";
    static char fmt_20[] = "(/1x,\002sor  has converged in \002,i5,\002 iter"
	    "ations\002)";

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer n;
    static doublereal t1, t2;
    extern /* Subroutine */ int vfill_(integer *, doublereal *, doublereal *);
    extern doublereal timer_(doublereal *);
    static doublereal timit, dummy;
    extern /* Subroutine */ int itsor_(U_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *);
    static integer nwksp;
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *), ershow_(integer *, char *,
	    ftnlen), perror1_(S_fp, doublereal *, integer *, doublereal *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___637 = { 0, 0, 0, fmt_10, 0 };
    static cilist io___639 = { 0, 0, 0, fmt_20, 0 };



/*     sorw drives the successive over-relaxation algorithm. */

/* ... parameters -- */

/*          suba   matrix-vector multiplication routine */
/*          subq   routine to do an sor pass */
/*          n      input integer.  order of the system (= nn) */
/*          u      input/output vector.  on input, u contains the */
/*                 initial guess to the solution.  on output, it */
/*                 contains the latest estimate to the solution. */
/*          ubar   input vector containing the true solution */
/*                  (optional) */
/*          rhs    input vector.  contains the right hand side */
/*                 of the matrix problem. */
/*          wksp   vector used for working space. */
/*          nw     length of wksp array.  if this length is less than */
/*                  the amount needed, nw will give the needed amount */
/*                  upon output. */
/*          iparm  integer vector of length 30.  allows user to */
/*                 specify some integer parameters which affect */
/*                 the method. */
/*          rparm  floating point vector of length 30.  allows user to */
/*                 specify some floating point parameters which affect */
/*                 the method. */
/*          ier    output integer.  error flag. */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/* ... initialize common blocks */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    *ier = 0;
    n = *nn;
    t1 = timer_(&dummy);
    itcom1_1.iacel = 3;
    timit = 0.;
    digit1 = 0.;
    digit2 = 0.;
    echall_(&n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L35;
    }
    if (itcom1_1.level >= 2) {
	io___637.ciunit = itcom1_1.nout;
	s_wsfe(&io___637);
	e_wsfe();
    }

/* ... compute workspace base addresses and check for sufficient */
/* ... workspace. */

    nwksp = n << 1;
    if (*nw >= nwksp) {
	goto L15;
    }
    *ier = -2;
    ershow_(ier, "sorw", (ftnlen)4);
    goto L30;

/* ... zero out workspace */

L15:
    vfill_(&nwksp, &wksp[1], &c_b121);

/* ... iteration sequence */

    itsor_((U_fp)subq, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &u[1], &
	    ubar[1], &rhs[1], &wksp[1], ier);

    if (*ier < 0 || *ier == 1) {
	goto L25;
    }

/* ... method has converged */

    if (itcom1_1.level >= 1) {
	io___639.ciunit = itcom1_1.nout;
	s_wsfe(&io___639);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

/* ... optional error analysis */

L25:
    if (itcom1_1.idgts < 0) {
	goto L30;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &u[1],
	    &rhs[1], &wksp[1], &digit1, &digit2, &itcom1_1.idgts);

/* ... set return parameters in iparm and rparm */

L30:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    *nw = n << 1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
    rparm[9] = itcom5_1.omega;
    rparm[10] = itcom5_1.alphab;
    rparm[11] = itcom5_1.betab;
    rparm[12] = itcom5_1.specr;

L35:
    if (itcom1_1.level >= 3) {
	echall_(&n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }

    return 0;
} /* sorw_ */

/* Subroutine */ int itcg_(S_fp suba, S_fp subq, doublereal *coef, integer *
	jcoef, doublereal *wfac, integer *jwfac, integer *nn, doublereal *u,
	doublereal *ubar, doublereal *rhs, doublereal *r__, doublereal *p,
	doublereal *z__, doublereal *tri, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int iterm_(integer *, doublereal *), chgcon_(
	    doublereal *, integer *), ershow_(integer *, char *, ftnlen),
	    pstops_(integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *);


/*     itcg does the conjugate gradient iterations. */

/* ... parameters -- */

/*         suba      matrix-vector multiplication routine */
/*         subq      preconditioning routine */
/*         n         order of system (= nn) */
/*         u         current solution */
/*         ubar      known solution (optional) */
/*         rhs       right hand side vector */
/*         r,p,z     workspace vectors of length n each */
/*         tri       tridiagonal matrix associated with the */
/*                    eigenvalues of the tridiagonal matrix. */
/*         ier       error code */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --tri;
    --z__;
    --p;
    --r__;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    itcom1_1.in = 0;
    itcom1_1.is = 0;
    itcom9_1.rzdot = 0.;
    itcom3_1.alpha = 0.;
    itcom3_1.beta = 0.;
    itcom3_1.alphao = 0.;
    itcom2_1.maxadp = itcom2_1.maxadd;
    itcom2_1.minadp = itcom2_1.minadd;

/*     compute r = residual */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &u[1], &r__[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	r__[i__] = rhs[i__] - r__[i__];
    }
    goto L25;

/* ***** begin iteration loop ***** */

L15:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	r__[i__] -= itcom3_1.alpha * z__[i__];
    }

/* ... do preconditioning step -- solve q*z = r for z. */

L25:
    (*subq)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &r__[1], &z__[1]);

/* ... compute rzdot = (r,z) */

    itcom3_1.dkm1 = itcom9_1.rzdot;
    itcom9_1.rzdot = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	itcom9_1.rzdot += r__[i__] * z__[i__];
    }
    if (itcom9_1.rzdot > 0.) {
	goto L35;
    }
    *ier = -7;
    ershow_(ier, "itcg", (ftnlen)4);
    return 0;

/* ... determine whether or not to stop. */

L35:
    pstops_(&n, &r__[1], &z__[1], &u[1], &ubar[1], ier);
    if (itcom1_1.level >= 2) {
	iterm_(&n, &u[1]);
    }
    if (itcom2_1.halt || *ier < 0) {
	return 0;
    }
    if (itcom1_1.in < itcom1_1.itmax) {
	goto L40;
    }
    *ier = 1;
    ershow_(ier, "itcg", (ftnlen)4);
    itcom3_1.zeta = itcom3_1.stptst;
    return 0;

/* ... compute   beta = rzdot/dkm1 */

L40:
    if (itcom1_1.in == 0) {
	goto L45;
    }
    itcom3_1.beta = itcom9_1.rzdot / itcom3_1.dkm1;

/* ... compute   p = z + beta*p */

L45:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L50: */
	p[i__] = z__[i__] + itcom3_1.beta * p[i__];
    }

/* ... compute   alpha = rzdot / (p,a*p) */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &p[1], &z__[1]);
    itcom3_1.alphao = itcom3_1.alpha;
    itcom3_1.pap = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L55: */
	itcom3_1.pap += p[i__] * z__[i__];
    }
    itcom3_1.alpha = itcom9_1.rzdot / itcom3_1.pap;
    if (itcom3_1.pap > 0.) {
	goto L60;
    }
    *ier = -6;
    ershow_(ier, "itcg", (ftnlen)4);
    return 0;

/* ... compute latest eigenvalue estimates. */

L60:
    if (itcom2_1.maxadp || itcom2_1.minadp) {
	chgcon_(&tri[1], ier);
    }

/* ... compute new solution   u = u + alpha*p */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L65: */
	u[i__] += itcom3_1.alpha * p[i__];
    }
    ++itcom1_1.in;
    ++itcom1_1.is;
    goto L15;
} /* itcg_ */

/* Subroutine */ int itsi_(S_fp suba, S_fp subq, doublereal *coef, integer *
	jcoef, doublereal *wfac, integer *jwfac, integer *nn, doublereal *u,
	doublereal *ubar, doublereal *rhs, doublereal *r__, doublereal *p,
	doublereal *z__, doublereal *wksp, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, n;
    static doublereal term;
    static integer icode;
    extern /* Subroutine */ int chgsi_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    integer *, integer *), parsi_(void), iterm_(integer *, doublereal
	    *), ershow_(integer *, char *, ftnlen), pstops_(integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *, integer *)
	    ;


/*     itsi does the semi-iterative iterations. */

/* ... parameters -- */

/*         suba      matrix-vector multiplication routine */
/*         subq      preconditioning routine */
/*         n         order of system (= nn) */
/*         u         current solution */
/*         ubar      known solution (optional) */
/*         rhs       right hand side vector */
/*         r,p,z,    workspace vectors of length n each */
/*         wksp      volatile workspace */
/*         ier       error code */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --wksp;
    --z__;
    --p;
    --r__;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    itcom1_1.in = 0;

/* ... new chebychev sequence. */

L10:
    itcom1_1.is = 0;
    itcom3_1.alpha = 0.;
    itcom3_1.beta = 0.;
    itcom3_1.rho = 1.;
    itcom9_1.rzdot = 0.;
    itcom3_1.gamma = 2. / (itcom3_1.emax + itcom3_1.emin);
    itcom3_1.sigma = (itcom3_1.emax - itcom3_1.emin) / (itcom3_1.emax +
	    itcom3_1.emin);
    term = sqrt(1. - itcom3_1.sigma * itcom3_1.sigma);
    itcom3_1.rr = (1. - term) / (term + 1.);
    itcom2_1.maxadp = itcom2_1.maxadd;
    itcom2_1.minadp = itcom2_1.minadd;

/*     compute r = residual */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &u[1], &r__[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	r__[i__] = rhs[i__] - r__[i__];
    }
    goto L30;

/* ***** begin iteration loop ***** */

L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	r__[i__] -= itcom3_1.alpha * z__[i__];
    }

/* ... do preconditioning step -- solve q*z = r for z. */

L30:
    (*subq)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &r__[1], &z__[1]);

/* ... compute rzdot = (r,z) */

    itcom3_1.dkm1 = itcom9_1.rzdot;
    itcom9_1.rzdot = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L35: */
	itcom9_1.rzdot += r__[i__] * z__[i__];
    }
    if (itcom1_1.is == 0) {
	itcom3_1.dkq = itcom9_1.rzdot;
    }
    if (itcom9_1.rzdot >= 0.) {
	goto L40;
    }
    *ier = -7;
    ershow_(ier, "itsi", (ftnlen)4);
    return 0;

/* ... determine whether or not to stop. */

L40:
    pstops_(&n, &r__[1], &z__[1], &u[1], &ubar[1], ier);
    if (itcom1_1.level >= 2) {
	iterm_(&n, &u[1]);
    }
    if (itcom2_1.halt || *ier < 0) {
	return 0;
    }
    if (itcom1_1.in < itcom1_1.itmax) {
	goto L45;
    }
    *ier = 1;
    ershow_(ier, "itsi", (ftnlen)4);
    itcom3_1.zeta = itcom3_1.stptst;
    return 0;

/* ... compute iteration parameters. */

L45:
    parsi_();

/* ... compute   p = z + beta*p */
/* ...           u = u + alpha*p */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	p[i__] = z__[i__] + itcom3_1.beta * p[i__];
	u[i__] += itcom3_1.alpha * p[i__];
/* L50: */
    }

/* ... adapt on emin and emax */

    ++itcom1_1.in;
    if (! itcom2_1.maxadp && ! itcom2_1.minadp) {
	goto L55;
    }
    chgsi_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &z__[1],
	    &wksp[1], &icode, ier);
    if (*ier < 0) {
	return 0;
    }

/* ... check if new estimates of emax, emin are to be used. */

    if (icode == 1) {
	goto L10;
    }

/* ... estimates of emax, emin are still good. */

L55:
    ++itcom1_1.is;
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &p[1], &z__[1]);
    goto L20;
} /* itsi_ */

/* Subroutine */ int itsrcg_(S_fp suba, S_fp subq, U_fp subadp, doublereal *
	coef, integer *jcoef, doublereal *wfac, integer *jwfac, integer *nn,
	doublereal *u, doublereal *ubar, doublereal *rhs, doublereal *r__,
	doublereal *p, doublereal *z__, doublereal *tri, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n, isw, icode;
    extern /* Subroutine */ int iterm_(integer *, doublereal *), nmcalc_(
	    doublereal *, integer *, doublereal *, integer *, integer *, S_fp,
	     integer *, doublereal *, doublereal *, doublereal *, integer *),
	    chgcon_(doublereal *, integer *), ssorad_(U_fp, doublereal *,
	    integer *, doublereal *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, integer *), ershow_(integer *, char *,
	     ftnlen), pstops_(integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *);


/*     itsrcg does the ssor conjugate gradient iterations. */

/* ... parameters -- */

/*         suba      matrix-vector multiplication routine */
/*         subq      preconditioning routine */
/*         subadp    adpation routine */
/*         n         order of system (= nn) */
/*         u         current solution */
/*         ubar      known solution (optional) */
/*         rhs       right hand side vector */
/*         r,p,z     workspace vectors of length n each */
/*         tri       tridiagonal matrix associated with the */
/*                    eigenvalues of the tridiagonal matrix. */
/*         ier       error code */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --tri;
    --z__;
    --p;
    --r__;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    itcom1_1.in = 0;
    isw = 1;
L5:
    itcom1_1.is = 0;
    itcom9_1.rzdot = 0.;
    itcom3_1.alpha = 0.;
    itcom3_1.beta = 0.;
    itcom3_1.alphao = 0.;
    itcom2_1.maxadp = itcom2_1.maxadd;
    itcom2_1.minadp = itcom2_1.minadd;

/*     recompute bnorm */

    nmcalc_(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &isw, (S_fp)subq, &n, &
	    rhs[1], &ubar[1], &r__[1], ier);
    if (*ier < 0) {
	return 0;
    }
    isw = 2;

/*     compute r = residual */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &u[1], &r__[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	r__[i__] = rhs[i__] - r__[i__];
    }
    goto L25;

/* ***** begin iteration loop ***** */

L15:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	r__[i__] -= itcom3_1.alpha * z__[i__];
    }

/* ... do preconditioning step -- solve q*z = r for z. */

L25:
    (*subq)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &r__[1], &z__[1]);

/* ... compute rzdot = (r,z) */

    itcom3_1.dkm1 = itcom9_1.rzdot;
    itcom9_1.rzdot = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	itcom9_1.rzdot += r__[i__] * z__[i__];
    }
    if (itcom9_1.rzdot >= 0.) {
	goto L35;
    }
    *ier = -7;
    ershow_(ier, "itsrcg", (ftnlen)6);
    return 0;

/* ... determine whether or not to stop. */

L35:
    pstops_(&n, &r__[1], &z__[1], &u[1], &ubar[1], ier);
    if (itcom1_1.level >= 2) {
	iterm_(&n, &u[1]);
    }
    if (itcom2_1.halt || *ier < 0) {
	return 0;
    }
    if (itcom1_1.in < itcom1_1.itmax) {
	goto L40;
    }
    *ier = 1;
    ershow_(ier, "itsrcg", (ftnlen)6);
    itcom3_1.zeta = itcom3_1.stptst;
    return 0;

/* ... compute   beta = rzdot/dkm1 */

L40:
    if (itcom1_1.is == 0) {
	goto L45;
    }
    itcom3_1.beta = itcom9_1.rzdot / itcom3_1.dkm1;

/* ... compute   p = z + beta*p */

L45:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L50: */
	p[i__] = z__[i__] + itcom3_1.beta * p[i__];
    }

/* ... compute   alpha = rzdot / (p,a*p) */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &p[1], &z__[1]);
    itcom3_1.alphao = itcom3_1.alpha;
    itcom3_1.pap = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L55: */
	itcom3_1.pap += p[i__] * z__[i__];
    }
    itcom3_1.alpha = itcom9_1.rzdot / itcom3_1.pap;
    if (itcom3_1.pap >= 0.) {
	goto L60;
    }
    *ier = -6;
    ershow_(ier, "itsrcg", (ftnlen)6);
    return 0;

/* ... compute latest eigenvalue estimates. */

L60:
    if (itcom2_1.minadp) {
	chgcon_(&tri[1], ier);
    }

/* ... compute new solution   u = u + alpha*p */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L65: */
	u[i__] += itcom3_1.alpha * p[i__];
    }
    ++itcom1_1.is;
    ++itcom1_1.in;
    ssorad_((U_fp)subadp, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &p[1],
	     &z__[1], &r__[1], &icode);
    if (icode == 0) {
	goto L15;
    }
    goto L5;
} /* itsrcg_ */

/* Subroutine */ int itsrsi_(S_fp suba, S_fp subq, U_fp subadp, doublereal *
	coef, integer *jcoef, doublereal *wfac, integer *jwfac, integer *nn,
	doublereal *u, doublereal *ubar, doublereal *rhs, doublereal *r__,
	doublereal *p, doublereal *z__, doublereal *wksp, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, n;
    static doublereal rq;
    static integer isw;
    static doublereal term;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static integer icode;
    extern /* Subroutine */ int chgsi_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    integer *, integer *), parsi_(void), iterm_(integer *, doublereal
	    *), nmcalc_(doublereal *, integer *, doublereal *, integer *,
	    integer *, S_fp, integer *, doublereal *, doublereal *,
	    doublereal *, integer *), ssorad_(U_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, integer *), ershow_(integer *, char *, ftnlen),
	    pstops_(integer *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *);


/*     itsrsi does the ssor semi-iterative iterations. */

/* ... parameters -- */

/*         suba      matrix-vector multiplication routine */
/*         subq      preconditioning routine */
/*         subadp    adpation routine */
/*         n         order of system (= nn) */
/*         u         current solution */
/*         ubar      known solution (optional) */
/*         rhs       right hand side vector */
/*         r,p,z,    workspace vectors of length n each */
/*         wksp      volatile workspace */
/*         ier       error code */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --wksp;
    --z__;
    --p;
    --r__;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;

    itcom1_1.in = 0;
    isw = 1;

/*     recompute bnorm */

L5:
    nmcalc_(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &isw, (S_fp)subq, &n, &
	    rhs[1], &ubar[1], &r__[1], ier);
    if (*ier < 0) {
	return 0;
    }
    isw = 2;

/* ... update rayleigh quotient . */

    if (itcom1_1.in == 0) {
	goto L10;
    }
    (*subq)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &p[1], &z__[1]);
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &z__[1], &r__[1]);
    rq = vdot_(&n, &z__[1], &r__[1]) / vdot_(&n, &z__[1], &p[1]);
    itcom3_1.rqmin = rq;
    if (itcom2_1.minadd) {
	itcom3_1.emin = itcom3_1.rqmin;
    }

/* ... new chebychev sequence. */

L10:
    itcom1_1.is = 0;
    itcom3_1.alpha = 0.;
    itcom3_1.beta = 0.;
    itcom3_1.rho = 1.;
    itcom9_1.rzdot = 0.;
    itcom3_1.gamma = 2. / (itcom3_1.emax + itcom3_1.emin);
    itcom3_1.sigma = (itcom3_1.emax - itcom3_1.emin) / (itcom3_1.emax +
	    itcom3_1.emin);
    term = sqrt(1. - itcom3_1.sigma * itcom3_1.sigma);
    itcom3_1.rr = (1. - term) / (term + 1.);
    itcom2_1.minadp = itcom2_1.minadd;

/*     compute r = residual */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &u[1], &r__[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	r__[i__] = rhs[i__] - r__[i__];
    }
    goto L30;

/* ***** begin iteration loop ***** */

L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	r__[i__] -= itcom3_1.alpha * z__[i__];
    }

/* ... do preconditioning step -- solve q*z = r for z. */

L30:
    (*subq)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &r__[1], &z__[1]);

/* ... compute rzdot = (r,z) */

    itcom3_1.dkm1 = itcom9_1.rzdot;
    itcom9_1.rzdot = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L35: */
	itcom9_1.rzdot += r__[i__] * z__[i__];
    }
    if (itcom1_1.is == 0) {
	itcom3_1.dkq = itcom9_1.rzdot;
    }
    if (itcom9_1.rzdot >= 0.) {
	goto L40;
    }
    *ier = -7;
    ershow_(ier, "itsrsi", (ftnlen)6);
    return 0;

/* ... determine whether or not to stop. */

L40:
    pstops_(&n, &r__[1], &z__[1], &u[1], &ubar[1], ier);
    if (itcom1_1.level >= 2) {
	iterm_(&n, &u[1]);
    }
    if (itcom2_1.halt || *ier < 0) {
	return 0;
    }
    if (itcom1_1.in < itcom1_1.itmax) {
	goto L45;
    }
    *ier = 1;
    ershow_(ier, "itsrsi", (ftnlen)6);
    itcom3_1.zeta = itcom3_1.stptst;
    return 0;

/* ... compute iteration parameters. */

L45:
    parsi_();

/* ... compute   p = z + beta*p */
/* ...           u = u + alpha*p */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	p[i__] = z__[i__] + itcom3_1.beta * p[i__];
	u[i__] += itcom3_1.alpha * p[i__];
/* L50: */
    }

/* ... adapt on emin and emax */

    ++itcom1_1.in;
    if (! itcom2_1.minadp) {
	goto L55;
    }
    chgsi_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &z__[1],
	    &wksp[1], &icode, ier);
    if (*ier < 0) {
	return 0;
    }

/* ... check if new estimates of emax, emin are to be used. */

    if (icode == 1) {
	goto L10;
    }

/* ... estimates of emax, emin are still good. */

L55:
    ++itcom1_1.is;
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &p[1], &z__[1]);
    ssorad_((U_fp)subadp, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &p[1],
	     &z__[1], &r__[1], &icode);
    if (icode == 0) {
	goto L20;
    }
    goto L5;
} /* itsrsi_ */

/* Subroutine */ int itsor_(S_fp subq, doublereal *coef, integer *jcoef,
	doublereal *wfac, integer *jwfac, integer *nn, doublereal *u,
	doublereal *ubar, doublereal *rhs, doublereal *wksp, integer *ier)
{
    /* System generated locals */
    integer i__1, i__2, i__3;
    doublereal d__1, d__2;

    /* Builtin functions */
    double sqrt(doublereal), pow_dd(doublereal *, doublereal *);

    /* Local variables */
    static doublereal h__;
    static integer i__, n, ip, ib2;
    extern doublereal tau_(integer *);
    static integer iss;
    static doublereal sum, dnrm;
    static integer iter, iphat;
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    extern integer ipstr_(doublereal *);
    static doublereal spcrm1;
    static logical change;
    static doublereal omegap, delnnm, delsnm;
    static integer ipstar;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen), sorstp_(
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... itsor does the sor iterations */

/* ... parameters -- */

/*          subq   routine to do an sor pass */
/*          n      size of system */
/*          rhs    right hand side */
/*          u      solution vector */
/*          ubar   known solution (optional) */
/*          wksp   workspace vector of length 2*n */

/* ... specifications for parameters */


/* *** begin -- itpack common */


/* *** end   -- itpack common */


/* ... set initial parameters not already set */

    /* Parameter adjustments */
    --wksp;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    itcom1_1.in = 0;
    itcom1_1.is = 0;
    ip = 0;
    iss = 0;
    iphat = 2;
    delnnm = 0.;
    delsnm = 0.;
    sorstp_(&n, &u[1], &ubar[1], &c_b121, &c_b121);
    change = itcom5_1.omgadp;
    ib2 = n + 1;
    if (! itcom5_1.omgadp) {
	goto L10;
    }
    omegap = itcom5_1.omega;
    itcom5_1.omega = 1.;
    ipstar = 4;
    if (omegap <= 1.) {
	change = FALSE_;
    }

/* ... start iterating. */

L10:
    i__1 = itcom1_1.itmax + 1;
    for (iter = 1; iter <= i__1; ++iter) {

/* ... output intermediate information */

	if (itcom1_1.level >= 2) {
	    iterm_(&n, &u[1]);
	}
	if (itcom2_1.halt) {
	    return 0;
	}
	if (! change) {
	    goto L15;
	}
	change = FALSE_;
	++itcom1_1.is;
	ip = 0;
	iss = 0;
/* Computing MIN */
	d__1 = omegap, d__2 = tau_(&itcom1_1.is);
	itcom5_1.omega = min(d__1,d__2);
/* Computing MAX */
	i__2 = 3, i__3 = (integer) ((itcom5_1.omega - 1.) / (2. -
		itcom5_1.omega));
	iphat = max(i__2,i__3);
	ipstar = ipstr_(&itcom5_1.omega);

/* ... compute u (in + 1) and norm of del(s,p) */

L15:
	delsnm = delnnm;
	spcrm1 = itcom5_1.specr;
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L20: */
	    wksp[i__] = rhs[i__];
	}
	(*subq)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &u[1], &wksp[1],
		 &wksp[ib2]);
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L25: */
	    wksp[i__] = u[i__] - wksp[n + i__];
	}
	sum = 0.;
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L28: */
	    sum += wksp[i__] * wksp[i__];
	}
	delnnm = sqrt(sum);
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L30: */
	    u[i__] = wksp[i__ + n];
	}
	if (delnnm == 0.) {
	    goto L35;
	}
	if (itcom1_1.in != 0) {
	    itcom5_1.specr = delnnm / delsnm;
	}
	if (ip < iphat) {
	    goto L50;
	}

/* ... stopping test, set h */

	if (itcom5_1.specr >= 1.) {
	    goto L50;
	}
	if (! (itcom5_1.specr > itcom5_1.omega - 1.)) {
	    goto L35;
	}
	h__ = itcom5_1.specr;
	goto L40;
L35:
	++iss;
	h__ = itcom5_1.omega - 1.;

/* ... perform stopping test. */

L40:
/* Computing 2nd power */
	d__1 = delnnm;
	dnrm = d__1 * d__1;
	sorstp_(&n, &u[1], &ubar[1], &dnrm, &h__);
	if (itcom2_1.halt) {
	    goto L50;
	}

/* ... method has not converged yet, test for changing omega */

	if (! itcom5_1.omgadp) {
	    goto L50;
	}
	if (ip < ipstar) {
	    goto L50;
	}
	if (itcom5_1.omega > 1.) {
	    goto L45;
	}
	itcom3_1.emax = sqrt((abs(itcom5_1.specr)));
	omegap = 2. / (sqrt((d__1 = 1. - itcom5_1.specr, abs(d__1))) + 1.);
	change = TRUE_;
	goto L50;
L45:
	if (iss != 0) {
	    goto L50;
	}
	d__1 = itcom5_1.omega - 1.;
	if (itcom5_1.specr <= pow_dd(&d__1, &itcom5_1.fff)) {
	    goto L50;
	}
	if (itcom5_1.specr + 5e-5 <= spcrm1) {
	    goto L50;
	}

/* ... change parameters */

	itcom3_1.emax = (itcom5_1.specr + itcom5_1.omega - 1.) / (sqrt((abs(
		itcom5_1.specr))) * itcom5_1.omega);
	omegap = 2. / (sqrt((d__1 = 1. - itcom3_1.emax * itcom3_1.emax, abs(
		d__1))) + 1.);
	change = TRUE_;

L50:
	++ip;
	++itcom1_1.in;
/* L55: */
    }
    *ier = 1;
    --itcom1_1.in;
    ershow_(ier, "itsor", (ftnlen)5);
    itcom3_1.zeta = itcom3_1.stptst;
    return 0;
} /* itsor_ */

/* Subroutine */ int basicw_(S_fp suba, S_fp subql, S_fp subqr, doublereal *
	coef, integer *jcoef, doublereal *wfac, integer *jwfac, integer *n,
	doublereal *u, doublereal *ubar, doublereal *rhs, doublereal *wk,
	integer *nw, integer *iparm, doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 basic\002)";
    static char fmt_720[] = "(/\002 basic method converged in \002,i5,\002 i"
	    "terations.\002)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static doublereal t1, t2;
    static integer iv1;
    static logical iql, iqr;
    static integer izt;
    static doublereal xxx;
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    static doublereal timit, dummy;
    static integer nwusd;
    extern /* Subroutine */ int pstop_(integer *, S_fp, S_fp, S_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *);
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static integer iwfree;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *), inithv_(integer *);
    static doublereal extrap;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen), vexopy_(
	    integer *, doublereal *, doublereal *, doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___676 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___685 = { 0, 0, 0, fmt_720, 0 };



/* code to run the basic (unaccelerated) iterative method, */
/* with preconditioning.  that is, it applies the fixed point method */
/* to the preconditioned system. */
/* two-sided preconditioning is efficiently implemented. */


/* *** begin -- package common */


/* *** end   -- package common */

/* preliminary calculations */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    itcom1_1.iacel = 0;
    *ier = 0;
    nwusd = 0;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L996;
    }
    if (itcom1_1.level >= 2) {
	io___676.ciunit = itcom1_1.nout;
	s_wsfe(&io___676);
	e_wsfe();
    }
/* use knowledge about spectrum to optimally extrapolate ... */
    extrap = (itcom3_1.emax + itcom3_1.emin) / 2.;
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;

/* initialize the stopping test ... */

    inithv_(&c__0);
    itcom9_1.zthave = TRUE_;
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L735;
    }

/* bust up workspace ... */

    izt = 1;
    iv1 = izt + *n;
    iwfree = iv1 + *n;
    if (itcom1_1.iqlr == 0) {
	iwfree = iv1;
    }
/* Computing MAX */
    i__1 = nwusd, i__2 = iwfree - 1;
    nwusd = max(i__1,i__2);

/* check the memory usage ... */

    if (nwusd > *nw) {
	goto L999;
    }

/* do preliminary calculations ... */

    itcom1_1.in = 0;
    itcom1_1.is = 0;
    switch (itcom1_1.iqlr + 1) {
	case 1:  goto L151;
	case 2:  goto L152;
	case 3:  goto L153;
	case 4:  goto L154;
    }

L151:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[izt]);
    vexopy_(n, &wk[izt], &rhs[1], &wk[izt], &c__2);
    goto L10;

L152:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[izt]);
    goto L10;

L153:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[izt]);
    goto L10;

L154:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[izt]);
    vexopy_(n, &wk[izt], &rhs[1], &wk[izt], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[izt], &wk[iv1]);
    (*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[izt]);
    goto L10;

/* -----------------------begin iteration loop---------------------- */

/* determine whether or not to stop -- */

L10:
    inithv_(&c__1);
    nwpstp = *nw - (iwfree - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &wk[
	    izt], &wk[iwfree], &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iwfree - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &u[1]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }

/* form iterate ... */

    d__1 = 1. / extrap;
    vtriad_(n, &u[1], &u[1], &d__1, &wk[izt], &c__1);

/* form residuals, as necessary ... */

    switch (itcom1_1.iqlr + 1) {
	case 1:  goto L161;
	case 2:  goto L162;
	case 3:  goto L163;
	case 4:  goto L164;
    }

L161:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[izt]);
    vexopy_(n, &wk[izt], &rhs[1], &wk[izt], &c__2);
    goto L110;

L162:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[izt]);
    goto L110;

L163:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[izt]);
    goto L110;

L164:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[izt]);
    vexopy_(n, &wk[izt], &rhs[1], &wk[izt], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[izt], &wk[iv1]);
    (*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[izt]);
    goto L110;

/* proceed to next iteration */

L110:
    ++itcom1_1.in;
    ++itcom1_1.is;
    goto L10;

/* --------------------------------finish up------------------------- */

L900:
    if (itcom2_1.halt) {
	goto L715;
    }
    *ier = 1;
    ershow_(ier, "basicw", (ftnlen)6);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;
L715:
    if (itcom1_1.level >= 1) {
	io___685.ciunit = itcom1_1.nout;
	s_wsfe(&io___685);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts < 0) {
	goto L730;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
L730:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;

/* error returns */

L996:
    ershow_(ier, "basicw", (ftnlen)6);
    goto L735;

/* insuff. floating point wksp ... */
L999:
    *ier = -2;
    ershow_(ier, "basicw", (ftnlen)6);
    goto L735;

} /* basicw_ */

/* Subroutine */ int mew_(S_fp suba, S_fp subql, S_fp subqr, doublereal *coef,
	 integer *jcoef, doublereal *wfac, integer *jwfac, integer *n,
	doublereal *u, doublereal *ubar, doublereal *rhs, doublereal *wk,
	integer *nw, integer *iparm, doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 me\002)";
    static char fmt_720[] = "(/\002 me converged in \002,i5,\002 iterations"
	    ".\002)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1, d__2;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    double sqrt(doublereal);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static doublereal t1, t2;
    static integer ip, ir, iz, iv1, iv2;
    static logical iql;
    static doublereal dot;
    static logical iqr;
    static integer ipt, izt;
    static doublereal xxx, bet1, bet2, scal;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static integer iqlap;
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    static doublereal timit, dummy;
    static integer nwusd;
    extern /* Subroutine */ int pstop_(integer *, S_fp, S_fp, S_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *);
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static doublereal vlamda;
    static integer iwfree;
    static doublereal dotold;
    static integer iqrlap;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *);
    static doublereal toplam;
    extern /* Subroutine */ int inithv_(integer *), ershow_(integer *, char *,
	     ftnlen), vexopy_(integer *, doublereal *, doublereal *,
	    doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___694 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___715 = { 0, 0, 0, fmt_720, 0 };



/* this routine runs the minimal error algorithm of fridman. */
/* the reference is: v. m. fridman, "the method of minimum iterations */
/* ...", ussr computational math. and math. phys., vol. 2, 1962, */
/* pp. 362-3. */

/* two-sided preconditioning is implemented.  the iteration matrix */
/* should be symmetric for this algorithm to work. */

/* we have introduced periodic scaling of the direction vectors, to */
/* prevent overflow. */


/* *** begin -- package common */


/* *** end   -- package common */

/* the following indexing functions are used to access the old */
/* direction vectors -- */


/* various preliminary calculations. */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    dot = 0.;
    nwusd = 0;
    *ier = 0;
    itcom1_1.iacel = 4;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L997;
    }
    if (itcom1_1.level >= 2) {
	io___694.ciunit = itcom1_1.nout;
	s_wsfe(&io___694);
	e_wsfe();
    }
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;

/* initialize the stopping test ... */

    inithv_(&c__0);
    itcom9_1.zhave = TRUE_;
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L730;
    }

/* memory allocation, etc. */

/* nomenclature -- r  -- residual of the original system. */
/*                 z  -- inv(ql)*r */
/*                 zt -- inv(qr)*z */

    ip = 1;
    ipt = ip + (*n << 1);
    iz = ipt + (*n << 1);
    ir = iz + *n;
    iv1 = ir + *n;
    if (! itcom9_1.rcalp) {
	iv1 = ir;
    }
    izt = iv1 + *n;
    iv2 = izt + *n;
    if (! itcom9_1.ztcalp) {
	iv2 = izt;
    }
    iqlap = iv1;
    iqrlap = iv2;
    iwfree = iv2 + *n;

/* note that memory usage has been overlapped whenever possible, */
/* in order to save space. */

/* Computing MAX */
    i__1 = nwusd, i__2 = iwfree - 1;
    nwusd = max(i__1,i__2);

/* check the memory usage -- */

    if (nwusd > *nw) {
	goto L999;
    }

    itcom1_1.in = 0;
    itcom1_1.is = 0;
    itcom9_1.rhave = itcom9_1.rcalp;
    itcom9_1.zthave = itcom9_1.ztcalp;

/* perform first-iterate calculations */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[ir]);
    vexopy_(n, &wk[ir], &rhs[1], &wk[ir], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ir], &wk[iz]);
    (*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iz], &wk[izt]);

/* ---------------------------- begin iteration loop ---------------------------- */

/* determine whether or not to stop -- */
/* note that we have already done the calculations necessary so that suba */
/* and subql are not actually used by pstop. */

L10:
    inithv_(&c__1);
    nwpstp = *nw - (iwfree - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &wk[ir], &wk[iz],
	     &wk[izt], &wk[iwfree], &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iwfree - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &u[1]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }

/* compute p(n), the direction vector, and inv(qr)*p(n) (=pt(n)). */

    scal = 1.;

/* first, case of in .eq. 0 */

    if (itcom1_1.in != 0) {
	goto L100;
    }
    toplam = vdot_(n, &wk[iz], &wk[iz]);
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[izt], &wk[iv1]);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[ip +
	    itcom1_1.in % 2 * *n]);
    (*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ip +
	    itcom1_1.in % 2 * *n], &wk[ipt + itcom1_1.in % 2 * *n]);
    goto L120;

/* case in .gt. 0 */

L100:
    i__1 = itcom1_1.in - 1;
    toplam = vdot_(n, &wk[ip + i__1 % 2 * *n], &wk[iz]);
    i__1 = itcom1_1.in - 1;
    bet1 = -vdot_(n, &wk[ip + i__1 % 2 * *n], &wk[iqlap]) / dot;
    if (itcom1_1.in != 1) {
	goto L110;
    }

/* case in .eq. 1 */

    i__1 = itcom1_1.in - 1;
    vtriad_(n, &wk[ip + itcom1_1.in % 2 * *n], &wk[iqlap], &bet1, &wk[ip +
	    i__1 % 2 * *n], &c__1);
    i__1 = itcom1_1.in - 1;
    vtriad_(n, &wk[ipt + itcom1_1.in % 2 * *n], &wk[iqrlap], &bet1, &wk[ipt +
	    i__1 % 2 * *n], &c__1);
    goto L120;

/* case in .gt. 1 */

L110:
    i__1 = itcom1_1.in - 2;
    bet2 = -vdot_(n, &wk[ip + i__1 % 2 * *n], &wk[iqlap]) / dotold;
    i__1 = itcom1_1.in - 2;
    vtriad_(n, &wk[ip + itcom1_1.in % 2 * *n], &wk[iqlap], &bet2, &wk[ip +
	    i__1 % 2 * *n], &c__1);
    i__1 = itcom1_1.in - 2;
    vtriad_(n, &wk[ipt + itcom1_1.in % 2 * *n], &wk[iqrlap], &bet2, &wk[ipt +
	    i__1 % 2 * *n], &c__1);
    i__1 = itcom1_1.in - 1;
    vtriad_(n, &wk[ip + itcom1_1.in % 2 * *n], &wk[ip + itcom1_1.in % 2 * *n],
	     &bet1, &wk[ip + i__1 % 2 * *n], &c__1);
    i__1 = itcom1_1.in - 1;
    vtriad_(n, &wk[ipt + itcom1_1.in % 2 * *n], &wk[ipt + itcom1_1.in % 2 * *
	    n], &bet1, &wk[ipt + i__1 % 2 * *n], &c__1);

/* at this point, we are finished forming the latest direction vector. */
/* we proceed to calculate lambda and update the solution and the */
/* residual. */

L120:
    dotold = dot;
    dot = vdot_(n, &wk[ip + itcom1_1.in % 2 * *n], &wk[ip + itcom1_1.in % 2 *
	    *n]);
/*     if (dot .lt. srelpr) go to 998 */

/* scale direction vector if necessary ... */
/* Computing 2nd power */
    d__1 = itcom4_1.srelpr;
/* Computing 2nd power */
    d__2 = itcom4_1.srelpr;
    if (dot < d__1 * d__1 || dot > 1. / (d__2 * d__2)) {
	scal = sqrt(dot);
	d__1 = 1. / scal;
	vtriad_(n, &wk[ip + itcom1_1.in % 2 * *n], &xxx, &d__1, &wk[ip +
		itcom1_1.in % 2 * *n], &c__2);
	d__1 = 1. / scal;
	vtriad_(n, &wk[ipt + itcom1_1.in % 2 * *n], &xxx, &d__1, &wk[ipt +
		itcom1_1.in % 2 * *n], &c__2);
	dot = 1.;
    }

/* L124: */
    vlamda = toplam / dot / scal;

/* u -- */

    vtriad_(n, &u[1], &u[1], &vlamda, &wk[ipt + itcom1_1.in % 2 * *n], &c__1);

/* r -- */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ipt +
	    itcom1_1.in % 2 * *n], &wk[iv2]);
    if (itcom9_1.rhave) {
	d__1 = -vlamda;
	vtriad_(n, &wk[ir], &wk[ir], &d__1, &wk[iv2], &c__1);
    }

/* z -- */

    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv2], &wk[iqlap]
	    );
    d__1 = -vlamda;
    vtriad_(n, &wk[iz], &wk[iz], &d__1, &wk[iqlap], &c__1);

/* zt -- */

    (*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iqlap], &wk[
	    iqrlap]);
    if (itcom9_1.zthave) {
	d__1 = -vlamda;
	vtriad_(n, &wk[izt], &wk[izt], &d__1, &wk[iqrlap], &c__1);
    }

/* proceed to next iteration */

    ++itcom1_1.in;
    ++itcom1_1.is;
    goto L10;

/* -------------------------------finish up----------------------------- */

L900:
    if (itcom2_1.halt) {
	goto L715;
    }
    *ier = 1;
    ershow_(ier, "mew", (ftnlen)3);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;
L715:
    if (itcom1_1.level >= 1) {
	io___715.ciunit = itcom1_1.nout;
	s_wsfe(&io___715);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts < 0) {
	goto L730;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
L730:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;

/* error returns */

L997:
    ershow_(ier, "mew", (ftnlen)3);
    goto L735;

/* L998: */
    *ier = -15;
    ershow_(ier, "mew", (ftnlen)3);
    goto L725;

L999:
    *ier = -2;
    ershow_(ier, "mew", (ftnlen)3);
    goto L735;

} /* mew_ */

/* Subroutine */ int cgnrw_(S_fp suba, S_fp subat, S_fp subql, S_fp subqlt,
	S_fp subqr, U_fp subqrt, doublereal *coef, integer *jcoef, doublereal
	*wfac, integer *jwfac, integer *n, doublereal *u, doublereal *ubar,
	doublereal *rhs, doublereal *wk, integer *nw, integer *iparm,
	doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 cgnr\002)";
    static char fmt_720[] = "(/\002 cgnr converged in \002,i5,\002 iteration"
	    "s.\002)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static doublereal t1, t2, an;
    static integer ip, ir, iv1, iv2;
    static doublereal ard;
    static logical iql, iqr;
    static doublereal xxx;
    static integer itri;
    extern doublereal vdot_(integer *, doublereal *, doublereal *), timer_(
	    doublereal *);
    extern /* Subroutine */ int vfill_(integer *, doublereal *, doublereal *),
	     iterm_(integer *, doublereal *);
    static doublereal dummy, timit;
    static integer nwusd;
    extern /* Subroutine */ int pstop_(integer *, S_fp, S_fp, S_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *);
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *), chgcon_(doublereal *, integer *)
	    ;
    static doublereal ardold, vlamda;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *), inithv_(integer *),
	    ershow_(integer *, char *, ftnlen), vexopy_(integer *, doublereal
	    *, doublereal *, doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___725 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___737 = { 0, 0, 0, fmt_720, 0 };



/* code to run the conjugate gradient algorithm on the normal equations. */
/* in this variant, the residual of the original system is minimized */
/* per iteration.  currently, only left preconditioning is implemented. */


/* *** begin -- package common */


/* *** end   -- package common */

/* preliminary calculations. */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    nwusd = 0;
    *ier = 0;
    itcom1_1.iacel = 5;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L997;
    }
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;
    if (iqr) {
	goto L995;
    }
    if (itcom1_1.level >= 2) {
	io___725.ciunit = itcom1_1.nout;
	s_wsfe(&io___725);
	e_wsfe();
    }
    itcom2_1.maxadp = itcom2_1.maxadd;
    itcom2_1.minadp = itcom2_1.minadd;
    itcom3_1.alphao = 0.;
    itcom3_1.alpha = 0.;
    itcom3_1.beta = 0.;

/* initialize the stopping test ... */

    inithv_(&c__0);
    itcom9_1.zthave = TRUE_;
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L730;
    }

    itri = 1;
    ip = itri;
    if (! (itcom2_1.maxadd || itcom2_1.minadd)) {
	goto L850;
    }
    ip = itri + (itcom1_1.itmax << 1);
    i__1 = itcom1_1.itmax << 1;
    vfill_(&i__1, &wk[itri], &c_b121);
L850:
    ir = ip + *n;
    iv1 = ir + *n;
    iv2 = iv1 + *n;
/* Computing MAX */
    i__1 = nwusd, i__2 = iv2 - 1 + *n;
    nwusd = max(i__1,i__2);

/* check the memory usage -- */

    if (nwusd > *nw) {
	goto L999;
    }

    itcom1_1.in = 0;
    itcom1_1.is = 0;
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[ir]);

/* --------------------------begin iteration loop------------------------ */

/* determine whether or not to stop -- */

L10:
    inithv_(&c__1);
    nwpstp = *nw - (iv1 - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &wk[
	    ir], &wk[iv1], &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iv1 - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &u[1]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }

    if (itcom1_1.in != 0) {
	goto L110;
    }

/* perform first-iterate calculations */

    (*subqlt)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ir], &wk[iv1]);
    (*subat)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[ip]);
    ard = vdot_(n, &wk[ip], &wk[ip]);
    goto L111;

/* perform subsequent-iterate calculations */

L110:
    ardold = ard;
/*     if (abs(ardold) .lt. srelpr) go to 996 */
    (*subqlt)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ir], &wk[iv1]);
    (*subat)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    ard = vdot_(n, &wk[iv2], &wk[iv2]);
    an = ard / ardold;
    vtriad_(n, &wk[ip], &wk[iv2], &an, &wk[ip], &c__1);
    itcom3_1.beta = an;

/* proceed to form the iterate. */

L111:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ip], &wk[iv1]);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    itcom3_1.pap = vdot_(n, &wk[iv2], &wk[iv2]);
/* Computing 2nd power */
    d__1 = itcom4_1.srelpr;
    if (abs(itcom3_1.pap) < d__1 * d__1) {
	goto L998;
    }
    vlamda = ard / itcom3_1.pap;

    vtriad_(n, &u[1], &u[1], &vlamda, &wk[ip], &c__1);
    d__1 = -vlamda;
    vtriad_(n, &wk[ir], &wk[ir], &d__1, &wk[iv2], &c__1);

/* update eigenvalue estimates */

    itcom3_1.alphao = itcom3_1.alpha;
    itcom3_1.alpha = vlamda;
    if (itcom2_1.maxadp || itcom2_1.minadp) {
	chgcon_(&wk[itri], ier);
    }
    if (*ier < 0) {
	goto L725;
    }

/* proceed to next iteration */

    ++itcom1_1.in;
    ++itcom1_1.is;
    goto L10;

/* -------------------------------finish up--------------------------- */

L900:
    if (itcom2_1.halt) {
	goto L715;
    }
    *ier = 1;
    ershow_(ier, "cgnrw", (ftnlen)5);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;
L715:
    if (itcom1_1.level >= 1) {
	io___737.ciunit = itcom1_1.nout;
	s_wsfe(&io___737);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts < 0) {
	goto L730;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
L730:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;

/* error returns */

L995:
    *ier = -16;
    ershow_(ier, "cgnrw", (ftnlen)5);
    return 0;

/* L996: */
    *ier = -13;
    ershow_(ier, "cgnrw", (ftnlen)5);
    goto L725;

L997:
    ershow_(ier, "cgnrw", (ftnlen)5);
    goto L735;

L998:
    *ier = -15;
    ershow_(ier, "cgnrw", (ftnlen)5);
    goto L725;

L999:
    *ier = -2;
    ershow_(ier, "cgnrw", (ftnlen)5);
    goto L735;

} /* cgnrw_ */

/* Subroutine */ int lsqrw_(S_fp suba, S_fp subat, S_fp subql, S_fp subqlt,
	S_fp subqr, U_fp subqrt, doublereal *coef, integer *jcoef, doublereal
	*wfac, integer *jwfac, integer *n, doublereal *u, doublereal *ubar,
	doublereal *rhs, doublereal *wk, integer *nw, integer *iparm,
	doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 lsqr\002)";
    static char fmt_720[] = "(/\002 lsqr converged in \002,i5,\002 iteration"
	    "s.\002)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1, d__2;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    double sqrt(doublereal);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static doublereal c__, s, t1, t2;
    static integer iu, iv, iw, iv1, iv2;
    static doublereal phi;
    static logical iql, iqr;
    static doublereal xxx;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static doublereal theta;
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    static doublereal timit, dummy;
    static integer nwusd;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *),
	     pstop_(integer *, S_fp, S_fp, S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *);
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static doublereal phibar, rhobar;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *), inithv_(integer *),
	    ershow_(integer *, char *, ftnlen), vexopy_(integer *, doublereal
	    *, doublereal *, doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___747 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___761 = { 0, 0, 0, fmt_720, 0 };



/* code to run the lsqr algorithm.  the algorithm is taken from */
/* the article 'lsqr -- an algorithm for sparse linear equations */
/* and sparse least squares.' */
/* by c. c. paige amd m. a. saunders, in acm transactions on */
/* mathematical software, vol. 8, no. 1, march 1982, pp. 43-71. */
/* the iterates produced are the same as those of cgnr, in exact */
/* arithmetic, but this should be more stable.  only left */
/* preconditioning is currently implemented. */


/* *** begin -- package common */


/* *** end   -- package common */

/* preliminary calculations. */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    nwusd = 0;
    *ier = 0;
    itcom1_1.iacel = 6;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L996;
    }
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;
    if (iqr) {
	goto L995;
    }
    if (itcom1_1.level >= 2) {
	io___747.ciunit = itcom1_1.nout;
	s_wsfe(&io___747);
	e_wsfe();
    }

/* initialize the stopping test ... */

    inithv_(&c__0);
    itcom9_1.zdhav = TRUE_;
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L735;
    }

/* ... associated integer variables. */

    iu = 1;
    iv = iu + *n;
    iw = iv + *n;
    iv1 = iw + *n;
    iv2 = iv1 + *n;
/* Computing MAX */
    i__1 = nwusd, i__2 = iv2 - 1 + *n;
    nwusd = max(i__1,i__2);

/* check the memory usage -- */

    if (nwusd > *nw) {
	goto L999;
    }

    itcom1_1.in = 0;
    itcom1_1.is = 0;

/* now, perform first-iterate calculations */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    itcom3_1.beta = sqrt(vdot_(n, &wk[iv2], &wk[iv2]));
    if (abs(itcom3_1.beta) < itcom4_1.srelpr) {
	goto L997;
    }
    d__1 = 1. / itcom3_1.beta;
    vtriad_(n, &wk[iu], &xxx, &d__1, &wk[iv2], &c__2);

    (*subqlt)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iu], &wk[iv1]);
    (*subat)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    itcom3_1.alpha = sqrt(vdot_(n, &wk[iv2], &wk[iv2]));
    if (abs(itcom3_1.alpha) < itcom4_1.srelpr) {
	goto L997;
    }
    d__1 = 1. / itcom3_1.alpha;
    vtriad_(n, &wk[iv], &xxx, &d__1, &wk[iv2], &c__2);

    vcopy_(n, &wk[iv], &wk[iw]);
    phibar = itcom3_1.beta;
    rhobar = itcom3_1.alpha;
/* Computing 2nd power */
    d__1 = phibar;
    itcom9_1.zdot = d__1 * d__1;
/* if u(0) is zero, then the norm of u(n) can be calculated for free. */
/* otherwise, i don't know. */

/* ---------------------------begin iteration loop--------------------- */

/* determine whether or not to stop -- */

L10:
    inithv_(&c__1);
    itcom9_1.zdhav = TRUE_;
    nwpstp = *nw - (iv1 - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[iv1], &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iv1 - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &u[1]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }

/* ... compute the lanczos vectors. */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv], &wk[iv1]);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    d__1 = -itcom3_1.alpha;
    vtriad_(n, &wk[iu], &wk[iv2], &d__1, &wk[iu], &c__1);
    itcom3_1.beta = sqrt(vdot_(n, &wk[iu], &wk[iu]));
    if (abs(itcom3_1.beta) < itcom4_1.srelpr) {
	goto L997;
    }
    d__1 = 1. / itcom3_1.beta;
    vtriad_(n, &wk[iu], &xxx, &d__1, &wk[iu], &c__2);

    (*subqlt)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iu], &wk[iv1]);
    (*subat)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    d__1 = -itcom3_1.beta;
    vtriad_(n, &wk[iv], &wk[iv2], &d__1, &wk[iv], &c__1);
    itcom3_1.alpha = sqrt(vdot_(n, &wk[iv], &wk[iv]));
    if (abs(itcom3_1.alpha) < itcom4_1.srelpr) {
	goto L997;
    }
    d__1 = 1. / itcom3_1.alpha;
    vtriad_(n, &wk[iv], &xxx, &d__1, &wk[iv], &c__2);

/* continue by calculating various scalars. */

/* Computing 2nd power */
    d__1 = rhobar;
/* Computing 2nd power */
    d__2 = itcom3_1.beta;
    itcom3_1.rho = sqrt(d__1 * d__1 + d__2 * d__2);
    if (itcom3_1.rho < itcom4_1.srelpr) {
	goto L998;
    }
    c__ = rhobar / itcom3_1.rho;
    s = itcom3_1.beta / itcom3_1.rho;
    theta = s * itcom3_1.alpha;
    rhobar = -c__ * itcom3_1.alpha;
    phi = c__ * phibar;
    phibar = s * phibar;

/* now generate the new u and w vectors. */

    d__1 = phi / itcom3_1.rho;
    vtriad_(n, &u[1], &u[1], &d__1, &wk[iw], &c__1);
    d__1 = -theta / itcom3_1.rho;
    vtriad_(n, &wk[iw], &wk[iv], &d__1, &wk[iw], &c__1);

/* proceed to next iteration */

/* Computing 2nd power */
    d__1 = phibar;
    itcom9_1.zdot = d__1 * d__1;
    ++itcom1_1.in;
    ++itcom1_1.is;
    goto L10;

/* -----------------------------finish up------------------------- */

L900:
    if (itcom2_1.halt) {
	goto L715;
    }
    *ier = 1;
    ershow_(ier, "lsqrw", (ftnlen)5);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;
L715:
    if (itcom1_1.level >= 1) {
	io___761.ciunit = itcom1_1.nout;
	s_wsfe(&io___761);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts < 0) {
	goto L730;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
L730:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;

/* error returns */

L995:
    *ier = -16;
    ershow_(ier, "lsqrw", (ftnlen)5);
    return 0;

L996:
    ershow_(ier, "lsqrw", (ftnlen)5);
    goto L735;

L997:
    *ier = -13;
    ershow_(ier, "lsqrw", (ftnlen)5);
    goto L725;

L998:
    *ier = -14;
    ershow_(ier, "lsqrw", (ftnlen)5);
    goto L725;

L999:
    *ier = -2;
    ershow_(ier, "lsqrw", (ftnlen)5);
    goto L735;

} /* lsqrw_ */

/* Subroutine */ int odirw_(S_fp suba, S_fp subql, S_fp subqr, doublereal *
	coef, integer *jcoef, doublereal *wfac, integer *jwfac, integer *n,
	doublereal *u, doublereal *ubar, doublereal *rhs, doublereal *wk,
	integer *nw, integer *iparm, doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 orthodir\002)";
    static char fmt_720[] = "(/\002 orthodir converged in \002,i5,\002 itera"
	    "tions.\002)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublereal d__1, d__2;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__;
    static doublereal t1, t2;
    static integer np, iz, nv, iv1, iv2;
    static doublereal bet;
    static logical iql;
    static doublereal dot;
    static logical iqr;
    static integer ipt, isv;
    static doublereal top;
    static integer izt;
    static doublereal xxx;
    static integer iend, idot;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static integer iqapt;
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    static doublereal dummy, timit;
    static integer nwusd;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *),
	     pstop_(integer *, S_fp, S_fp, S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *);
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static integer ibegin;
    static doublereal vlamda;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *), inithv_(integer *),
	    ershow_(integer *, char *, ftnlen), vexopy_(integer *, doublereal
	    *, doublereal *, doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___769 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___791 = { 0, 0, 0, fmt_720, 0 };



/* this routine implements orthodir with truncation and */
/* restarting and with 2-sided preconditioning.  the effective value */
/* of the z matrix is (inv(ql)*a*inv(qr))**t. */


/* *** begin -- package common */


/* *** end   -- package common */

/* the following indexing functions are used to access the old */
/* direction vectors and dot products -- */


/* various preliminary calculations. */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    nwusd = 0;
    *ier = 0;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L997;
    }
    io___769.ciunit = itcom1_1.nout;
    s_wsfe(&io___769);
    e_wsfe();
    itcom1_1.iacel = 7;
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;

/* initialize the stopping test ... */

    inithv_(&c__0);
    itcom9_1.zhave = TRUE_;
    itcom9_1.zthave = TRUE_;
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L997;
    }

/* memory allocation, etc. */

/* Computing MAX */
/* Computing MIN */
    i__3 = itcom1_1.ns1, i__4 = itcom1_1.ns2 - 1;
    i__1 = 1, i__2 = min(i__3,i__4);
    nv = max(i__1,i__2);
    ipt = 1;
    iqapt = ipt + nv * *n;
    idot = iqapt + nv * *n;
    iz = idot + nv;
    izt = iz + *n;
    if (! iqr) {
	izt = iz;
    }
    isv = izt + *n;
    iv1 = isv + *n;
    iv2 = iv1 + *n;

    if (iql) {
/* Computing MAX */
	i__1 = nwusd, i__2 = iv2 - 1 + *n;
	nwusd = max(i__1,i__2);
    }
    if (! iql) {
/* Computing MAX */
	i__1 = nwusd, i__2 = iv1 - 1 + *n;
	nwusd = max(i__1,i__2);
    }

/* check the memory usage -- */

    if (nwusd > *nw) {
	goto L999;
    }

    itcom1_1.in = 0;
    itcom1_1.is = 0;

/* perform first-iterate calculations */

    if (iql) {
	goto L122;
    }
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iz]);
    vexopy_(n, &wk[iz], &rhs[1], &wk[iz], &c__2);
    goto L121;
L122:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iz]);
L121:
    if (iqr) {
	(*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iz], &wk[
		izt]);
    }
/*     if (.not. iqr) zdot = vdot (n,wk(iz),wk(iz)) */

/* ========================= begin iteration loop ==================== */


/* determine whether or not to stop ... */

L10:
    inithv_(&c__1);
    nwpstp = *nw - (iv1 - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &wk[iz], &
	    wk[izt], &wk[iv1], &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iv1 - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &u[1]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }

/* proceed to calculate the direction vectors. */

/* first, case of no old p vectors. */

/* Computing MIN */
    i__1 = itcom1_1.in % itcom1_1.ns2;
    np = min(i__1,itcom1_1.ns1);
    if (np != 0) {
	goto L100;
    }

    if (itcom1_1.is == 0) {
	vcopy_(n, &wk[izt], &wk[ipt + itcom1_1.in % nv * *n]);
    }
    if (itcom1_1.is != 0) {
	vcopy_(n, &wk[isv], &wk[ipt + itcom1_1.in % nv * *n]);
    }
    if (iql) {
	goto L123;
    }
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ipt +
	    itcom1_1.in % nv * *n], &wk[iqapt + itcom1_1.in % nv * *n]);
    goto L120;
L123:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ipt +
	    itcom1_1.in % nv * *n], &wk[iv1]);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iqapt
	    + itcom1_1.in % nv * *n]);
    goto L120;

/* case of at least one old p vector. */
/* this case is handled in a tricky way, to optimize the workspace. */

L100:
    if (iql) {
	goto L124;
    }
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[isv], &wk[iv1]);
    goto L125;
L124:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[isv], &wk[iv2]);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv2], &wk[iv1]);

L125:
    i__1 = itcom1_1.in - np;
    top = vdot_(n, &wk[iqapt + i__1 % nv * *n], &wk[iv1]);
    i__1 = itcom1_1.in - np;
    bet = -top / wk[idot + i__1 % nv];
    i__1 = itcom1_1.in - np;
    vtriad_(n, &wk[ipt + itcom1_1.in % nv * *n], &wk[isv], &bet, &wk[ipt +
	    i__1 % nv * *n], &c__1);
    i__1 = itcom1_1.in - np;
    vtriad_(n, &wk[iqapt + itcom1_1.in % nv * *n], &wk[iv1], &bet, &wk[iqapt
	    + i__1 % nv * *n], &c__1);
    ibegin = itcom1_1.in - np + 1;
    iend = itcom1_1.in - 1;
    if (ibegin > iend) {
	goto L613;
    }
    i__1 = iend;
    for (i__ = ibegin; i__ <= i__1; ++i__) {
	top = vdot_(n, &wk[iqapt + i__ % nv * *n], &wk[iv1]);
	bet = -top / wk[idot + i__ % nv];
	vtriad_(n, &wk[ipt + itcom1_1.in % nv * *n], &wk[ipt + itcom1_1.in %
		nv * *n], &bet, &wk[ipt + i__ % nv * *n], &c__1);
/* L612: */
	vtriad_(n, &wk[iqapt + itcom1_1.in % nv * *n], &wk[iqapt +
		itcom1_1.in % nv * *n], &bet, &wk[iqapt + i__ % nv * *n], &
		c__1);
    }
L613:

/* periodically scale the direction vector, to prevent overflow ... */

L120:
    dot = vdot_(n, &wk[iqapt + itcom1_1.in % nv * *n], &wk[iqapt +
	    itcom1_1.in % nv * *n]);
/* Computing 2nd power */
    d__1 = itcom4_1.srelpr;
/* Computing 2nd power */
    d__2 = itcom4_1.srelpr;
    if (dot < d__1 * d__1 || dot > 1. / (d__2 * d__2)) {
	d__1 = 1. / dot;
	vtriad_(n, &wk[ipt + itcom1_1.in % nv * *n], &xxx, &d__1, &wk[ipt +
		itcom1_1.in % nv * *n], &c__2);
	d__1 = 1. / dot;
	vtriad_(n, &wk[iqapt + itcom1_1.in % nv * *n], &xxx, &d__1, &wk[iqapt
		+ itcom1_1.in % nv * *n], &c__2);
	dot = 1.;
    }

/* at this point, we are finished forming the latest direction vector. */
/* we proceed to calculate lambda and update the solution and */
/* the residuals. */

/* L129: */
/*     if (abs(dot) .lt. srelpr) go to 998 */
    wk[idot + itcom1_1.in % nv] = dot;
    top = vdot_(n, &wk[iqapt + itcom1_1.in % nv * *n], &wk[iz]);
    vlamda = top / dot;
/* the following commented-out line is unstable.  but it can be fixed. */
/*     if (.not. iqr) zdot = zdot - 2*vlamda*top + vlamda**2*dot */

/* u -- */

    vtriad_(n, &u[1], &u[1], &vlamda, &wk[ipt + itcom1_1.in % nv * *n], &c__1)
	    ;

/* z -- */

    d__1 = -vlamda;
    vtriad_(n, &wk[iz], &wk[iz], &d__1, &wk[iqapt + itcom1_1.in % nv * *n], &
	    c__1);

/* zt -- */

    (*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iqapt +
	    itcom1_1.in % nv * *n], &wk[isv]);
    if (iqr) {
	d__1 = -vlamda;
	vtriad_(n, &wk[izt], &wk[izt], &d__1, &wk[isv], &c__1);
    }

/* proceed to next iteration */

    ++itcom1_1.in;
    ++itcom1_1.is;
    if (itcom1_1.is == itcom1_1.ns2) {
	itcom1_1.is = 0;
    }
    goto L10;

/* -------------------------------finish up---------------------------- */

L900:
    if (! itcom2_1.halt) {
	goto L996;
    }
    if (itcom1_1.level >= 1) {
	io___791.ciunit = itcom1_1.nout;
	s_wsfe(&io___791);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts >= 0) {
	perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[
		1], &rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
    }
/* pack revised parms into iparm, rparm ... */
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;


/* error returns */

/* no convergence ... */
L996:
    *ier = 1;
    ershow_(ier, "odirw", (ftnlen)5);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;

/* generic error handler ... */
L997:
    ershow_(ier, "odirw", (ftnlen)5);
    goto L735;

/* breakdown ... */
/* L998: */
    *ier = -15;
    ershow_(ier, "odirw", (ftnlen)5);
    goto L725;

/* insufficient floating point wksp ... */
L999:
    *ier = -2;
    ershow_(ier, "odirw", (ftnlen)5);
    goto L735;
} /* odirw_ */

/* Subroutine */ int ominw_(S_fp suba, U_fp subql, U_fp subqr, doublereal *
	coef, integer *jcoef, doublereal *wfac, integer *jwfac, integer *n,
	doublereal *u, doublereal *ubar, doublereal *rhs, doublereal *wk,
	integer *nw, integer *iparm, doublereal *rparm, integer *ier)
{
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *), omingw_(S_fp, U_fp, U_fp, U_fp,
	    U_fp, doublereal *, integer *, doublereal *, integer *, integer *,
	     doublereal *, doublereal *, doublereal *, doublereal *, integer *
	    , integer *, doublereal *, integer *);
    extern /* Subroutine */ int nullpl_(), nullpr_();


/* this routine implements the truncated/restarted orthomin algorithm. */
/* eigenvalue estimation is implemented. */
/* note that this also implements the gcr algorithm. */



    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    *ier = 0;
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	return 0;
    }

/* pass on to workhorse routine ... */

    omingw_((S_fp)suba, (U_fp)subql, (U_fp)subqr, (U_fp)nullpl_, (U_fp)
	    nullpr_, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    ubar[1], &rhs[1], &wk[1], nw, &iparm[1], &rparm[1], ier);
    return 0;
} /* ominw_ */

/* Subroutine */ int omingw_(S_fp suba, U_fp subql, U_fp subqr, S_fp precl,
	S_fp precr, doublereal *coef, integer *jcoef, doublereal *wfac,
	integer *jwfac, integer *n, doublereal *u, doublereal *ubar,
	doublereal *rhs, doublereal *wk, integer *nw, integer *iparm,
	doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_497[] = "(\002 omin\002)";
    static char fmt_720[] = "(/\002 orthomin converged in \002,i5,\002 itera"
	    "tions.\002)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5, i__6, i__7;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    double sqrt(doublereal);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__;
    static doublereal t1, t2;
    static integer id, ir, np, iz, nv, iv1, iv2;
    static doublereal bet;
    static logical ipl, ipr;
    static integer ipt;
    static doublereal top;
    static integer izt;
    static doublereal xxx, apap;
    static integer ilam;
    static doublereal apar;
    static integer idot, nwhe;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static integer iapar, iqapt, ihess;
    static logical evest;
    static integer nhess;
    static logical ztget;
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    static integer nwusd;
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    static integer nwtmp;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *),
	     vfill_(integer *, doublereal *, doublereal *);
    static doublereal timit, digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static doublereal vlamda;
    static logical hadest;
    static integer numbig, methev;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *);
    static logical havest;
    static integer iesize;
    extern /* Subroutine */ int hesest_(doublereal *, integer *, integer *,
	    integer *, integer *, logical *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *);
    static doublereal eminnw, emaxnw;
    extern /* Subroutine */ int inithv_(integer *), ershow_(integer *, char *,
	     ftnlen), pstopg_(integer *, S_fp, U_fp, U_fp, S_fp, S_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *),
	    vexopy_(integer *, doublereal *, doublereal *, doublereal *,
	    integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___801 = { 0, 0, 0, fmt_497, 0 };
    static cilist io___836 = { 0, 0, 0, fmt_720, 0 };



/* this is a generalized version of the omingw routine which allows a */
/* more general computational form for the preconditioning. */


/* *** begin -- package common */


/* *** end   -- package common */

/* the following indexing functions are used to access the old */
/* direction vectors and dot products -- */


/* various preliminary calculations. */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    t1 = timer_(&dummy);

    ipl = itcom1_1.iplr == 1 || itcom1_1.iplr == 3;
    ipr = itcom1_1.iplr == 2 || itcom1_1.iplr == 3;

    itcom1_1.iacel = 8;
    nwusd = 0;
    if (itcom1_1.level >= 1) {
	io___801.ciunit = itcom1_1.nout;
	s_wsfe(&io___801);
	e_wsfe();
    }

/* initialize the stopping test ... */

    inithv_(&c__0);
    itcom9_1.zhave = TRUE_;
    itcom9_1.zthave = TRUE_;
    nwpstp = *nw;
    pstopg_(&c__0, (S_fp)suba, (U_fp)subql, (U_fp)subqr, (S_fp)precl, (S_fp)
	    precr, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &ubar[
	    1], &rhs[1], &xxx, &xxx, &xxx, &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L997;
    }
    ztget = itcom9_1.ztcalp;
    itcom9_1.zthave = ztget;

/* memory allocation, etc. */

    numbig = 1000;
    methev = 1;
    if (abs(itcom1_1.ns3) >= numbig) {
	if (itcom1_1.ns3 > 0) {
	    itcom1_1.ns3 -= numbig;
	}
	if (itcom1_1.ns3 < 0) {
	    itcom1_1.ns3 += numbig;
	}
	methev = 2;
    }

    evest = itcom1_1.ns3 != 0 && (itcom2_1.maxadd || itcom2_1.minadd);
    nhess = min(itcom1_1.itmax,itcom1_1.ns2) + 2;
/* Computing MAX */
/* Computing MIN */
    i__3 = itcom1_1.ns1, i__4 = itcom1_1.ns2 - 1;
    i__1 = 1, i__2 = min(i__3,i__4);
    nv = max(i__1,i__2);
    ipt = 1;
    iqapt = ipt + nv * *n;
    idot = iqapt + nv * *n;
    iapar = idot + (nv + 1);
    ihess = iapar + nv;
    ilam = ihess + nhess * (nv + 2);
    if (! evest) {
	ilam = ihess;
    }
    iz = ilam + (nv + 1);
    izt = iz + *n;
    if (! ipr) {
	izt = iz;
    }
    iv1 = izt + *n;
    iv2 = iv1 + *n;
    ir = iz;
    if (ipl) {
	ir = iv1;
    }

    nwtmp = iv1 - 1 + *n;
    if (ipl) {
	nwtmp = iv2 - 1 + *n;
    }
    nwusd = max(nwusd,nwtmp);

/* check the memory usage -- */

    if (nwusd > *nw) {
	goto L999;
    }

    itcom1_1.in = 0;
    itcom1_1.is = 0;

/* perform first-iterate calculations */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[ir]);
    vexopy_(n, &wk[ir], &rhs[1], &wk[ir], &c__2);
    if (ipl) {
	(*precl)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, (U_fp)subql, (
		S_fp)suba, (U_fp)subqr, &wk[ir], &wk[iz]);
    }
    hadest = FALSE_;

/* ------------------------- begin iteration loop ---------------------- */

/* determine whether or not to stop ... */

L10:
    if (! ztget) {
	goto L710;
    }
    if (ipr) {
	(*precr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, (U_fp)subql, (
		S_fp)suba, (U_fp)subqr, &wk[iz], &wk[izt]);
    }

L710:
    inithv_(&c__1);
    nwpstp = *nw - (iv1 - 1);
    pstopg_(&c__1, (S_fp)suba, (U_fp)subql, (U_fp)subqr, (S_fp)precl, (S_fp)
	    precr, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &ubar[
	    1], &rhs[1], &xxx, &wk[iz], &wk[izt], &wk[iv1], &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iv1 - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &u[1]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }

    if (itcom9_1.zthave) {
	goto L711;
    }
    if (ipr) {
	(*precr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, (U_fp)subql, (
		S_fp)suba, (U_fp)subqr, &wk[iz], &wk[izt]);
    }

/* ------------------proceed to calculate the direction vectors---------------- */

/* first, case of no old p vectors. */

L711:
/* Computing MIN */
    i__1 = itcom1_1.in % itcom1_1.ns2;
    np = min(i__1,itcom1_1.ns1);
    if (np != 0) {
	goto L100;
    }

    vcopy_(n, &wk[izt], &wk[ipt + itcom1_1.in % nv * *n]);
    if (! ipl) {
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ipt +
		itcom1_1.in % nv * *n], &wk[iqapt + itcom1_1.in % nv * *n]);
    } else {
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ipt +
		itcom1_1.in % nv * *n], &wk[iv1]);
	(*precl)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, (U_fp)subql, (
		S_fp)suba, (U_fp)subqr, &wk[iv1], &wk[iqapt + itcom1_1.in %
		nv * *n]);
    }
    goto L120;

/* case of at least one old p vector. */
/* this case is handled in a tricky way, to optimize the workspace. */

L100:
    if (! ipl) {
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[izt], &wk[
		iv1]);
    } else {
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[izt], &wk[
		iv2]);
	(*precl)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, (U_fp)subql, (
		S_fp)suba, (U_fp)subqr, &wk[iv2], &wk[iv1]);
    }

    i__1 = itcom1_1.in - np;
    top = vdot_(n, &wk[iqapt + i__1 % nv * *n], &wk[iv1]);
    i__1 = itcom1_1.in - np;
    wk[iapar + i__1 % nv] = top;
    i__1 = itcom1_1.in - np;
    bet = -top / wk[idot + i__1 % (nv + 1)];
    i__1 = itcom1_1.in - np;
    vtriad_(n, &wk[ipt + itcom1_1.in % nv * *n], &wk[izt], &bet, &wk[ipt +
	    i__1 % nv * *n], &c__1);
    i__1 = itcom1_1.in - np;
    vtriad_(n, &wk[iqapt + itcom1_1.in % nv * *n], &wk[iv1], &bet, &wk[iqapt
	    + i__1 % nv * *n], &c__1);

    i__1 = itcom1_1.in - 1;
    for (i__ = itcom1_1.in - np + 1; i__ <= i__1; ++i__) {
	top = vdot_(n, &wk[iqapt + i__ % nv * *n], &wk[iv1]);
	wk[iapar + i__ % nv] = top;
	bet = -top / wk[idot + i__ % (nv + 1)];
	vtriad_(n, &wk[ipt + itcom1_1.in % nv * *n], &wk[ipt + itcom1_1.in %
		nv * *n], &bet, &wk[ipt + i__ % nv * *n], &c__1);
/* L612: */
	vtriad_(n, &wk[iqapt + itcom1_1.in % nv * *n], &wk[iqapt +
		itcom1_1.in % nv * *n], &bet, &wk[iqapt + i__ % nv * *n], &
		c__1);
    }

/* at this point, we are finished forming the latest direction vector. */
/* we proceed to calculate lambda and update the solution and */
/* the residuals. */

L120:
    apap = vdot_(n, &wk[iqapt + itcom1_1.in % nv * *n], &wk[iqapt +
	    itcom1_1.in % nv * *n]);
/*     if (abs(apap) .lt. srelpr**2) go to 998 */
    if (abs(apap) == 0.) {
	goto L998;
    }
    wk[idot + itcom1_1.in % (nv + 1)] = apap;
    top = vdot_(n, &wk[iqapt + itcom1_1.in % nv * *n], &wk[iz]);
    vlamda = top / apap;
/*     if (.not. ipr) zzdot = zzdot - 2*vlamda*top + vlamda**2*apap */

/* u -- */
    vtriad_(n, &u[1], &u[1], &vlamda, &wk[ipt + itcom1_1.in % nv * *n], &c__1)
	    ;

/* z -- */
    d__1 = -vlamda;
    vtriad_(n, &wk[iz], &wk[iz], &d__1, &wk[iqapt + itcom1_1.in % nv * *n], &
	    c__1);

/* ----------------------------hess matrix update--------------------------- */

/* there are two schemes here, based on two different ways of projecting */
/* the iteration matrix. */

/* update hessenberg matrix: scheme 1 */

    if (! evest) {
	goto L955;
    }
    wk[ilam + itcom1_1.in % (nv + 1)] = vlamda;
    if (itcom1_1.is == 0) {
	i__1 = nhess * (nv + 2);
	vfill_(&i__1, &wk[ihess], &c_b121);
    }
    if (methev != 1) {
	goto L746;
    }

    i__1 = itcom1_1.in;
    for (i__ = itcom1_1.in - np; i__ <= i__1; ++i__) {
	if (i__ == itcom1_1.in) {
	    apar = apap;
	}
	if (i__ != itcom1_1.in) {
	    apar = wk[iapar + i__ % nv];
	}
	i__2 = i__ + 1 + (itcom1_1.is - itcom1_1.in);
	i__3 = itcom1_1.in - i__ + 2;
	i__4 = i__ + 1 + (itcom1_1.is - itcom1_1.in);
	i__5 = itcom1_1.in - i__ + 2;
	wk[ihess + (i__2 - 1) + (i__3 - 1) * nhess] = wk[ihess + (i__4 - 1) +
		(i__5 - 1) * nhess] + apar / wk[ilam + itcom1_1.in % (nv + 1)]
		 / sqrt(wk[idot + itcom1_1.in % (nv + 1)] * wk[idot + i__ % (
		nv + 1)]);
	if (itcom1_1.is != 0) {
	    i__2 = itcom1_1.in - 1;
	    i__3 = i__ + 1 + (itcom1_1.is - itcom1_1.in);
	    i__4 = itcom1_1.in - i__ + 1;
	    i__5 = i__ + 1 + (itcom1_1.is - itcom1_1.in);
	    i__6 = itcom1_1.in - i__ + 1;
	    i__7 = itcom1_1.in - 1;
	    wk[ihess + (i__3 - 1) + (i__4 - 1) * nhess] = wk[ihess + (i__5 -
		    1) + (i__6 - 1) * nhess] - apar / wk[ilam + i__7 % (nv +
		    1)] / sqrt(wk[idot + i__2 % (nv + 1)] * wk[idot + i__ % (
		    nv + 1)]);
	}
/* L954: */
    }
    iesize = itcom1_1.is;
    goto L747;

/* update hessenberg matrix: scheme 2 */

L746:
    iesize = itcom1_1.is + 1;
    i__1 = itcom1_1.is + 2;
    wk[ihess + (i__1 - 1) + (c__1 - 1) * nhess] = -1. / vlamda;
    i__1 = itcom1_1.is + 1;
    wk[ihess + (i__1 - 1) + (c__2 - 1) * nhess] = 1. / vlamda;
    if (np == 0) {
	goto L749;
    }
    i__1 = itcom1_1.in - 1;
    for (i__ = itcom1_1.in - np; i__ <= i__1; ++i__) {
	id = itcom1_1.in - i__ + 1;
	i__2 = itcom1_1.is + 3 - id;
	i__3 = itcom1_1.is + 3 - id;
	wk[ihess + (i__2 - 1) + (id - 1) * nhess] = wk[ihess + (i__3 - 1) + (
		id - 1) * nhess] - wk[iapar + i__ % nv] / wk[idot + i__ % (nv
		+ 1)] / wk[ilam + i__ % (nv + 1)];
/* L748: */
	i__2 = itcom1_1.is + 2 - id;
	i__3 = id + 1;
	i__4 = itcom1_1.is + 2 - id;
	i__5 = id + 1;
	wk[ihess + (i__2 - 1) + (i__3 - 1) * nhess] = wk[ihess + (i__4 - 1) +
		(i__5 - 1) * nhess] + wk[iapar + i__ % nv] / wk[idot + i__ % (
		nv + 1)] / wk[ilam + i__ % (nv + 1)];
    }
L749:

/* estimate eigenvalues ... */

L747:
    nwhe = *nw - (iv1 - 1);
    i__2 = nv + 2;
    hesest_(&wk[ihess], &nhess, &i__2, &iesize, &itcom1_1.ns3, &havest, &
	    emaxnw, &eminnw, &wk[iv1], &nwhe, ier);
/* Computing MAX */
    i__2 = nwusd, i__3 = iv1 - 1 + nwhe;
    nwusd = max(i__2,i__3);
    if (*ier != 0) {
	goto L995;
    }
    if (! havest) {
	goto L955;
    }
    if (hadest) {
	goto L956;
    }
    if (itcom2_1.maxadd) {
	itcom3_1.emax = emaxnw;
    }
    if (itcom2_1.minadd) {
	itcom3_1.emin = eminnw;
    }
    hadest = TRUE_;
    goto L955;
L956:
    if (itcom2_1.maxadd) {
	itcom3_1.emax = max(itcom3_1.emax,emaxnw);
    }
    if (itcom2_1.minadd) {
	itcom3_1.emin = min(itcom3_1.emin,eminnw);
    }

/* ---------------------------proceed to next iteration------------------------ */

L955:
    ++itcom1_1.in;
    ++itcom1_1.is;
    if (itcom1_1.is == itcom1_1.ns2) {
	itcom1_1.is = 0;
    }
    goto L10;

/* -------------------------------finish up------------------------------------ */

L900:
    if (! itcom2_1.halt) {
	goto L996;
    }
    if (itcom1_1.level >= 1) {
	io___836.ciunit = itcom1_1.nout;
	s_wsfe(&io___836);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts >= 0) {
	perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[
		1], &rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
    }
/* pack revised parms into iparm, rparm ... */
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;


/* --------------------------------error returns----------------------------- */

/* unimplemented option ... */
L995:
    *ier = -16;
    ershow_(ier, "omingw", (ftnlen)6);
    goto L725;

/* no convergence ... */
L996:
    *ier = 1;
    ershow_(ier, "omingw", (ftnlen)6);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;

/* generic error handler ... */
L997:
    ershow_(ier, "omingw", (ftnlen)6);
    goto L735;

/* breakdown ... */
L998:
    *ier = -15;
    ershow_(ier, "omingw", (ftnlen)6);
    goto L725;

/* insufficient floating point wksp ... */
L999:
    *ier = -2;
    ershow_(ier, "omingw", (ftnlen)6);
    goto L735;
} /* omingw_ */

/* Subroutine */ int oresw_(S_fp suba, S_fp subql, S_fp subqr, doublereal *
	coef, integer *jcoef, doublereal *wfac, integer *jwfac, integer *n,
	doublereal *u, doublereal *ubar, doublereal *rhs, doublereal *wk,
	integer *nw, integer *iparm, doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 orthores\002)";
    static char fmt_720[] = "(/\002 orthores converged in \002,i5,\002 itera"
	    "tions.\002)";

    /* System generated locals */
    integer i__1, i__2, i__3;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__;
    static doublereal t1, t2;
    static integer iu, np, iz, nv, iv1, iv2;
    static doublereal den, sig;
    static logical iql, iqr;
    static doublereal top, xxx;
    static integer iend, idot;
    extern doublereal vdot_(integer *, doublereal *, doublereal *), timer_(
	    doublereal *);
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    static doublereal timit, dummy;
    static integer nwusd;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *),
	     pstop_(integer *, S_fp, S_fp, S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *);
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static integer ibegin;
    static doublereal vlamda;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *), inithv_(integer *);
    static doublereal sigsum;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen), vexopy_(
	    integer *, doublereal *, doublereal *, doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___844 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___864 = { 0, 0, 0, fmt_720, 0 };



/* this routine implements orthores with truncation and */
/* restarting and with 2-sided preconditioning.  the value of z is */
/* the identity.  the code is optimal in speed and workspace */
/* requirements, for general a, ql and qr. */


/* *** begin -- package common */


/* *** end   -- package common */

/* the following indexing functions are used to access the old */
/* direction vectors and dot products -- */


/* various preliminary calculations. */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    nwusd = 0;
    *ier = 0;
    itcom1_1.iacel = 9;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L997;
    }
    if (itcom1_1.level >= 2) {
	io___844.ciunit = itcom1_1.nout;
	s_wsfe(&io___844);
	e_wsfe();
    }
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;

/* initialize the stopping test ... */

    inithv_(&c__0);
    itcom9_1.zhave = TRUE_;
    itcom9_1.zthave = TRUE_;
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L730;
    }

/* memory allocation, etc. */

/* nomenclature -- r  -- residual of the original system. */
/*                 z  -- inv(ql)*r */
/*                 zt -- inv(qr)*z */

/* Computing MAX */
/* Computing MIN */
    i__3 = itcom1_1.ns1 + 1;
    i__1 = 1, i__2 = min(i__3,itcom1_1.ns2);
    nv = max(i__1,i__2);
    iu = 1;
    iz = iu + nv * *n;
    idot = iz + nv * *n;
    iv1 = idot + nv;
    iv2 = iv1 + *n;
/* Computing MAX */
    i__1 = nwusd, i__2 = iv2 - 1 + *n;
    nwusd = max(i__1,i__2);

/* check the memory usage -- */

    if (nwusd > *nw) {
	goto L999;
    }

    itcom1_1.in = 0;

/* perform first-iterate calculations. */
/* note -- we will use the vector 'u' to store ztilde. the u vectors */
/* will be stored in the table.  wk(iv1) will hold r. */

    vcopy_(n, &u[1], &wk[iu + c__0 % nv * *n]);
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iz +
	    c__0 % nv * *n]);
    (*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iz + c__0 % nv *
	     *n], &u[1]);
    wk[idot + c__0 % nv] = vdot_(n, &wk[iz + c__0 % nv * *n], &wk[iz + c__0 %
	    nv * *n]);

/* -------------------------begin iteration loop----------------------- */

/* determine whether or not to stop -- */

L10:
    inithv_(&c__1);
    nwpstp = *nw - (iv2 - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &wk[iu + itcom1_1.in % nv * *n], &ubar[1],
	    &rhs[1], &xxx, &wk[iz + itcom1_1.in % nv * *n], &u[1], &wk[iv2], &
	    nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iv2 - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &wk[iu + itcom1_1.in % nv * *n]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }

/* proceed to calculate the iterates. */

/* Computing MIN */
    i__1 = itcom1_1.in % itcom1_1.ns2 + 1, i__2 = itcom1_1.ns1 + 1;
    np = min(i__1,i__2);
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    i__1 = itcom1_1.in + 1 - np;
    top = vdot_(n, &wk[iz + i__1 % nv * *n], &wk[iv2]);
    i__1 = itcom1_1.in + 1 - np;
    sig = top / wk[idot + i__1 % nv];
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1 - np;
    d__1 = -sig;
    vtriad_(n, &wk[iz + i__1 % nv * *n], &wk[iv2], &d__1, &wk[iz + i__2 % nv *
	     *n], &c__1);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1 - np;
    vtriad_(n, &wk[iu + i__1 % nv * *n], &u[1], &sig, &wk[iu + i__2 % nv * *n]
	    , &c__1);
    sigsum = sig;
    ibegin = itcom1_1.in - np + 2;
    iend = itcom1_1.in;
    if (ibegin > iend) {
	goto L613;
    }
    i__1 = iend;
    for (i__ = ibegin; i__ <= i__1; ++i__) {
	top = vdot_(n, &wk[iz + i__ % nv * *n], &wk[iv2]);
	den = wk[idot + i__ % nv];
	if (abs(den) < itcom4_1.srelpr) {
	    goto L998;
	}
	sig = top / den;
	i__2 = itcom1_1.in + 1;
	i__3 = itcom1_1.in + 1;
	d__1 = -sig;
	vtriad_(n, &wk[iz + i__2 % nv * *n], &wk[iz + i__3 % nv * *n], &d__1,
		&wk[iz + i__ % nv * *n], &c__1);
	i__2 = itcom1_1.in + 1;
	i__3 = itcom1_1.in + 1;
	vtriad_(n, &wk[iu + i__2 % nv * *n], &wk[iu + i__3 % nv * *n], &sig, &
		wk[iu + i__ % nv * *n], &c__1);
/* L612: */
	sigsum += sig;
    }
L613:
    if (abs(sigsum) < itcom4_1.srelpr) {
	goto L998;
    }
    vlamda = 1. / sigsum;
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    d__1 = -vlamda;
    vtriad_(n, &wk[iz + i__1 % nv * *n], &xxx, &d__1, &wk[iz + i__2 % nv * *n]
	    , &c__2);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[iu + i__1 % nv * *n], &xxx, &vlamda, &wk[iu + i__2 % nv * *
	    n], &c__2);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    i__3 = itcom1_1.in + 1;
    wk[idot + i__1 % nv] = vdot_(n, &wk[iz + i__2 % nv * *n], &wk[iz + i__3 %
	    nv * *n]);

    i__1 = itcom1_1.in + 1;
    (*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iz + i__1 % nv *
	     *n], &u[1]);

/* proceed to next iteration */

    ++itcom1_1.in;
    goto L10;

/* -----------------------------finish up---------------------------- */

L900:
    vcopy_(n, &wk[iu + itcom1_1.in % nv * *n], &u[1]);
    if (itcom2_1.halt) {
	goto L715;
    }
    *ier = 1;
    ershow_(ier, "oresw", (ftnlen)5);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;
L715:
    if (itcom1_1.level >= 1) {
	io___864.ciunit = itcom1_1.nout;
	s_wsfe(&io___864);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts < 0) {
	goto L730;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
L730:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;

/* error returns */

L997:
    ershow_(ier, "oresw", (ftnlen)5);
    goto L735;

L998:
    *ier = -15;
    ershow_(ier, "oresw", (ftnlen)5);
    goto L725;

L999:
    *ier = -2;
    ershow_(ier, "oresw", (ftnlen)5);
    goto L735;

} /* oresw_ */

/* Subroutine */ int iomw_(S_fp suba, S_fp subql, S_fp subqr, doublereal *
	coef, integer *jcoef, doublereal *wfac, integer *jwfac, integer *n,
	doublereal *u, doublereal *ubar, doublereal *rhs, doublereal *wk,
	integer *nw, integer *iparm, doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 iom\002)";
    static char fmt_720[] = "(/\002 iom converged in \002,i5,\002 iteratio"
	    "ns.\002)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__;
    static doublereal t1, t2;
    static integer iu, iv, iw, os, nv, iv1, iv2;
    static logical iql;
    static doublereal ucn;
    static logical iqr;
    static doublereal xxx;
    static integer ibgn, iend;
    static doublereal gdum[1];
    static integer icos, isin;
    extern /* Subroutine */ int pvec_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     logical *, doublereal *, doublereal *, integer *);
    static doublereal zold, zbar;
    static integer vect1, vect2;
    static doublereal ucnp1;
    static integer dots1, dots2;
    static logical uneed, exact;
    static doublereal zbold;
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    static integer idotw;
    static doublereal dummy;
    extern /* Subroutine */ int qrupd_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *);
    static doublereal timit;
    static integer nwusd;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *),
	     pstop_(integer *, S_fp, S_fp, S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *);
    static integer ibeta2, ibeta1;
    static doublereal gamma1, gamma2, digit1, digit2, wkxxx[1], vn1old,
	    vn2old, vnorm1, vnorm2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static doublereal ucnbar;
    static logical gamize;
    static doublereal factor;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *), inithv_(integer *),
	    ershow_(integer *, char *, ftnlen), vexopy_(integer *, doublereal
	    *, doublereal *, doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___875 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___914 = { 0, 0, 0, fmt_720, 0 };



/* code to run the (truncated) iom algorithm.  the reference is */
/* youcef saad, "krylov subspace methods ...", mathematics of */
/* computation, vol. 37, july 1981, pp. 105f. */

/* in the symmetric case this algorithm reduces to the symmlq */
/* algorithm of paige and saunders, except paige and saunders have */
/* implemented a trick to avoid breakdown before convergence.  this */
/* trick is not implemented here. */


/* *** begin -- package common */


/* *** end   -- package common */

/* next, the indexing functions. */


/* preliminary calculations. */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    nwusd = 0;
    *ier = 0;
    itcom1_1.iacel = 10;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L996;
    }
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;
    gamize = TRUE_;
    if (iqr) {
	goto L995;
    }
    if (itcom1_1.level >= 2) {
	io___875.ciunit = itcom1_1.nout;
	s_wsfe(&io___875);
	e_wsfe();
    }
/* the following flag tells us whether the truncating actually */
/* throws out important information.  it should actually be set to */
/* true if the matrix is symmetric. */
    exact = FALSE_;

/* initialize the stopping test ... */

    inithv_(&c__0);
    itcom9_1.zdhav = TRUE_;
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L730;
    }

/* ... associated integer variables. */

    os = abs(itcom1_1.ns1);
    iv = 1;
    nv = os;
    idotw = 1;
    iw = 1;
    vect1 = iw + iv * *n * os;
    vect2 = vect1;
    dots1 = vect2 + iv * *n * nv;
    dots2 = dots1;
    ibeta1 = dots2 + idotw * os;
    ibeta2 = ibeta1;
    icos = ibeta2 + os;
    isin = icos + os;
    iu = isin + os;
    iv1 = iu + os + 1;
    iv2 = iv1 + *n;
/* Computing MAX */
    i__1 = nwusd, i__2 = iv2 - 1 + *n;
    nwusd = max(i__1,i__2);

/* check the memory usage -- */

    if (nwusd > *nw) {
	goto L999;
    }

    itcom1_1.in = 0;
    itcom1_1.is = 0;
    uneed = itcom9_1.rcalp || itcom9_1.zcalp || itcom9_1.ztcalp ||
	    itcom9_1.udhav || itcom1_1.ntest == 6 || itcom1_1.level >= 3;

/* --------------------------begin iteration loop--------------------- */

/* perform first-iterate calculations ... */

L10:
    if (itcom1_1.is != 0) {
	goto L100;
    }
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    pvec_(n, &nv, &iv, &c__1, &os, &idotw, &itcom1_1.is, &c__1, &c__1, &wk[
	    vect1], &wk[dots1], &c__0, &wk[ibeta1], gdum, &gamize, &wk[iv2],
	    wkxxx, ier);
    gamma1 = gdum[0];
    if (*ier < 0) {
	goto L997;
    }
    gamma2 = gamma1;
    vnorm1 = 1. / gamma1;
    vnorm2 = 1. / gamma2;
/* Computing 2nd power */
    d__1 = vnorm1;
    itcom9_1.zdot = d__1 * d__1;
    ucnp1 = 0.;

L100:
    inithv_(&c__1);
    itcom9_1.zdhav = TRUE_;
    nwpstp = *nw - (iv1 - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[iv1], &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iv1 - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &u[1]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }


/* ... compute q(n+1), etc -- the direction vectors */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[vect1 +
	    itcom1_1.is % nv * *n], &wk[iv1]);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    i__1 = itcom1_1.is + 1;
    pvec_(n, &nv, &iv, &c__1, &os, &idotw, &i__1, &c__1, &c__1, &wk[vect1], &
	    wk[dots1], &c__0, &wk[ibeta1], gdum, &gamize, &wk[iv2], wkxxx,
	    ier);
    gamma1 = gdum[0];
    if (*ier < 0) {
	goto L997;
    }
    gamma2 = gamma1;

/* ... now record norms. */

    vn1old = vnorm1;
    vnorm1 = 1. / gamma1;
    vn2old = vnorm2;
    vnorm2 = 1. / gamma2;

/* ... now update the factorization */

    ucnbar = ucnp1;
/* Computing MAX */
    i__1 = 0, i__2 = itcom1_1.is + 1 - os;
    ibgn = max(i__1,i__2);
    i__1 = itcom1_1.is;
    for (i__ = ibgn; i__ <= i__1; ++i__) {
/* L1: */
	i__2 = i__ + 1;
	wk[iu + i__2 % (os + 1)] = -wk[ibeta2 + i__ % os];
    }
    if (ibgn > 0) {
	wk[iu + ibgn % (os + 1)] = 0.;
    }
    i__2 = itcom1_1.is + 1;
    i__1 = os + 1;
    qrupd_(&i__2, &i__1, &os, &wk[icos], &wk[isin], &ucnbar, &ucn, &wk[iu], &
	    vn2old, ier);
    if (*ier < 0) {
	goto L998;
    }
    i__2 = itcom1_1.is + 1;
    ucnp1 = wk[iu + i__2 % (os + 1)];

/* ... update the old w vector. */

    if (itcom1_1.is != 0) {
	i__2 = itcom1_1.is - 1;
	i__1 = itcom1_1.is - 1;
	d__1 = ucnbar / ucn;
	vtriad_(n, &wk[iw + *n * (i__2 % os)], &xxx, &d__1, &wk[iw + *n * (
		i__1 % os)], &c__2);
    }

/* ... now generate the new w vector. */

    if (abs(ucnp1) < itcom4_1.srelpr) {
	goto L998;
    }
    vcopy_(n, &wk[vect1 + itcom1_1.is % nv * *n], &wk[iv1]);
/* Computing MAX */
    i__2 = 1, i__1 = itcom1_1.is - os + 1;
    ibgn = max(i__2,i__1);
    iend = itcom1_1.is;
    if (iend < ibgn) {
	goto L200;
    }
    i__2 = iend;
    for (i__ = ibgn; i__ <= i__2; ++i__) {
/* L201: */
	i__1 = i__ - 1;
	d__1 = -wk[iu + i__ % (os + 1)];
	vtriad_(n, &wk[iv1], &wk[iv1], &d__1, &wk[iw + *n * (i__1 % os)], &
		c__1);
    }
L200:
    d__1 = 1. / ucnp1;
    vtriad_(n, &wk[iw + *n * (itcom1_1.is % os)], &xxx, &d__1, &wk[iv1], &
	    c__2);
    if (itcom1_1.is != 0) {
	goto L205;
    }

/* ... update iterate u(0). */

    zold = 0.;
    zbar = vn1old;
    if (uneed) {
	vtriad_(n, &u[1], &u[1], &zbar, &wk[iw + *n * (c__0 % os)], &c__1);
    }
    goto L210;

/* ... update subsequent iterates u(n). */

L205:
    zold = wk[icos + itcom1_1.is % os] * zbar;
    zbold = zbar;
    zbar = -wk[isin + itcom1_1.is % os] * zbar;
    factor = zold;
    if (uneed) {
	factor -= zbold * ucn / ucnbar;
    }
    i__1 = itcom1_1.is - 1;
    vtriad_(n, &u[1], &u[1], &factor, &wk[iw + *n * (i__1 % os)], &c__1);
    if (uneed) {
	vtriad_(n, &u[1], &u[1], &zbar, &wk[iw + *n * (itcom1_1.is % os)], &
		c__1);
    }
/* to avoid breakdown for the symmetric indefinite case, we'd only add */
/* in w(is-1) here, i believe. */
L210:
/* Computing 2nd power */
    d__1 = zbar / ucnp1 * vnorm1;
    itcom9_1.zdot = d__1 * d__1;

/* proceed to next iteration */

    ++itcom1_1.in;
    ++itcom1_1.is;
    goto L10;

/* -----------------------------finish up------------------------------ */

L900:
    if (! uneed) {
	i__1 = itcom1_1.is - 1;
	vtriad_(n, &u[1], &u[1], &zbar, &wk[iw + *n * (i__1 % os)], &c__1);
    }
    if (itcom2_1.halt) {
	goto L715;
    }
    *ier = 1;
    ershow_(ier, "iomw", (ftnlen)4);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;
L715:
    if (itcom1_1.level >= 1) {
	io___914.ciunit = itcom1_1.nout;
	s_wsfe(&io___914);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts < 0) {
	goto L730;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
L730:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;

/* error returns */

L995:
    *ier = -16;
    ershow_(ier, "iomw", (ftnlen)4);
    return 0;

L996:
    ershow_(ier, "iomw", (ftnlen)4);
    goto L735;

L997:
    *ier = -13;
    ershow_(ier, "iomw", (ftnlen)4);
    goto L725;

L998:
    *ier = -14;
    ershow_(ier, "iomw", (ftnlen)4);
    goto L725;

L999:
    *ier = -2;
    ershow_(ier, "iomw", (ftnlen)4);
    goto L735;

} /* iomw_ */

/* Subroutine */ int gmresw_(S_fp suba, S_fp subql, S_fp subqr, doublereal *
	coef, integer *jcoef, doublereal *wfac, integer *jwfac, integer *n,
	doublereal *u, doublereal *ubar, doublereal *rhs, doublereal *wk,
	integer *nw, integer *iparm, doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 gmres\002)";
    static char fmt_720[] = "(/\002 gmres converged in \002,i5,\002 iteratio"
	    "ns.\002)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublereal d__1, d__2;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    double sqrt(doublereal);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static doublereal h__;
    static integer i__, j;
    static doublereal t1, t2, v1, v2, uc;
    static integer ip, nm, iu, iw, iy, nv, iz;
    static doublereal ut;
    static integer iv1, iv2;
    static doublereal apf;
    static integer ipf;
    static doublereal val;
    static logical iql;
    static integer iwf, nuc, izc, nzc;
    static logical iqr;
    static integer ipt, ixi;
    static doublereal dot, xif;
    static integer ipz;
    static doublereal sum;
    static integer nvt;
    static doublereal xxx;
    static integer ns2e, ibeg, iend, ibgn, icos, isin, nbwh;
    static doublereal ctmp;
    static integer nwhe;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static integer nrot;
    static doublereal stmp;
    static logical uneed, exact, zneed;
    static integer ihess, nhess;
    static logical trunc;
    static integer nbwuh, nwusd;
    extern doublereal timer_(doublereal *);
    static doublereal dummy;
    static integer iadpt;
    extern /* Subroutine */ int pstop_(integer *, S_fp, S_fp, S_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *);
    static doublereal vnorm;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *),
	     iterm_(integer *, doublereal *), vfill_(integer *, doublereal *,
	    doublereal *);
    static doublereal pfnew;
    static integer iuold, iunew;
    static logical rstrt;
    static doublereal denom, wfnew;
    static integer iynew;
    static doublereal digit1, digit2, timit;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static logical hadest, evadpt;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *);
    static logical havest;
    extern /* Subroutine */ int hesest_(doublereal *, integer *, integer *,
	    integer *, integer *, logical *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *);
    static doublereal eminnw, emaxnw;
    extern /* Subroutine */ int inithv_(integer *);
    static logical zhvold;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen);
    static integer ipznew;
    static logical rstrtd;
    extern /* Subroutine */ int vexopy_(integer *, doublereal *, doublereal *,
	     doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___928 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___992 = { 0, 0, 0, fmt_720, 0 };



/* code to run the truncated/restarted gmres algorithm.  a detailed */
/* description of this useful algorithm may be found in the paper, */
/* "gmres: a generalized minimal residual algorithm for solving */
/* nonsymmetric linear systems", youcef saad and martin h. schultz, */
/* siam j. sci. stat. comput., v. 7, no. 3, july 1986. */

/* further scoop on how to set up qr factorizations can be obtained in */
/* "practical use of some krylov subspace methods for solving */
/* indefinite and unsymmetric linear systems", youcef saad, siam j. sci. */
/* stat. comput., v. 5, no. 1, march 1984. */

/* the advantage of this algorithm over its competitors orthomin and gcr */
/* is that work and storage are saved by avoiding the computation of */
/* certain vectors. */

/* this routine now handles right and 2-sided preconditioning.  the main */
/* thing to note about this is that a new table of basis vecttors is now */
/* necessary, to use to update the solution. */

/* this routine also avoids explicit scaling of the p and w vectors. */

/* for the pure restarted case, we actually compute the final arnoldi */
/* vector, rather than just estimating its norm.  this is a diversion */
/* from the saad/schultz paper.  this was done because in some cases it */
/* was found that the norm estimation was subject to significant */
/* numerical error. */

/* modified feb. 1990 to make the restarted method more efficient. */
/* specifically, new formulas were installed for the scalar part of */
/* the computation to give an optimal asymptotic dependence on ns2. */

/* ---------------------------------------------------------------------- */


/* *** begin -- package common */


/* *** end   -- package common */

/* -------------------------- indexing functions -------------------------- */

/* the following function accesses the arnoldi vectors. */

/* the following accesses q-r times the arnoldi vectors */

/* fudge factor for the arnoldi vectors.  p(actual) = p(stored)*pfudge. */
/* (we do the same trick with a*p.) */

/* the following accesses the w-vectors. */

/* fudge factors for the w vectors ... */
/* (similarly, the vector "xi" is fudged.) */

/* the following accesses the hessenberg matrix -- stored by diagonals ... */

/* the following are the cosines and sines of the rotations. */

/* the following accesses the u matrix -- stored by columns ... */

/* the following accesses the z-vector ... */

/* ----------------------- preliminary calculations ---------------------- */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    nwusd = 0;
    *ier = 0;
    itcom1_1.iacel = 11;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L996;
    }
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;
    iadpt = itcom1_1.ns3;
    evadpt = (itcom2_1.maxadd || itcom2_1.minadd) && iadpt != 0;
    trunc = itcom1_1.ns1 < itcom1_1.ns2 - 1;
    exact = ! trunc;
    if (itcom1_1.ns1 < 2) {
	goto L995;
    }
    if (itcom1_1.level >= 2) {
	io___928.ciunit = itcom1_1.nout;
	s_wsfe(&io___928);
	e_wsfe();
    }

/* --------------------------initialize the stopping test------------------ */

    inithv_(&c__0);
    itcom9_1.zdhav = ! (trunc && ! exact);
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L730;
    }

/* uneed tells us whether u must be computed explicitly per iteration. */
/* similarly for zneed. */
    uneed = itcom9_1.rcalp || itcom9_1.udhav || itcom1_1.ntest == 6 ||
	    itcom1_1.level >= 3;
    zneed = itcom9_1.zcalp;
    hadest = FALSE_;

/* ------------------------associated integer variables--------------------- */

/* ---effective ns2--- */
    ns2e = min(itcom1_1.ns2,itcom1_1.itmax);
/* ---length of diags of hess matrix--- */
    nhess = ns2e + 2;
/* ---bandwidth of the hess matrix--- */
/* Computing MIN */
    i__1 = itcom1_1.ns1 + 1, i__2 = ns2e + 1;
    nbwh = min(i__1,i__2);
/* ---bandwidth of u-or-h--- */
/* Computing MIN */
    i__1 = itcom1_1.ns1 + 2, i__2 = ns2e + 1;
    nbwuh = min(i__1,i__2);
/* ---number columns stored of the u matrix--- */
    if (trunc) {
	nuc = 1;
    }
    if (! trunc) {
	nuc = ns2e;
    }
/* ---size of arnoldi-vector tables--- */
/* Computing MIN */
    i__1 = itcom1_1.ns1, i__2 = ns2e + 1;
    nv = min(i__1,i__2);
    nvt = nv;
    if (iqr && ! trunc) {
	nvt = nv - 1;
    }
    if (iqr && trunc) {
	nvt = 1;
    }
/* ---number of givens rotations to store--- */
    nrot = min(itcom1_1.ns1,ns2e);
/* ---number of elts of z-vector to store--- */
    if (trunc) {
	nzc = 2;
    }
    if (! trunc) {
	nzc = ns2e + 1;
    }

/* ------------------------------memory layout--------------------------- */

    ihess = 1;
    ipt = ihess + nhess * nbwh;
    if (! evadpt) {
	ipt = ihess;
    }
    ip = ipt + *n * nvt;
    if (! iqr) {
	ip = ipt;
    }
    izc = ip + *n * nv;
    icos = izc + nzc;
    isin = icos + nrot;
    iy = isin + nrot;
    iu = iy + ns2e;
    if (trunc || ! uneed) {
	iu = iy;
    }
    ipz = iu + nbwuh * nuc;
    ipf = ipz + ns2e + 1;
    if (trunc) {
	ipf = ipz;
    }
    iz = ipf + nv;
    iw = iz + *n;
    iwf = iw + *n * nv;
    ixi = iwf + nv;
    iv1 = ixi + *n;
    if (! trunc) {
	iv1 = iw;
    }
    iv2 = iv1 + *n;
/* Computing MAX */
    i__1 = nwusd, i__2 = iv2 + *n - 1;
    nwusd = max(i__1,i__2);

/* --- check the memory usage --- */

    if (nwusd > *nw) {
	goto L999;
    }

    itcom1_1.in = 0;
    itcom1_1.is = 0;
    rstrtd = TRUE_;

/* -------------------------------------------------------------------- */
/* ---------------------------begin iteration loop--------------------- */
/* -------------------------------------------------------------------- */

/* handle first iteration after restart ... */

L10:
    inithv_(&c__1);
    itcom9_1.zdhav = ! (trunc && ! exact) && itcom1_1.in != 0;
    if (! rstrtd) {
	goto L100;
    }
/*    ---get resid--- */
    if (! itcom9_1.zhave) {
	if (iql) {
	    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[
		    iv1]);
	    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
	    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &
		    wk[iz]);
	} else {
	    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[
		    iz]);
	    vexopy_(n, &wk[iz], &rhs[1], &wk[iz], &c__2);
	}
	itcom9_1.zhave = TRUE_;
    }
/*    ---get resid norm--- */
    if (! itcom9_1.zdhav) {
	itcom9_1.zdot = vdot_(n, &wk[iz], &wk[iz]);
	itcom9_1.zdhav = TRUE_;
    }
    if (itcom9_1.zdot < 0.) {
	goto L994;
    }
    vnorm = sqrt(itcom9_1.zdot);
/* Computing 2nd power */
    d__1 = itcom4_1.srelpr;
    if (vnorm < d__1 * d__1) {
	goto L997;
    }
    vcopy_(n, &wk[iz], &wk[ip + itcom1_1.is % nv * *n]);
    wk[ipf + itcom1_1.is % nv] = 1. / vnorm;
    i__1 = itcom1_1.is + 1;
    wk[izc + (i__1 - 1) % nzc] = vnorm;

/* --- perform stopping test --- */

L100:
    nwpstp = *nw - (iv1 - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &wk[iz], &
	    xxx, &wk[iv1], &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iv1 - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &u[1]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }

/* rstrt tells us whether this is the last step before restarting ... */
    rstrt = itcom1_1.is + 1 == itcom1_1.ns2;
    if (evadpt && itcom1_1.is == 0) {
	i__1 = nhess * nbwh;
	vfill_(&i__1, &wk[ihess], &c_b121);
    }

/* -----------------------compute the new arnoldi vector---------------- */

/* pn(is+1)*p(is+1) = a*p(is) + sum (i=0 to is) (beta(is+1,i)*p(i)), */

/* ---get a times old vec--- */
    if (iqr) {
	(*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ip +
		itcom1_1.is % nv * *n], &wk[ipt + itcom1_1.is % nvt * *n]);
    }
    if (iql) {
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ipt +
		itcom1_1.is % nvt * *n], &wk[iv1]);
	(*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[
		iv2]);
    } else {
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ipt +
		itcom1_1.is % nvt * *n], &wk[iv2]);
    }
    apf = wk[ipf + itcom1_1.is % nv];
/* ---compute arnoldi vector--- */
/* Computing MAX */
    i__1 = itcom1_1.is + 1 - itcom1_1.ns1;
    ibeg = max(i__1,0);
    iend = itcom1_1.is;
    if (ibeg > 0) {
	i__1 = itcom1_1.is + 1;
	wk[iu + i__1 - ibeg + 1 + (i__1 - 1) % nuc * nbwuh] = 0.;
    }
    pfnew = apf;
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
	h__ = vdot_(n, &wk[ip + i__ % nv * *n], &wk[iv2]) * wk[ipf + i__ % nv]
		 * apf;
	i__2 = i__ + 1;
	i__3 = itcom1_1.is + 1;
	wk[iu + i__3 - i__2 + 1 + (i__3 - 1) % nuc * nbwuh] = h__;
	if (evadpt) {
	    i__2 = i__ + 1;
	    i__3 = itcom1_1.is + 1;
	    wk[ihess + (i__2 - 1) + (i__3 - i__2 + 1) * nhess] = h__;
	}
	if (i__ == ibeg) {
	    i__2 = itcom1_1.is + 1;
	    d__1 = -h__ * wk[ipf + i__ % nv] / pfnew;
	    vtriad_(n, &wk[ip + i__2 % nv * *n], &wk[iv2], &d__1, &wk[ip +
		    i__ % nv * *n], &c__1);
	}
	if (i__ != ibeg) {
	    i__2 = itcom1_1.is + 1;
	    i__3 = itcom1_1.is + 1;
	    d__1 = -h__ * wk[ipf + i__ % nv] / pfnew;
	    vtriad_(n, &wk[ip + i__2 % nv * *n], &wk[ip + i__3 % nv * *n], &
		    d__1, &wk[ip + i__ % nv * *n], &c__1);
	}
/* L199: */
    }
    i__1 = itcom1_1.is + 1;
    wk[ipf + i__1 % nv] = pfnew;
/* ---get norm--- */
    i__1 = itcom1_1.is + 1;
    i__2 = itcom1_1.is + 1;
/* Computing 2nd power */
    d__1 = pfnew;
    dot = vdot_(n, &wk[ip + i__1 % nv * *n], &wk[ip + i__2 % nv * *n]) * (
	    d__1 * d__1);
    vnorm = sqrt(dot);
/* Computing 2nd power */
    d__1 = itcom4_1.srelpr;
    if (vnorm < d__1 * d__1) {
	goto L192;
    }
    i__1 = itcom1_1.is + 2;
    i__2 = itcom1_1.is + 1;
    wk[iu + i__2 - i__1 + 1 + (i__2 - 1) % nuc * nbwuh] = vnorm;
    if (evadpt) {
	i__1 = itcom1_1.is + 2;
	i__2 = itcom1_1.is + 1;
	wk[ihess + (i__1 - 1) + (i__2 - i__1 + 1) * nhess] = vnorm;
    }
/* ---scale--- */
    i__1 = itcom1_1.is + 1;
    i__2 = itcom1_1.is + 1;
    wk[ipf + i__1 % nv] = wk[ipf + i__2 % nv] / vnorm;
    i__1 = itcom1_1.is + 1;
    i__2 = itcom1_1.is + 1;
    if ((d__1 = wk[ipf + i__1 % nv], abs(d__1)) < itcom4_1.srelpr || (d__2 =
	    wk[ipf + i__2 % nv], abs(d__2)) > 1. / itcom4_1.srelpr) {
	i__1 = itcom1_1.is + 1;
	i__2 = itcom1_1.is + 1;
	i__3 = itcom1_1.is + 1;
	vtriad_(n, &wk[ip + i__1 % nv * *n], &xxx, &wk[ipf + i__2 % nv], &wk[
		ip + i__3 % nv * *n], &c__2);
	i__1 = itcom1_1.is + 1;
	wk[ipf + i__1 % nv] = 1.;
    }

/* -----------------------update the qr factorization------------------- */

L192:
/* ---apply old rotations--- */
/* Computing MAX */
    i__1 = 0, i__2 = itcom1_1.is - itcom1_1.ns1;
    ibgn = max(i__1,i__2);
    i__1 = ibgn + 1;
    i__2 = itcom1_1.is + 1;
    iuold = iu + i__2 - i__1 + 1 + (i__2 - 1) % nuc * nbwuh;
    i__1 = itcom1_1.is - 1;
    for (i__ = ibgn; i__ <= i__1; ++i__) {
	i__2 = i__ + 2;
	i__3 = itcom1_1.is + 1;
	iunew = iu + i__3 - i__2 + 1 + (i__3 - 1) % nuc * nbwuh;
	ut = wk[iuold];
	h__ = wk[iunew];
	i__2 = i__ + 1;
	ctmp = wk[icos + i__2 % nrot];
	i__2 = i__ + 1;
	stmp = wk[isin + i__2 % nrot];
	wk[iuold] = ctmp * ut + stmp * h__;
	wk[iunew] = -stmp * ut + ctmp * h__;
/* L7977: */
	iuold = iunew;
    }
    i__1 = itcom1_1.is + 2;
    i__2 = itcom1_1.is + 1;
    iunew = iu + i__2 - i__1 + 1 + (i__2 - 1) % nuc * nbwuh;
/* ---calc new rotation--- */
    v1 = wk[iuold];
    v2 = wk[iunew];
/* Computing 2nd power */
    d__1 = v1;
/* Computing 2nd power */
    d__2 = v2;
    denom = sqrt(d__1 * d__1 + d__2 * d__2);
    if (denom < itcom4_1.srelpr) {
	goto L998;
    }
    i__1 = itcom1_1.is + 1;
    wk[icos + i__1 % nrot] = v1 / denom;
    i__1 = itcom1_1.is + 1;
    wk[isin + i__1 % nrot] = v2 / denom;
/* ---apply new rotation--- */
    wk[iuold] = denom;
    wk[iunew] = 0.;

/* --------------------------compute w, if needed------------------------ */

    i__1 = itcom1_1.is + 1;
    i__2 = itcom1_1.is + 1;
    uc = wk[iu + i__2 - i__1 + 1 + (i__2 - 1) % nuc * nbwuh];
/* Computing 2nd power */
    d__1 = itcom4_1.srelpr;
    if (abs(uc) < d__1 * d__1) {
	goto L998;
    }
    if (! trunc) {
	goto L572;
    }

/* ... case of explicit w calc ... */

    if (itcom1_1.is == 0) {
	vcopy_(n, &wk[ipt + itcom1_1.is % nvt * *n], &wk[iw + *n * (c__1 % nv)
		]);
	i__1 = itcom1_1.is + 1;
	wk[iwf + i__1 % nv] = wk[ipf + itcom1_1.is % nv] / uc;
/*       call vtriad (n,wk(indw(is+1)),xxx,1.0d0/uc,wk(indpt(is)),2) */
	goto L572;
    }
    wfnew = wk[ipf + itcom1_1.is % nv];
/* Computing MAX */
    i__1 = 1, i__2 = itcom1_1.is + 1 - itcom1_1.ns1;
    ibeg = max(i__1,i__2);
    iend = itcom1_1.is;
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
	if (i__ == ibeg) {
	    i__2 = itcom1_1.is + 1;
	    i__3 = itcom1_1.is + 1;
	    d__1 = -wk[iu + i__3 - i__ + 1 + (i__3 - 1) % nuc * nbwuh] * wk[
		    iwf + i__ % nv] / wfnew;
	    vtriad_(n, &wk[iw + *n * (i__2 % nv)], &wk[ipt + itcom1_1.is %
		    nvt * *n], &d__1, &wk[iw + *n * (i__ % nv)], &c__1);
	}
	if (i__ != ibeg) {
	    i__2 = itcom1_1.is + 1;
	    i__3 = itcom1_1.is + 1;
	    i__4 = itcom1_1.is + 1;
	    d__1 = -wk[iu + i__4 - i__ + 1 + (i__4 - 1) % nuc * nbwuh] * wk[
		    iwf + i__ % nv] / wfnew;
	    vtriad_(n, &wk[iw + *n * (i__2 % nv)], &wk[iw + *n * (i__3 % nv)],
		     &d__1, &wk[iw + *n * (i__ % nv)], &c__1);
	}
/* L574: */
    }
    i__1 = itcom1_1.is + 1;
    wk[iwf + i__1 % nv] = wfnew / uc;
    i__1 = itcom1_1.is + 1;
    i__2 = itcom1_1.is + 1;
    if ((d__1 = wk[iwf + i__1 % nv], abs(d__1)) < itcom4_1.srelpr || (d__2 =
	    wk[iwf + i__2 % nv], abs(d__2)) > 1. / itcom4_1.srelpr) {
	i__1 = itcom1_1.is + 1;
	i__2 = itcom1_1.is + 1;
	i__3 = itcom1_1.is + 1;
	vtriad_(n, &wk[iw + *n * (i__1 % nv)], &xxx, &wk[iwf + i__2 % nv], &
		wk[iw + *n * (i__3 % nv)], &c__2);
	i__1 = itcom1_1.is + 1;
	wk[iwf + i__1 % nv] = 1.;
    }
L572:

/* ---get new zc entries--- */
    i__1 = itcom1_1.is + 2;
    i__2 = itcom1_1.is + 1;
    i__3 = itcom1_1.is + 1;
    wk[izc + (i__1 - 1) % nzc] = -wk[isin + i__2 % nrot] * wk[izc + (i__3 - 1)
	     % nzc];
    i__1 = itcom1_1.is + 1;
    i__2 = itcom1_1.is + 1;
    i__3 = itcom1_1.is + 1;
    wk[izc + (i__1 - 1) % nzc] = wk[icos + i__2 % nrot] * wk[izc + (i__3 - 1)
	    % nzc];

/* ------------------- u-vector computation section --------------------- */

    if (trunc) {

/* ---truncated case--- */
	i__1 = itcom1_1.is + 1;
	i__2 = itcom1_1.is + 1;
	i__3 = itcom1_1.is + 1;
	d__1 = wk[izc + (i__1 - 1) % nzc] * wk[iwf + i__2 % nv];
	vtriad_(n, &u[1], &u[1], &d__1, &wk[iw + *n * (i__3 % nv)], &c__1);
    } else {

/* ---non-truncated case--- */
	if (! (uneed || rstrt)) {
	    goto L410;
	}
	iynew = iv1;
/* Computing MAX */
	i__1 = nwusd, i__2 = iynew + ns2e - 1;
	nwusd = max(i__1,i__2);
	if (nwusd > *nw) {
	    goto L999;
	}
/*     ---do back solve on u-matrix--- */
	nm = itcom1_1.is + 1;
	for (i__ = nm; i__ >= 1; --i__) {
	    sum = wk[izc + (i__ - 1) % nzc];
	    i__1 = nm;
	    for (j = i__ + 1; j <= i__1; ++j) {
/* L624: */
		sum -= wk[iynew - 1 + j] * wk[iu + j - i__ + 1 + (j - 1) %
			nuc * nbwuh];
	    }
/* L623: */
	    wk[iynew - 1 + i__] = sum / wk[iu + i__ - i__ + 1 + (i__ - 1) %
		    nuc * nbwuh];
	}
/*     ---form iterate--- */
	i__1 = nm - 1;
	for (i__ = 0; i__ <= i__1; ++i__) {
	    val = wk[iynew + i__];
	    if (uneed && i__ != nm - 1) {
		val -= wk[iy + i__];
	    }
/* L625: */
	    d__1 = val * wk[ipf + i__ % nv];
	    vtriad_(n, &u[1], &u[1], &d__1, &wk[ipt + i__ % nvt * *n], &c__1);
	}
	if (uneed) {
	    vcopy_(&nm, &wk[iynew], &wk[iy]);
	}
    }
L410:

/* --------------------- residual computation section ------------------- */

    zhvold = itcom9_1.zhave;
    itcom9_1.zhave = FALSE_;
    if (trunc) {
	goto L671;
    }

/* ---non-truncated case--- */

/* do it if resid needed by pstop or if restarting. */
    if (zneed || rstrt) {
	ipznew = iv1;
/* Computing MAX */
	i__1 = nwusd, i__2 = ipznew + ns2e;
	nwusd = max(i__1,i__2);
	if (nwusd > *nw) {
	    goto L999;
	}
	i__1 = itcom1_1.is + 1;
	vcopy_(&i__1, &wk[izc], &wk[ipznew]);
	wk[ipznew + itcom1_1.is + 1] = 0.;
/*     ---apply rotations--- */
	for (i__ = itcom1_1.is + 1; i__ >= 1; --i__) {
	    v1 = wk[icos + i__ % nrot] * wk[ipznew + i__ - 1] - wk[isin + i__
		    % nrot] * wk[ipznew + i__];
	    v2 = wk[isin + i__ % nrot] * wk[ipznew + i__ - 1] + wk[icos + i__
		    % nrot] * wk[ipznew + i__];
	    wk[ipznew + i__ - 1] = v1;
/* L644: */
	    wk[ipznew + i__] = v2;
	}
/*     ---form resid--- */
	i__1 = itcom1_1.is + 1;
	for (i__ = 0; i__ <= i__1; ++i__) {
	    val = wk[ipznew + i__];
	    if (zhvold && i__ != itcom1_1.is + 1) {
		val -= wk[ipz];
	    }
/* L645: */
	    d__1 = -val * wk[ipf + i__ % nv];
	    vtriad_(n, &wk[iz], &wk[iz], &d__1, &wk[ip + i__ % nv * *n], &
		    c__1);
	}
	i__1 = itcom1_1.is + 2;
	vcopy_(&i__1, &wk[ipznew], &wk[ipz]);
	itcom9_1.zhave = TRUE_;
    }
    goto L425;

/* ---truncated case--- */

/* do it if pstop needs it or if we may restart later. */
L671:
    if (zneed || itcom1_1.itmax > itcom1_1.ns2) {
/*     ---update xi--- */
	if (itcom1_1.is == 0) {
	    vcopy_(n, &wk[ip + itcom1_1.is % nv * *n], &wk[ixi]);
	    xif = wk[ipf + itcom1_1.is % nv];
	} else {
	    xif *= -wk[isin + itcom1_1.is % nrot];
	    d__1 = wk[icos + itcom1_1.is % nrot] * wk[ipf + itcom1_1.is % nv]
		    / xif;
	    vtriad_(n, &wk[ixi], &wk[ixi], &d__1, &wk[ip + itcom1_1.is % nv *
		    *n], &c__1);
	}
	if (abs(xif) < itcom4_1.srelpr || abs(xif) > 1. / itcom4_1.srelpr) {
	    vtriad_(n, &wk[ixi], &xxx, &xif, &wk[ixi], &c__2);
	    xif = 1.;
	}
/*     ---form resid--- */
	i__1 = itcom1_1.is + 1;
	i__2 = itcom1_1.is + 1;
	d__1 = -wk[izc + (i__1 - 1) % nzc] * wk[icos + i__2 % nrot] * xif;
	vtriad_(n, &wk[iz], &wk[iz], &d__1, &wk[ixi], &c__1);
	i__1 = itcom1_1.is + 1;
	i__2 = itcom1_1.is + 1;
	i__3 = itcom1_1.is + 1;
	i__4 = itcom1_1.is + 1;
	d__1 = -wk[izc + (i__1 - 1) % nzc] * wk[isin + i__2 % nrot] * wk[ipf
		+ i__3 % nv];
	vtriad_(n, &wk[iz], &wk[iz], &d__1, &wk[ip + i__4 % nv * *n], &c__1);
	itcom9_1.zhave = TRUE_;
    }
L425:

/* ---get resid norm--- */

    if (exact) {
	i__1 = itcom1_1.is + 2;
/* Computing 2nd power */
	d__1 = wk[izc + (i__1 - 1) % nzc];
	itcom9_1.zdot = d__1 * d__1;
    }

/* --------------------------------ev est------------------------------- */

    if (evadpt) {
	nwhe = *nw - (iv1 - 1);
	i__1 = nv + 2;
	i__2 = itcom1_1.is + 1;
	hesest_(&wk[ihess], &nhess, &i__1, &i__2, &iadpt, &havest, &emaxnw, &
		eminnw, &wk[iv1], &nwhe, ier);
/* Computing MAX */
	i__1 = nwusd, i__2 = iv1 - 1 + nwhe;
	nwusd = max(i__1,i__2);
	if (*ier != 0) {
	    goto L996;
	}
	if (! havest) {
	    goto L874;
	}
	if (hadest) {
	    goto L876;
	}
	if (itcom2_1.maxadd) {
	    itcom3_1.emax = emaxnw;
	}
	if (itcom2_1.minadd) {
	    itcom3_1.emin = eminnw;
	}
	hadest = TRUE_;
	goto L874;
L876:
	if (itcom2_1.maxadd) {
	    itcom3_1.emax = max(itcom3_1.emax,emaxnw);
	}
	if (itcom2_1.minadd) {
	    itcom3_1.emin = min(itcom3_1.emin,eminnw);
	}
    }

/* -------------------------finish up the iteration---------------------- */

L874:
    ++itcom1_1.in;
    ++itcom1_1.is;
    if (rstrt) {
	itcom1_1.is = 0;
    }
    rstrtd = rstrt;
    goto L10;

/* ---------------------------------------------------------------------- */
/* ------------------------------wrap it up------------------------------ */
/* ---------------------------------------------------------------------- */

/* ---form u, if not up-to-date--- */

L900:
    if (uneed || rstrtd || trunc) {
	goto L901;
    }
    iynew = iv1;
/* Computing MAX */
    i__1 = nwusd, i__2 = iynew + ns2e - 1;
    nwusd = max(i__1,i__2);
    if (nwusd > *nw) {
	goto L999;
    }
/*     ---do back solve on u-matrix--- */
    nm = itcom1_1.is;
    for (i__ = nm; i__ >= 1; --i__) {
	sum = wk[izc + (i__ - 1) % nzc];
	i__1 = nm;
	for (j = i__ + 1; j <= i__1; ++j) {
/* L664: */
	    sum -= wk[iynew - 1 + j] * wk[iu + j - i__ + 1 + (j - 1) % nuc *
		    nbwuh];
	}
/* L663: */
	wk[iynew - 1 + i__] = sum / wk[iu + i__ - i__ + 1 + (i__ - 1) % nuc *
		nbwuh];
    }
/*     ---form iterate--- */
    i__1 = nm - 1;
    for (i__ = 0; i__ <= i__1; ++i__) {
	val = wk[iynew + i__];
/* L665: */
	d__1 = val * wk[ipf + i__ % nv];
	vtriad_(n, &u[1], &u[1], &d__1, &wk[ipt + i__ % nvt * *n], &c__1);
    }

/* ---------------------------------------------------------------------- */
/* -----------------------------head out of here------------------------- */
/* ---------------------------------------------------------------------- */

L901:
    if (itcom2_1.halt) {
	goto L715;
    }
    *ier = 1;
    ershow_(ier, "gmresw", (ftnlen)6);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;
L715:
    if (itcom1_1.level >= 1) {
	io___992.ciunit = itcom1_1.nout;
	s_wsfe(&io___992);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts < 0) {
	goto L730;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
L730:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;

/* ----------------------------error returns----------------------------- */

L994:
    *ier = -15;
    ershow_(ier, "gmresw", (ftnlen)6);
    return 0;

L995:
    *ier = -16;
    ershow_(ier, "gmresw", (ftnlen)6);
    return 0;

L996:
    ershow_(ier, "gmresw", (ftnlen)6);
    goto L735;

L997:
    *ier = -13;
    ershow_(ier, "gmresw", (ftnlen)6);
    goto L725;

L998:
    *ier = -14;
    ershow_(ier, "gmresw", (ftnlen)6);
    goto L725;

L999:
    *ier = -2;
    ershow_(ier, "gmresw", (ftnlen)6);
    goto L735;

} /* gmresw_ */

/* Subroutine */ int uslqw_(S_fp suba, S_fp subat, S_fp subql, S_fp subqlt,
	S_fp subqr, U_fp subqrt, doublereal *coef, integer *jcoef, doublereal
	*wfac, integer *jwfac, integer *n, doublereal *u, doublereal *ubar,
	doublereal *rhs, doublereal *wk, integer *nw, integer *iparm,
	doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 usymlq\002)";
    static char fmt_720[] = "(/\002 usymlq converged in \002,i5,\002 iterati"
	    "ons.\002)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    double sqrt(doublereal);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__;
    static doublereal t1, t2, an;
    static integer iu, iv, iw, os, nv, iv1, iv2;
    static logical iql;
    static doublereal ucn;
    static logical iqr;
    static doublereal xxx;
    static integer ibgn, iend, icos;
    static doublereal zbar;
    static integer isin;
    static doublereal zold;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static integer vect1, vect2;
    static doublereal ucnp1;
    static logical uneed;
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    static doublereal zbold, timit, dummy;
    extern /* Subroutine */ int qrupd_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *);
    static integer nwusd;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *);
    static integer ibeta1, ibeta2;
    extern /* Subroutine */ int pstop_(integer *, S_fp, S_fp, S_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *);
    static doublereal gamma1, gamma2, digit1, digit2, vn1old, vn2old, vnorm1,
	    vnorm2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static doublereal ucnbar, factor;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *), inithv_(integer *),
	    ershow_(integer *, char *, ftnlen), vexopy_(integer *, doublereal
	    *, doublereal *, doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___1002 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___1036 = { 0, 0, 0, fmt_720, 0 };



/* code to run the usymlq algorithm.  see: m. a. saunders, h. d. simon */
/* and e. l. yip, "two conjugate-gradient-type methods for sparse */
/* unsymmetric linear equations, report eta-tr-18, boeing computer */
/* services, seattle, washington, 1984, to appear in siam journal on */
/* numerical analysis. */

/* note -- this routine is still not quite optimal. */


/* *** begin -- package common */


/* *** end   -- package common */

/* next, the indexing functions. */


/* preliminary calculations. */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    nwusd = 0;
    *ier = 0;
    itcom1_1.iacel = 12;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L996;
    }
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;
    if (iqr) {
	goto L995;
    }
    if (itcom1_1.level >= 2) {
	io___1002.ciunit = itcom1_1.nout;
	s_wsfe(&io___1002);
	e_wsfe();
    }

/* initialize the stopping test ... */

    inithv_(&c__0);
    itcom9_1.zdhav = TRUE_;
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L730;
    }

/* ... associated integer variables. */

    os = 2;
    iv = 1;
    nv = os;
    iw = 1;
    vect1 = iw + iv * *n * os;
    vect2 = vect1 + iv * *n * nv;
    ibeta1 = vect2 + iv * *n * nv;
    ibeta2 = ibeta1 + os;
    icos = ibeta2 + os;
    isin = icos + os;
    iu = isin + os;
    iv1 = iu + os + 1;
    iv2 = iv1 + *n;
/* Computing MAX */
    i__1 = nwusd, i__2 = iv2 - 1 + *n;
    nwusd = max(i__1,i__2);

/* check the memory usage -- */

    if (nwusd > *nw) {
	goto L999;
    }

    itcom1_1.in = 0;
    itcom1_1.is = 0;
    uneed = itcom9_1.rcalp || itcom9_1.zcalp || itcom9_1.ztcalp ||
	    itcom9_1.udhav || itcom1_1.ntest == 6 || itcom1_1.level >= 3;

/* ------------------------begin iteration loop----------------------- */

/* perform first-iterate calculations ... */

L10:
    if (itcom1_1.in != 0) {
	goto L100;
    }
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    vnorm1 = sqrt(vdot_(n, &wk[iv2], &wk[iv2]));
    vnorm2 = vnorm1;
    if (abs(vnorm1) < itcom4_1.srelpr) {
	goto L997;
    }
    gamma1 = 1. / vnorm1;
    gamma2 = 1. / vnorm2;
    vtriad_(n, &wk[vect1 + c__0 % nv * *n], &xxx, &gamma1, &wk[iv2], &c__2);
    vcopy_(n, &wk[vect1 + c__0 % nv * *n], &wk[vect2 + c__0 % nv * *n]);
/* Computing 2nd power */
    d__1 = vnorm1;
    itcom9_1.zdot = d__1 * d__1;
    ucnp1 = 0.;

/* determine whether or not to stop -- */

L100:
    inithv_(&c__1);
    itcom9_1.zdhav = TRUE_;
    nwpstp = *nw - (iv1 - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[iv1], &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iv1 - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &u[1]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }

/* ... compute q(n+1), etc -- the direction vectors */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[vect1 +
	    itcom1_1.in % nv * *n], &wk[iv1]);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    an = vdot_(n, &wk[vect2 + itcom1_1.in % nv * *n], &wk[iv2]);
    if (itcom1_1.in != 0) {
	goto L110;
    }
    i__1 = itcom1_1.in + 1;
    d__1 = -an;
    vtriad_(n, &wk[vect2 + i__1 % nv * *n], &wk[iv2], &d__1, &wk[vect2 +
	    itcom1_1.in % nv * *n], &c__1);
    wk[ibeta2 + itcom1_1.in % os] = -an;
    goto L111;
L110:
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in - 1;
    d__1 = -vnorm1;
    vtriad_(n, &wk[vect2 + i__1 % nv * *n], &xxx, &d__1, &wk[vect2 + i__2 %
	    nv * *n], &c__2);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[vect2 + i__1 % nv * *n], &wk[vect2 + i__2 % nv * *n], &
	    c_b922, &wk[iv2], &c__1);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    d__1 = -an;
    vtriad_(n, &wk[vect2 + i__1 % nv * *n], &wk[vect2 + i__2 % nv * *n], &
	    d__1, &wk[vect2 + itcom1_1.in % nv * *n], &c__1);
    wk[ibeta2 + itcom1_1.in % os] = -an;
    i__1 = itcom1_1.in - 1;
    wk[ibeta2 + i__1 % os] = -vnorm1;
L111:
    vn2old = vnorm2;
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vnorm2 = sqrt(vdot_(n, &wk[vect2 + i__1 % nv * *n], &wk[vect2 + i__2 % nv
	    * *n]));
    if (abs(vnorm2) < itcom4_1.srelpr) {
	goto L997;
    }
    gamma2 = 1. / vnorm2;
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[vect2 + i__1 % nv * *n], &xxx, &gamma2, &wk[vect2 + i__2 %
	    nv * *n], &c__2);

    (*subqlt)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[vect2 +
	    itcom1_1.in % nv * *n], &wk[iv1]);
    (*subat)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    if (itcom1_1.in != 0) {
	goto L810;
    }
    i__1 = itcom1_1.in + 1;
    d__1 = -an;
    vtriad_(n, &wk[vect1 + i__1 % nv * *n], &wk[iv2], &d__1, &wk[vect1 +
	    itcom1_1.in % nv * *n], &c__1);
    wk[ibeta1 + itcom1_1.in % os] = -an;
    goto L811;
L810:
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in - 1;
    d__1 = -vn2old;
    vtriad_(n, &wk[vect1 + i__1 % nv * *n], &xxx, &d__1, &wk[vect1 + i__2 %
	    nv * *n], &c__2);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[vect1 + i__1 % nv * *n], &wk[vect1 + i__2 % nv * *n], &
	    c_b922, &wk[iv2], &c__1);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    d__1 = -an;
    vtriad_(n, &wk[vect1 + i__1 % nv * *n], &wk[vect1 + i__2 % nv * *n], &
	    d__1, &wk[vect1 + itcom1_1.in % nv * *n], &c__1);
    wk[ibeta1 + itcom1_1.in % os] = -an;
    i__1 = itcom1_1.in - 1;
    wk[ibeta1 + i__1 % os] = -vn2old;
L811:
    vn1old = vnorm1;
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vnorm1 = sqrt(vdot_(n, &wk[vect1 + i__1 % nv * *n], &wk[vect1 + i__2 % nv
	    * *n]));
    if (abs(vnorm1) < itcom4_1.srelpr) {
	goto L997;
    }
    gamma1 = 1. / vnorm1;
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[vect1 + i__1 % nv * *n], &xxx, &gamma1, &wk[vect1 + i__2 %
	    nv * *n], &c__2);

/* ... now update the factorization */
    ucnbar = ucnp1;
/* Computing MAX */
    i__1 = 0, i__2 = itcom1_1.in + 1 - os;
    ibgn = max(i__1,i__2);
    i__1 = itcom1_1.in;
    for (i__ = ibgn; i__ <= i__1; ++i__) {
/* L1: */
	i__2 = i__ + 1;
	wk[iu + i__2 % (os + 1)] = -wk[ibeta2 + i__ % os];
    }
    if (ibgn > 0) {
	wk[iu + ibgn % (os + 1)] = 0.;
    }
    i__2 = itcom1_1.in + 1;
    i__1 = os + 1;
    qrupd_(&i__2, &i__1, &os, &wk[icos], &wk[isin], &ucnbar, &ucn, &wk[iu], &
	    vn2old, ier);
    if (*ier != 0) {
	goto L998;
    }
    i__2 = itcom1_1.in + 1;
    ucnp1 = wk[iu + i__2 % (os + 1)];

/* ... update the old w vector. */

    if (itcom1_1.in != 0) {
	i__2 = itcom1_1.in - 1;
	i__1 = itcom1_1.in - 1;
	d__1 = ucnbar / ucn;
	vtriad_(n, &wk[iw + *n * (i__2 % os)], &xxx, &d__1, &wk[iw + *n * (
		i__1 % os)], &c__2);
    }

/* ... now generate the new w vector. */

    if (abs(ucnp1) < itcom4_1.srelpr) {
	goto L998;
    }
    vcopy_(n, &wk[vect1 + itcom1_1.in % nv * *n], &wk[iv1]);
/* Computing MAX */
    i__2 = 1, i__1 = itcom1_1.in - os + 1;
    ibgn = max(i__2,i__1);
    iend = itcom1_1.in;
    if (iend < ibgn) {
	goto L200;
    }
    i__2 = iend;
    for (i__ = ibgn; i__ <= i__2; ++i__) {
/* L201: */
	i__1 = i__ - 1;
	d__1 = -wk[iu + i__ % (os + 1)];
	vtriad_(n, &wk[iv1], &wk[iv1], &d__1, &wk[iw + *n * (i__1 % os)], &
		c__1);
    }
L200:
    d__1 = 1. / ucnp1;
    vtriad_(n, &wk[iw + *n * (itcom1_1.in % os)], &xxx, &d__1, &wk[iv1], &
	    c__2);
    if (itcom1_1.in != 0) {
	goto L205;
    }

/* ... update iterate u(0). */
    zold = 0.;
    zbar = vn1old;
    if (uneed) {
	vtriad_(n, &u[1], &u[1], &zbar, &wk[iw + *n * (c__0 % os)], &c__1);
    }
    goto L210;

/* ... update subsequent iterates u(n). */

L205:
    zold = wk[icos + itcom1_1.in % os] * zbar;
    zbold = zbar;
    zbar = -wk[isin + itcom1_1.in % os] * zbar;
    factor = zold;
    if (uneed) {
	factor -= zbold * ucn / ucnbar;
    }
    i__1 = itcom1_1.in - 1;
    vtriad_(n, &u[1], &u[1], &factor, &wk[iw + *n * (i__1 % os)], &c__1);
    if (uneed) {
	vtriad_(n, &u[1], &u[1], &zbar, &wk[iw + *n * (itcom1_1.in % os)], &
		c__1);
    }
L210:
/* Computing 2nd power */
    d__1 = zbar / ucnp1 * vnorm1;
    itcom9_1.zdot = d__1 * d__1;

/* proceed to next iteration */

    ++itcom1_1.in;
    ++itcom1_1.is;
    goto L10;

/* ------------------------------finish up------------------------------- */

L900:
    if (! uneed) {
	i__1 = itcom1_1.in - 1;
	vtriad_(n, &u[1], &u[1], &zbar, &wk[iw + *n * (i__1 % os)], &c__1);
    }
    if (itcom2_1.halt) {
	goto L715;
    }
    *ier = 1;
    ershow_(ier, "uslqw", (ftnlen)5);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;
L715:
    if (itcom1_1.level >= 1) {
	io___1036.ciunit = itcom1_1.nout;
	s_wsfe(&io___1036);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts < 0) {
	goto L730;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
L730:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;

/* error returns */

/* unimplemented option */
L995:
    *ier = -16;
    ershow_(ier, "uslqw", (ftnlen)5);
    return 0;
L996:
    ershow_(ier, "uslqw", (ftnlen)5);
    goto L735;

L997:
    *ier = -13;
    ershow_(ier, "uslqw", (ftnlen)5);
    goto L725;

L998:
    *ier = -14;
    ershow_(ier, "uslqw", (ftnlen)5);
    goto L725;

L999:
    *ier = -2;
    ershow_(ier, "uslqw", (ftnlen)5);
    goto L735;

} /* uslqw_ */

/* Subroutine */ int usqrw_(S_fp suba, S_fp subat, S_fp subql, S_fp subqlt,
	S_fp subqr, U_fp subqrt, doublereal *coef, integer *jcoef, doublereal
	*wfac, integer *jwfac, integer *n, doublereal *u, doublereal *ubar,
	doublereal *rhs, doublereal *wk, integer *nw, integer *iparm,
	doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 usymqr\002)";
    static char fmt_720[] = "(/\002 usymqr converged in \002,i5,\002 iterati"
	    "ons.\002)";

    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void);
    double sqrt(doublereal);
    integer do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__;
    static doublereal x, z__, t1, t2, an, uc;
    static integer iu, iv, iw, os, nv, iv1, iv2;
    static logical iql, iqr;
    static doublereal xxx;
    static integer ibgn, iend, icos, isin;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static integer vect1, vect2;
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    static doublereal timit, dummy;
    extern /* Subroutine */ int qrupd_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *);
    static integer nwusd;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *);
    static integer ibeta1, ibeta2;
    extern /* Subroutine */ int pstop_(integer *, S_fp, S_fp, S_fp,
	    doublereal *, integer *, doublereal *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *, integer *);
    static doublereal gamma1, gamma2, znext, digit1, digit2, vn2old, vnorm1,
	    vnorm2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *), vtriad_(integer *, doublereal *,
	     doublereal *, doublereal *, doublereal *, integer *), inithv_(
	    integer *), ershow_(integer *, char *, ftnlen), vexopy_(integer *,
	     doublereal *, doublereal *, doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___1046 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___1075 = { 0, 0, 0, fmt_720, 0 };



/* code to run the usymqr algorithm. same reference as usymlq */
/* algorithm. */


/* *** begin -- package common */


/* *** end   -- package common */

/* next, the indexing functions. */


/* preliminary calculations. */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    nwusd = 0;
    *ier = 0;
    itcom1_1.iacel = 13;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L996;
    }
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;
    if (iqr) {
	goto L995;
    }
    if (itcom1_1.level >= 2) {
	io___1046.ciunit = itcom1_1.nout;
	s_wsfe(&io___1046);
	e_wsfe();
    }

/* initialize the stopping test ... */

    inithv_(&c__0);
    itcom9_1.zdhav = TRUE_;
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L730;
    }

/* ... associated integer variables. */

    os = 2;
    iv = 1;
    nv = os;
    iw = 1;
    vect1 = iw + iv * *n * os;
    vect2 = vect1 + iv * *n * nv;
    ibeta1 = vect2 + iv * *n * nv;
    ibeta2 = ibeta1 + os;
    icos = ibeta2 + os;
    isin = icos + os + 1;
    iu = isin + os + 1;
    iv1 = iu + os + 2;
    iv2 = iv1 + *n;
/* Computing MAX */
    i__1 = nwusd, i__2 = iv2 - 1 + *n;
    nwusd = max(i__1,i__2);

/* check the memory usage -- */

    if (nwusd > *nw) {
	goto L999;
    }


/* now, perform first-iterate calculations */
    itcom1_1.in = 0;
    itcom1_1.is = 0;
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    vnorm1 = sqrt(vdot_(n, &wk[iv2], &wk[iv2]));
    vnorm2 = vnorm1;
    if (abs(vnorm1) < itcom4_1.srelpr) {
	goto L997;
    }
    gamma1 = 1. / vnorm1;
    gamma2 = 1. / vnorm2;
    vtriad_(n, &wk[vect1 + c__0 % nv * *n], &xxx, &gamma1, &wk[iv2], &c__2);
    vcopy_(n, &wk[vect1 + c__0 % nv * *n], &wk[vect2 + c__0 % nv * *n]);
/* Computing 2nd power */
    d__1 = vnorm1;
    itcom9_1.zdot = d__1 * d__1;
    znext = vnorm1;

/* ------------------------begin iteration loop------------------------ */

/* determine whether or not to stop -- */

L10:
    inithv_(&c__1);
    itcom9_1.zdhav = TRUE_;
    nwpstp = *nw - (iv1 - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[iv1], &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iv1 - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &u[1]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }


/* ... compute q(n+1), etc -- the direction vectors */
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[vect1 +
	    itcom1_1.in % nv * *n], &wk[iv1]);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    an = vdot_(n, &wk[vect2 + itcom1_1.in % nv * *n], &wk[iv2]);
    if (itcom1_1.in != 0) {
	goto L110;
    }
    i__1 = itcom1_1.in + 1;
    d__1 = -an;
    vtriad_(n, &wk[vect2 + i__1 % nv * *n], &wk[iv2], &d__1, &wk[vect2 +
	    itcom1_1.in % nv * *n], &c__1);
    wk[ibeta2 + itcom1_1.in % os] = -an;
    goto L111;
L110:
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in - 1;
    d__1 = -vnorm1;
    vtriad_(n, &wk[vect2 + i__1 % nv * *n], &xxx, &d__1, &wk[vect2 + i__2 %
	    nv * *n], &c__2);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[vect2 + i__1 % nv * *n], &wk[vect2 + i__2 % nv * *n], &
	    c_b922, &wk[iv2], &c__1);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    d__1 = -an;
    vtriad_(n, &wk[vect2 + i__1 % nv * *n], &wk[vect2 + i__2 % nv * *n], &
	    d__1, &wk[vect2 + itcom1_1.in % nv * *n], &c__1);
    wk[ibeta2 + itcom1_1.in % os] = -an;
    i__1 = itcom1_1.in - 1;
    wk[ibeta2 + i__1 % os] = -vnorm1;
L111:
    vn2old = vnorm2;
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vnorm2 = sqrt(vdot_(n, &wk[vect2 + i__1 % nv * *n], &wk[vect2 + i__2 % nv
	    * *n]));
    if (abs(vnorm2) < itcom4_1.srelpr) {
	goto L997;
    }
    gamma2 = 1. / vnorm2;
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[vect2 + i__1 % nv * *n], &xxx, &gamma2, &wk[vect2 + i__2 %
	    nv * *n], &c__2);

    (*subqlt)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[vect2 +
	    itcom1_1.in % nv * *n], &wk[iv1]);
    (*subat)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    if (itcom1_1.in != 0) {
	goto L810;
    }
    i__1 = itcom1_1.in + 1;
    d__1 = -an;
    vtriad_(n, &wk[vect1 + i__1 % nv * *n], &wk[iv2], &d__1, &wk[vect1 +
	    itcom1_1.in % nv * *n], &c__1);
    wk[ibeta1 + itcom1_1.in % os] = -an;
    goto L811;
L810:
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in - 1;
    d__1 = -vn2old;
    vtriad_(n, &wk[vect1 + i__1 % nv * *n], &xxx, &d__1, &wk[vect1 + i__2 %
	    nv * *n], &c__2);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[vect1 + i__1 % nv * *n], &wk[vect1 + i__2 % nv * *n], &
	    c_b922, &wk[iv2], &c__1);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    d__1 = -an;
    vtriad_(n, &wk[vect1 + i__1 % nv * *n], &wk[vect1 + i__2 % nv * *n], &
	    d__1, &wk[vect1 + itcom1_1.in % nv * *n], &c__1);
    wk[ibeta1 + itcom1_1.in % os] = -an;
    i__1 = itcom1_1.in - 1;
    wk[ibeta1 + i__1 % os] = -vn2old;
L811:
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vnorm1 = sqrt(vdot_(n, &wk[vect1 + i__1 % nv * *n], &wk[vect1 + i__2 % nv
	    * *n]));
    if (abs(vnorm1) < itcom4_1.srelpr) {
	goto L997;
    }
    gamma1 = 1. / vnorm1;
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[vect1 + i__1 % nv * *n], &xxx, &gamma1, &wk[vect1 + i__2 %
	    nv * *n], &c__2);

/* ... now update the factorization */
/* Computing MAX */
    i__1 = 0, i__2 = itcom1_1.in + 1 - os;
    ibgn = max(i__1,i__2);
    i__1 = itcom1_1.in;
    for (i__ = ibgn; i__ <= i__1; ++i__) {
/* L1: */
	i__2 = i__ + 1;
	wk[iu + i__2 % (os + 2)] = -wk[ibeta2 + i__ % os];
    }
    if (ibgn > 0) {
	wk[iu + ibgn % (os + 2)] = 0.;
    }
    i__2 = itcom1_1.in + 2;
    wk[iu + i__2 % (os + 2)] = vnorm2;
    i__2 = itcom1_1.in + 1;
    i__1 = itcom1_1.in + 2;
    i__3 = os + 2;
    i__4 = os + 1;
    qrupd_(&i__1, &i__3, &i__4, &wk[icos], &wk[isin], &wk[iu + i__2 % (os + 2)
	    ], &x, &wk[iu], &vnorm2, ier);
    if (*ier < 0) {
	goto L998;
    }

/* ... now generate the new w vector. */
    i__2 = itcom1_1.in + 1;
    uc = wk[iu + i__2 % (os + 2)];
    if (abs(uc) < itcom4_1.srelpr) {
	goto L998;
    }
    vcopy_(n, &wk[vect1 + itcom1_1.in % nv * *n], &wk[iv1]);
/* Computing MAX */
    i__2 = 1, i__1 = itcom1_1.in - os + 1;
    ibgn = max(i__2,i__1);
    iend = itcom1_1.in;
    if (iend < ibgn) {
	goto L200;
    }
    i__2 = iend;
    for (i__ = ibgn; i__ <= i__2; ++i__) {
/* L201: */
	i__1 = i__ - 1;
	d__1 = -wk[iu + i__ % (os + 2)];
	vtriad_(n, &wk[iv1], &wk[iv1], &d__1, &wk[iw + *n * (i__1 % os)], &
		c__1);
    }
L200:
    d__1 = 1. / uc;
    vtriad_(n, &wk[iw + *n * (itcom1_1.in % os)], &xxx, &d__1, &wk[iv1], &
	    c__2);

/* ... update iterates u(n). */
    i__1 = itcom1_1.in + 1;
    z__ = wk[icos + i__1 % (os + 1)] * znext;
    i__1 = itcom1_1.in + 1;
    znext = -wk[isin + i__1 % (os + 1)] * znext;
    vtriad_(n, &u[1], &u[1], &z__, &wk[iw + *n * (itcom1_1.in % os)], &c__1);
/* Computing 2nd power */
    d__1 = znext;
    itcom9_1.zdot = d__1 * d__1;

/* proceed to next iteration */

    ++itcom1_1.in;
    ++itcom1_1.is;
    goto L10;

/* -----------------------------finish up---------------------------- */

L900:
    if (itcom2_1.halt) {
	goto L715;
    }
    *ier = 1;
    ershow_(ier, "usqrw", (ftnlen)5);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;
L715:
    if (itcom1_1.level >= 1) {
	io___1075.ciunit = itcom1_1.nout;
	s_wsfe(&io___1075);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts < 0) {
	goto L730;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
L730:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;

/* error returns */

L995:
    *ier = -16;
    ershow_(ier, "usqrw", (ftnlen)5);
    return 0;

L996:
    ershow_(ier, "usqrw", (ftnlen)5);
    goto L735;

L997:
    *ier = -13;
    ershow_(ier, "usqrw", (ftnlen)5);
    goto L725;

L998:
    *ier = -14;
    ershow_(ier, "usqrw", (ftnlen)5);
    goto L725;

L999:
    *ier = -2;
    ershow_(ier, "usqrw", (ftnlen)5);
    goto L735;

} /* usqrw_ */

/* Subroutine */ int ldirw_(S_fp suba, S_fp subat, S_fp subql, S_fp subqlt,
	S_fp subqr, U_fp subqrt, doublereal *coef, integer *jcoef, doublereal
	*wfac, integer *jwfac, integer *n, doublereal *u, doublereal *ubar,
	doublereal *rhs, doublereal *wk, integer *nw, integer *iparm,
	doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 landir\002)";
    static char fmt_720[] = "(/\002 lanczos/orthodir converged in \002,i5"
	    ",\002 iterations.\002)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static doublereal t1, t2, an, bn;
    static integer iq, ir;
    static doublereal qr;
    static integer iv1, iv2, iv3;
    static doublereal qaq;
    static logical iql, iqr;
    static integer iqt;
    static doublereal xxx, aqaq;
    extern doublereal vdot_(integer *, doublereal *, doublereal *), timer_(
	    doublereal *);
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    static doublereal dummy, timit;
    static integer nwusd;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *),
	     pstop_(integer *, S_fp, S_fp, S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *);
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static doublereal vlamda, qaqold;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *), inithv_(integer *),
	    ershow_(integer *, char *, ftnlen), vexopy_(integer *, doublereal
	    *, doublereal *, doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___1085 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___1101 = { 0, 0, 0, fmt_720, 0 };



/* code to run the lanczos/orthodir algorithm. see jea and young, in */
/* linear algebra and its applications, vol 52/3, 1983, pp399f. */


/* *** begin -- package common */


/* *** end   -- package common */

/* indexing functions. */


/* preliminary calculations. */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    nwusd = 0;
    *ier = 0;
    itcom1_1.iacel = 14;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L997;
    }
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;
    if (iqr) {
	goto L995;
    }
    if (itcom1_1.level >= 2) {
	io___1085.ciunit = itcom1_1.nout;
	s_wsfe(&io___1085);
	e_wsfe();
    }

/* initialize the stopping test ... */

    inithv_(&c__0);
    itcom9_1.zhave = TRUE_;
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L730;
    }

    iq = 1;
    iqt = iq + (*n << 1);
    ir = iqt + (*n << 1);
    iv1 = ir + *n;
    iv2 = iv1 + *n;
    iv3 = iv2 + *n;
/* Computing MAX */
    i__1 = nwusd, i__2 = iv3 - 1 + *n;
    nwusd = max(i__1,i__2);

/* check the memory usage. */

    if (nwusd > *nw) {
	goto L999;
    }

    itcom1_1.in = 0;
    itcom1_1.is = 0;
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[ir]);

/* begin iteration loop */

/* determine whether or not to stop. */

L10:
    inithv_(&c__1);
    nwpstp = *nw - (iv1 - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &wk[ir], &
	    xxx, &wk[iv1], &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iv1 - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &u[1]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }

    if (itcom1_1.in != 0) {
	goto L110;
    }

/* perform first-iterate calculations */

    vcopy_(n, &wk[ir], &wk[iq + *n * (itcom1_1.in % 2)]);
    vcopy_(n, &wk[iq + *n * (itcom1_1.in % 2)], &wk[iqt + *n * (itcom1_1.in %
	    2)]);
    qaq = 0.;
    goto L115;

/* proceed to calculate the direction vectors, for in .gt. 0. */

L110:
    i__1 = itcom1_1.in - 1;
    (*subqlt)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iqt + *n * (
	    i__1 % 2)], &wk[iv1]);
    (*subat)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv3]);
    aqaq = vdot_(n, &wk[iv2], &wk[iv3]);
    an = aqaq / qaq;
    if (itcom1_1.in != 1) {
	goto L150;
    }
    i__1 = itcom1_1.in - 1;
    d__1 = -an;
    vtriad_(n, &wk[iq + *n * (itcom1_1.in % 2)], &wk[iv2], &d__1, &wk[iq + *n
	    * (i__1 % 2)], &c__1);
    i__1 = itcom1_1.in - 1;
    d__1 = -an;
    vtriad_(n, &wk[iqt + *n * (itcom1_1.in % 2)], &wk[iv3], &d__1, &wk[iqt + *
	    n * (i__1 % 2)], &c__1);
    goto L115;
L150:
    bn = qaq / qaqold;
    i__1 = itcom1_1.in - 2;
    d__1 = -bn;
    vtriad_(n, &wk[iq + *n * (itcom1_1.in % 2)], &wk[iv2], &d__1, &wk[iq + *n
	    * (i__1 % 2)], &c__1);
    i__1 = itcom1_1.in - 1;
    d__1 = -an;
    vtriad_(n, &wk[iq + *n * (itcom1_1.in % 2)], &wk[iq + *n * (itcom1_1.in %
	    2)], &d__1, &wk[iq + *n * (i__1 % 2)], &c__1);
    i__1 = itcom1_1.in - 2;
    d__1 = -bn;
    vtriad_(n, &wk[iqt + *n * (itcom1_1.in % 2)], &wk[iv3], &d__1, &wk[iqt + *
	    n * (i__1 % 2)], &c__1);
    i__1 = itcom1_1.in - 1;
    d__1 = -an;
    vtriad_(n, &wk[iqt + *n * (itcom1_1.in % 2)], &wk[iqt + *n * (itcom1_1.in
	    % 2)], &d__1, &wk[iqt + *n * (i__1 % 2)], &c__1);

/* proceed to form the iterate. */

L115:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iq + *n * (
	    itcom1_1.in % 2)], &wk[iv1]);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    qaqold = qaq;
    qaq = vdot_(n, &wk[iqt + *n * (itcom1_1.in % 2)], &wk[iv2]);
    if (abs(qaq) < itcom4_1.srelpr) {
	goto L998;
    }
    qr = vdot_(n, &wk[iqt + *n * (itcom1_1.in % 2)], &wk[ir]);
    vlamda = qr / qaq;
    vtriad_(n, &u[1], &u[1], &vlamda, &wk[iq + *n * (itcom1_1.in % 2)], &c__1)
	    ;
    d__1 = -vlamda;
    vtriad_(n, &wk[ir], &wk[ir], &d__1, &wk[iv2], &c__1);

/* proceed to next iteration */

    ++itcom1_1.in;
    ++itcom1_1.is;
    goto L10;

/* -----------------------------finish up----------------------------- */

L900:
    if (itcom2_1.halt) {
	goto L715;
    }
    *ier = 1;
    ershow_(ier, "ldirw", (ftnlen)5);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;
L715:
    if (itcom1_1.level >= 1) {
	io___1101.ciunit = itcom1_1.nout;
	s_wsfe(&io___1101);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts < 0) {
	goto L730;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
L730:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;

/* error returns */

L995:
    *ier = -16;
    ershow_(ier, "ldirw", (ftnlen)5);
    return 0;

L997:
    ershow_(ier, "ldirw", (ftnlen)5);
    goto L735;

L998:
    *ier = -15;
    ershow_(ier, "ldirw", (ftnlen)5);
    goto L725;

L999:
    *ier = -2;
    ershow_(ier, "ldirw", (ftnlen)5);
    goto L735;

} /* ldirw_ */

/* Subroutine */ int lminw_(S_fp suba, S_fp subat, S_fp subql, S_fp subqlt,
	S_fp subqr, S_fp subqrt, doublereal *coef, integer *jcoef, doublereal
	*wfac, integer *jwfac, integer *n, doublereal *u, doublereal *ubar,
	doublereal *rhs, doublereal *wk, integer *nw, integer *iparm,
	doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 lanmin\002)";
    static char fmt_720[] = "(/\002 lanczos/orthomin converged in \002,i5"
	    ",\002 iterations.\002)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static doublereal t1, t2, an, rd;
    static integer ip, iz, iv1, iv2;
    static logical iql, iqr;
    static integer ipt, izt;
    static doublereal xxx;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static integer iphat;
    extern doublereal timer_(doublereal *);
    static integer izhat;
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    static doublereal dummy, rdold, timit;
    static integer nwusd;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *),
	     pstop_(integer *, S_fp, S_fp, S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *);
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static doublereal vlamda;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *), inithv_(integer *),
	    ershow_(integer *, char *, ftnlen), vexopy_(integer *, doublereal
	    *, doublereal *, doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___1109 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___1126 = { 0, 0, 0, fmt_720, 0 };



/* code to run the lanczos/orthomin algorithm. */
/* here, zhat and phat will refer to the "dummy" system of the */
/* lanczos method. */


/* *** begin -- package common */


/* *** end   -- package common */


    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    nwusd = 0;
    *ier = 0;
    itcom1_1.iacel = 15;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L997;
    }
    if (itcom1_1.level >= 2) {
	io___1109.ciunit = itcom1_1.nout;
	s_wsfe(&io___1109);
	e_wsfe();
    }

/* initialize the stopping test ... */

    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;
    inithv_(&c__0);
    itcom9_1.zhave = TRUE_;
    itcom9_1.zthave = TRUE_;
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L730;
    }

/* allocate memory -- overlap wherever possible ... */
    ip = 1;
    ipt = ip + *n;
    if (! iqr) {
	ipt = ip;
    }
    iphat = ipt + *n;
    iz = iphat + *n;
    izt = iz + *n;
    if (! iqr) {
	izt = iz;
    }
    izhat = izt + *n;
    iv1 = izhat + *n;
    iv2 = iv1 + *n;
    if (itcom1_1.iqlr == 0) {
/* Computing MAX */
	i__1 = nwusd, i__2 = iv1 - 1 + *n;
	nwusd = max(i__1,i__2);
    }
    if (itcom1_1.iqlr != 0) {
/* Computing MAX */
	i__1 = nwusd, i__2 = iv2 - 1 + *n;
	nwusd = max(i__1,i__2);
    }

/* check the memory usage. */

    if (nwusd > *nw) {
	goto L999;
    }

    itcom1_1.in = 0;
    itcom1_1.is = 0;
    if (! iql) {
	goto L121;
    }
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iz]);
    goto L122;
L121:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iz]);
    vexopy_(n, &wk[iz], &rhs[1], &wk[iz], &c__2);
L122:
    if (iqr) {
	(*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iz], &wk[
		izt]);
    }

/* ============================begin iteration loop====================== */

/* determine whether or not to stop. */

L10:
    inithv_(&c__1);
    nwpstp = *nw - (iv1 - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &wk[iz], &
	    wk[izt], &wk[iv1], &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iv1 - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &u[1]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }

    if (itcom1_1.in != 0) {
	goto L110;
    }

/* perform first-iterate calculations */

    vcopy_(n, &wk[iz], &wk[izhat]);
    rd = vdot_(n, &wk[iz], &wk[izhat]);
    vcopy_(n, &wk[iz], &wk[ip]);
    vcopy_(n, &wk[izhat], &wk[iphat]);
    if (iqr) {
	vcopy_(n, &wk[izt], &wk[ipt]);
    }
    goto L111;

/* perform subsequent-iterate calculations */

L110:
    rdold = rd;
/*     if (abs(rdold) .lt. srelpr) go to 996 */
    if (abs(rdold) == 0.) {
	goto L996;
    }

/* form the old zhat ... */
    switch (itcom1_1.iqlr + 1) {
	case 1:  goto L131;
	case 2:  goto L132;
	case 3:  goto L133;
	case 4:  goto L134;
    }
L131:
    (*subat)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iphat], &wk[iv1]
	    );
    goto L135;
L132:
    (*subqlt)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iphat], &wk[
	    iv2]);
    (*subat)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv2], &wk[iv1]);
    goto L135;
L133:
    (*subat)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iphat], &wk[iv2]
	    );
    (*subqrt)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv2], &wk[iv1])
	    ;
    goto L135;
L134:
    (*subqlt)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iphat], &wk[
	    iv1]);
    (*subat)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    (*subqrt)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv2], &wk[iv1])
	    ;
L135:
    d__1 = -vlamda;
    vtriad_(n, &wk[izhat], &wk[izhat], &d__1, &wk[iv1], &c__1);

/* form the direction vectors ... */
    rd = vdot_(n, &wk[iz], &wk[izhat]);
    an = rd / rdold;
    vtriad_(n, &wk[ip], &wk[iz], &an, &wk[ip], &c__1);
    vtriad_(n, &wk[iphat], &wk[izhat], &an, &wk[iphat], &c__1);
    if (iqr) {
	vtriad_(n, &wk[ipt], &wk[izt], &an, &wk[ipt], &c__1);
    }

/* ============================form the iterate======================== */

L111:
    if (iql) {
	goto L141;
    }
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ipt], &wk[iv1]);
    goto L142;
L141:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ipt], &wk[iv2]);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv2], &wk[iv1]);
L142:
    itcom3_1.pap = vdot_(n, &wk[iphat], &wk[iv1]);
/*     if (abs(pap) .lt. srelpr**2) go to 998 */
    if (abs(itcom3_1.pap) == 0.) {
	goto L998;
    }
    vlamda = rd / itcom3_1.pap;


    vtriad_(n, &u[1], &u[1], &vlamda, &wk[ipt], &c__1);
    d__1 = -vlamda;
    vtriad_(n, &wk[iz], &wk[iz], &d__1, &wk[iv1], &c__1);
    if (! iqr) {
	goto L151;
    }
    (*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iv2]);
    d__1 = -vlamda;
    vtriad_(n, &wk[izt], &wk[izt], &d__1, &wk[iv2], &c__1);

/* proceed to next iteration */

L151:
    ++itcom1_1.in;
    ++itcom1_1.is;
    goto L10;

/* ------------------------------finish up----------------------------- */

L900:
    if (itcom2_1.halt) {
	goto L715;
    }
    *ier = 1;
    ershow_(ier, "lminw", (ftnlen)5);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;
L715:
    if (itcom1_1.level >= 1) {
	io___1126.ciunit = itcom1_1.nout;
	s_wsfe(&io___1126);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts < 0) {
	goto L730;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
L730:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;

/* error returns */

L996:
    *ier = -13;
    ershow_(ier, "lminw", (ftnlen)5);
    goto L725;

L997:
    ershow_(ier, "lminw", (ftnlen)5);
    goto L735;

L998:
    *ier = -15;
    ershow_(ier, "lminw", (ftnlen)5);
    goto L725;

L999:
    *ier = -2;
    ershow_(ier, "lminw", (ftnlen)5);
    goto L735;

} /* lminw_ */

/* Subroutine */ int lresw_(S_fp suba, S_fp subat, S_fp subql, S_fp subqlt,
	S_fp subqr, U_fp subqrt, doublereal *coef, integer *jcoef, doublereal
	*wfac, integer *jwfac, integer *n, doublereal *u, doublereal *ubar,
	doublereal *rhs, doublereal *wk, integer *nw, integer *iparm,
	doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 lanres\002)";
    static char fmt_720[] = "(/\002 lanczos/orthores converged in \002,i5"
	    ",\002 iterations.\002)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static doublereal t1, t2, rd;
    static integer ir, iu, nv, iv1;
    static doublereal gam, rar;
    static logical iql, iqr;
    static integer irt;
    static doublereal xxx;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static doublereal rdold;
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    static doublereal timit, dummy;
    static integer nwusd;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *),
	     pstop_(integer *, S_fp, S_fp, S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *);
    static doublereal digit1, digit2;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static doublereal gamold;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *), inithv_(integer *);
    static doublereal rhoinv;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen), vexopy_(
	    integer *, doublereal *, doublereal *, doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___1136 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___1150 = { 0, 0, 0, fmt_720, 0 };



/* code to run the lanczos/orthores algorithm. */


/* *** begin -- package common */


/* *** end   -- package common */

/* indexing functions. */


/* preliminary calculations. */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    nwusd = 0;
    *ier = 0;
    itcom1_1.iacel = 16;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L997;
    }
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;
    if (iqr) {
	goto L995;
    }
    if (itcom1_1.level >= 2) {
	io___1136.ciunit = itcom1_1.nout;
	s_wsfe(&io___1136);
	e_wsfe();
    }

/* initialize the stopping test ... */

    inithv_(&c__0);
    itcom9_1.zhave = TRUE_;
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L730;
    }

    nv = 2;
    iu = 1;
    ir = iu + nv * *n;
    irt = ir + nv * *n;
    iv1 = irt + nv * *n;
/* Computing MAX */
    i__1 = nwusd, i__2 = iv1 - 1 + *n;
    nwusd = max(i__1,i__2);

/* check the memory usage. */

    if (nwusd > *nw) {
	goto L999;
    }

/* note -- we will use the vector 'u' for scratch storage, to save space. */

    vcopy_(n, &u[1], &wk[iu + *n * (c__0 % nv)]);
    itcom1_1.in = 0;
    itcom1_1.is = 0;
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iu + *n * (
	    itcom1_1.in % nv)], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[ir + *
	    n * (itcom1_1.in % nv)]);
    vcopy_(n, &wk[ir + *n * (itcom1_1.in % nv)], &wk[irt + *n * (itcom1_1.in %
	     nv)]);

/* --------------------------begin iteration loop----------------------- */

/* determine whether or not to stop. */

L10:
    inithv_(&c__1);
    nwpstp = *nw - (iv1 - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &wk[iu + *n * (itcom1_1.in % nv)], &ubar[1]
	    , &rhs[1], &xxx, &wk[ir + *n * (itcom1_1.in % nv)], &xxx, &wk[iv1]
	    , &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iv1 - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &wk[iu + *n * (itcom1_1.in % nv)]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }

/* proceed to calculate the parameters. */
/* first, gamma. */

    rd = vdot_(n, &wk[ir + *n * (itcom1_1.in % nv)], &wk[irt + *n * (
	    itcom1_1.in % nv)]);
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ir + *n * (
	    itcom1_1.in % nv)], &wk[iv1]);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &u[1]);
    rar = vdot_(n, &u[1], &wk[irt + *n * (itcom1_1.in % nv)]);
    if (abs(rar) < itcom4_1.srelpr) {
	goto L998;
    }
    gam = rd / rar;

/* now, rho. */

    if (itcom1_1.in != 0) {
	goto L118;
    }
    itcom3_1.rho = 1.;
    goto L119;
L118:
    if (abs(gamold) < itcom4_1.srelpr) {
	goto L998;
    }
    if (abs(rdold) < itcom4_1.srelpr) {
	goto L998;
    }
    if (abs(itcom3_1.rho) < itcom4_1.srelpr) {
	goto L998;
    }
    rhoinv = 1. - gam / gamold * (rd / rdold) / itcom3_1.rho;
    if (abs(rhoinv) < itcom4_1.srelpr) {
	goto L998;
    }
    itcom3_1.rho = 1. / rhoinv;

/* now work on updating u, r, rt. */
/* first, the first iteration. */

L119:
    if (itcom1_1.in != 0) {
	goto L150;
    }
    i__1 = itcom1_1.in + 1;
    vtriad_(n, &wk[iu + *n * (i__1 % nv)], &wk[iu + *n * (itcom1_1.in % nv)],
	    &gam, &wk[ir + *n * (itcom1_1.in % nv)], &c__1);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[iu + *n * (i__1 % nv)], &xxx, &itcom3_1.rho, &wk[iu + *n *
	    (i__2 % nv)], &c__2);
    i__1 = itcom1_1.in + 1;
    d__1 = -gam;
    vtriad_(n, &wk[ir + *n * (i__1 % nv)], &wk[ir + *n * (itcom1_1.in % nv)],
	    &d__1, &u[1], &c__1);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[ir + *n * (i__1 % nv)], &xxx, &itcom3_1.rho, &wk[ir + *n *
	    (i__2 % nv)], &c__2);
    (*subqlt)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[irt + *n * (
	    itcom1_1.in % nv)], &wk[iv1]);
    (*subat)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &u[1]);
    i__1 = itcom1_1.in + 1;
    d__1 = -gam;
    vtriad_(n, &wk[irt + *n * (i__1 % nv)], &wk[irt + *n * (itcom1_1.in % nv)]
	    , &d__1, &u[1], &c__1);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[irt + *n * (i__1 % nv)], &xxx, &itcom3_1.rho, &wk[irt + *n
	    * (i__2 % nv)], &c__2);
    goto L151;

/* now work on subsequent iterations. */

L150:
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in - 1;
    d__1 = 1. - itcom3_1.rho;
    vtriad_(n, &wk[iu + *n * (i__1 % nv)], &xxx, &d__1, &wk[iu + *n * (i__2 %
	    nv)], &c__2);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[iu + *n * (i__1 % nv)], &wk[iu + *n * (i__2 % nv)], &
	    itcom3_1.rho, &wk[iu + *n * (itcom1_1.in % nv)], &c__1);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    d__1 = itcom3_1.rho * gam;
    vtriad_(n, &wk[iu + *n * (i__1 % nv)], &wk[iu + *n * (i__2 % nv)], &d__1,
	    &wk[ir + *n * (itcom1_1.in % nv)], &c__1);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in - 1;
    d__1 = 1. - itcom3_1.rho;
    vtriad_(n, &wk[ir + *n * (i__1 % nv)], &xxx, &d__1, &wk[ir + *n * (i__2 %
	    nv)], &c__2);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[ir + *n * (i__1 % nv)], &wk[ir + *n * (i__2 % nv)], &
	    itcom3_1.rho, &wk[ir + *n * (itcom1_1.in % nv)], &c__1);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    d__1 = -itcom3_1.rho * gam;
    vtriad_(n, &wk[ir + *n * (i__1 % nv)], &wk[ir + *n * (i__2 % nv)], &d__1,
	    &u[1], &c__1);
    (*subqlt)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[irt + *n * (
	    itcom1_1.in % nv)], &wk[iv1]);
    (*subat)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &u[1]);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in - 1;
    d__1 = 1. - itcom3_1.rho;
    vtriad_(n, &wk[irt + *n * (i__1 % nv)], &xxx, &d__1, &wk[irt + *n * (i__2
	    % nv)], &c__2);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    vtriad_(n, &wk[irt + *n * (i__1 % nv)], &wk[irt + *n * (i__2 % nv)], &
	    itcom3_1.rho, &wk[irt + *n * (itcom1_1.in % nv)], &c__1);
    i__1 = itcom1_1.in + 1;
    i__2 = itcom1_1.in + 1;
    d__1 = -itcom3_1.rho * gam;
    vtriad_(n, &wk[irt + *n * (i__1 % nv)], &wk[irt + *n * (i__2 % nv)], &
	    d__1, &u[1], &c__1);

/* proceed to next iteration */

L151:
    gamold = gam;
    rdold = rd;
    ++itcom1_1.in;
    ++itcom1_1.is;
    goto L10;

/* -------------------------------finish up---------------------------- */

L900:
    vcopy_(n, &wk[iu + *n * (itcom1_1.in % nv)], &u[1]);
    if (itcom2_1.halt) {
	goto L715;
    }
    *ier = 1;
    ershow_(ier, "lresw", (ftnlen)5);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;
L715:
    if (itcom1_1.level >= 1) {
	io___1150.ciunit = itcom1_1.nout;
	s_wsfe(&io___1150);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts < 0) {
	goto L730;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
L730:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;

/* error returns */

L995:
    *ier = -16;
    ershow_(ier, "lresw", (ftnlen)5);
    return 0;

L997:
    ershow_(ier, "lresw", (ftnlen)5);
    goto L735;

L998:
    *ier = -15;
    ershow_(ier, "lresw", (ftnlen)5);
    goto L725;

L999:
    *ier = -2;
    ershow_(ier, "lresw", (ftnlen)5);
    goto L735;

} /* lresw_ */

/* Subroutine */ int bcgsw_(S_fp suba, S_fp subql, S_fp subqr, doublereal *
	coef, integer *jcoef, doublereal *wfac, integer *jwfac, integer *n,
	doublereal *u, doublereal *ubar, doublereal *rhs, doublereal *wk,
	integer *nw, integer *iparm, doublereal *rparm, integer *ier)
{
    /* Format strings */
    static char fmt_496[] = "(\002 bcgs\002)";
    static char fmt_720[] = "(/\002 bcgs converged in \002,i5,\002 iteration"
	    "s.\002)";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static doublereal t1, t2;
    static integer ip, iq, iz, ir0, iv1, iv2, iv3;
    static doublereal r0r;
    static integer iaq;
    static logical iql, iqr;
    static integer ipt, izt;
    static doublereal xxx, r0aq;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static integer ipaaq;
    extern doublereal timer_(doublereal *);
    extern /* Subroutine */ int iterm_(integer *, doublereal *);
    static doublereal timit, dummy;
    static integer nwusd;
    extern /* Subroutine */ int vcopy_(integer *, doublereal *, doublereal *),
	     pstop_(integer *, S_fp, S_fp, S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *);
    static doublereal digit1, digit2, r0rold;
    extern /* Subroutine */ int echall_(integer *, integer *, doublereal *,
	    integer *, integer *, integer *);
    static integer ippaaq;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *), inithv_(integer *),
	    ershow_(integer *, char *, ftnlen), vexopy_(integer *, doublereal
	    *, doublereal *, doublereal *, integer *);
    static integer nwpstp;
    extern /* Subroutine */ int perror1_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___1158 = { 0, 0, 0, fmt_496, 0 };
    static cilist io___1178 = { 0, 0, 0, fmt_720, 0 };



/* code to run the biconjugate-gradient-squared algorithm. */
/* the algorithm is taken from "preconditioned biconjugate gradient */
/* methods for numerical reservoir simulation", by p. joly and r. */
/* eymard, to appear in journal of computational physics.  the original */
/* reference  is p. sonneveld, "cgs, a fast lanczos-type solver for */
/* unsymmetric linear systems," report 84-16, delft university of */
/* technology, dept. of mathematics and informatics. */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --rparm;
    --iparm;
    --wk;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    nwusd = 0;
    *ier = 0;
    itcom1_1.iacel = 15;
    t1 = timer_(&dummy);
    echall_(n, &iparm[1], &rparm[1], &c__1, &c__2, ier);
    if (*ier < 0) {
	goto L997;
    }
    if (itcom1_1.level >= 2) {
	io___1158.ciunit = itcom1_1.nout;
	s_wsfe(&io___1158);
	e_wsfe();
    }
    iql = itcom1_1.iqlr == 1 || itcom1_1.iqlr == 3;
    iqr = itcom1_1.iqlr == 2 || itcom1_1.iqlr == 3;
    if (iqr) {
	goto L995;
    }

/* initialize the stopping test ... */

    inithv_(&c__0);
    itcom9_1.zhave = TRUE_;
    nwpstp = *nw;
    pstop_(&c__0, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &xxx, &xxx,
	     &wk[1], &nwpstp, ier);
    nwusd = max(nwusd,nwpstp);
    if (*ier < 0) {
	goto L730;
    }

/* allocate memory -- overlap wherever possible ... */
    ir0 = 1;
    ip = ir0 + *n;
    ipt = ip + *n;
    if (! iqr) {
	ipt = ip;
    }
    iq = ipt + *n;
    iz = iq + *n;
    izt = iz + *n;
    if (! iqr) {
	izt = iz;
    }
    iv1 = izt + *n;
    iv2 = iv1 + *n;
    iv3 = iv2 + *n;
/* Computing MAX */
    i__1 = nwusd, i__2 = iv3 - 1 + *n;
    nwusd = max(i__1,i__2);
    ipaaq = iv1;
    ippaaq = iv2;

/* check the memory usage. */

    if (nwusd > *nw) {
	goto L999;
    }

    itcom1_1.in = 0;
    itcom1_1.is = 0;
    if (! iql) {
	goto L121;
    }
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iv1]);
    vexopy_(n, &wk[iv1], &rhs[1], &wk[iv1], &c__2);
    (*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv1], &wk[iz]);
    goto L122;
L121:
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[iz]);
    vexopy_(n, &wk[iz], &rhs[1], &wk[iz], &c__2);
L122:
    if (iqr) {
	(*subqr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iz], &wk[
		izt]);
    }

/* =======================begin iteration loop======================= */

/* determine whether or not to stop. */

L10:
    inithv_(&c__1);
    nwpstp = *nw - (iv2 - 1);
    pstop_(&c__1, (S_fp)suba, (S_fp)subql, (S_fp)subqr, &coef[1], &jcoef[1], &
	    wfac[1], &jwfac[1], n, &u[1], &ubar[1], &rhs[1], &xxx, &wk[iz], &
	    wk[izt], &wk[iv2], &nwpstp, ier);
/* Computing MAX */
    i__1 = nwusd, i__2 = nwpstp + iv2 - 1;
    nwusd = max(i__1,i__2);
    if (itcom1_1.level >= 2) {
	iterm_(n, &u[1]);
    }
    if (itcom2_1.halt || itcom1_1.in >= itcom1_1.itmax || *ier < 0) {
	goto L900;
    }

    if (itcom1_1.in != 0) {
	goto L110;
    }

/* perform first-iterate calculations */

    vcopy_(n, &wk[iz], &wk[ir0]);
    vcopy_(n, &wk[iz], &wk[ip]);
    vcopy_(n, &wk[iz], &wk[iq]);
    r0r = vdot_(n, &wk[iz], &wk[ir0]);
    goto L111;

/* perform subsequent-iterate calculations */

L110:
    r0rold = r0r;
    r0r = vdot_(n, &wk[ir0], &wk[iz]);
/* Computing 2nd power */
    d__1 = itcom4_1.srelpr;
    if (abs(r0rold) < d__1 * d__1) {
	goto L996;
    }
    itcom3_1.beta = r0r / r0rold;

/* form direction vectors ... */

    vtriad_(n, &wk[ip], &wk[iz], &itcom3_1.beta, &wk[ipaaq], &c__1);
    vtriad_(n, &wk[iv2], &wk[ipaaq], &itcom3_1.beta, &wk[iq], &c__1);
    vtriad_(n, &wk[iq], &wk[ip], &itcom3_1.beta, &wk[iv2], &c__1);

/* ==========================form the iterate========================== */

/* at this point we have the vectors p and q and the new dot(r,r0) ... */
/* now form aq ... */

L111:
    iaq = iv1;
    if (! iql) {
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iq], &wk[iaq]
		);
    } else {
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iq], &wk[iv2]
		);
	(*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv2], &wk[
		iaq]);
    }
/* dot(r0,aq) ... */
    r0aq = vdot_(n, &wk[ir0], &wk[iaq]);
/* Computing 2nd power */
    d__1 = itcom4_1.srelpr;
    if (abs(r0aq) < d__1 * d__1) {
	goto L998;
    }
    itcom3_1.alpha = r0r / r0aq;
/* p-alpha*aq, p+p-alpha*aq ... */
    d__1 = -itcom3_1.alpha;
    vtriad_(n, &wk[ipaaq], &wk[ip], &d__1, &wk[iaq], &c__1);
    vexopy_(n, &wk[ippaaq], &wk[ip], &wk[ipaaq], &c__1);

/* ---get u--- */
    vtriad_(n, &u[1], &u[1], &itcom3_1.alpha, &wk[ippaaq], &c__1);

/* ---get resid--- */
    if (! iql) {
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ippaaq], &wk[
		iv3]);
	d__1 = -itcom3_1.alpha;
	vtriad_(n, &wk[iz], &wk[iz], &d__1, &wk[iv3], &c__1);
    } else {
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[ippaaq], &wk[
		iv3]);
	(*subql)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &wk[iv3], &wk[
		iv2]);
	d__1 = -itcom3_1.alpha;
	vtriad_(n, &wk[iz], &wk[iz], &d__1, &wk[iv2], &c__1);
    }

/* proceed to next iteration */

    ++itcom1_1.in;
    ++itcom1_1.is;
    goto L10;

/* ----------------------------------finish up---------------------------------- */

L900:
    if (itcom2_1.halt) {
	goto L715;
    }
    *ier = 1;
    ershow_(ier, "bcgsw", (ftnlen)5);
    itcom3_1.zeta = itcom3_1.stptst;
    goto L725;
L715:
    if (itcom1_1.level >= 1) {
	io___1178.ciunit = itcom1_1.nout;
	s_wsfe(&io___1178);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	e_wsfe();
    }

L725:
    if (itcom1_1.idgts < 0) {
	goto L730;
    }
    perror1_((S_fp)suba, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    rhs[1], &wk[1], &digit1, &digit2, &itcom1_1.idgts);
L730:
    t2 = timer_(&dummy);
    timit = t2 - t1;
    iparm[2] = itcom1_1.in;
    rparm[1] = itcom3_1.zeta;
    rparm[2] = itcom3_1.emax;
    rparm[3] = itcom3_1.emin;
    rparm[6] = timit;
    rparm[7] = digit1;
    rparm[8] = digit2;
L735:
    if (itcom1_1.level >= 3) {
	echall_(n, &iparm[1], &rparm[1], &c__2, &c__2, ier);
    }
    *nw = nwusd;
    return 0;

/* error returns */

L995:
    *ier = -16;
    ershow_(ier, "bcgsw", (ftnlen)5);
    goto L725;

L996:
    *ier = -13;
    ershow_(ier, "bcgsw", (ftnlen)5);
    goto L725;

L997:
    ershow_(ier, "bcgsw", (ftnlen)5);
    goto L735;

L998:
    *ier = -15;
    ershow_(ier, "bcgsw", (ftnlen)5);
    goto L725;

L999:
    *ier = -2;
    ershow_(ier, "bcgsw", (ftnlen)5);
    goto L735;

} /* bcgsw_ */

/* Subroutine */ int nullpl_(doublereal *coef, integer *jcoef, doublereal *wk,
	 integer *iwk, integer *n, S_fp subql, U_fp suba, U_fp subqr,
	doublereal *u, doublereal *v)
{

/* routine to just apply the left preconditioner ... */


    /* Parameter adjustments */
    --v;
    --u;
    --iwk;
    --wk;
    --jcoef;
    --coef;

    /* Function Body */
    (*subql)(&coef[1], &jcoef[1], &wk[1], &iwk[1], n, &u[1], &v[1]);
    return 0;
} /* nullpl_ */

/* Subroutine */ int nullpr_(doublereal *coef, integer *jcoef, doublereal *wk,
	 integer *iwk, integer *n, U_fp subql, U_fp suba, S_fp subqr,
	doublereal *u, doublereal *v)
{

/* routine to just apply the right preconditioner ... */


    /* Parameter adjustments */
    --v;
    --u;
    --iwk;
    --wk;
    --jcoef;
    --coef;

    /* Function Body */
    (*subqr)(&coef[1], &jcoef[1], &wk[1], &iwk[1], n, &u[1], &v[1]);
    return 0;
} /* nullpr_ */

/* Subroutine */ int cgcrpr_(doublereal *coef, integer *jcoef, doublereal *wk,
	 integer *iwk, integer *n, U_fp subql, S_fp suba, S_fp subqr,
	doublereal *u, doublereal *v)
{
    extern /* Subroutine */ int tmult_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *), vexopy_(
	    integer *, doublereal *, doublereal *, doublereal *, integer *);


/* right preconditioner routine to use with cgcr method. */





/* could bypass next line if subqr is just a copy ... */
    /* Parameter adjustments */
    --v;
    --u;
    --iwk;
    --wk;
    --jcoef;
    --coef;

    /* Function Body */
    (*subqr)(&coef[1], &jcoef[1], &wk[1], &iwk[1], n, &u[1], &v[1]);
    (*suba)(&coef[1], &jcoef[1], &wk[1], &iwk[1], n, &v[1], &wk[
	    ccgcr_1.ivcgcr]);
    tmult_(n, &ccgcr_1.nblk, &ccgcr_1.nband, &wk[ccgcr_1.ictac], &wk[
	    ccgcr_1.ieta], &wk[ccgcr_1.ivcgcr], &wk[ccgcr_1.ivcgcr]);
    vexopy_(n, &v[1], &v[1], &wk[ccgcr_1.ivcgcr], &c__2);

    return 0;
} /* cgcrpr_ */

/* Subroutine */ int getblk_(doublereal *coef, integer *jcoef, integer *n,
	integer *nblk, integer *nband, doublereal *ctac, integer *nw, integer
	*ier)
{
    /* System generated locals */
    integer ctac_dim1, ctac_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, ii, id1, id2, j1s, j2s, ind, ipj, idm1, ind1,
	    ind2, id1s, id2s, ibeg, iend, imid, nmid;
    static logical symm;
    static integer nhbp1, ibbeg, idiag, ibend, ihalf, ibase, idmin, iomid,
	    idmax;
    static doublereal denom;
    extern /* Subroutine */ int vfill_(integer *, doublereal *, doublereal *);
    static integer nbsiz, itemp1, itemp2, nhband, nsubmt;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen);
    static doublereal xpivot;


/* this utility routine for the cgcr algorithm computes the matrix */
/* (c**t)*a*c and factors it.  here, each column of c is zero */
/* everywhere except it is all 1's on one of its blocks. */



/* ... data common blocks */



    /* Parameter adjustments */
    --coef;
    --jcoef;
    ctac_dim1 = *nblk;
    ctac_offset = 1 + ctac_dim1;
    ctac -= ctac_offset;

    /* Function Body */
    *nband = 0;

/* *************************** find the bandwidth ********************** */


    idmin = 0;
    idmax = 0;
    i__1 = dscons_1.maxnz;
    for (i__ = 1; i__ <= i__1; ++i__) {
	idiag = jcoef[i__];
	idmin = min(idmin,idiag);
/* L10: */
	idmax = max(idmax,idiag);
    }
    if (itcom6_1.nstore == 2) {
	idmin = -idmax;
    }
/* Computing MAX */
    i__1 = -idmin;
    ihalf = max(i__1,idmax);
    nbsiz = *n / *nblk;
    nhband = (ihalf + nbsiz - 1) / nbsiz;
    *nband = (nhband << 1) + 1;

/* ******************************************************************* */

/* now form the matrix.  basically what we need to do here is to */
/* add up all the elements in each block of the a-matrix. */

    if (*nblk * *nband > *nw) {
	goto L999;
    }
    *nw = *nblk * *nband;

    i__1 = *nblk * *nband;
    vfill_(&i__1, &ctac[ctac_offset], &c_b121);

/* loop over the diagonals ... */
    i__1 = dscons_1.maxnz;
    for (i__ = 1; i__ <= i__1; ++i__) {
	idiag = jcoef[i__];
/* Computing MAX */
	i__2 = 1, i__3 = 1 - idiag;
	ibeg = max(i__2,i__3);
/* Computing MIN */
	i__2 = *n, i__3 = *n - idiag;
	iend = min(i__2,i__3);
	ibbeg = (ibeg - 1) / nbsiz + 1;
	ibend = (iend - 1) / nbsiz + 1;
	ibase = (i__ - 1) * dscons_1.ndim;

	symm = itcom6_1.nstore == 2 && idiag != 0;
	idm1 = idiag - 1;
	iomid = -idm1;
	nmid = *n - idiag;
	nhbp1 = nhband + 1;
/* loop over the rows of ctac ... */
	i__2 = ibend;
	for (j = ibbeg; j <= i__2; ++j) {
/* Computing MAX */
	    i__3 = (j - 1) * nbsiz + 1;
	    ibeg = max(i__3,iomid);
/* Computing MIN */
	    i__3 = j * nbsiz;
	    iend = min(i__3,nmid);
/*     ic1 = (ibeg+idiag-1)/nbsiz + 1 */
/*     ic2 = (iend+idiag-1)/nbsiz + 1 */
/*     id1 = ic1 - j + nhband + 1 */
/*     id2 = ic2 - j + nhband + 1 */
	    itemp1 = (ibeg + idm1) / nbsiz;
	    itemp2 = (iend + idm1) / nbsiz;
	    id1 = itemp1 + 2 - j + nhband;
	    id2 = itemp2 + 2 - j + nhband;
	    j1s = j + id1 - nhbp1;
	    j2s = j + id2 - nhbp1;
	    id1s = *nband - id1 + 1;
	    id2s = *nband - id2 + 1;
	    if (id1 != id2) {
		goto L3;
	    }
/*     ctac(j,id1) = ctac(j,id1) */
/*    a              + vadd(iend-ibeg+1,coef(ibase+ibeg)) */
	    i__3 = iend;
	    for (ii = ibeg; ii <= i__3; ++ii) {
		if (symm) {
		    ctac[j1s + id1s * ctac_dim1] += coef[ibase + ii];
		}
/* L41: */
		ctac[j + id1 * ctac_dim1] += coef[ibase + ii];
	    }
	    goto L2;
/* 3    imid = 1 + (ic2-1)*nbsiz - idiag */
L3:
	    imid = iomid + itemp2 * nbsiz;
/*     ctac(j,id1) = ctac(j,id1) */
/*    a              + vadd(imid-ibeg  ,coef(ibase+ibeg)) */
	    i__3 = imid - 1;
	    for (ii = ibeg; ii <= i__3; ++ii) {
		if (symm) {
		    ctac[j1s + id1s * ctac_dim1] += coef[ibase + ii];
		}
/* L42: */
		ctac[j + id1 * ctac_dim1] += coef[ibase + ii];
	    }
/*     ctac(j,id2) = ctac(j,id2) */
/*    a              + vadd(iend-imid+1,coef(ibase+imid)) */
	    i__3 = iend;
	    for (ii = imid; ii <= i__3; ++ii) {
		if (symm) {
		    ctac[j2s + id2s * ctac_dim1] += coef[ibase + ii];
		}
/* L43: */
		ctac[j + id2 * ctac_dim1] += coef[ibase + ii];
	    }

L2:
	    ;
	}

/* L1: */
    }

/* **************************** do lu factorization ******************** */

    i__1 = *nblk - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
	denom = ctac[i__ + nhbp1 * ctac_dim1];
	if (abs(denom) < itcom4_1.srelpr) {
	    goto L998;
	}
	xpivot = 1. / denom;
/* Computing MIN */
	i__2 = nhband, i__3 = *nblk - i__;
	nsubmt = min(i__2,i__3);
	i__2 = nsubmt;
	for (j = 1; j <= i__2; ++j) {
	    ipj = i__ + j;
	    ind2 = nhbp1 - j;
	    i__3 = nsubmt;
	    for (k = 1; k <= i__3; ++k) {
/* 30   ctac(i+j,nhband-j+1+k) = ctac(i+j,nhband-j+1+k) */
/*    a  - xpivot*ctac(i+j,nhband-j+1)*ctac(i,nhband+1+k) */
		ind = nhbp1 - j + k;
/* L30: */
		ctac[ipj + ind * ctac_dim1] -= xpivot * ctac[ipj + ind2 *
			ctac_dim1] * ctac[i__ + (nhbp1 + k) * ctac_dim1];
	    }
	}
	i__3 = nsubmt;
	for (j = 1; j <= i__3; ++j) {
	    ipj = i__ + j;
	    ind1 = nhbp1 - j;
	    ind2 = nhbp1 + j;
/*     ctac(i+j,nhband+1-j) = ctac(i+j,nhband+1-j)*xpivot */
/* 32   ctac(i  ,nhband+1+j) = ctac(i  ,nhband+1+j)*xpivot */
	    ctac[ipj + ind1 * ctac_dim1] *= xpivot;
/* L32: */
	    ctac[i__ + ind2 * ctac_dim1] *= xpivot;
	}
/* L31: */
    }
    return 0;


/* error returns */

/* breakdown ... */
L998:
    *ier = -6;
    ershow_(ier, "getblk", (ftnlen)6);
    return 0;

/* insuff. memory ... */
L999:
    *ier = -2;
    ershow_(ier, "getblk", (ftnlen)6);
    *nw = *nblk * *nband;
    return 0;
} /* getblk_ */

/* Subroutine */ int tmult_(integer *n, integer *nblk, integer *nband,
	doublereal *ctac, doublereal *eta, doublereal *u, doublereal *v)
{
    /* System generated locals */
    integer ctac_dim1, ctac_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, ip1, ind;
    static doublereal val;
    static integer ibeg, iend, icol, irow, nhbp1, nbsiz, nhband;


/* this utility routine for the cgcr algorithm computes the product of */
/* the t-matrix with a vector.  here, t = c*((c**t)*a*c)**(-1) * c**t, */
/* a projection. */


    /* Parameter adjustments */
    ctac_dim1 = *nblk;
    ctac_offset = 1 + ctac_dim1;
    ctac -= ctac_offset;
    --eta;
    --u;
    --v;

    /* Function Body */
    nbsiz = *n / *nblk;
    nhband = (*nband - 1) / 2;
    nhbp1 = nhband + 1;

/* form the eta vector - aggregation step. */

    i__1 = *nblk - 1;
    for (i__ = 0; i__ <= i__1; ++i__) {
/* 1    eta(i) = vadd (nbsiz,u(1+i*nbsiz)) */
	ip1 = i__ + 1;
	eta[ip1] = 0.;
	i__2 = nbsiz;
	for (j = 1; j <= i__2; ++j) {
/* L1: */
	    eta[ip1] += u[i__ * nbsiz + j];
	}
    }

/* perform the forward solve. */

    if (nhband == 0) {
	goto L40;
    }
    i__2 = *nblk;
    for (irow = 2; irow <= i__2; ++irow) {
/* Computing MAX */
	i__1 = 1, i__3 = irow - nhband;
	ibeg = max(i__1,i__3);
	iend = irow - 1;
	ind = nhbp1 - irow;
	i__1 = iend;
	for (icol = ibeg; icol <= i__1; ++icol) {
/* L3: */
	    eta[irow] -= eta[icol] * ctac[irow + (ind + icol) * ctac_dim1];
	}
/* L2: */
    }

/* perform the diagonal solve. */

L40:
    i__2 = *nblk;
    for (i__ = 1; i__ <= i__2; ++i__) {
/* L4: */
	eta[i__] /= ctac[i__ + nhbp1 * ctac_dim1];
    }

/* perform the back solve. */

    if (nhband == 0) {
	goto L41;
    }
    i__2 = *nblk - 1;
    for (i__ = 1; i__ <= i__2; ++i__) {
	irow = *nblk - i__;
	ibeg = irow + 1;
/* Computing MIN */
	i__1 = irow + nhband;
	iend = min(i__1,*nblk);
	ind = nhbp1 - irow;
	i__1 = iend;
	for (icol = ibeg; icol <= i__1; ++icol) {
/* L6: */
	    eta[irow] -= eta[icol] * ctac[irow + (ind + icol) * ctac_dim1];
	}
/* L5: */
    }

/* form the vector t*u - disaggregation step. */

L41:
    i__2 = *nblk - 1;
    for (i__ = 0; i__ <= i__2; ++i__) {
	val = eta[i__ + 1];
/* 7    call vfill (nbsiz,v(1+i*nbsiz),eta(i+1)) */
	i__1 = nbsiz;
	for (j = 1; j <= i__1; ++j) {
/* L7: */
	    v[i__ * nbsiz + j] = val;
	}
    }

    return 0;
} /* tmult_ */

doublereal vadd_(integer *n, doublereal *v)
{
    /* System generated locals */
    integer i__1;
    doublereal ret_val;

    /* Local variables */
    static integer i__;
    static doublereal sum;


/* adds up all elements of a vector */


    /* Parameter adjustments */
    --v;

    /* Function Body */
    sum = 0.;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	sum += v[i__];
    }
    ret_val = sum;
    return ret_val;
} /* vadd_ */

/* Subroutine */ int hesest_(doublereal *hess, integer *nhess, integer *nd,
	integer *esize, integer *imode, logical *havest, doublereal *emax,
	doublereal *emin, doublereal *wk, integer *nw, integer *ier)
{
    /* System generated locals */
    integer hess_dim1, hess_offset, i__1, i__2, i__3;
    doublereal d__1, d__2;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, j;
    extern /* Subroutine */ int hqr_(integer *, integer *, integer *, integer
	    *, doublereal *, doublereal *, doublereal *, integer *);
    static integer ibeg, jbeg, iend, jend, ndim, imat, ierr;
    static doublereal vmod;
    static integer iimag, ireal;
    extern /* Subroutine */ int vfill_(integer *, doublereal *, doublereal *);
    static integer nwusd;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen);


/* routine to calculate the moduli of the extremal eigenvalues of a */
/* banded hessenberg matrix. */

/* hess      - the hessenberg matrix, stored by diagonals */
/* nhess, nd - dimensions of array hess */
/* esize     - indicator of how many rows/cols of hess have been */
/*             filled out so far */
/* imode     - style of eigenvalue estimation: */
/*   abs(imode)  - use this size of principal submatrix to do estimate */
/*   sign(imode) - use either leading or trailing principal submatrix */



    /* Parameter adjustments */
    hess_dim1 = *nhess;
    hess_offset = 1 + hess_dim1;
    hess -= hess_offset;
    --wk;

    /* Function Body */
    *havest = FALSE_;
    if (*imode > 0 && *esize > *imode) {
	return 0;
    }

/* memory allocation */

/* Computing MIN */
    i__1 = *esize, i__2 = abs(*imode);
    ndim = min(i__1,i__2);
    if (ndim <= 0) {
	return 0;
    }
    imat = 1;
    ireal = imat + ndim * ndim;
    iimag = ireal + ndim;

    nwusd = iimag - 1 + ndim;
    if (nwusd > *nw) {
	goto L999;
    }
    *nw = nwusd;

/* make the hess matrix into a full matrix */

    if (*imode < 0) {
	goto L1;
    }
    ibeg = 1;
    iend = *esize;
    goto L2;
L1:
/* Computing MAX */
    i__1 = 1, i__2 = *esize - abs(*imode) + 1;
    ibeg = max(i__1,i__2);
    iend = *esize;
L2:
    i__1 = ndim * ndim;
    vfill_(&i__1, &wk[imat], &c_b121);
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* Computing MAX */
	i__2 = ibeg, i__3 = i__ - 1;
	jbeg = max(i__2,i__3);
/* Computing MIN */
	i__2 = ibeg - 1 + ndim, i__3 = i__ + *nd - 2;
	jend = min(i__2,i__3);
	i__2 = jend;
	for (j = jbeg; j <= i__2; ++j) {
/* L3: */
	    wk[imat + (i__ - ibeg) + (j - ibeg) * ndim] = hess[i__ + (j - i__
		    + 2) * hess_dim1];
	}
    }

/* call to eispack to calculate eigenvalues */

    ierr = 0;
    hqr_(&ndim, &ndim, &c__1, &ndim, &wk[imat], &wk[ireal], &wk[iimag], &ierr)
	    ;
    if (ierr != 0) {
	goto L998;
    }

/* find eigenvalues with largest and smallest modulus */

/* Computing 2nd power */
    d__1 = wk[ireal];
/* Computing 2nd power */
    d__2 = wk[iimag];
    *emax = d__1 * d__1 + d__2 * d__2;
    *emin = *emax;
    if (ndim == 1) {
	goto L5;
    }
    i__2 = ndim;
    for (i__ = 2; i__ <= i__2; ++i__) {
/* Computing 2nd power */
	d__1 = wk[ireal - 1 + i__];
/* Computing 2nd power */
	d__2 = wk[iimag - 1 + i__];
	vmod = d__1 * d__1 + d__2 * d__2;
	*emax = max(*emax,vmod);
/* L6: */
	*emin = min(*emin,vmod);
    }

L5:
    *emax = sqrt(*emax);
    *emin = sqrt(*emin);
    *havest = TRUE_;
    return 0;


/* error returns ... */

/* error in call to eispack */
L998:
    *ier = -18;
    ershow_(ier, "hesest", (ftnlen)6);
    return 0;

/* insuff. floating point workspace */
L999:
    *ier = -2;
    *nw = nwusd;
    ershow_(ier, "hesest", (ftnlen)6);
    return 0;
} /* hesest_ */

/* Subroutine */ int pvec_(integer *n, integer *nv, integer *iv, integer *s,
	integer *s1, integer *idotw, integer *it, integer *il, integer *ir,
	doublereal *vect, doublereal *dots, integer *ndc, doublereal *betas,
	doublereal *gamma, logical *gamize, doublereal *svec, doublereal *wk,
	integer *ier)
{
    /* System generated locals */
    integer gamma_dim1, gamma_offset, i__1, i__2, i__3, i__4, i__5;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, j, k, l, m;
    static doublereal xxx;
    static integer ibgn, iend, jbgn, jend;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int vfill_(integer *, doublereal *, doublereal *),
	     gauss_(integer *, integer *, doublereal *, doublereal *,
	    doublereal *, integer *), vcopy_(integer *, doublereal *,
	    doublereal *);
    static doublereal vnorm;
    extern /* Subroutine */ int vtriad_(integer *, doublereal *, doublereal *,
	     doublereal *, doublereal *, integer *);


/* this routine performs generalized gram-schmidt on a collection */
/* of vectors. */
/* it is used to update the table of direction vectors for */
/* generalized conjugate gradient methods per-iteration. */
/* note that this routine was intended to be rather general, */
/* including block conjugate gradient methods. */

/* params -- */
/* n      - size of the vectors */
/* nv     - the size of the p-vector table. */
/*          ie., the table contains p(it-1), p(it-2),...,p(it-nv). */
/* iv     - number of p-vector-like objects we are dragging along. */
/*          eg., if iv=3, then we may be computing p, ap and q(inv)ap. */
/* s      - the block size for block conjugate gradient methods. */
/* s1     - indicates how many of the old p-vectors are to be used to */
/*          orthogonalize the new p-vector. */
/* idotw  - indicates the bandwidth of the matrix used to calculate */
/*          the betas. */
/*          generally equals s1, but if the h-matrix is symmetric */
/*          then = 1. */
/* it     - iteration number.  this routine calculates p(it). */
/* il,ir  - integers between 1 and iv.  indicate whether p, ap or */
/*          q(inv)ap */
/*          is to be used to calculate the inner product for */
/*          orthogonality. */
/* vect   - the p-vector table. */
/* dots   - workspace for the dot products. */
/* ndc    - the number of dot products that have already been */
/*          computed by formit. */
/* betas  - workspace for the betas. */
/* gamma  - an s by s matrix containing the coefficients from applying */
/*          gram schmidt to p(it). */
/* gamize - flag to indicate whether gram schmidt is to be applied */
/*          after p(it) is calculated. */
/* svec   - input packet of vectors to the p-vector calculation */
/*          process. */
/* wk     - workspace. must be of size s. */
/* ier    - error code */

/* array structure and indexing functions -- */

/* vect(n,s,nv,iv)    jv */
/* svec(n,s,iv)       isv */
/* dots(s,s,idotw,s1) id */
/* betas(s,s,s1)      ib */
/* gamma(s,s)         - */


/* define the necessary indexing functions. */


    /* Parameter adjustments */
    gamma_dim1 = *s;
    gamma_offset = 1 + gamma_dim1;
    gamma -= gamma_offset;
    --vect;
    --dots;
    --betas;
    --svec;
    --wk;

    /* Function Body */
    *ier = 0;

/* ... handle first iteration. */

    if (*it == 0 || *s1 <= 0) {
	goto L1000;
    }

/* ... now handle general iteration. */

/* ... first, calculate dot products (p(it-1),p(i)). */

/* Computing MAX */
    i__1 = *it - *idotw;
    ibgn = max(i__1,0);
    iend = *it - 1 - *ndc;
    if (ibgn > iend) {
	goto L10;
    }
    i__1 = iend;
    for (i__ = ibgn; i__ <= i__1; ++i__) {
	i__2 = *s;
	for (j = 1; j <= i__2; ++j) {
	    i__3 = *s;
	    for (k = 1; k <= i__3; ++k) {
/* L2: */
		i__4 = *it - 1;
		i__5 = *it - 1;
		dots[1 + (j - 1) + *s * (k - 1 + *s * (i__4 - i__ + *idotw * (
			i__4 % *s1)))] = vdot_(n, &vect[1 + (c__1 - 1) + *n *
			(j - 1 + *s * (i__5 % *nv + *nv * (*il - 1)))], &vect[
			1 + (c__1 - 1) + *n * (k - 1 + *s * (i__ % *nv + *nv *
			 (*ir - 1)))]);
	    }
	}
    }

/* ... next, form all the new betas. */

L10:
/* Computing MAX */
    i__4 = *it - *s1;
    ibgn = max(i__4,0);
    iend = *it - 1;
    i__4 = iend;
    for (i__ = ibgn; i__ <= i__4; ++i__) {
	i__5 = *s;
	for (l = 1; l <= i__5; ++l) {
	    i__3 = *s;
	    for (k = 1; k <= i__3; ++k) {
		wk[k] = -vdot_(n, &vect[1 + (c__1 - 1) + *n * (k - 1 + *s * (
			i__ % *nv + *nv * (*il - 1)))], &svec[1 + (c__1 - 1)
			+ *n * (l - 1 + *s * (*ir - 1))]);
/* Computing MAX */
		i__2 = i__ - *idotw + 1, i__1 = *it - *s1, i__2 = max(i__2,
			i__1);
		jbgn = max(i__2,0);
		jend = i__ - 1;
		if (jend < jbgn) {
		    goto L35;
		}
		i__2 = jend;
		for (j = jbgn; j <= i__2; ++j) {
		    i__1 = *s;
		    for (m = 1; m <= i__1; ++m) {
/* L4: */
			wk[k] -= dots[1 + (k - 1) + *s * (m - 1 + *s * (i__ -
				j + *idotw * (i__ % *s1)))] * betas[1 + (m -
				1) + *s * (l - 1 + *s * (j % *s1))];
		    }
		}
L35:
		;
	    }
	    i__3 = *s * *s;
	    vcopy_(&i__3, &dots[1 + (c__1 - 1) + *s * (c__1 - 1 + *s * (i__ -
		    i__ + *idotw * (i__ % *s1)))], &gamma[gamma_offset]);
	    gauss_(s, s, &gamma[gamma_offset], &wk[1], &betas[1 + (c__1 - 1)
		    + *s * (l - 1 + *s * (i__ % *s1))], ier);
	    if (*ier != 0) {
		goto L999;
	    }
/* L34: */
	}
/* L3: */
    }

/* ... now, get new p vectors. */

    i__4 = *iv;
    for (m = 1; m <= i__4; ++m) {
	i__5 = iend;
	for (i__ = ibgn; i__ <= i__5; ++i__) {
	    i__3 = *s;
	    for (l = 1; l <= i__3; ++l) {
		i__1 = *s;
		for (k = 1; k <= i__1; ++k) {
/* L6: */
		    vtriad_(n, &svec[1 + (c__1 - 1) + *n * (l - 1 + *s * (m -
			    1))], &svec[1 + (c__1 - 1) + *n * (l - 1 + *s * (
			    m - 1))], &betas[1 + (k - 1) + *s * (l - 1 + *s *
			    (i__ % *s1))], &vect[1 + (c__1 - 1) + *n * (k - 1
			    + *s * (i__ % *nv + *nv * (m - 1)))], &c__1);
		}
/* L37: */
	    }
	}
    }

/* ... copy new vectors into the table. */

L1000:
    i__3 = *iv;
    for (m = 1; m <= i__3; ++m) {
/* L168: */
	i__5 = *n * *s;
	vcopy_(&i__5, &svec[1 + (c__1 - 1) + *n * (c__1 - 1 + *s * (m - 1))],
		&vect[1 + (c__1 - 1) + *n * (c__1 - 1 + *s * (*it % *nv + *nv
		* (m - 1)))]);
    }

/* ... now calculate gamma and orthogonalize the new block of p-vectors */

    i__5 = *s * *s;
    vfill_(&i__5, &gamma[gamma_offset], &c_b121);
    i__5 = *s;
    for (i__ = 1; i__ <= i__5; ++i__) {
/* L881: */
	gamma[i__ + i__ * gamma_dim1] = 1.;
    }
    if (! (*gamize)) {
	return 0;
    }
    i__5 = *s;
    for (i__ = 1; i__ <= i__5; ++i__) {
	if (i__ == 1) {
	    goto L882;
	}
	i__3 = i__ - 1;
	for (j = 1; j <= i__3; ++j) {
/* L883: */
	    wk[j] = vdot_(n, &vect[1 + (c__1 - 1) + *n * (c__1 - 1 + *s * (j %
		     *nv + *nv * (*it - 1)))], &vect[1 + (c__1 - 1) + *n * (
		    c__1 - 1 + *s * (i__ % *nv + *nv * (*it - 1)))]);
	}
	i__3 = i__ - 1;
	for (j = 1; j <= i__3; ++j) {
	    i__4 = *iv;
	    for (m = 1; m <= i__4; ++m) {
/* L885: */
		d__1 = -wk[j];
		vtriad_(n, &vect[1 + (c__1 - 1) + *n * (i__ - 1 + *s * (*it %
			*nv + *nv * (m - 1)))], &vect[1 + (c__1 - 1) + *n * (
			i__ - 1 + *s * (*it % *nv + *nv * (m - 1)))], &d__1, &
			vect[1 + (c__1 - 1) + *n * (j - 1 + *s * (*it % *nv +
			*nv * (m - 1)))], &c__1);
	    }
	    i__4 = i__ - 1;
	    for (k = j; k <= i__4; ++k) {
/* L886: */
		gamma[j + i__ * gamma_dim1] -= gamma[j + k * gamma_dim1] * wk[
			k];
	    }
/* L884: */
	}
L882:
	vnorm = sqrt(vdot_(n, &vect[1 + (c__1 - 1) + *n * (i__ - 1 + *s * (*
		it % *nv + *nv * (c__1 - 1)))], &vect[1 + (c__1 - 1) + *n * (
		i__ - 1 + *s * (*it % *nv + *nv * (c__1 - 1)))]));
/* Computing 2nd power */
	d__1 = itcom4_1.srelpr;
	if (abs(vnorm) < d__1 * d__1) {
	    goto L999;
	}
	i__3 = *iv;
	for (m = 1; m <= i__3; ++m) {
/* L888: */
	    d__1 = 1. / vnorm;
	    vtriad_(n, &vect[1 + (c__1 - 1) + *n * (i__ - 1 + *s * (*it % *nv
		    + *nv * (m - 1)))], &xxx, &d__1, &vect[1 + (c__1 - 1) + *
		    n * (i__ - 1 + *s * (*it % *nv + *nv * (m - 1)))], &c__2);
	}
	i__3 = i__;
	for (j = 1; j <= i__3; ++j) {
/* L887: */
	    gamma[j + i__ * gamma_dim1] /= vnorm;
	}
/* L879: */
    }
    return 0;

/* ... error return. */

L999:
    *ier = -100;
    return 0;
} /* pvec_ */

/* Subroutine */ int gauss_(integer *ndim, integer *n, doublereal *a,
	doublereal *rhs, doublereal *u, integer *ier)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2, i__3;
    doublereal d__1, d__2;

    /* Local variables */
    static integer i__, j, k;
    static doublereal fact;


/* gaussian elimination routine. */

    /* Parameter adjustments */
    --u;
    --rhs;
    a_dim1 = *ndim;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */
    *ier = 0;
    if (*n == 1) {
	goto L190;
    }
    i__1 = *n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* Computing 2nd power */
	d__2 = itcom4_1.srelpr;
	if ((d__1 = a[i__ + i__ * a_dim1], abs(d__1)) < d__2 * d__2) {
	    goto L999;
	}
	i__2 = *n;
	for (j = i__ + 1; j <= i__2; ++j) {
	    fact = a[j + i__ * a_dim1] / a[i__ + i__ * a_dim1];
	    a[j + i__ * a_dim1] = 0.;
	    i__3 = *n;
	    for (k = i__ + 1; k <= i__3; ++k) {
/* L2: */
		a[j + k * a_dim1] -= fact * a[i__ + k * a_dim1];
	    }
	    rhs[j] -= fact * rhs[i__];
/* L10: */
	}
/* L1: */
    }

L190:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	k = *n - i__ + 1;
/* Computing 2nd power */
	d__2 = itcom4_1.srelpr;
	if ((d__1 = a[k + k * a_dim1], abs(d__1)) < d__2 * d__2) {
	    goto L999;
	}
	u[k] = rhs[k];
	if (i__ == 1) {
	    goto L44;
	}
	i__2 = *n;
	for (j = k + 1; j <= i__2; ++j) {
	    u[k] -= u[j] * a[k + j * a_dim1];
/* L4: */
	}
L44:
	u[k] /= a[k + k * a_dim1];
/* L3: */
    }
    return 0;
L999:
    *ier = -100;
    return 0;
} /* gauss_ */

/* Subroutine */ int qrupd_(integer *ndim, integer *nnz, integer *nind,
	doublereal *c__, doublereal *s, doublereal *ucnbar, doublereal *ucn,
	doublereal *u, doublereal *b, integer *ier)
{
    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Builtin functions */
    double sqrt(doublereal), d_sign(doublereal *, doublereal *);

    /* Local variables */
    static integer j;
    static doublereal u1, u2;
    static integer jbgn, jend;
    static doublereal ucnb, denom;


/* this routine updates the qr factorization of the banded upper */
/* hessenberg matrix used by various conjugate gradient variants. */

/* parameters -- */
/* ndim   - the current size of the hessenberg matrix */
/* nnz    - the actual number of nonzeros in the band of the */
/*          hessenberg matrix.  obviously, must be .le. than nind. */
/* nind   - the bandwidth of the hessenberg matrix, as stored */
/* c,s    - arrays which hold the cosines and sines of all the */
/*          rotations that have been performed so far */
/* u      - the new rightmost column of the hessenberg matrix, */
/*          which is to be rotated */
/* b      - the element of the hessenberg matrix to be zapped */
/*          by the new rotation */
/* ucnbar - the element of the hessenberg matrix that b is to be */
/* ucn    - rotated into the new value of ucnbar, after the rotation */


/* note -- due to the fortran implementation on the cyber 205, it is */
/* necessary to make ucnbar an array rather than a scalar. */


/* ... define the usual indexing functions. */


/* ... indu is used to index u. */

    /* Parameter adjustments */
    --u;
    --ucnbar;
    --s;
    --c__;

    /* Function Body */
    if (*ndim <= 1) {
	return 0;
    }

/* ... apply all the old rotations to the column. */

/* Computing MAX */
    i__1 = 1, i__2 = *ndim - *nnz + 1;
    jbgn = max(i__1,i__2);
    jend = *ndim - 2;
    if (jend < jbgn) {
	goto L3;
    }
    i__1 = jend;
    for (j = jbgn; j <= i__1; ++j) {
	i__2 = j + 1;
	u1 = c__[1 + j % *nind] * u[1 + j % (*nind + 1)] + s[1 + j % *nind] *
		u[1 + i__2 % (*nind + 1)];
	i__2 = j + 1;
	u2 = -s[1 + j % *nind] * u[1 + j % (*nind + 1)] + c__[1 + j % *nind] *
		 u[1 + i__2 % (*nind + 1)];
	u[1 + j % (*nind + 1)] = u1;
	i__2 = j + 1;
	u[1 + i__2 % (*nind + 1)] = u2;
/* L2: */
    }
L3:

/* ... now proceed to form the new  2-by-2 rotation matrix. */

    ucnb = ucnbar[1];
    denom = sqrt(ucnb * ucnb + *b * *b);
    if (abs(ucnb) >= 1e-40) {
	denom = d_sign(&denom, &ucnb);
    }
    if (abs(denom) < 1e-40) {
	goto L999;
    }
    i__1 = *ndim - 1;
    c__[1 + i__1 % *nind] = ucnb / denom;
    i__1 = *ndim - 1;
    s[1 + i__1 % *nind] = *b / denom;

/* ... now apply the new rotation. */

    i__1 = *ndim - 1;
    i__2 = *ndim - 1;
    i__3 = *ndim - 1;
    u1 = c__[1 + i__1 % *nind] * u[1 + i__2 % (*nind + 1)] + s[1 + i__3 % *
	    nind] * u[1 + *ndim % (*nind + 1)];
    i__1 = *ndim - 1;
    i__2 = *ndim - 1;
    i__3 = *ndim - 1;
    u2 = -s[1 + i__1 % *nind] * u[1 + i__2 % (*nind + 1)] + c__[1 + i__3 % *
	    nind] * u[1 + *ndim % (*nind + 1)];
    i__1 = *ndim - 1;
    u[1 + i__1 % (*nind + 1)] = u1;
    u[1 + *ndim % (*nind + 1)] = u2;
    i__1 = *ndim - 1;
    i__2 = *ndim - 1;
    *ucn = c__[1 + i__1 % *nind] * ucnb + s[1 + i__2 % *nind] * *b;
    return 0;
L999:
    *ier = -14;
    return 0;
} /* qrupd_ */

/* Subroutine */ int pstop_(integer *ncall, S_fp suba, S_fp subql, S_fp subqr,
	 doublereal *coef, integer *jcoef, doublereal *wfac, integer *jwfac,
	integer *n, doublereal *u, doublereal *ubar, doublereal *rhs,
	doublereal *r__, doublereal *z__, doublereal *zt, doublereal *wk,
	integer *nw, integer *ier)
{
    extern /* Subroutine */ int nullpl_(doublereal *, integer *, doublereal *,
	     integer *, integer *, S_fp, U_fp, U_fp, doublereal *, doublereal
	    *), nullpr_(doublereal *, integer *, doublereal *, integer *,
	    integer *, U_fp, U_fp, S_fp, doublereal *, doublereal *), pstopg_(
	    integer *, S_fp, S_fp, S_fp, S_fp, S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *);



    /* Parameter adjustments */
    --wk;
    --zt;
    --z__;
    --r__;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    pstopg_(ncall, (S_fp)suba, (S_fp)subql, (S_fp)subqr, (S_fp)nullpl_, (S_fp)
	    nullpr_, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &
	    ubar[1], &rhs[1], &r__[1], &z__[1], &zt[1], &wk[1], nw, ier);
    return 0;
} /* pstop_ */

/* Subroutine */ int pstopg_(integer *ncall, S_fp suba, S_fp subql, S_fp
	subqr, S_fp precl, S_fp precr, doublereal *coef, integer *jcoef,
	doublereal *wfac, integer *jwfac, integer *n, doublereal *u,
	doublereal *ubar, doublereal *rhs, doublereal *r__, doublereal *z__,
	doublereal *zt, doublereal *wk, integer *nw, integer *ier)
{
    /* Initialized data */

    static integer idlarr[10] = { 1,3,3,3,1,0,1,2,2,2 };
    static integer idrarr[10] = { 3,3,3,3,1,0,2,2,2,2 };
    static integer needbn[10] = { 1,0,1,1,1,0,1,0,1,1 };

    /* Format strings */
    static char fmt_105[] = "";
    static char fmt_110[] = "";
    static char fmt_115[] = "";
    static char fmt_125[] = "";
    static char fmt_126[] = "";
    static char fmt_135[] = "";
    static char fmt_136[] = "";
    static char fmt_151[] = "";
    static char fmt_1350[] = "";
    static char fmt_1360[] = "";
    static char fmt_1370[] = "";
    static char fmt_1380[] = "";
    static char fmt_1390[] = "";
    static char fmt_1400[] = "";
    static char fmt_1410[] = "";

    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1, d__2;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, ir, iz, iv1, iv2, idl, idp, idr;
    static logical ipl, ipr;
    static doublereal top;
    static integer izt, idle, idre, idlp, idrp, idot;
    static logical rhav;
    static integer locr;
    static logical init, zhav, udhv, rdhv, zdhv;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static integer locz;
    static doublereal uold, tiny;
    static logical risz, rzhv;
    static integer lbldc;
    static logical rcalc, rdcal, udcal;
    static integer lbldn;
    static logical zcalc, zdcal, rzcal;
    static integer lblvn;
    static doublereal uedot;
    static integer loczt;
    static logical zthav, ztdhv;
    static integer nwusd;
    static logical riszt, rzthv, ziszt, zzthv, nufact, ztcalc, ztdcal;
    static integer iwfree;
    extern /* Subroutine */ int ckconv_(integer *);
    extern doublereal seldot_(integer *, integer *, doublereal *, doublereal *
	    , doublereal *, doublereal *, integer *, doublereal *, doublereal
	    *, doublereal *, doublereal *);
    static logical rztcal;
    static doublereal bottom;
    static logical zztcal;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen), vexopy_(
	    integer *, doublereal *, doublereal *, doublereal *, integer *);

    /* Assigned format variables */
    static char *lbldn_fmt, *lbldc_fmt, *lblvn_fmt;


/* ... pstop computes one of stopping tests to determine if the */
/*     iterative method has converged to a solution within the */
/*     error tolerance, zeta.  the stopping tests are -- */

/*    (1)  (emax/emin) * sqrt ( (r ,zt)/(rhs,inv(q)*rhs) ) */
/*    (2)  ( 1.0/emin) * sqrt ( (zt,zt)/(u,u) ) */
/*    (3)  (emax/emin) * sqrt ( (zt,zt)/(inv(q)*rhs,inv(q)*rhs) ) */
/*    (4)                sqrt ( (zt,zt)/(inv(q)*rhs,inv(q)*rhs) ) */
/*    (5)                sqrt ( (r ,r )/(rhs,rhs) ) */
/*    (6)                sqrt ( (u-ubar,u-ubar)/(ubar,ubar) ) */
/*    (7)  (emax/emin) * sqrt ( (r,z)/(rhs,inv(ql)*rhs) ) */
/*    (8)  ( 1.0/emin) * sqrt ( (z,z)/(u,u) ) */
/*    (9)  (emax/emin) * sqrt ( (z,z)/(inv(ql)*rhs,inv(ql)*rhs) ) */
/*   (10)                sqrt ( (z,z)/(inv(ql)*rhs,inv(ql)*rhs) ) */

/* ... here, emax and emin are estimates of the 2-norm of the iteration */
/*     matrix and its inverse. */

/* key parameters -- */

/* ncall: = 0 for first call to pstop by accelerator */
/*        < 0 for recalc of bnorms, in the case that a new prec has */
/*            been calc'ed */
/*        > 0 for a routine call to check the stopping test */

/* iplr : = 0 the left and right preconditioning matrices are the */
/*            identity */
/*        = 1 the right prec is the identity */
/*        = 2 the left prec is the identity */
/*        = 3 neither the left nor the right prec matrix is the */
/*            identity */

/* r: the residual of the original system, if rhave = .true. */
/* z :  ql**(-1) r, if zhave = .true. */
/* zt : qr**(-1) z, if zthave = .true. */


/* this routine is admittedly quite overdesigned.  the idea was to have */
/* a general routine which would calculate the needed inner products */
/* with the absolute least amount of work, by determining which inner */
/* products already exist. */


/* *** begin -- package common */


/* *** end   -- package common */


    /* Parameter adjustments */
    --wk;
    --zt;
    --z__;
    --r__;
    --rhs;
    --ubar;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */


    nwusd = 0;
    itcom2_1.halt = FALSE_;
    tiny = itcom4_1.srelpr * 500.;

/* get flags to tell us if there is any prec on the left or right ... */
    ipl = itcom1_1.iplr == 1 || itcom1_1.iplr == 3;
    ipr = itcom1_1.iplr == 2 || itcom1_1.iplr == 3;
/* find equivalences between r, z, zt ... */
    risz = ! ipl;
    ziszt = ! ipr;
    riszt = risz && ziszt;
/* decode ntest ... */
    idl = idlarr[itcom1_1.ntest - 1];
    idr = idrarr[itcom1_1.ntest - 1];
    idot = idl + (idr - 1) * 3;

    init = *ncall == 0;
    nufact = *ncall < 0;
    if (! (init || nufact)) {
	goto L900;
    }

/* ====================================================================== */
/* ========================== initialization section ==================== */
    iv1 = 1;
    iv2 = iv1 + *n;

/* ... compute bnorms, as necessary. */

    if (needbn[itcom1_1.ntest - 1] == 0) {
	goto L750;
    }
    idle = idl;
    if (idle == 3 && ziszt) {
	idle = 2;
    }
    if (idle == 2 && risz) {
	idle = 1;
    }
    idre = idr;
    if (idre == 3 && ziszt) {
	idre = 2;
    }
    if (idre == 2 && risz) {
	idre = 1;
    }
    idp = 0;
    idlp = 0;
    idrp = 0;
    nwusd = 0;
    if (nwusd > *nw) {
	goto L999;
    }
/* calc ql(inv)*rhs, if necess ... */
    if (max(idle,idre) > 1 && ipl) {
	nwusd += *n;
	if (nwusd > *nw) {
	    goto L999;
	}
	++idp;
	(*precl)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, (S_fp)subql, (
		S_fp)suba, (S_fp)subqr, &rhs[1], &wk[*n * (idp - 1) + 1]);
	if (idle > 1) {
	    ++idlp;
	}
	if (idre > 1) {
	    ++idrp;
	}
    }
/* calc qr(inv)*ql(inv)*rhs, if necess ... */
    if (max(idle,idre) > 2) {
	nwusd += *n;
	if (nwusd > *nw) {
	    goto L999;
	}
	++idp;
	if (idp == 1) {
	    (*precr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, (S_fp)subql,
		     (S_fp)suba, (S_fp)subqr, &rhs[1], &wk[*n * (idp - 1) + 1]
		    );
	}
	if (idp == 2) {
	    (*precr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, (S_fp)subql,
		     (S_fp)suba, (S_fp)subqr, &wk[*n * (idp - 2) + 1], &wk[*n
		    * (idp - 1) + 1]);
	}
	if (idle > 2) {
	    ++idlp;
	}
	if (idre > 2) {
	    ++idrp;
	}
    }
/* get needed dot ... */
    if (init || (idlp != 0 || idrp != 0)) {
	i__1 = idlp + 1;
	i__2 = idrp + 1;
	itcom3_1.bnorm1 = seldot_(n, &i__1, &rhs[1], &wk[1], &wk[*n + 1], &wk[
		(*n << 1) + 1], &i__2, &rhs[1], &wk[1], &wk[*n + 1], &wk[(*n
		<< 1) + 1]);
	if (itcom3_1.bnorm1 < 0.) {
	    goto L998;
	}
/* Computing MAX */
	d__1 = itcom4_1.srelpr, d__2 = sqrt(itcom3_1.bnorm1);
	itcom3_1.bnorm1 = max(d__1,d__2);
    }
    if (idlp == 0 || idrp == 0) {
	itcom3_1.bnorm = itcom3_1.bnorm1;
    }

/* ... get ubar norm, as necessary ... */

L750:
    if (nufact) {
	goto L900;
    }
    itcom3_1.ubarnm = itcom4_1.srelpr;
    if (itcom1_1.ntest == 6) {
	itcom3_1.ubarnm = sqrt(vdot_(n, &ubar[1], &ubar[1]));
    }

/* ... end of initialization phase ... */
/* =============================================================================== */
/* =============================================================================== */

/* ... now begin the actual stopping test section ... */

/* notes on the strategy of this routine: */
/*     basically, what we're after in order to perform the stopping */
/* tests is certain dot products.  the needed dot products may already */
/* be available from the accelerator (in variables rrot, etc., as */
/* indicated in flags rdhav, etc.) otherwise, it will be necessary to */
/* compute these from the appropriate vectors.  these vectors in turn */
/* may already exist (in variables r, z, zt, as indicated b */
/* rhave, zhave, zthave), or it may be necessary to compute them. */
/* if they are computed by pstop, then the workspace is used to store */
/* them. furthermore, there are dependencies between the vectors: zt */
/* requires z, z requires r.  add to this the further complication that */
/* it may be possible to c optimize: if there is no left preconditioner, */
/* then r equals z, and so forth. */
/*     this routine attempts to get the necessary data to do the */
/* stopping test in the most optimal way. */
/*     a few notes on the semantics of variables.  the flag rhave tells */
/* whether the variable named r actually contains the residual; the flag */
/* rhav tells whether the residual exists somewhere - whether in r, z, */
/* zt or workspace.  if c nonzero, the variable ir tells where in the */
/* workspace the residual is (if it is in the workspace).  now, the */
/* variable rdhav tells whether rdot actually contains the dot product */
/* of r with itself.  unlike r and rhave, rdot and rdhav will actually */
/* be updated by pstop if they are calculated herein, or if rdot can be */
/* found from some other dot. */
/*     the variable rcalp indicates whether r was somewhere in workspace */
/* after pstop did its work.  the accelerator would like to know this, */
/* since it may want to circumvent letting pstop do a vector calculation */
/* if it can do it more efficiently. */
/*     for the initialization call (ncall=0), there is a dry run of */
/* the stopping test.  that is, the flags rhave, rcalp, rrhave, etc. */
/* are set to what they would be set in an actual call, but no actual */
/* vector calculations are done.  this is necessary so that the */
/* accelerator can plan ahead and take action to circumvent pstop doing */
/* lengthly calculations - e.g., calculating the residual using an a */
/* mult when the accelerator could do it simply by doing a saxpy. */


L900:

/* make temporaries for dot haves (modify the actual dot haves only */
/* if ncall>0) */
    udhv = itcom9_1.udhav;
    rdhv = itcom9_1.rdhav;
    rzhv = itcom9_1.rzhav;
    rzthv = itcom9_1.rzthav;
    zdhv = itcom9_1.zdhav;
    zzthv = itcom9_1.zzthav;
    ztdhv = itcom9_1.ztdhav;

/* evaluate vector haves ... */
    rhav = itcom9_1.rhave || itcom9_1.zhave && risz || itcom9_1.zthave &&
	    riszt;
    zhav = itcom9_1.zhave || itcom9_1.rhave && risz || itcom9_1.zthave &&
	    ziszt;
    zthav = itcom9_1.zthave || itcom9_1.rhave && riszt || itcom9_1.zhave &&
	    ziszt;

/* take note that there are no vectors in the workspace ... */
    ir = 0;
    iz = 0;
    izt = 0;

    iwfree = 1;

/* ********** calculate r ********** */

/* find dot needs ... */
/* L102: */
    lbldn = 0;
    lbldn_fmt = fmt_105;
    goto L1100;
/* calculate whatever dots we can ... */
L105:
    lbldc = 0;
    lbldc_fmt = fmt_110;
    goto L1300;
/* find vector needs ... */
L110:
    lblvn = 0;
    lblvn_fmt = fmt_115;
    goto L1200;
/* get r ... */
L115:
    if (! rcalc) {
	goto L120;
    }
    ir = iwfree;
    iwfree += *n;
    nwusd = iwfree - 1;
    if (init || nufact) {
	goto L116;
    }
    if (nwusd > *nw) {
	goto L999;
    }
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &u[1], &wk[ir]);
    vexopy_(n, &wk[ir], &rhs[1], &wk[ir], &c__2);
L116:
    rhav = TRUE_;
/* revise vector haves ... */
    if (! risz) {
	goto L111;
    }
    iz = ir;
    zhav = TRUE_;
L111:
    if (! riszt) {
	goto L120;
    }
    izt = ir;
    zthav = TRUE_;

/* ********** calculate z ********** */

/* calculate dots ... */
L120:
    lbldc = 1;
    lbldc_fmt = fmt_125;
    goto L1300;
/* revise vector needs ... */
L125:
    lblvn = 1;
    lblvn_fmt = fmt_126;
    goto L1200;
/* get z ... */
L126:
    if (! zcalc) {
	goto L130;
    }
    iz = iwfree;
    iwfree += *n;
    nwusd = iwfree - 1;
    if (init || nufact) {
	goto L127;
    }
    if (nwusd > *nw) {
	goto L999;
    }
    if (itcom9_1.rhave) {
	(*precl)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, (S_fp)subql, (
		S_fp)suba, (S_fp)subqr, &r__[1], &wk[iz]);
    }
    if (ir != 0) {
	(*precl)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, (S_fp)subql, (
		S_fp)suba, (S_fp)subqr, &wk[ir], &wk[iz]);
    }
L127:
    zhav = TRUE_;
/* revise vector haves ... */
    if (! risz) {
	goto L121;
    }
    ir = iz;
    rhav = TRUE_;
L121:
    if (! ziszt) {
	goto L130;
    }
    izt = iz;
    zthav = TRUE_;

/* ********** calculate zt ********** */

/* calculate dots ... */
L130:
    lbldc = 2;
    lbldc_fmt = fmt_135;
    goto L1300;
/*  revise vector needs .. */
L135:
    lblvn = 2;
    lblvn_fmt = fmt_136;
    goto L1200;
/* get zt ... */
L136:
    if (! ztcalc) {
	goto L150;
    }
    izt = iwfree;
    iwfree += *n;
    nwusd = iwfree - 1;
    if (init || nufact) {
	goto L137;
    }
    if (nwusd > *nw) {
	goto L999;
    }
    if (itcom9_1.zhave) {
	(*precr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, (S_fp)subql, (
		S_fp)suba, (S_fp)subqr, &z__[1], &wk[izt]);
    }
    if (! itcom9_1.zhave && (itcom9_1.rhave && risz)) {
	(*precr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, (S_fp)subql, (
		S_fp)suba, (S_fp)subqr, &r__[1], &wk[izt]);
    }
    if (iz != 0) {
	(*precr)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, (S_fp)subql, (
		S_fp)suba, (S_fp)subqr, &wk[iz], &wk[izt]);
    }
L137:
    zthav = TRUE_;
/* revise vector haves ... */
    if (! riszt) {
	goto L131;
    }
    ir = izt;
    rhav = TRUE_;
L131:
    if (! ziszt) {
	goto L150;
    }
    iz = izt;
    zhav = TRUE_;

/* ***** take care of details before going on to perform the stopping */
/*      test */

/* calculate whatever dots we can ... */
L150:
    lbldc = 3;
    lbldc_fmt = fmt_151;
    goto L1300;
/* save vector calculation needs ... */
L151:
    itcom9_1.rcalp = ir != 0;
    itcom9_1.zcalp = iz != 0;
    itcom9_1.ztcalp = izt != 0;
/* head home, if ncall .le. 0 ... */
    if (init || nufact) {
	goto L950;
    }

/* save dot have temporaries, if ncall>0 ... */
    itcom9_1.udhav = udhv;
    itcom9_1.rdhav = rdhv;
    itcom9_1.rzhav = rzhv;
    itcom9_1.rzthav = rzthv;
    itcom9_1.zdhav = zdhv;
    itcom9_1.zzthav = zzthv;
    itcom9_1.ztdhav = ztdhv;

/* get (u-ubar,u-ubar) */
    if (itcom1_1.ntest != 6) {
	goto L45;
    }
    uedot = 0.;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L40: */
/* Computing 2nd power */
	d__1 = u[i__] - ubar[i__];
	uedot += d__1 * d__1;
    }

/* =============================================================================== */
/* ====================== stopping test computation section ====================== */

/* at this point, all the needed dot products have been computed, and */
/* we are to actually perform the stopping test. */

L45:
    switch (itcom1_1.ntest) {
	case 1:  goto L51;
	case 2:  goto L52;
	case 3:  goto L53;
	case 4:  goto L54;
	case 5:  goto L55;
	case 6:  goto L56;
	case 7:  goto L57;
	case 8:  goto L58;
	case 9:  goto L59;
	case 10:  goto L60;
    }

/* ... test 1 */

L51:
    if (itcom9_1.rztdot < -itcom4_1.srelpr) {
	goto L998;
    }
    top = itcom3_1.emax * sqrt((abs(itcom9_1.rztdot)));
    bottom = itcom3_1.emin * itcom3_1.bnorm1;
    goto L80;

/* ... test 2 */

L52:
    top = sqrt((abs(itcom9_1.ztdot)));
    bottom = itcom3_1.emin * itcom3_1.udnm;
    goto L80;

/* ... test 3 */

L53:
    top = itcom3_1.emax * sqrt((abs(itcom9_1.ztdot)));
    bottom = itcom3_1.emin * itcom3_1.bnorm1;
    goto L80;

/* ... test 4 */

L54:
    top = sqrt((abs(itcom9_1.ztdot)));
    bottom = itcom3_1.bnorm1;
    goto L80;

/* ... test 5 */

L55:
    top = sqrt((abs(itcom9_1.rdot)));
    bottom = itcom3_1.bnorm1;
    goto L80;

/* ... test 6 */

L56:
    top = sqrt((abs(uedot)));
    bottom = itcom3_1.ubarnm;
    goto L80;

/* ... test 7 */

L57:
    if (itcom9_1.rzdot < -itcom4_1.srelpr) {
	goto L998;
    }
    top = itcom3_1.emax * sqrt((abs(itcom9_1.rzdot)));
    bottom = itcom3_1.emin * itcom3_1.bnorm1;
    goto L80;

/* ... test 8 */

L58:
    top = sqrt((abs(itcom9_1.zdot)));
    bottom = itcom3_1.emin * itcom3_1.udnm;
    goto L80;

/* ... test 9 */

L59:
    top = itcom3_1.emax * sqrt((abs(itcom9_1.zdot)));
    bottom = itcom3_1.emin * itcom3_1.bnorm1;
    goto L80;

/* ... test 10 */

L60:
    top = sqrt((abs(itcom9_1.zdot)));
    bottom = itcom3_1.bnorm1;
    goto L80;

L80:
    if (bottom < tiny) {
	bottom = tiny;
    }
    itcom3_1.stptst = top / bottom;
    ckconv_(ier);
    if (*ier < 0) {
	goto L950;
    }
    itcom2_1.halt = FALSE_;
    if (top < bottom * itcom3_1.zeta) {
	itcom2_1.halt = TRUE_;
    }

/* done with the stopping test, head home. */
    goto L950;

/* =============================================================================== */
/* *********************** section to calculate dot-needs ************************ */

/* here, we consider which dot products the stopping test needs, and */
/* see whether the needed dot products are currently nonexistent and */
/* thus must be calculated. */

L1100:

/* spread any dot information to other dots, as possible ... */
    if (risz) {
	if (rdhv) {
	    itcom9_1.rzdot = itcom9_1.rdot;
	    rzhv = TRUE_;
	    itcom9_1.zdot = itcom9_1.rdot;
	    zdhv = TRUE_;
	}
	if (rzhv) {
	    itcom9_1.rdot = itcom9_1.rzdot;
	    rdhv = TRUE_;
	    itcom9_1.zdot = itcom9_1.rzdot;
	    zdhv = TRUE_;
	}
	if (zdhv) {
	    itcom9_1.rzdot = itcom9_1.zdot;
	    rzhv = TRUE_;
	    itcom9_1.rdot = itcom9_1.zdot;
	    rdhv = TRUE_;
	}
    }

    if (ziszt) {
	if (zdhv) {
	    itcom9_1.zztdot = itcom9_1.zdot;
	    zzthv = TRUE_;
	    itcom9_1.ztdot = itcom9_1.zdot;
	    ztdhv = TRUE_;
	}
	if (zzthv) {
	    itcom9_1.zdot = itcom9_1.zztdot;
	    zdhv = TRUE_;
	    itcom9_1.ztdot = itcom9_1.zztdot;
	    ztdhv = TRUE_;
	}
	if (ztdhv) {
	    itcom9_1.zdot = itcom9_1.ztdot;
	    zdhv = TRUE_;
	    itcom9_1.zztdot = itcom9_1.ztdot;
	    zzthv = TRUE_;
	}
    }

    if (riszt) {
	if (rdhv) {
	    itcom9_1.rztdot = itcom9_1.rdot;
	    rzthv = TRUE_;
	    itcom9_1.ztdot = itcom9_1.rdot;
	    ztdhv = TRUE_;
	}
	if (rzthv) {
	    itcom9_1.rdot = itcom9_1.rztdot;
	    rdhv = TRUE_;
	    itcom9_1.ztdot = itcom9_1.rztdot;
	    ztdhv = TRUE_;
	}
	if (ztdhv) {
	    itcom9_1.rztdot = itcom9_1.ztdot;
	    rzthv = TRUE_;
	    itcom9_1.rdot = itcom9_1.ztdot;
	    rdhv = TRUE_;
	}
    }

/* figure out which dots actually need to be calculated ... */
/* L1103: */
    udcal = needbn[itcom1_1.ntest - 1] == 0 && itcom1_1.ntest != 6 && ! udhv;
    rdcal = idot == 1 && ! rdhv;
    rzcal = (idot == 2 || idot == 4) && ! rzhv;
    rztcal = (idot == 3 || idot == 7) && ! rzthv;
    zdcal = idot == 5 && ! zdhv;
    zztcal = (idot == 6 || idot == 8) && ! zzthv;
    ztdcal = idot == 9 && ! ztdhv;
    switch (lbldn) {
	case 0: goto L105;
	case 1: goto L1350;
	case 2: goto L1360;
	case 3: goto L1370;
	case 4: goto L1380;
	case 5: goto L1390;
	case 6: goto L1400;
	case 7: goto L1410;
    }

/* =============================================================================== */
/* ********************* section to calculate vector-needs *********************** */

/* here, we see which vectors have to be calculated in order to */
/* satisfy the dot calculation needs. */

L1200:
    ztcalc = (rztcal || zztcal || ztdcal) && ! zthav;
    zcalc = (rzcal || zdcal || zztcal || ztcalc) && ! zhav;
    rcalc = (rdcal || rzcal || rztcal || zcalc) && ! rhav;
    switch (lblvn) {
	case 0: goto L115;
	case 1: goto L126;
	case 2: goto L136;
    }

/* =============================================================================== */
/* ********************* dot product calculation section ************************* */

/* here, we calculate whatever dot products can be calculated from the */
/* currently existing vectors. */

/* first locate where the needed vectors are ... */
L1300:
    if (itcom9_1.rhave) {
	locr = 1;
    }
    if (itcom9_1.zhave && risz) {
	locr = 2;
    }
    if (itcom9_1.zthave && riszt) {
	locr = 3;
    }
    if (ir != 0) {
	locr = 4;
    }

    if (itcom9_1.rhave && risz) {
	locz = 1;
    }
    if (itcom9_1.zhave) {
	locz = 2;
    }
    if (itcom9_1.zthave && ziszt) {
	locz = 3;
    }
    if (iz != 0) {
	locz = 4;
    }

    if (itcom9_1.rhave && riszt) {
	loczt = 1;
    }
    if (itcom9_1.zhave && ziszt) {
	loczt = 2;
    }
    if (itcom9_1.zthave) {
	loczt = 3;
    }
    if (izt != 0) {
	loczt = 4;
    }

/* now calculate whatever dot products we can ... */

/* ** get udnm ... */
    if (! udcal) {
	goto L1350;
    }
    if (itcom1_1.in > 5 && itcom1_1.in % 5 != 0) {
	goto L1350;
    }
    uold = itcom3_1.udnm;
    if (init || nufact) {
	goto L1349;
    }
    itcom3_1.udnm = sqrt((d__1 = vdot_(n, &u[1], &u[1]), abs(d__1)));
/*     if ((in .gt. 5) .and. (abs (udnm-uold) .lt. udnm*zeta)) */
/*    a           is3 = 1 */
    if (itcom3_1.udnm < itcom4_1.srelpr) {
	itcom3_1.udnm = 1.;
    }
L1349:
    udhv = TRUE_;
    lbldn = 1;
    lbldn_fmt = fmt_1350;
    goto L1100;

/* ** get rdot ... */
L1350:
    if (! (rdcal && rhav)) {
	goto L1360;
    }
    if (init || nufact) {
	goto L1359;
    }
    itcom9_1.rdot = seldot_(n, &locr, &r__[1], &z__[1], &zt[1], &wk[ir], &
	    locr, &r__[1], &z__[1], &zt[1], &wk[ir]);
L1359:
    rdhv = TRUE_;
    lbldn = 2;
    lbldn_fmt = fmt_1360;
    goto L1100;

/* ** get rzdot ... */
L1360:
    if (! (rzcal && rhav && zhav)) {
	goto L1370;
    }
    if (init || nufact) {
	goto L1369;
    }
    itcom9_1.rzdot = seldot_(n, &locr, &r__[1], &z__[1], &zt[1], &wk[ir], &
	    locz, &r__[1], &z__[1], &zt[1], &wk[iz]);
L1369:
    rzhv = TRUE_;
    lbldn = 3;
    lbldn_fmt = fmt_1370;
    goto L1100;

/* ** get rztdot ... */
L1370:
    if (! (rztcal && rhav && zthav)) {
	goto L1380;
    }
    if (init || nufact) {
	goto L1379;
    }
    itcom9_1.rztdot = seldot_(n, &locr, &r__[1], &z__[1], &zt[1], &wk[ir], &
	    loczt, &r__[1], &z__[1], &zt[1], &wk[izt]);
L1379:
    rzthv = TRUE_;
    lbldn = 4;
    lbldn_fmt = fmt_1380;
    goto L1100;

/* ** get zdot ... */
L1380:
    if (! (zdcal && zhav)) {
	goto L1390;
    }
    if (init || nufact) {
	goto L1389;
    }
    itcom9_1.zdot = seldot_(n, &locz, &r__[1], &z__[1], &zt[1], &wk[iz], &
	    locz, &r__[1], &z__[1], &zt[1], &wk[iz]);
L1389:
    zdhv = TRUE_;
    lbldn = 5;
    lbldn_fmt = fmt_1390;
    goto L1100;

/* ** get zztdot ... */
L1390:
    if (! (zztcal && zhav && zthav)) {
	goto L1400;
    }
    if (init || nufact) {
	goto L1399;
    }
    itcom9_1.zztdot = seldot_(n, &locz, &r__[1], &z__[1], &zt[1], &wk[iz], &
	    loczt, &r__[1], &z__[1], &zt[1], &wk[izt]);
L1399:
    zzthv = TRUE_;
    lbldn = 6;
    lbldn_fmt = fmt_1400;
    goto L1100;

/* ** get ztdot ... */
L1400:
    if (! (ztdcal && zthav)) {
	goto L1410;
    }
    if (init || nufact) {
	goto L1409;
    }
    itcom9_1.ztdot = seldot_(n, &loczt, &r__[1], &z__[1], &zt[1], &wk[izt], &
	    loczt, &r__[1], &z__[1], &zt[1], &wk[izt]);
L1409:
    ztdhv = TRUE_;
    lbldn = 7;
    lbldn_fmt = fmt_1410;
    goto L1100;

L1410:
    switch (lbldc) {
	case 0: goto L110;
	case 1: goto L125;
	case 2: goto L135;
	case 3: goto L151;
    }

/* =============================================================================== */
L950:
    *nw = nwusd;
    return 0;
/* ================================= error returns =============================== */

/* splitting matrix is not positive definite */

L998:
    *ier = -7;
    ershow_(ier, "pstop", (ftnlen)5);
    goto L950;

/* insuff. floating point wksp */

L999:
    *ier = -2;
    ershow_(ier, "pstop", (ftnlen)5);
    goto L950;
} /* pstopg_ */

doublereal seldot_(integer *n, integer *iu, doublereal *u1, doublereal *u2,
	doublereal *u3, doublereal *u4, integer *iv, doublereal *v1,
	doublereal *v2, doublereal *v3, doublereal *v4)
{
    /* System generated locals */
    doublereal ret_val;

    /* Local variables */
    static integer ind;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);


/* this routine computes a dot product from a selected pair of vectors */


    /* Parameter adjustments */
    --v4;
    --v3;
    --v2;
    --v1;
    --u4;
    --u3;
    --u2;
    --u1;

    /* Function Body */
    ind = *iv + (*iu - 1 << 2);
    if (ind == 1) {
	ret_val = vdot_(n, &u1[1], &v1[1]);
    }
    if (ind == 2) {
	ret_val = vdot_(n, &u1[1], &v2[1]);
    }
    if (ind == 3) {
	ret_val = vdot_(n, &u1[1], &v3[1]);
    }
    if (ind == 4) {
	ret_val = vdot_(n, &u1[1], &v4[1]);
    }
    if (ind == 5) {
	ret_val = vdot_(n, &u2[1], &v1[1]);
    }
    if (ind == 6) {
	ret_val = vdot_(n, &u2[1], &v2[1]);
    }
    if (ind == 7) {
	ret_val = vdot_(n, &u2[1], &v3[1]);
    }
    if (ind == 8) {
	ret_val = vdot_(n, &u2[1], &v4[1]);
    }
    if (ind == 9) {
	ret_val = vdot_(n, &u3[1], &v1[1]);
    }
    if (ind == 10) {
	ret_val = vdot_(n, &u3[1], &v2[1]);
    }
    if (ind == 11) {
	ret_val = vdot_(n, &u3[1], &v3[1]);
    }
    if (ind == 12) {
	ret_val = vdot_(n, &u3[1], &v4[1]);
    }
    if (ind == 13) {
	ret_val = vdot_(n, &u4[1], &v1[1]);
    }
    if (ind == 14) {
	ret_val = vdot_(n, &u4[1], &v2[1]);
    }
    if (ind == 15) {
	ret_val = vdot_(n, &u4[1], &v3[1]);
    }
    if (ind == 16) {
	ret_val = vdot_(n, &u4[1], &v4[1]);
    }
    return ret_val;
} /* seldot_ */

/* Subroutine */ int ckconv_(integer *ier)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Local variables */
    static integer i__;
    static doublereal val;
    static integer ist;
    static doublereal stold[20];
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen);


/* routine to determine whether iterative method has stagnated, */
/* or other unfortunate situation. */



    if (itcom1_1.in <= 0) {
	ist = 0;
    }

    ++ist;
    stold[1 + ist % 20 - 1] = itcom3_1.stptst;
    if (ist < 20) {
	goto L900;
    }
/*     do 2 i = 1, nst-1 */
    for (i__ = 19; i__ >= 1; --i__) {
/*     val = abs(stold(ind(ist-i))-stptst)/stptst */
	i__1 = ist - i__;
	val = (d__1 = stold[1 + i__1 % 20 - 1] - itcom3_1.stptst, abs(d__1));
	if (val > itcom3_1.stptst * 1e-7) {
	    goto L900;
	}
/* L2: */
    }
    *ier = -19;
    ershow_(ier, "ckconv", (ftnlen)6);
    return 0;

L900:
    return 0;
} /* ckconv_ */

/* Subroutine */ int inithv_(integer *icall)
{

/* routine to initialize dot and vector haves to false. */


    itcom9_1.udhav = FALSE_;
    itcom9_1.rdhav = FALSE_;
    itcom9_1.rzhav = FALSE_;
    itcom9_1.rzthav = FALSE_;
    itcom9_1.zdhav = FALSE_;
    itcom9_1.zzthav = FALSE_;
    itcom9_1.ztdhav = FALSE_;
    if (*icall == 1) {
	return 0;
    }
    itcom9_1.rhave = FALSE_;
    itcom9_1.zhave = FALSE_;
    itcom9_1.zthave = FALSE_;

    return 0;
} /* inithv_ */

/* Subroutine */ int hqr_(integer *nm, integer *n, integer *low, integer *igh,
	 doublereal *h__, doublereal *wr, doublereal *wi, integer *ierr)
{
    /* System generated locals */
    integer h_dim1, h_offset, i__1, i__2, i__3;
    doublereal d__1, d__2;

    /* Builtin functions */
    double sqrt(doublereal), d_sign(doublereal *, doublereal *);

    /* Local variables */
    static integer i__, j, k, l, m;
    static doublereal p, q, r__, s, t, w, x, y;
    static integer na, en, ll, mm;
    static doublereal zz;
    static integer mp2, itn, its, enm2;
    static doublereal tst1, tst2, norm;
    static logical notlas;



/*     this routine is a translation of the algol procedure hqr, */
/*     num. math. 14, 219-231(1970) by martin, peters, and wilkinson. */
/*     handbook for auto. comp., vol.ii-linear algebra, 359-371(1971). */

/*     this routine finds the eigenvalues of a floating point */
/*     upper hessenberg matrix by the qr method. */

/*     on input */

/*        nm must be set to the row dimension of two-dimensional */
/*          array parameters as declared in the calling program */
/*          dimension statement. */

/*        n is the order of the matrix. */

/*        low and igh are integers determined by the balancing */
/*          routine  balanc.  if  balanc  has not been used, */
/*          set low=1, igh=n. */

/*        h contains the upper hessenberg matrix.  information about */
/*          the transformations used in the reduction to hessenberg */
/*          form by  elmhes  or  orthes, if performed, is stored */
/*          in the remaining triangle under the hessenberg matrix. */

/*     on output */

/*        h has been destroyed.  therefore, it must be saved */
/*          before calling  hqr  if subsequent calculation and */
/*          back transformation of eigenvectors is to be performed. */

/*        wr and wi contain the real and imaginary parts, */
/*          respectively, of the eigenvalues.  the eigenvalues */
/*          are unordered except that complex conjugate pairs */
/*          of values appear consecutively with the eigenvalue */
/*          having the positive imaginary part first.  if an */
/*          error exit is made, the eigenvalues should be correct */
/*          for indices ierr+1,...,n. */

/*        ierr is set to */
/*          zero       for normal return, */
/*          j          if the limit of 30*n iterations is exhausted */
/*                     while the j-th eigenvalue is being sought. */

/*     questions and comments should be directed to burton s. garbow, */
/*     mathematics and computer science div, argonne national laboratory */

/*     this version dated august 1983. */

/*     ------------------------------------------------------------------ */

    /* Parameter adjustments */
    --wi;
    --wr;
    h_dim1 = *nm;
    h_offset = 1 + h_dim1;
    h__ -= h_offset;

    /* Function Body */
    *ierr = 0;
    norm = 0.;
    k = 1;
/*     .......... store roots isolated by balanc */
/*                and compute matrix norm .......... */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {

	i__2 = *n;
	for (j = k; j <= i__2; ++j) {
/* L40: */
	    norm += (d__1 = h__[i__ + j * h_dim1], abs(d__1));
	}

	k = i__;
	if (i__ >= *low && i__ <= *igh) {
	    goto L50;
	}
	wr[i__] = h__[i__ + i__ * h_dim1];
	wi[i__] = 0.;
L50:
	;
    }

    en = *igh;
    t = 0.;
    itn = *n * 30;
/*     .......... search for next eigenvalues .......... */
L60:
    if (en < *low) {
	goto L1001;
    }
    its = 0;
    na = en - 1;
    enm2 = na - 1;
/*     .......... look for single small sub-diagonal element */
/*                for l=en step -1 until low do -- .......... */
L70:
    i__1 = en;
    for (ll = *low; ll <= i__1; ++ll) {
	l = en + *low - ll;
	if (l == *low) {
	    goto L100;
	}
	s = (d__1 = h__[l - 1 + (l - 1) * h_dim1], abs(d__1)) + (d__2 = h__[l
		+ l * h_dim1], abs(d__2));
	if (s == 0.) {
	    s = norm;
	}
	tst1 = s;
	tst2 = tst1 + (d__1 = h__[l + (l - 1) * h_dim1], abs(d__1));
	if (tst2 == tst1) {
	    goto L100;
	}
/* L80: */
    }
/*     .......... form shift .......... */
L100:
    x = h__[en + en * h_dim1];
    if (l == en) {
	goto L270;
    }
    y = h__[na + na * h_dim1];
    w = h__[en + na * h_dim1] * h__[na + en * h_dim1];
    if (l == na) {
	goto L280;
    }
    if (itn == 0) {
	goto L1000;
    }
    if (its != 10 && its != 20) {
	goto L130;
    }
/*     .......... form exceptional shift .......... */
    t += x;

    i__1 = en;
    for (i__ = *low; i__ <= i__1; ++i__) {
/* L120: */
	h__[i__ + i__ * h_dim1] -= x;
    }

    s = (d__1 = h__[en + na * h_dim1], abs(d__1)) + (d__2 = h__[na + enm2 *
	    h_dim1], abs(d__2));
    x = s * .75;
    y = x;
    w = s * -.4375 * s;
L130:
    ++its;
    --itn;
/*     .......... look for two consecutive small */
/*                sub-diagonal elements. */
/*                for m=en-2 step -1 until l do -- .......... */
    i__1 = enm2;
    for (mm = l; mm <= i__1; ++mm) {
	m = enm2 + l - mm;
	zz = h__[m + m * h_dim1];
	r__ = x - zz;
	s = y - zz;
	p = (r__ * s - w) / h__[m + 1 + m * h_dim1] + h__[m + (m + 1) *
		h_dim1];
	q = h__[m + 1 + (m + 1) * h_dim1] - zz - r__ - s;
	r__ = h__[m + 2 + (m + 1) * h_dim1];
	s = abs(p) + abs(q) + abs(r__);
	p /= s;
	q /= s;
	r__ /= s;
	if (m == l) {
	    goto L150;
	}
	tst1 = abs(p) * ((d__1 = h__[m - 1 + (m - 1) * h_dim1], abs(d__1)) +
		abs(zz) + (d__2 = h__[m + 1 + (m + 1) * h_dim1], abs(d__2)));
	tst2 = tst1 + (d__1 = h__[m + (m - 1) * h_dim1], abs(d__1)) * (abs(q)
		+ abs(r__));
	if (tst2 == tst1) {
	    goto L150;
	}
/* L140: */
    }

L150:
    mp2 = m + 2;

    i__1 = en;
    for (i__ = mp2; i__ <= i__1; ++i__) {
	h__[i__ + (i__ - 2) * h_dim1] = 0.;
	if (i__ == mp2) {
	    goto L160;
	}
	h__[i__ + (i__ - 3) * h_dim1] = 0.;
L160:
	;
    }
/*     .......... double qr step involving rows l to en and */
/*                columns m to en .......... */
    i__1 = na;
    for (k = m; k <= i__1; ++k) {
	notlas = k != na;
	if (k == m) {
	    goto L170;
	}
	p = h__[k + (k - 1) * h_dim1];
	q = h__[k + 1 + (k - 1) * h_dim1];
	r__ = 0.;
	if (notlas) {
	    r__ = h__[k + 2 + (k - 1) * h_dim1];
	}
	x = abs(p) + abs(q) + abs(r__);
	if (x == 0.) {
	    goto L260;
	}
	p /= x;
	q /= x;
	r__ /= x;
L170:
	d__1 = sqrt(p * p + q * q + r__ * r__);
	s = d_sign(&d__1, &p);
	if (k == m) {
	    goto L180;
	}
	h__[k + (k - 1) * h_dim1] = -s * x;
	goto L190;
L180:
	if (l != m) {
	    h__[k + (k - 1) * h_dim1] = -h__[k + (k - 1) * h_dim1];
	}
L190:
	p += s;
	x = p / s;
	y = q / s;
	zz = r__ / s;
	q /= p;
	r__ /= p;
	if (notlas) {
	    goto L225;
	}
/*     .......... row modification .......... */
	i__2 = *n;
	for (j = k; j <= i__2; ++j) {
	    p = h__[k + j * h_dim1] + q * h__[k + 1 + j * h_dim1];
	    h__[k + j * h_dim1] -= p * x;
	    h__[k + 1 + j * h_dim1] -= p * y;
/* L200: */
	}

/* Computing MIN */
	i__2 = en, i__3 = k + 3;
	j = min(i__2,i__3);
/*     .......... column modification .......... */
	i__2 = j;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    p = x * h__[i__ + k * h_dim1] + y * h__[i__ + (k + 1) * h_dim1];
	    h__[i__ + k * h_dim1] -= p;
	    h__[i__ + (k + 1) * h_dim1] -= p * q;
/* L210: */
	}
	goto L255;
L225:
/*     .......... row modification .......... */
	i__2 = *n;
	for (j = k; j <= i__2; ++j) {
	    p = h__[k + j * h_dim1] + q * h__[k + 1 + j * h_dim1] + r__ * h__[
		    k + 2 + j * h_dim1];
	    h__[k + j * h_dim1] -= p * x;
	    h__[k + 1 + j * h_dim1] -= p * y;
	    h__[k + 2 + j * h_dim1] -= p * zz;
/* L230: */
	}

/* Computing MIN */
	i__2 = en, i__3 = k + 3;
	j = min(i__2,i__3);
/*     .......... column modification .......... */
	i__2 = j;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    p = x * h__[i__ + k * h_dim1] + y * h__[i__ + (k + 1) * h_dim1] +
		    zz * h__[i__ + (k + 2) * h_dim1];
	    h__[i__ + k * h_dim1] -= p;
	    h__[i__ + (k + 1) * h_dim1] -= p * q;
	    h__[i__ + (k + 2) * h_dim1] -= p * r__;
/* L240: */
	}
L255:

L260:
	;
    }

    goto L70;
/*     .......... one root found .......... */
L270:
    wr[en] = x + t;
    wi[en] = 0.;
    en = na;
    goto L60;
/*     .......... two roots found .......... */
L280:
    p = (y - x) / 2.;
    q = p * p + w;
    zz = sqrt((abs(q)));
    x += t;
    if (q < 0.) {
	goto L320;
    }
/*     .......... real pair .......... */
    zz = p + d_sign(&zz, &p);
    wr[na] = x + zz;
    wr[en] = wr[na];
    if (zz != 0.) {
	wr[en] = x - w / zz;
    }
    wi[na] = 0.;
    wi[en] = 0.;
    goto L330;
/*     .......... complex pair .......... */
L320:
    wr[na] = x + p;
    wr[en] = x + p;
    wi[na] = zz;
    wi[en] = -zz;
L330:
    en = enm2;
    goto L60;
/*     .......... set error -- all eigenvalues have not */
/*                converged after 30*n iterations .......... */
L1000:
    *ierr = en;
L1001:
    return 0;
} /* hqr_ */

/* Subroutine */ int adjust_(integer *n, integer *ndim, integer *maxnzz,
	integer *jcoef, integer *key)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, maxnz;


/* ... adjust makes adjustments to the jcoef array. */

/* ... parameters -- */

/*          n      dimension of the matrix. */
/*          ndim   row dimension of jcoef array in defining routine */
/*          maxnz  number of columns in jcoef array */
/*          jcoef  integer matrix representation array */
/*          key    indicator flag */
/*                  = 1   remove zeros from jcoef array */
/*                  = 2   restore zeros to jcoef array */

/* ... specifications for parameters */


    /* Parameter adjustments */
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;

    /* Function Body */
    maxnz = *maxnzz;
    if (maxnz < 2) {
	return 0;
    }
    if (*key == 2) {
	goto L20;
    }

/* ... change zero elements of jcoef array. */

    i__1 = maxnz;
    for (j = 2; j <= i__1; ++j) {
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L10: */
	    if (jcoef[i__ + j * jcoef_dim1] <= 0) {
		jcoef[i__ + j * jcoef_dim1] = i__;
	    }
	}
/* L15: */
    }
    return 0;

/* ... put original zeros back in jcoef array. */

L20:
    i__1 = maxnz;
    for (j = 2; j <= i__1; ++j) {
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L25: */
	    if (jcoef[i__ + j * jcoef_dim1] == i__) {
		jcoef[i__ + j * jcoef_dim1] = 0;
	    }
	}
/* L30: */
    }
    return 0;
} /* adjust_ */

/* Subroutine */ int adinfn_(integer *nn, integer *ndim, integer *maxnzz,
	integer *jcoef, doublereal *coef, integer *nstore, doublereal *ainf,
	doublereal *wksp)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1, i__2, i__3;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, n;
    static doublereal t1;
    static integer jd, len;
    extern doublereal vmin_(integer *, doublereal *);
    extern /* Subroutine */ int ainfn_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *);
    static integer maxnz;


/* ... adinfn computes an upper bound on the spectral radius of */
/*     inv(d)*a. */

/* ... parameters -- */

/*         n       order of system (= nn) */
/*         ndim    row dimension of coef array in defining routine */
/*         maxnz   number of columns in coef array (= maxnzz) */
/*         jcoef   integer matrix representation array */
/*         coef    matrix representation array */
/*         nstore  matrix storage mode */
/*                  = 2   symmetric diagonal format */
/*                  = 3   nonsymmetric diagonal format */
/*         ainf    upper bound estimate upon output */
/*         wksp    workspace vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;
    --wksp;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;
    if (*ainf > 0.) {
	return 0;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	wksp[i__] = coef[i__ + coef_dim1];
    }
    i__1 = maxnz;
    for (jd = 1; jd <= i__1; ++jd) {
	i__2 = maxnz;
	for (j = 1; j <= i__2; ++j) {
	    if (jcoef[j] != jd) {
		goto L20;
	    }
	    i__3 = n;
	    for (i__ = 1; i__ <= i__3; ++i__) {
/* L15: */
		wksp[i__] -= (d__1 = coef[i__ + j * coef_dim1], abs(d__1));
	    }
	    if (*nstore == 3) {
		goto L25;
	    }
	    len = n - jd;
	    i__3 = len;
	    for (i__ = 1; i__ <= i__3; ++i__) {
/* L18: */
		wksp[i__ + jd] -= (d__1 = coef[i__ + j * coef_dim1], abs(d__1)
			);
	    }
	    goto L25;
L20:
	    ;
	}
	goto L30;
L25:
	;
    }
L30:
    if (*nstore == 2) {
	goto L50;
    }
    i__1 = maxnz;
    for (jd = 1; jd <= i__1; ++jd) {
	i__2 = maxnz;
	for (j = 1; j <= i__2; ++j) {
	    if (jcoef[j] != -jd) {
		goto L40;
	    }
	    i__3 = n;
	    for (i__ = 1; i__ <= i__3; ++i__) {
/* L35: */
		wksp[i__] -= (d__1 = coef[i__ + j * coef_dim1], abs(d__1));
	    }
	    goto L45;
L40:
	    ;
	}
	goto L50;
L45:
	;
    }

/* ... factor. */

L50:
    t1 = vmin_(&n, &wksp[1]);
    if (t1 <= 0.) {
	t1 = 1.;
    }
    ainfn_(&n, ndim, &maxnz, &jcoef[1], &coef[coef_offset], nstore, ainf, &
	    wksp[1]);
    *ainf /= t1;
    return 0;
} /* adinfn_ */

/* Subroutine */ int ainfn_(integer *nn, integer *ndim, integer *maxnzz,
	integer *jcoef, doublereal *coef, integer *nstore, doublereal *ainf,
	doublereal *wksp)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, coef_dim1, coef_offset, i__1, i__2,
	    i__3;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, k, n, np1, ind, len, ist1, ist2;
    extern doublereal vmax_(integer *, doublereal *);
    static integer maxnz;


/* ... ainfn calculates the infinity norm of the matrix a. */

/* ... parameters -- */

/*         n       order of system (= nn) */
/*         ndim    row dimension of coef array in defining routine */
/*         maxnz   number of columns in coef array (= maxnzz) */
/*         jcoef   integer matrix representation array */
/*         coef    matrix representation array */
/*         nstore  matrix storage mode */
/*                  = 1   purdue format */
/*                  = 2   symmetric diagonal format */
/*                  = 3   nonsymmetric diagonal format */
/*                  = 4   symmetric sparse format */
/*                  = 5   nonsymmetric sparse format */
/*         ainf    the infinity norm of the matrix, //a//, upon */
/*                  output */
/*         wksp    workspace vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    --wksp;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;
    if (*ainf > 0.) {
	return 0;
    }
    switch (*nstore) {
	case 1:  goto L10;
	case 2:  goto L30;
	case 3:  goto L55;
	case 4:  goto L75;
	case 5:  goto L75;
    }

/* ... ellpack data structure. */

L10:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	wksp[i__] = (d__1 = coef[i__ + coef_dim1], abs(d__1));
    }
    if (maxnz <= 1) {
	goto L995;
    }
    i__1 = maxnz;
    for (j = 2; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L20: */
	    wksp[i__] += (d__1 = coef[i__ + j * coef_dim1], abs(d__1));
	}
/* L25: */
    }
    goto L995;

/* ... symmetric diagonal data structure. */

L30:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L35: */
	wksp[i__] = (d__1 = coef[i__ + coef_dim1], abs(d__1));
    }
    if (maxnz <= 1) {
	goto L995;
    }
    i__1 = maxnz;
    for (j = 2; j <= i__1; ++j) {
	ind = jcoef[j + jcoef_dim1];
	len = n - ind;
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L40: */
	    wksp[i__] += (d__1 = coef[i__ + j * coef_dim1], abs(d__1));
	}
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L45: */
	    wksp[i__ + ind] += (d__1 = coef[i__ + j * coef_dim1], abs(d__1));
	}
/* L50: */
    }
    goto L995;

/* ... nonsymmetric diagonal data structure. */

L55:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L60: */
	wksp[i__] = (d__1 = coef[i__ + coef_dim1], abs(d__1));
    }
    if (maxnz <= 1) {
	goto L995;
    }
    i__1 = maxnz;
    for (j = 2; j <= i__1; ++j) {
	ind = jcoef[j + jcoef_dim1];
	len = n - abs(ind);
/* Computing MAX */
	i__2 = 1, i__3 = 1 - ind;
	ist1 = max(i__2,i__3);
/* Computing MIN */
	i__2 = n, i__3 = n - ind;
	ist2 = min(i__2,i__3);
	i__2 = ist2;
	for (i__ = ist1; i__ <= i__2; ++i__) {
/* L65: */
	    wksp[i__] += (d__1 = coef[i__ + j * coef_dim1], abs(d__1));
	}
/* L70: */
    }
    goto L995;

/* ... sparse structure. */

L75:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L80: */
	wksp[i__] = (d__1 = coef[i__ + coef_dim1], abs(d__1));
    }
    if (maxnz <= n) {
	goto L995;
    }
    np1 = n + 1;
    i__1 = maxnz;
    for (k = np1; k <= i__1; ++k) {
/* L85: */
	wksp[jcoef[k + jcoef_dim1]] += (d__1 = coef[k + coef_dim1], abs(d__1))
		;
    }
    if (*nstore == 5) {
	goto L995;
    }
    i__1 = maxnz;
    for (k = np1; k <= i__1; ++k) {
/* L90: */
	wksp[jcoef[k + (jcoef_dim1 << 1)]] += (d__1 = coef[k + coef_dim1],
		abs(d__1));
    }

/* ... determine ainf = max (wksp(i)). */

L995:
    *ainf = vmax_(&n, &wksp[1]);
    return 0;
} /* ainfn_ */

/* Subroutine */ int bdfac_(integer *lda, integer *nn, integer *nsizee,
	integer *nt, integer *nb, doublereal *a, integer *isym)
{
    /* Initialized data */

    static integer lenv = 10;

    /* System generated locals */
    integer a_dim1, a_offset, i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int bfac_(integer *, integer *, integer *,
	    doublereal *, doublereal *), pfac_(integer *, doublereal *,
	    doublereal *, doublereal *), tfac_(integer *, doublereal *,
	    doublereal *);
    static integer maxb, maxt, nsys;
    extern /* Subroutine */ int bfacm_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *), bfacn_(integer *, integer
	    *, integer *, integer *, doublereal *, doublereal *, doublereal *)
	    , pfacm_(integer *, integer *, doublereal *, doublereal *,
	    doublereal *), pfacn_(integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *), tfacm_(integer *,
	    integer *, doublereal *, doublereal *), tfacn_(integer *,
	    doublereal *, doublereal *, doublereal *);
    static integer nsize;
    extern /* Subroutine */ int bfacnm_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *),
	    pfacnm_(integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *), tfacnm_(integer *,
	    integer *, doublereal *, doublereal *, doublereal *);


/* ... bdfac computes the factorization of a dense banded matrix. */

/* ... parameters -- */

/*        lda    leading dimension of array a */
/*        n      active size of array a */
/*        nsize  size of an individual subsystem (if multiple systems) */
/*                nsize = n upon input if not a multiple system */
/*        nt     number of diagonals needed to store the super- */
/*                diagonals */
/*        nb     number of diagonals needed to store the sub- */
/*                diagonals */
/*        a      array */
/*        isym   symmetry switch */
/*                = 0   matrix is symmetric */
/*                = 1   matrix is nonsymmetric */

/* ... specifications for parameters */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;

    /* Function Body */

    n = *nn;
    maxt = *nt;
    nsize = *nsizee;
    nsys = n / nsize;

/* ... branch on symmetry. */

    if (*isym == 1) {
	goto L30;
    }

/* ... symmetric case. */

/* ... diagonal case (maxt = 0). */

    if (maxt != 0) {
	goto L15;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	a[i__ + a_dim1] = 1. / a[i__ + a_dim1];
    }
    return 0;

/* ... tridiagonal case (maxt = 1). */

L15:
    if (maxt != 1) {
	goto L20;
    }
    if (nsys <= lenv) {
	tfac_(&n, &a[a_offset], &a[(a_dim1 << 1) + 1]);
    }
    if (nsys > lenv) {
	tfacm_(&n, &nsize, &a[a_offset], &a[(a_dim1 << 1) + 1]);
    }
    return 0;

/* ... pentadiagonal case (maxt = 2). */

L20:
    if (maxt != 2) {
	goto L25;
    }
    if (nsys <= lenv) {
	pfac_(&n, &a[a_offset], &a[(a_dim1 << 1) + 1], &a[a_dim1 * 3 + 1]);
    }
    if (nsys > lenv) {
	pfacm_(&n, &nsize, &a[a_offset], &a[(a_dim1 << 1) + 1], &a[a_dim1 * 3
		+ 1]);
    }
    return 0;

/* ... banded case (maxt .gt. 2). */

L25:
    if (nsys <= lenv) {
	bfac_(lda, &n, &maxt, &a[a_offset], &a[(a_dim1 << 1) + 1]);
    }
    if (nsys > lenv) {
	bfacm_(&n, &nsize, &nsys, &maxt, &a[a_offset], &a[(a_dim1 << 1) + 1]);
    }
    return 0;

/* ... nonsymmetric case. */

L30:
    maxb = *nb;

/* ... diagonal case (maxt = maxb = 0). */

    if (maxt != 0 || maxb != 0) {
	goto L40;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L35: */
	a[i__ + a_dim1] = 1. / a[i__ + a_dim1];
    }
    return 0;

/* ... tridiagonal case (maxt = maxb = 1). */

L40:
    if (maxt != 1 || maxb != 1) {
	goto L45;
    }
    if (nsys <= lenv) {
	tfacn_(&n, &a[a_offset], &a[(a_dim1 << 1) + 1], &a[a_dim1 * 3 + 2]);
    }
    if (nsys > lenv) {
	tfacnm_(&n, &nsize, &a[a_offset], &a[(a_dim1 << 1) + 1], &a[a_dim1 *
		3 + 2]);
    }
    return 0;

/* ... pentadiagonal case (maxt = maxb = 2). */

L45:
    if (maxt != 2 || maxb != 2) {
	goto L50;
    }
    if (nsys <= lenv) {
	pfacn_(&n, &a[a_offset], &a[(a_dim1 << 1) + 1], &a[a_dim1 * 3 + 1], &
		a[(a_dim1 << 2) + 2], &a[a_dim1 * 5 + 3]);
    }
    if (nsys > lenv) {
	pfacnm_(&n, &nsize, &a[a_offset], &a[(a_dim1 << 1) + 1], &a[a_dim1 *
		3 + 1], &a[(a_dim1 << 2) + 2], &a[a_dim1 * 5 + 3]);
    }
    return 0;

/* ... all other cases. */

L50:
    if (nsys <= lenv) {
	bfacn_(lda, &n, &maxt, &maxb, &a[a_offset], &a[(a_dim1 << 1) + 1], &a[
		(maxt + 2) * a_dim1 + 1]);
    }
    if (nsys > lenv) {
	bfacnm_(&n, &nsize, &nsys, &maxt, &maxb, &a[a_offset], &a[(a_dim1 <<
		1) + 1], &a[(maxt + 2) * a_dim1 + 1]);
    }
    return 0;
} /* bdfac_ */

/* Subroutine */ int bdinv_(integer *lda, integer *nn, integer *nsizee,
	integer *nt, integer *nb, doublereal *fac, integer *isym)
{
    /* Initialized data */

    static integer lenv = 10;

    /* System generated locals */
    integer fac_dim1, fac_offset, i__1;

    /* Local variables */
    static integer n, maxb;
    extern /* Subroutine */ int binv_(integer *, integer *, integer *,
	    doublereal *);
    static integer maxt;
    extern /* Subroutine */ int tinv_(integer *, doublereal *, doublereal *);
    static integer nsys;
    extern /* Subroutine */ int binvn_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *);
    static integer nsize;
    extern /* Subroutine */ int tinvm_(integer *, integer *, doublereal *,
	    doublereal *), tinvn_(integer *, doublereal *, doublereal *,
	    doublereal *), tinvnm_(integer *, integer *, doublereal *,
	    doublereal *, doublereal *);


/* ... bdinv computes the inverse of a dense banded matrix. */

/* ... parameters -- */

/*        lda    leading dimension of factorization matrix fac */
/*        n      active size of factorization matrix fac */
/*        nsize  size of an individual subsystem (if multiple systems) */
/*                nsize = n upon input if not a multiple system */
/*        nt     number of diagonals needed to store the super- */
/*                diagonals */
/*        nb     number of diagonals needed to store the sub- */
/*                diagonals */
/*        fac    array containing factorization upon input */
/*        isym   symmetry switch */
/*                = 0   matrix is symmetric */
/*                = 1   matrix is nonsymmetric */

/* ... specifications for parameters */

    /* Parameter adjustments */
    fac_dim1 = *lda;
    fac_offset = 1 + fac_dim1;
    fac -= fac_offset;

    /* Function Body */

    n = *nn;
    maxt = *nt;
    nsize = *nsizee;
    nsys = n / nsize;

/* ... branch on symmetry. */

    if (*isym == 1) {
	goto L30;
    }

/* ... symmetric case. */

    if ((i__1 = maxt - 1) < 0) {
	goto L10;
    } else if (i__1 == 0) {
	goto L20;
    } else {
	goto L25;
    }

/* ... diagonal case (maxt = 0). */

L10:
    return 0;

/* ... tridiagonal case (maxt = 1). */

L20:
    if (nsys <= lenv) {
	tinv_(&n, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1]);
    }
    if (nsys > lenv) {
	tinvm_(&n, &nsize, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1]);
    }
    return 0;

/* ... banded case (maxt .ge. 2). */

L25:
    i__1 = maxt + 1;
    binv_(lda, &n, &i__1, &fac[fac_offset]);
    return 0;

/* ... nonsymmetric case. */

L30:
    maxb = *nb;

/* ... diagonal case (maxt = maxb = 0). */

    if (maxt != 0 || maxb != 0) {
	goto L40;
    }
    return 0;

/* ... tridiagonal case (maxt = maxb = 1). */

L40:
    if (maxt != 1 || maxb != 1) {
	goto L45;
    }
    if (nsys <= lenv) {
	tinvn_(&n, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1], &fac[fac_dim1
		* 3 + 2]);
    }
    if (nsys > lenv) {
	tinvnm_(&n, &nsize, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1], &fac[
		fac_dim1 * 3 + 2]);
    }
    return 0;

/* ... all other cases. */

L45:
    binvn_(lda, &n, &maxt, &maxb, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1],
	     &fac[(maxt + 2) * fac_dim1 + 1]);
    return 0;
} /* bdinv_ */

/* Subroutine */ int bdsol_(integer *lda, integer *nn, integer *nsizee,
	integer *nt, integer *nb, doublereal *fac, doublereal *y, doublereal *
	x, integer *isym)
{
    /* Initialized data */

    static integer lenv = 10;

    /* System generated locals */
    integer fac_dim1, fac_offset, i__1;

    /* Local variables */
    static integer i__, n, maxb;
    extern /* Subroutine */ int bsol_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *);
    static integer maxt, nsys;
    extern /* Subroutine */ int bsolm_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *), bsoln_(
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *);
    static integer nsize;
    extern /* Subroutine */ int psoln_(integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *), tsoln_(integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *), bsolnm_(integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *), psolnm_(integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *, doublereal *, doublereal *), tsolnm_(integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *);


/* ... bdsol computes the solution to a dense banded matrix. */
/*     thus, bdsol finds the solution to   a*x = y,  where fac */
/*     contains the factorization of the a matrix. */

/* ... parameters -- */

/*        lda    leading dimension of array fac */
/*        n      active size of array fac */
/*        nsize  size of an individual subsystem (if multiple systems) */
/*                nsize = n upon input if not a multiple system */
/*        nt     number of diagonals needed to store the super- */
/*                diagonals of the factorization */
/*        nb     number of diagonals needed to store the sub- */
/*                diagonals of the factorization */
/*        fac    array containing the factorization of the matrix */
/*        y      upon input, y conains the right hand side */
/*        x      upon output, x contains the solution to  a*x = y */
/*        isym   symmetry switch */
/*                = 0   matrix is symmetric */
/*                = 1   matrix is nonsymmetric */

/* ... specifications for parameters */

    /* Parameter adjustments */
    fac_dim1 = *lda;
    fac_offset = 1 + fac_dim1;
    fac -= fac_offset;
    --y;
    --x;

    /* Function Body */

    n = *nn;
    maxt = *nt;
    nsize = *nsizee;
    nsys = n / nsize;

/* ... branch on symmetry. */

    if (*isym == 1) {
	goto L30;
    }

/* ... symmetric case. */

/* ... diagonal case (maxt = 0). */

    if (maxt != 0) {
	goto L15;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = fac[i__ + fac_dim1] * y[i__];
    }
    return 0;

/* ... tridiagonal case (maxt = 1). */

L15:
    if (maxt != 1) {
	goto L20;
    }
    if (nsys <= lenv) {
	tsoln_(&n, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1], &fac[(
		fac_dim1 << 1) + 1], &y[1], &x[1]);
    }
    if (nsys > lenv) {
	tsolnm_(&n, &nsize, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1], &fac[
		(fac_dim1 << 1) + 1], &y[1], &x[1]);
    }
    return 0;

/* ... pentadiagonal case (maxt = 2). */

L20:
    if (maxt != 2) {
	goto L25;
    }
    if (nsys <= lenv) {
	psoln_(&n, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1], &fac[fac_dim1
		* 3 + 1], &fac[(fac_dim1 << 1) + 1], &fac[fac_dim1 * 3 + 1], &
		y[1], &x[1]);
    }
    if (nsys > lenv) {
	psolnm_(&n, &nsize, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1], &fac[
		fac_dim1 * 3 + 1], &fac[(fac_dim1 << 1) + 1], &fac[fac_dim1 *
		3 + 1], &y[1], &x[1]);
    }
    return 0;

/* ... banded case (maxt .ge. 3). */

L25:
    if (nsys <= lenv) {
	bsol_(lda, &n, &maxt, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1], &y[
		1], &x[1]);
    }
    if (nsys > lenv) {
	bsolm_(&n, &nsize, &maxt, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1],
		 &y[1], &x[1]);
    }
    return 0;

/* ... nonsymmetric case. */

L30:
    maxb = *nb;

/* ... diagonal case (maxt = maxb = 0). */

    if (maxt != 0 || maxb != 0) {
	goto L40;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L35: */
	x[i__] = fac[i__ + fac_dim1] * y[i__];
    }
    return 0;

/* ... tridiagonal case (maxt = maxb = 1). */

L40:
    if (maxt != 1 || maxb != 1) {
	goto L45;
    }
    if (nsys <= lenv) {
	tsoln_(&n, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1], &fac[fac_dim1
		* 3 + 2], &y[1], &x[1]);
    }
    if (nsys > lenv) {
	tsolnm_(&n, &nsize, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1], &fac[
		fac_dim1 * 3 + 2], &y[1], &x[1]);
    }
    return 0;

/* ... pentadiagonal case (maxt = maxb = 2). */

L45:
    if (maxt != 2 || maxb != 2) {
	goto L50;
    }
    if (nsys <= lenv) {
	psoln_(&n, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1], &fac[fac_dim1
		* 3 + 1], &fac[(fac_dim1 << 2) + 2], &fac[fac_dim1 * 5 + 3], &
		y[1], &x[1]);
    }
    if (nsys > lenv) {
	psolnm_(&n, &nsize, &fac[fac_offset], &fac[(fac_dim1 << 1) + 1], &fac[
		fac_dim1 * 3 + 1], &fac[(fac_dim1 << 2) + 2], &fac[fac_dim1 *
		5 + 3], &y[1], &x[1]);
    }
    return 0;

/* ... all other cases. */

L50:
    if (nsys <= lenv) {
	bsoln_(lda, &n, &maxt, &maxb, &fac[fac_offset], &fac[(fac_dim1 << 1)
		+ 1], &fac[(maxt + 2) * fac_dim1 + 1], &y[1], &x[1]);
    }
    if (nsys > lenv) {
	bsolnm_(&n, &nsize, &maxt, &maxb, &fac[fac_offset], &fac[(fac_dim1 <<
		1) + 1], &fac[(maxt + 2) * fac_dim1 + 1], &y[1], &x[1]);
    }
    return 0;
} /* bdsol_ */

/* Subroutine */ int bdsolt_(integer *lda, integer *nn, integer *nsizee,
	integer *nt, integer *nb, doublereal *fac, doublereal *y, doublereal *
	x)
{
    /* Initialized data */

    static integer lenv = 10;

    /* System generated locals */
    integer fac_dim1, fac_offset, i__1;

    /* Local variables */
    static integer i__, n, maxb, maxt, nsys, nsize;
    extern /* Subroutine */ int psoln_(integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *), tsoln_(integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *), bsolnt_(integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *), bsontm_(integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *), psolnm_(integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *, doublereal *, doublereal *), tsolnm_(integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *,
	     doublereal *);


/* ... bdsolt computes the transpose solution to a nonsymmetric */
/*     dense banded matrix. */
/*     thus, bdsolt finds the solution to   (a**t)*x = y,  where fac */
/*     contains the factorization of the a matrix. */

/* ... parameters -- */

/*        lda    leading dimension of array fac */
/*        n      active size of array fac */
/*        nsize  size of an individual subsystem (if multiple systems) */
/*                nsize = n upon input if not a multiple system */
/*        nt     number of diagonals needed to store the super- */
/*                diagonals of the factorization */
/*        nb     number of diagonals needed to store the sub- */
/*                diagonals of the factorization */
/*        fac    array containing the factorization of the matrix */
/*        y      upon input, y conains the right hand side */
/*        x      upon output, x contains the solution to  a*x = y */

/* ... specifications for parameters */

    /* Parameter adjustments */
    fac_dim1 = *lda;
    fac_offset = 1 + fac_dim1;
    fac -= fac_offset;
    --y;
    --x;

    /* Function Body */

    n = *nn;
    maxt = *nt;
    maxb = *nb;
    nsize = *nsizee;
    nsys = n / nsize;

/* ... nonsymmetric case. */

/* ... diagonal case (maxt = maxb = 0). */

    if (maxt != 0 || maxb != 0) {
	goto L15;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = fac[i__ + fac_dim1] * y[i__];
    }
    return 0;

/* ... tridiagonal case (maxt = maxb = 1). */

L15:
    if (maxt != 1 || maxb != 1) {
	goto L20;
    }
    if (nsys <= lenv) {
	tsoln_(&n, &fac[fac_offset], &fac[fac_dim1 * 3 + 2], &fac[(fac_dim1 <<
		 1) + 1], &y[1], &x[1]);
    }
    if (nsys > lenv) {
	tsolnm_(&n, &nsize, &fac[fac_offset], &fac[fac_dim1 * 3 + 2], &fac[(
		fac_dim1 << 1) + 1], &y[1], &x[1]);
    }
    return 0;

/* ... pentadiagonal case (maxt = maxb = 2). */

L20:
    if (maxt != 2 || maxb != 2) {
	goto L25;
    }
    if (nsys <= lenv) {
	psoln_(&n, &fac[fac_offset], &fac[(fac_dim1 << 2) + 2], &fac[fac_dim1
		* 5 + 3], &fac[(fac_dim1 << 1) + 1], &fac[fac_dim1 * 3 + 1], &
		y[1], &x[1]);
    }
    if (nsys > lenv) {
	psolnm_(&n, &nsize, &fac[fac_offset], &fac[(fac_dim1 << 2) + 2], &fac[
		fac_dim1 * 5 + 3], &fac[(fac_dim1 << 1) + 1], &fac[fac_dim1 *
		3 + 1], &y[1], &x[1]);
    }
    return 0;

/* ... all other cases. */

L25:
    if (nsys <= lenv) {
	bsolnt_(lda, &n, &maxt, &maxb, &fac[fac_offset], &fac[(fac_dim1 << 1)
		+ 1], &fac[(maxt + 2) * fac_dim1 + 1], &y[1], &x[1]);
    }
    if (nsys > lenv) {
	bsontm_(&n, &nsize, &maxt, &maxb, &fac[fac_offset], &fac[(fac_dim1 <<
		1) + 1], &fac[(maxt + 2) * fac_dim1 + 1], &y[1], &x[1]);
    }
    return 0;
} /* bdsolt_ */

/* Subroutine */ int bbs_(integer *ndim, integer *nn, integer *maxt,
	doublereal *t, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, n, lim;
    static doublereal sum;


/* ... bbs does a banded back substitution  (i + t)*x = y. */
/*     t is a rectangular matrix of adjacent super-diagonals. */

/* ... parameters -- */

/*          ndim   row dimension of t array in defining routine */
/*          n      order of system */
/*          maxt   number of columns in t array */
/*          t      array of active size n by maxt giving the super- */
/*                  diagonals in the order 1,2,3,... */
/*          x      on input, x contains y */
/*                 vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --x;

    /* Function Body */
    n = *nn;
    for (i__ = n - 1; i__ >= 1; --i__) {
	sum = x[i__];
/* Computing MIN */
	i__1 = *maxt, i__2 = n - i__;
	lim = min(i__1,i__2);
	i__1 = lim;
	for (j = 1; j <= i__1; ++j) {
	    sum -= t[i__ + j * t_dim1] * x[i__ + j];
/* L15: */
	}
	x[i__] = sum;
/* L20: */
    }
    return 0;
} /* bbs_ */

/* Subroutine */ int bbsm_(integer *nsize, integer *nsys, integer *maxt,
	doublereal *t, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_dim2, t_offset, x_dim1, x_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, l, ij, lim;


/* ... bbsm does a back solve  (i + t)*x = y  where t is an array */
/*     containing superdiagonals in order 1,2,... . */

/* ... parameters -- */

/*          n      order of system */
/*          nsize  size of a single subsystem */
/*          nsys   number of independent subsystems */
/*          maxt   number of columns in t array */
/*          t      array of active size n by maxt containing */
/*                  the super-diagonal elements of the factorization */
/*          x      on input, x contains y */
/*                 vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    x_dim1 = *nsize;
    x_offset = 1 + x_dim1;
    x -= x_offset;
    t_dim1 = *nsize;
    t_dim2 = *nsys;
    t_offset = 1 + t_dim1 * (1 + t_dim2);
    t -= t_offset;

    /* Function Body */
    for (i__ = *nsize - 1; i__ >= 1; --i__) {
/* Computing MIN */
	i__1 = *nsize - i__;
	lim = min(i__1,*maxt);
	i__1 = lim;
	for (j = 1; j <= i__1; ++j) {
	    ij = i__ + j;
	    i__2 = *nsys;
	    for (l = 1; l <= i__2; ++l) {
/* L15: */
		x[i__ + l * x_dim1] -= t[i__ + (l + j * t_dim2) * t_dim1] * x[
			ij + l * x_dim1];
	    }
/* L20: */
	}
/* L25: */
    }
    return 0;
} /* bbsm_ */

/* Subroutine */ int bbst_(integer *ndim, integer *nn, integer *maxb,
	doublereal *b, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1;

    /* Local variables */
    static integer i__, j, n, lim;
    static doublereal term;


/* ... bbst does a backward substitution  (i + (b**t))*x = y */
/*     where the array b represents sub-diagonals.  b corresponds */
/*     to a banded system. */

/* ... parameters -- */

/*          ndim   row dimension of b in defining routine */
/*          n      order of system (= nn) */
/*          maxb   number of diagonals stored in b */
/*          b      array of active size n x maxb giving the */
/*                  sub-diagonals in the order -1,-2,... . */
/*          x      on input, x contains y */
/*                 vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --x;

    /* Function Body */
    n = *nn;
    for (i__ = n; i__ >= 2; --i__) {
	term = x[i__];
/* Computing MIN */
	i__1 = i__ - 1;
	lim = min(i__1,*maxb);
	i__1 = lim;
	for (j = 1; j <= i__1; ++j) {
	    x[i__ - j] -= b[i__ + j * b_dim1] * term;
/* L20: */
	}
/* L25: */
    }
    return 0;
} /* bbst_ */

/* Subroutine */ int bbstm_(integer *nsize, integer *nsys, integer *maxb,
	doublereal *b, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_dim2, b_offset, x_dim1, x_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, l, lim;


/* ... bbstm does the backward solve (i + (b**t))*x = y  where b */
/*     contains subdiagonals for multiple banded systems. */

/* ... parameters -- */

/*          n      order of system */
/*          nsize  the size of an individual subsystem */
/*          nsys   the number of subsystems */
/*          maxb   number of columns in b array */
/*          b      array of active size n by maxb containing */
/*                  sub-diagonals in the order -1,-2,-3,... */
/*          x      on input, x contains y */
/*                 vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    x_dim1 = *nsize;
    x_offset = 1 + x_dim1;
    x -= x_offset;
    b_dim1 = *nsize;
    b_dim2 = *nsys;
    b_offset = 1 + b_dim1 * (1 + b_dim2);
    b -= b_offset;

    /* Function Body */
    for (i__ = *nsize; i__ >= 2; --i__) {
/* Computing MIN */
	i__1 = i__ - 1;
	lim = min(i__1,*maxb);
	i__1 = lim;
	for (j = 1; j <= i__1; ++j) {
	    i__2 = *nsys;
	    for (l = 1; l <= i__2; ++l) {
/* L15: */
		x[i__ - j + l * x_dim1] -= b[i__ + (l + j * b_dim2) * b_dim1]
			* x[i__ + l * x_dim1];
	    }
/* L20: */
	}
/* L25: */
    }
    return 0;
} /* bbstm_ */

/* Subroutine */ int bfac_(integer *ndim, integer *nn, integer *maxt,
	doublereal *d__, doublereal *t)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, n, j1, j2, nm1, j1p1, len, lim;
    static doublereal term;
    static integer jcol1, jcol2;
    static doublereal pivot;


/* ... bfac computes a factorization to a single banded */
/*     symmetric matrix represented by d and t and replaces it. */

/* ... parameters -- */

/*          ndim   row dimension of t array in defining routine */
/*          n      order of system (= nn) */
/*          maxt   number of columns in t array */
/*          d      vector containing the diagonal elements of a */
/*          t      array of active size n by maxt containing the */
/*                  super-diagonals in the order 1,2,3,... */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --d__;

    /* Function Body */
    n = *nn;
    nm1 = n - 1;
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	pivot = d__[k];
/* Computing MIN */
	i__2 = n - k;
	lim = min(i__2,*maxt);
	i__2 = lim;
	for (j1 = 1; j1 <= i__2; ++j1) {
	    term = t[k + j1 * t_dim1] / pivot;
	    jcol1 = k + j1;
	    d__[jcol1] -= term * t[k + j1 * t_dim1];
	    if (j1 == lim) {
		goto L15;
	    }
	    j1p1 = j1 + 1;
	    i__3 = lim;
	    for (j2 = j1p1; j2 <= i__3; ++j2) {
		jcol2 = j2 - j1;
		t[jcol1 + jcol2 * t_dim1] -= term * t[k + j2 * t_dim1];
/* L10: */
	    }
L15:
	    ;
	}
/* L20: */
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	d__[i__] = 1. / d__[i__];
    }
    i__1 = *maxt;
    for (j = 1; j <= i__1; ++j) {
	len = n - j;
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L30: */
	    t[i__ + j * t_dim1] = d__[i__] * t[i__ + j * t_dim1];
	}
/* L35: */
    }
    return 0;
} /* bfac_ */

/* Subroutine */ int bfacm_(integer *n, integer *nsize, integer *nsys,
	integer *maxt, doublereal *d__, doublereal *t)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_dim2, t_offset, i__1, i__2, i__3,
	    i__4;
    doublereal d__1;

    /* Local variables */
    static integer k, l, j1, j2, jj, j1p1, len, lim, nsm1;
    extern /* Subroutine */ int vinv_(integer *, doublereal *);
    static integer jcol1, jcol2;
    extern /* Subroutine */ int vexopy_(integer *, doublereal *, doublereal *,
	     doublereal *, integer *);


/* ... bfacm computes factorizations to multiple banded */
/*     symmetric matrices represented by d and t and replaces it. */

/* ... parameters -- */

/*          n      order of global system (= nn) */
/*          nsize  order of a single system */
/*          nsys   number of independent subsystems */
/*          maxt   number of columns in t array */
/*          d      vector of length n containing the diagonal */
/*                  elements of a */
/*          t      array of active size n by maxt containing the */
/*                  super-diagonals in the order 1,2,3,... */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *nsize;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *nsize;
    t_dim2 = *nsys;
    t_offset = 1 + t_dim1 * (1 + t_dim2);
    t -= t_offset;

    /* Function Body */
    nsm1 = *nsize - 1;
    i__1 = nsm1;
    for (k = 1; k <= i__1; ++k) {
/* Computing MIN */
	i__2 = *nsize - k;
	lim = min(i__2,*maxt);
	i__2 = lim;
	for (j1 = 1; j1 <= i__2; ++j1) {
	    jcol1 = k + j1;
	    i__3 = *nsys;
	    for (l = 1; l <= i__3; ++l) {
/* L10: */
/* Computing 2nd power */
		d__1 = t[k + (l + j1 * t_dim2) * t_dim1];
		d__[jcol1 + l * d_dim1] -= d__1 * d__1 / d__[k + l * d_dim1];
	    }
	    if (j1 == lim) {
		goto L25;
	    }
	    j1p1 = j1 + 1;
	    i__3 = lim;
	    for (j2 = j1p1; j2 <= i__3; ++j2) {
		jcol2 = j2 - j1;
		i__4 = *nsys;
		for (l = 1; l <= i__4; ++l) {
		    t[jcol1 + (l + jcol2 * t_dim2) * t_dim1] -= t[k + (l + j1
			    * t_dim2) * t_dim1] * t[k + (l + j2 * t_dim2) *
			    t_dim1] / d__[k + l * d_dim1];
/* L15: */
		}
/* L20: */
	    }
L25:
	    ;
	}
/* L30: */
    }
    vinv_(n, &d__[d_offset]);
    i__1 = *maxt;
    for (jj = 1; jj <= i__1; ++jj) {
	len = *n - jj;
	vexopy_(&len, &t[(jj * t_dim2 + 1) * t_dim1 + 1], &d__[d_offset], &t[(
		jj * t_dim2 + 1) * t_dim1 + 1], &c__3);
/* L35: */
    }
    return 0;
} /* bfacm_ */

/* Subroutine */ int bfacn_(integer *ndim, integer *nn, integer *maxt,
	integer *maxb, doublereal *d__, doublereal *t, doublereal *b)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, l, n, ip, jp, nm1, len, liml, limu;
    static doublereal term, term1, pivot;


/* ... bfacn computes a factorization to a single banded */
/*     nonsymmetric matrix represented by d, t, and b and */
/*     replaces it. */

/* ... parameters -- */

/*          ndim   row dimension of t and b in defining routine */
/*          n      order of system (= nn) */
/*          maxt   number of diagonals stored in t */
/*          maxb   number of diagonals stored in b */
/*          d      vector of length n containing the diagonal */
/*                  elements of a */
/*          t      array of active size n x maxt giving the */
/*                  super-diagonals in the order 1,2,3,... */
/*          b      array of active size n x maxb giving the */
/*                  sub-diagonals in the order -1,-2,-3,... */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --d__;

    /* Function Body */
    n = *nn;
    nm1 = n - 1;
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	pivot = d__[k];
/* Computing MIN */
	i__2 = *maxb, i__3 = n - k;
	liml = min(i__2,i__3);
/* Computing MIN */
	i__2 = *maxt, i__3 = n - k;
	limu = min(i__2,i__3);
	i__2 = liml;
	for (ip = 1; ip <= i__2; ++ip) {
	    i__ = k + ip;
	    term = b[i__ + ip * b_dim1] / pivot;
	    i__3 = limu;
	    for (jp = 1; jp <= i__3; ++jp) {
		term1 = term * t[k + jp * t_dim1];
		l = jp - ip;
		if (l < 0) {
		    goto L10;
		} else if (l == 0) {
		    goto L15;
		} else {
		    goto L20;
		}
L10:
		b[i__ + -l * b_dim1] -= term1;
		goto L25;
L15:
		d__[i__] -= term1;
		goto L25;
L20:
		t[i__ + l * t_dim1] -= term1;
L25:
		;
	    }
/* L30: */
	}
/* L35: */
    }

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L40: */
	d__[i__] = 1. / d__[i__];
    }
    i__1 = *maxt;
    for (j = 1; j <= i__1; ++j) {
	len = n - j;
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L45: */
	    t[i__ + j * t_dim1] = d__[i__] * t[i__ + j * t_dim1];
	}
/* L50: */
    }
    i__1 = *maxb;
    for (j = 1; j <= i__1; ++j) {
	len = n - j;
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L55: */
	    b[i__ + j + j * b_dim1] = d__[i__] * b[i__ + j + j * b_dim1];
	}
/* L60: */
    }
    return 0;
} /* bfacn_ */

/* Subroutine */ int bfacnm_(integer *nn, integer *nsize, integer *nsys,
	integer *maxt, integer *maxb, doublereal *d__, doublereal *t,
	doublereal *b)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_dim2, t_offset, b_dim1, b_dim2,
	    b_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, k, l, m, n, ip, jp, len, nsm1, liml, limu;
    extern /* Subroutine */ int vinv_(integer *, doublereal *), vexopy_(
	    integer *, doublereal *, doublereal *, doublereal *, integer *);


/* ... bfacnm computes a factorization to multiple banded */
/*     nonsymmetric matrices represented by d, t, and b and */
/*     replaces it. */

/* ... parameters -- */

/*          nsize  size of a subsystem */
/*          nsys   number of independent subsystems */
/*          maxt   number of diagonals stored in t */
/*          maxb   number of diagonals stored in b */
/*          n      order of system (= nn) */
/*          d      vector of length n containing the diagonal */
/*                  elements of a */
/*          t      array of active size n x maxt giving the */
/*                  super-diagonals in the order 1,2,3,... */
/*          b      array of active size n x maxb giving the */
/*                  sub-diagonals in the order -1,-2,-3,... */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *nsize;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    b_dim1 = *nsize;
    b_dim2 = *nsys;
    b_offset = 1 + b_dim1 * (1 + b_dim2);
    b -= b_offset;
    t_dim1 = *nsize;
    t_dim2 = *nsys;
    t_offset = 1 + t_dim1 * (1 + t_dim2);
    t -= t_offset;

    /* Function Body */
    n = *nn;
    nsm1 = *nsize - 1;
    i__1 = nsm1;
    for (k = 1; k <= i__1; ++k) {
/* Computing MIN */
	i__2 = *maxb, i__3 = *nsize - k;
	liml = min(i__2,i__3);
/* Computing MIN */
	i__2 = *maxt, i__3 = *nsize - k;
	limu = min(i__2,i__3);
	i__2 = liml;
	for (ip = 1; ip <= i__2; ++ip) {
	    i__ = k + ip;
	    i__3 = limu;
	    for (jp = 1; jp <= i__3; ++jp) {
		l = jp - ip;
		if (l < 0) {
		    goto L10;
		} else if (l == 0) {
		    goto L20;
		} else {
		    goto L30;
		}
L10:
		i__4 = *nsys;
		for (m = 1; m <= i__4; ++m) {
/* L15: */
		    b[i__ + (m + -l * b_dim2) * b_dim1] -= b[i__ + (m + ip *
			    b_dim2) * b_dim1] * t[k + (m + jp * t_dim2) *
			    t_dim1] / d__[k + m * d_dim1];
		}
		goto L40;
L20:
		i__4 = *nsys;
		for (m = 1; m <= i__4; ++m) {
/* L25: */
		    d__[i__ + m * d_dim1] -= b[i__ + (m + ip * b_dim2) *
			    b_dim1] * t[k + (m + jp * t_dim2) * t_dim1] / d__[
			    k + m * d_dim1];
		}
		goto L40;
L30:
		i__4 = *nsys;
		for (m = 1; m <= i__4; ++m) {
/* L35: */
		    t[i__ + (m + l * t_dim2) * t_dim1] -= b[i__ + (m + ip *
			    b_dim2) * b_dim1] * t[k + (m + jp * t_dim2) *
			    t_dim1] / d__[k + m * d_dim1];
		}
L40:
		;
	    }
/* L45: */
	}
/* L50: */
    }

    vinv_(&n, &d__[d_offset]);
    i__1 = *maxt;
    for (j = 1; j <= i__1; ++j) {
	len = n - j;
	vexopy_(&len, &t[(j * t_dim2 + 1) * t_dim1 + 1], &d__[d_offset], &t[(
		j * t_dim2 + 1) * t_dim1 + 1], &c__3);
/* L55: */
    }
    i__1 = *maxb;
    for (j = 1; j <= i__1; ++j) {
	len = n - j;
	vexopy_(&len, &b[j + 1 + (j * b_dim2 + 1) * b_dim1], &d__[d_offset], &
		b[j + 1 + (j * b_dim2 + 1) * b_dim1], &c__3);
/* L60: */
    }
    return 0;
} /* bfacnm_ */

/* Subroutine */ int bfs_(integer *ndim, integer *nn, integer *maxb,
	doublereal *b, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, n, lim;
    static doublereal sum;


/* ... bfs does a forward substitution  (i + b)*x = y  where the */
/*     array b represents sub-diagonals.  b corresponds to a */
/*     banded system. */

/* ... parameters -- */

/*          ndim   row dimension of b in defining routine */
/*          n      order of system (= nn) */
/*          maxb   number of diagonals stored in b */
/*          b      array of active size n x maxb giving the */
/*                  sub-diagonals in the order -1,-2,-3,... . */
/*          x      on input, x contains y */
/*                 vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --x;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
/* Computing MIN */
	i__2 = i__ - 1;
	lim = min(i__2,*maxb);
	sum = x[i__];
	i__2 = lim;
	for (j = 1; j <= i__2; ++j) {
	    sum -= b[i__ + j * b_dim1] * x[i__ - j];
/* L10: */
	}
	x[i__] = sum;
/* L15: */
    }
    return 0;
} /* bfs_ */

/* Subroutine */ int bfsm_(integer *nsize, integer *nsys, integer *maxb,
	doublereal *b, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_dim2, b_offset, x_dim1, x_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, l, lim;


/* ... bfsm does the forward solve (i + b)*x = y  where b contains */
/*     subdiagonals for multiple banded systems. */

/* ... parameters -- */

/*          n      order of system */
/*          nsize  the size of an individual subsystem */
/*          nsys   the number of subsystems */
/*          maxb   number of columns in b array */
/*          b      array of active size n by maxb containing */
/*                  sub-diagonals in the order -1,-2,-3,... . */
/*          x      on input, x contains y */
/*                 vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    x_dim1 = *nsize;
    x_offset = 1 + x_dim1;
    x -= x_offset;
    b_dim1 = *nsize;
    b_dim2 = *nsys;
    b_offset = 1 + b_dim1 * (1 + b_dim2);
    b -= b_offset;

    /* Function Body */
    i__1 = *nsize;
    for (i__ = 2; i__ <= i__1; ++i__) {
/* Computing MIN */
	i__2 = i__ - 1;
	lim = min(i__2,*maxb);
	i__2 = lim;
	for (j = 1; j <= i__2; ++j) {
	    i__3 = *nsys;
	    for (l = 1; l <= i__3; ++l) {
/* L10: */
		x[i__ + l * x_dim1] -= b[i__ + (l + j * b_dim2) * b_dim1] * x[
			i__ - j + l * x_dim1];
	    }
/* L15: */
	}
/* L20: */
    }
    return 0;
} /* bfsm_ */

/* Subroutine */ int bfst_(integer *ndim, integer *nn, integer *maxt,
	doublereal *t, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, n, nm1, lim;
    static doublereal term;


/* ... bfst does a banded forward substitution  (i + (t**t))*x = y. */
/*     t is a rectangular matrix of adjacent super-diagonals. */

/* ... parameters -- */

/*          ndim   row dimension of t array in defining routine */
/*          n      order of system */
/*          maxt   number of columns in t array */
/*          t      array of active size n by maxt giving the super- */
/*                  diagonals in the order 1,2,3,... */
/*          x      on input, x contains y */
/*                 vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --x;

    /* Function Body */
    n = *nn;
    nm1 = n - 1;
    i__1 = nm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
	term = x[i__];
/* Computing MIN */
	i__2 = *maxt, i__3 = n - i__;
	lim = min(i__2,i__3);
	i__2 = lim;
	for (j = 1; j <= i__2; ++j) {
	    x[i__ + j] -= t[i__ + j * t_dim1] * term;
/* L15: */
	}
/* L20: */
    }
    return 0;
} /* bfst_ */

/* Subroutine */ int bfstm_(integer *nsize, integer *nsys, integer *maxt,
	doublereal *t, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_dim2, t_offset, x_dim1, x_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, l, ij, lim, nsm1;


/* ... bfstm does a forward solve  (i + (t**t))*x = y  where t is */
/*     an array containing superdiagonals in order 1,2,... . */
/*     (multiple systems) */

/* ... parameters -- */

/*          n      order of system */
/*          nsize  size of a single subsystem */
/*          nsys   number of independent subsystems */
/*          maxt   number of columns in t array */
/*          t      array of active size n by maxt containing */
/*                  the super-diagonal elements of the factorization */
/*          x      on input, x contains y */
/*                 vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    x_dim1 = *nsize;
    x_offset = 1 + x_dim1;
    x -= x_offset;
    t_dim1 = *nsize;
    t_dim2 = *nsys;
    t_offset = 1 + t_dim1 * (1 + t_dim2);
    t -= t_offset;

    /* Function Body */
    nsm1 = *nsize - 1;
    i__1 = nsm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* Computing MIN */
	i__2 = *maxt, i__3 = *nsize - i__;
	lim = min(i__2,i__3);
	i__2 = lim;
	for (j = 1; j <= i__2; ++j) {
	    ij = i__ + j;
	    i__3 = *nsys;
	    for (l = 1; l <= i__3; ++l) {
/* L10: */
		x[ij + l * x_dim1] -= t[i__ + (l + j * t_dim2) * t_dim1] * x[
			i__ + l * x_dim1];
	    }
/* L15: */
	}
/* L20: */
    }
    return 0;
} /* bfstm_ */

/* Subroutine */ int binv_(integer *ndim, integer *nn, integer *maxnz,
	doublereal *fact)
{
    /* System generated locals */
    integer fact_dim1, fact_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, n, l1, m1, m2, l2;
    static doublereal t1;
    static integer ik, nm1, lim;
    static doublereal sum1, sum2;


/* ... binv computes an approximate inverse to a single banded */
/*     symmetric matrix.  fact must contain upon input the output */
/*     from a factorization routine. */

/* ... parameters -- */

/*          ndim   row dimension of fact in the defining routine */
/*          n      order of system (= nn) */
/*          maxnz  bandwidth of the factorization and inverse */
/*          fact   array containing factorization diagonals */
/*                  in the order 0,1,2,3,... */

/* ... specifications for parameters */


    /* Parameter adjustments */
    fact_dim1 = *ndim;
    fact_offset = 1 + fact_dim1;
    fact -= fact_offset;

    /* Function Body */
    n = *nn;
    nm1 = n - 1;

/* ... general banded matrix. */

    i__1 = nm1;
    for (ik = 1; ik <= i__1; ++ik) {
	k = n - ik;
/* Computing MIN */
	i__2 = ik + 1;
	lim = min(i__2,*maxnz);
	sum1 = 0.;
	i__2 = lim;
	for (i__ = 2; i__ <= i__2; ++i__) {
	    t1 = fact[k + i__ * fact_dim1];
	    sum2 = 0.;
	    i__3 = lim;
	    for (j = 2; j <= i__3; ++j) {
		m1 = min(i__,j);
		m2 = max(i__,j);
		l1 = k + m1 - 1;
		l2 = m2 - m1 + 1;
		sum2 -= fact[k + j * fact_dim1] * fact[l1 + l2 * fact_dim1];
/* L10: */
	    }
	    fact[n + i__ * fact_dim1] = sum2;
	    sum1 -= t1 * sum2;
/* L15: */
	}
	fact[k + fact_dim1] += sum1;
	i__2 = lim;
	for (i__ = 2; i__ <= i__2; ++i__) {
/* L20: */
	    fact[k + i__ * fact_dim1] = fact[n + i__ * fact_dim1];
	}
/* L25: */
    }
    i__1 = *maxnz;
    for (i__ = 2; i__ <= i__1; ++i__) {
/* L30: */
	fact[n + i__ * fact_dim1] = 0.;
    }
    return 0;
} /* binv_ */

/* Subroutine */ int binvn_(integer *ndim, integer *nn, integer *maxt,
	integer *maxb, doublereal *d__, doublereal *t, doublereal *b)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, k, l, n, ik, nm1, lim, kpi, kpj;
    static doublereal sum;
    static integer limc, limr;


/* ... binvn computes an approximate inverse to a single banded */
/*     nonsymmetric matrix.  d, t, and b must contain upon input */
/*     the output from a factorization routine. */

/* ... parameters -- */

/*          ndim   row dimension of t and b in the defining routine */
/*          n      order of system (= nn) */
/*          maxt   number of columns in t */
/*          maxb   number of columns in b */
/*          d      vector of length n containing the diagonal */
/*                  elements of the factorization */
/*          t      array of active size n by maxt containing */
/*                  the superdiagonals of the factorization */
/*                  in the order 1,2,3,... */
/*          b      array of active size n by maxb containing */
/*                  the subdiagonals of the factorization */
/*                   in the order -1,-2,-3,.... */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --d__;

    /* Function Body */
    n = *nn;
    nm1 = n - 1;

/* ... general banded matrix. */

    i__1 = nm1;
    for (ik = 1; ik <= i__1; ++ik) {
	k = n - ik;

/* ... copy kth row and column into wksp. */

	limr = min(*maxt,ik);
	limc = min(*maxb,ik);
	i__2 = limr;
	for (j = 1; j <= i__2; ++j) {
/* L10: */
	    t[n + j * t_dim1] = t[k + j * t_dim1];
	}
	i__2 = limc;
	for (j = 1; j <= i__2; ++j) {
/* L15: */
	    b[j * b_dim1 + 1] = b[k + j + j * b_dim1];
	}

/* ... do computations for kth row. */

	i__2 = limr;
	for (j = 1; j <= i__2; ++j) {
	    sum = 0.;
/* Computing MIN */
	    i__3 = limr, i__4 = limc + j;
	    lim = min(i__3,i__4);
	    i__3 = lim;
	    for (i__ = 1; i__ <= i__3; ++i__) {
		kpi = k + i__;
		l = i__ - j;
		if (l < 0) {
		    goto L20;
		} else if (l == 0) {
		    goto L25;
		} else {
		    goto L30;
		}
L20:
		sum -= t[n + i__ * t_dim1] * t[kpi + -l * t_dim1];
		goto L35;
L25:
		sum -= t[n + i__ * t_dim1] * d__[kpi];
		goto L35;
L30:
		sum -= t[n + i__ * t_dim1] * b[kpi + l * b_dim1];
L35:
		;
	    }
	    t[k + j * t_dim1] = sum;
/* L40: */
	}

/* ... do computations for kth column. */

	i__2 = limc;
	for (j = 1; j <= i__2; ++j) {
	    sum = 0.;
/* Computing MIN */
	    i__3 = limc, i__4 = limr + j;
	    lim = min(i__3,i__4);
	    kpj = k + j;
	    i__3 = lim;
	    for (i__ = 1; i__ <= i__3; ++i__) {
		kpi = k + i__;
		l = i__ - j;
		if (l < 0) {
		    goto L45;
		} else if (l == 0) {
		    goto L50;
		} else {
		    goto L55;
		}
L45:
		sum -= b[i__ * b_dim1 + 1] * b[kpj + -l * b_dim1];
		goto L60;
L50:
		sum -= b[i__ * b_dim1 + 1] * d__[kpi];
		goto L60;
L55:
		sum -= b[i__ * b_dim1 + 1] * t[kpj + l * t_dim1];
L60:
		;
	    }
	    b[kpj + j * b_dim1] = sum;
/* L65: */
	}

/* ... compute kth diagonal element. */

	sum = d__[k];
	lim = min(limr,limc);
	i__2 = lim;
	for (j = 1; j <= i__2; ++j) {
/* L70: */
	    sum -= t[n + j * t_dim1] * b[k + j + j * b_dim1];
	}
	d__[k] = sum;
/* L75: */
    }

/* ... zero out workspace rows. */

    i__1 = *maxt;
    for (j = 1; j <= i__1; ++j) {
/* L80: */
	t[n + j * t_dim1] = 0.;
    }
    i__1 = *maxb;
    for (j = 1; j <= i__1; ++j) {
/* L85: */
	b[j * b_dim1 + 1] = 0.;
    }
    return 0;
} /* binvn_ */

/* Subroutine */ int bmul_(integer *ndim, integer *n, integer *maxt,
	doublereal *d__, doublereal *t, doublereal *x, doublereal *y)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1, i__2;

    /* Local variables */
    static integer i__, la, len;


/* ... bmul computes y = a*x, where x and y are vectors and */
/* ... a is a banded symmetric matrix. */

/* ... parameters -- */

/*         ndim          row dimension of array t */
/*         n             order of matrix */
/*         maxt          number of columns in t */
/*         d             vector of length n giving the */
/*                        diagonal elements of a */
/*         t             array of size n by maxt giving the */
/*                        superdiagonals of a in the order */
/*                        1,2,.... */
/*         x,y           vectors of order n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --d__;
    --x;
    --y;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = d__[i__] * x[i__];
    }
    if (*maxt <= 0) {
	return 0;
    }
    i__1 = *maxt;
    for (la = 1; la <= i__1; ++la) {
	len = *n - la;
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L15: */
	    y[i__] += t[i__ + la * t_dim1] * x[i__ + la];
	}
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L20: */
	    y[i__ + la] += t[i__ + la * t_dim1] * x[i__];
	}
/* L25: */
    }
    return 0;
} /* bmul_ */

/* Subroutine */ int bmuln_(integer *ndim, integer *n, integer *maxt, integer
	*maxb, doublereal *d__, doublereal *t, doublereal *b, doublereal *x,
	doublereal *y)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, len;


/* ... bmuln computes y = a*x, where x and y are vectors and */
/* ... d, t, and b represent a stored in nonsymmetric band */
/* ... storage format. */

/* ... parameters -- */

/*         ndim          row dimension of arrays t and b */
/*         n             order of array a */
/*         maxt          number of columns in t array */
/*         maxb          number of columns in b array */
/*         d             vector of length n giving the diagonal */
/*                        elements of a */
/*         t             array of active size n by maxt giving */
/*                        the super-diagonals of a in the order */
/*                        1,2,3,... */
/*         b             array of active size n by maxb giving */
/*                        the sub-diagonals of a in the order */
/*                        -1,-2,-3,.... */
/*         x,y           vectors of order n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --d__;
    --x;
    --y;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = d__[i__] * x[i__];
    }
    if (*maxt < 1) {
	goto L25;
    }
    i__1 = *maxt;
    for (j = 1; j <= i__1; ++j) {
	len = *n - j;
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L15: */
	    y[i__] += t[i__ + j * t_dim1] * x[i__ + j];
	}
/* L20: */
    }
L25:
    if (*maxb < 1) {
	return 0;
    }
    i__1 = *maxb;
    for (j = 1; j <= i__1; ++j) {
	len = *n - j;
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L30: */
	    y[i__ + j] += b[i__ + j + j * b_dim1] * x[i__];
	}
/* L35: */
    }
    return 0;
} /* bmuln_ */

/* Subroutine */ int bmulnt_(integer *ndim, integer *n, integer *maxt,
	integer *maxb, doublereal *d__, doublereal *t, doublereal *b,
	doublereal *x, doublereal *y)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, len;


/* ... bmulnt computes y = (a**t)*x, where x and y are vectors and */
/* ... d, t, and b represent a stored in nonsymmetric band */
/* ... storage format. */

/* ... parameters -- */

/*         ndim          row dimension of arrays t and b */
/*         n             order of array a */
/*         maxt          number of columns in t array */
/*         maxb          number of columns in b array */
/*         d             vector of length n giving the diagonal */
/*                        elements of a */
/*         t             array of active size n by maxt giving */
/*                        the super-diagonals of a in the order */
/*                        1,2,3,... */
/*         b             array of active size n by maxb giving */
/*                        the sub-diagonals of a in the order */
/*                        -1,-2,-3,... */
/*         x,y           vectors of order n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --d__;
    --x;
    --y;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = d__[i__] * x[i__];
    }
    if (*maxt < 1) {
	goto L25;
    }
    i__1 = *maxt;
    for (j = 1; j <= i__1; ++j) {
	len = *n - j;
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L15: */
	    y[i__ + j] += t[i__ + j * t_dim1] * x[i__];
	}
/* L20: */
    }
L25:
    if (*maxb < 1) {
	return 0;
    }
    i__1 = *maxb;
    for (j = 1; j <= i__1; ++j) {
	len = *n - j;
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L30: */
	    y[i__] += b[i__ + j + j * b_dim1] * x[i__ + j];
	}
/* L35: */
    }
    return 0;
} /* bmulnt_ */

/* Subroutine */ int bsol_(integer *ndim, integer *nn, integer *maxt,
	doublereal *d__, doublereal *t, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int bbs_(integer *, integer *, integer *,
	    doublereal *, doublereal *), bfst_(integer *, integer *, integer *
	    , doublereal *, doublereal *);


/* ... bsol solves a*x = y for a banded and symmetric matrix a. d and */
/*     t must contain upon input the factorization arrays from bfac. */

/* ... parameters -- */

/*          ndim   row dimension of t array in defining routine */
/*          n      order of system */
/*          maxt   number of columns in t array */
/*          d      vector of length n containing the diagonal */
/*                  pivots of the factorization */
/*          t      array of active size n by maxt giving the super- */
/*                  diagonals of the factorization in the order */
/*                  1,2,3,... */
/*          y      right-hand-side vector */
/*          x      vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    bfst_(ndim, &n, maxt, &t[t_offset], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = d__[i__] * x[i__];
    }
    bbs_(ndim, &n, maxt, &t[t_offset], &x[1]);
    return 0;
} /* bsol_ */

/* Subroutine */ int bsolm_(integer *nn, integer *nsize, integer *maxt,
	doublereal *d__, doublereal *t, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int bbsm_(integer *, integer *, integer *,
	    doublereal *, doublereal *);
    static integer nsys;
    extern /* Subroutine */ int bfstm_(integer *, integer *, integer *,
	    doublereal *, doublereal *);


/* ... bsolm solves the system  ax = y  for x, where a is multiple */
/*     symmetric banded matrices whose factorizations are contained in */
/*     d and t. */

/* ... parameters -- */

/*          n      order of system */
/*          nsize  size of a single subsystem */
/*          maxt   number of columns in t array */
/*          d      vector of length n containing the diagonal */
/*                  elements of the factorization */
/*          t      array of active size n by maxt containing */
/*                  the super-diagonal elements of the factorization */
/*                  in the order 1,2,3,... */
/*          y      right-hand-side vector */
/*          x      vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --x;
    --y;
    --t;
    --d__;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    nsys = n / *nsize;
    bfstm_(nsize, &nsys, maxt, &t[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = d__[i__] * x[i__];
    }
    bbsm_(nsize, &nsys, maxt, &t[1], &x[1]);
    return 0;
} /* bsolm_ */

/* Subroutine */ int bsoln_(integer *ndim, integer *nn, integer *maxt,
	integer *maxb, doublereal *d__, doublereal *t, doublereal *b,
	doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int bbs_(integer *, integer *, integer *,
	    doublereal *, doublereal *), bfs_(integer *, integer *, integer *,
	     doublereal *, doublereal *);


/* ... bsoln solves a*x = y for a banded and nonsymmetric matrix a. */
/*     d, t, and b must contain upon input the factorization arrays */
/*     from bfacn. */

/* ... parameters -- */

/*          ndim   row dimension of t array in defining routine */
/*          n      order of system */
/*          maxt   number of columns in t array */
/*          maxb   number of columns in b array */
/*          d      vector of length n containing the diagonal */
/*                  pivots of the factorization */
/*          t      array of active size n by maxt giving the super- */
/*                  diagonals of the factorization in the order */
/*                  1,2,3,... */
/*          b      array of active size n by maxb giving the sub- */
/*                  diagonals of the factorization in the order */
/*                  -1,-2,-3,... */
/*          y      right-hand-side vector */
/*          x      vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    bfs_(ndim, &n, maxb, &b[b_offset], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = d__[i__] * x[i__];
    }
    bbs_(ndim, &n, maxt, &t[t_offset], &x[1]);
    return 0;
} /* bsoln_ */

/* Subroutine */ int bsolnm_(integer *nn, integer *nsize, integer *maxt,
	integer *maxb, doublereal *d__, doublereal *t, doublereal *b,
	doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int bbsm_(integer *, integer *, integer *,
	    doublereal *, doublereal *), bfsm_(integer *, integer *, integer *
	    , doublereal *, doublereal *);
    static integer nsys;


/* ... bsolnm solves a*x = y for a banded and nonsymmetric matrix a. */
/*     d, t, and b must contain upon input the factorization arrays */
/*     from bfacnm.  (multiple systems) */

/* ... parameters -- */

/*          n      order of system */
/*          nsize  size of an individual subsystem */
/*          maxt   number of columns in t array */
/*          maxb   number of columns in b array */
/*          d      vector of length n containing the diagonal */
/*                  pivots of the factorization */
/*          t      array of active size n by maxt giving the super- */
/*                  diagonals of the factorization in the order */
/*                  1,2,3,... */
/*          b      array of active size n by maxb giving the sub- */
/*                  diagonals of the factorization in the order */
/*                  -1,-2,-3,... */
/*          y      right-hand-side vector */
/*          x      vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --x;
    --y;
    --b;
    --t;
    --d__;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    nsys = n / *nsize;
    bfsm_(nsize, &nsys, maxb, &b[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = d__[i__] * x[i__];
    }
    bbsm_(nsize, &nsys, maxt, &t[1], &x[1]);
    return 0;
} /* bsolnm_ */

/* Subroutine */ int bsolnt_(integer *ndim, integer *nn, integer *maxt,
	integer *maxb, doublereal *d__, doublereal *t, doublereal *b,
	doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int bbst_(integer *, integer *, integer *,
	    doublereal *, doublereal *), bfst_(integer *, integer *, integer *
	    , doublereal *, doublereal *);


/* ... bsolnt solves (a**t)*x = y for a banded and nonsymmetric */
/*     matrix a.  d, t, and b must contain upon input the */
/*     factorization arrays from bfacn. */

/* ... parameters -- */

/*          ndim   row dimension of t array in defining routine */
/*          n      order of system */
/*          maxt   number of columns in t array */
/*          maxb   number of columns in b array */
/*          d      vector of length n containing the diagonal */
/*                  pivots of the factorization */
/*          t      array of active size n by maxt giving the super- */
/*                  diagonals of the factorization in the order */
/*                  1,2,3,... */
/*          b      array of active size n by maxb giving the sub- */
/*                  diagonals of the factorization in the order */
/*                  -1,-2,-3,... */
/*          y      right-hand-side vector */
/*          x      vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    bfst_(ndim, &n, maxt, &t[t_offset], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = d__[i__] * x[i__];
    }
    bbst_(ndim, &n, maxb, &b[b_offset], &x[1]);
    return 0;
} /* bsolnt_ */

/* Subroutine */ int bsontm_(integer *nn, integer *nsize, integer *maxt,
	integer *maxb, doublereal *d__, doublereal *t, doublereal *b,
	doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n, nsys;
    extern /* Subroutine */ int bbstm_(integer *, integer *, integer *,
	    doublereal *, doublereal *), bfstm_(integer *, integer *, integer
	    *, doublereal *, doublereal *);


/* ... bsontm solves (a**t)*x = y for a banded and nonsymmetric */
/*     matrix a.  d, t, and b must contain upon input the */
/*     factorization arrays from bfacnm.  (multiple systems) */

/* ... parameters -- */

/*          n      order of system */
/*          nsize  size of an individual subsystem */
/*          maxt   number of columns in t array */
/*          maxb   number of columns in b array */
/*          d      vector of length n containing the diagonal */
/*                  pivots of the factorization */
/*          t      array of active size n by maxt giving the super- */
/*                  diagonals of the factorization in the order */
/*                  1,2,3,... */
/*          b      array of active size n by maxb giving the sub- */
/*                  diagonals of the factorization in the order */
/*                  -1,-2,-3,... */
/*          y      right-hand-side vector */
/*          x      vector containing solution upon output */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --x;
    --y;
    --b;
    --t;
    --d__;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    nsys = n / *nsize;
    bfstm_(nsize, &nsys, maxt, &t[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = d__[i__] * x[i__];
    }
    bbstm_(nsize, &nsys, maxb, &b[1], &x[1]);
    return 0;
} /* bsontm_ */

/* Subroutine */ int bicol_(integer *n, integer *nz, integer *ia, integer *ja,
	 integer *count, integer *father, integer *oppos, logical *propa)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer a, b, c__, d__, i__, j, k, v, w, w0;


/* ... bicolor determines whether or not the matrix represented */
/*     in the sparse (ia,ja) format is bi-colorable. */
/*     the algorithm used is the union-find algorithm. */

/* ... parameters -- */

/*        n      number of vertices */
/*        nz     number of edges (length of ia and ja vectors) */
/*        ia     integer vector of i values */
/*        ja     integer vector of j values */
/*        count  integer workspace vectors of length n each */
/*        father upon output, count gives the color of each node */
/*        oppos */
/*        propa  logical variable indicating on output whether */
/*                matrix has property a */

/* ... specification of parameters */


    /* Parameter adjustments */
    --oppos;
    --father;
    --count;
    --ja;
    --ia;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	count[i__] = 1;
	father[i__] = 0;
	oppos[i__] = 0;
/* L10: */
    }
    i__1 = *nz;
    for (k = 1; k <= i__1; ++k) {
	if (ia[k] == ja[k]) {
	    goto L60;
	}

/* ... a = find (ia(k)). */

	v = ia[k];
L15:
	if (father[v] == 0) {
	    goto L20;
	}
	v = father[v];
	goto L15;
L20:
	w = ia[k];
L25:
	if (father[w] == 0) {
	    goto L30;
	}
	w0 = w;
	w = father[w];
	father[w0] = v;
	goto L25;
L30:
	a = v;

/* ... b = find (ja(k)). */

	v = ja[k];
L35:
	if (father[v] == 0) {
	    goto L40;
	}
	v = father[v];
	goto L35;
L40:
	w = ja[k];
L45:
	if (father[w] == 0) {
	    goto L50;
	}
	w0 = w;
	w = father[w];
	father[w0] = v;
	goto L45;
L50:
	b = v;

/* ... test for a = b. */

	if (a != b) {
	    goto L55;
	}
	*propa = FALSE_;
	return 0;

/* ... do unioning. */

L55:
	if (oppos[a] == b) {
	    goto L60;
	}
	if (oppos[b] == 0) {
	    c__ = a;
	} else {

/* ... c = merge (a,oppos(b)). */

	    i__ = a;
	    j = oppos[b];
	    if (count[i__] >= count[j]) {
		father[j] = i__;
		count[i__] += count[j];
		c__ = i__;
	    } else {
		father[i__] = j;
		count[j] = count[i__] + count[j];
		c__ = j;
	    }
	}
	if (oppos[a] == 0) {
	    d__ = b;
	} else {

/* ... d = merge (b,oppos(a)). */

	    i__ = b;
	    j = oppos[a];
	    if (count[i__] >= count[j]) {
		father[j] = i__;
		count[i__] += count[j];
		d__ = i__;
	    } else {
		father[i__] = j;
		count[j] = count[i__] + count[j];
		d__ = j;
	    }
	}
	oppos[c__] = d__;
	oppos[d__] = c__;
L60:
	;
    }

/* ... do coloring. */

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L65: */
	count[i__] = 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {

/* ... a = find(i). */

	v = i__;
L70:
	if (father[v] == 0) {
	    goto L75;
	}
	v = father[v];
	goto L70;
L75:
	w = i__;
L80:
	if (father[w] == 0) {
	    goto L85;
	}
	w0 = w;
	w = father[w];
	father[w0] = v;
	goto L80;
L85:
	a = v;
	if (count[a] == 0) {
	    count[a] = 1;
	    count[i__] = 1;
	    j = oppos[a];
	    if (j != 0) {
		count[j] = 2;
	    }
	} else {
	    count[i__] = count[a];
	}
/* L90: */
    }
    *propa = TRUE_;
    return 0;
} /* bicol_ */

/* Subroutine */ int chgcon_(doublereal *tri, integer *ier)
{
    /* Format strings */
    static char fmt_31[] = "(/5x,\002estimation of maximum eigenvalue emax h"
	    "alted\002/5x,\002routine zbrent returned ier = \002,i5/5x,\002ad"
	    "aptive procedure turned off at iteration \002,i5/5x,\002final es"
	    "timate of maximum eigenvalue =\002,d15.7/)";
    static char fmt_41[] = "(/5x,\002estimation of minimum eigenvalue emin h"
	    "alted\002/5x,\002routine zbrent returned ier = \002,i5/5x,\002ad"
	    "aptive procedure turned off at iteration \002,i5/5x,\002final es"
	    "timate of minimum eigenvalue =\002,d15.7/)";

    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Builtin functions */
    double sqrt(doublereal);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static doublereal e1, t1, t2, t3, t4;
    static integer ip;
    static doublereal bl1, bl2, tl1, tl2, end, tsqr, emino, emaxo, start;
    extern doublereal eigvss_(integer *, doublereal *, doublereal *,
	    doublereal *, integer *, integer *);

    /* Fortran I/O blocks */
    static cilist io___1568 = { 0, 0, 0, fmt_31, 0 };
    static cilist io___1571 = { 0, 0, 0, fmt_41, 0 };



/* ... chgcon computes the new estimates for the largest and */
/*     smallest eigenvalues (emax and emin) for conjugate gradient */
/*     acceleration. */

/* ... parameters -- */

/*          tri    tridiagonal matrix associated with the eigenvalues */
/*                    of the conjugate gradient polynomial */
/*          ier    error code */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/*     description of variables in common blocks in main routine */

    /* Parameter adjustments */
    tri -= 3;

    /* Function Body */
    ip = itcom1_1.is;
    if ((i__1 = ip - 1) < 0) {
	goto L10;
    } else if (i__1 == 0) {
	goto L20;
    } else {
	goto L30;
    }

/* ... ip = 0 */

L10:
    end = 1. / itcom3_1.alpha;
    tri[3] = end;
    tri[4] = 0.;
    if (itcom2_1.maxadp) {
	itcom3_1.emax = end;
    }
    if (itcom2_1.minadp) {
	itcom3_1.emin = end;
    }
    return 0;

/* ... ip = 1 */

L20:
    t1 = 1. / itcom3_1.alpha + itcom3_1.beta / itcom3_1.alphao;
/* Computing 2nd power */
    d__1 = itcom3_1.alphao;
    t2 = itcom3_1.beta / (d__1 * d__1);
    tri[5] = t1;
    tri[6] = t2;
    tsqr = sqrt(t2);
    tl1 = tri[3] + tsqr;
    tl2 = t1 + tsqr;
    bl1 = tri[3] - tsqr;
    bl2 = t1 - tsqr;
    t3 = tri[3] + t1;
/* Computing 2nd power */
    d__1 = t1 - tri[3];
    t4 = sqrt(d__1 * d__1 + t2 * 4.);
    if (itcom2_1.maxadp) {
	itcom3_1.emax = (t3 + t4) / 2.;
    }
    if (itcom2_1.minadp) {
	itcom3_1.emin = (t3 - t4) / 2.;
    }
    return 0;

/* ... ip .ge. 2 */

L30:
    t1 = 1. / itcom3_1.alpha + itcom3_1.beta / itcom3_1.alphao;
/* Computing 2nd power */
    d__1 = itcom3_1.alphao;
    t2 = itcom3_1.beta / (d__1 * d__1);
    tsqr = sqrt(t2);
    tri[(ip + 1 << 1) + 1] = t1;
    tri[(ip + 1 << 1) + 2] = t2;
    if (! itcom2_1.maxadp) {
	goto L40;
    }

/* ... compute new estimate of emax. */

/* Computing MAX */
    d__1 = tl1, d__2 = tl2 + tsqr;
    tl1 = max(d__1,d__2);
    tl2 = t1 + tsqr;
    emaxo = itcom3_1.emax;
    end = max(tl1,tl2);
    i__1 = ip + 1;
    e1 = eigvss_(&i__1, &tri[3], &emaxo, &end, &c__2, ier);
    if (*ier != 3 && *ier != 4) {
	goto L35;
    }

/* ... poor estimate for emax.  therefore need to stop adaptive */
/*     procedure and keep old value of emax. */

    itcom2_1.maxadp = FALSE_;
    if (itcom1_1.level >= 2) {
	io___1568.ciunit = itcom1_1.nout;
	s_wsfe(&io___1568);
	do_fio(&c__1, (char *)&(*ier), (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&emaxo, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    goto L40;

/* ... valid emax estimate.  check for small relative change in emax. */

L35:
    itcom3_1.emax = e1;
    if ((d__1 = itcom3_1.emax - emaxo, abs(d__1)) < itcom3_1.emax *
	    itcom3_1.zeta) {
	itcom2_1.maxadp = FALSE_;
    }

/* ... compute new estimate of emin. */

L40:
    if (! itcom2_1.minadp) {
	return 0;
    }
/* Computing MIN */
    d__1 = bl1, d__2 = bl2 - tsqr;
    bl1 = min(d__1,d__2);
    bl2 = t1 - tsqr;
/* Computing MAX */
    d__1 = 0., d__2 = min(bl1,bl2);
    start = max(d__1,d__2);
    emino = itcom3_1.emin;
    i__1 = ip + 1;
    e1 = eigvss_(&i__1, &tri[3], &start, &emino, &c__1, ier);
    if (*ier != 3 && *ier != 4) {
	goto L45;
    }

/* ... poor estimate for emin.  therefore need to stop adaptive */
/*     procedure and keep old value of emin. */

    itcom2_1.minadp = FALSE_;
    if (itcom1_1.level >= 2) {
	io___1571.ciunit = itcom1_1.nout;
	s_wsfe(&io___1571);
	do_fio(&c__1, (char *)&(*ier), (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&emino, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    return 0;

/* ... valid emin estimate.  check for small relative change in emin. */

L45:
    itcom3_1.emin = e1;
    if ((d__1 = itcom3_1.emin - emino, abs(d__1)) < itcom3_1.emin *
	    itcom3_1.zeta) {
	itcom2_1.minadp = FALSE_;
    }
    return 0;
} /* chgcon_ */

/* Subroutine */ int chgsi_(S_fp suba, doublereal *coef, integer *jcoef,
	doublereal *wfac, integer *jwfac, integer *nn, doublereal *z__,
	doublereal *wksp, integer *icode, integer *ier)
{
    /* Format strings */
    static char fmt_20[] = "(/1x,15x,\002parameters were changed at iterat"
	    "ion\002,i7/1x,20x,\002rayleigh quotient  \002,f15.9/1x,20x,\002y"
	    "oung estimate     \002,f15.9/1x,20x,\002emin               \002,"
	    "f15.9/1x,20x,\002emax               \002,f15.9/)";
    static char fmt_30[] = "(/1x,15x,\002parameters were changed at iterat"
	    "ion\002,i7/1x,20x,\002rayleigh quotient  \002,f15.9/1x,20x,\002y"
	    "oung estimate     \002,f15.9/1x,20x,\002hageman estimate   \002,"
	    "f15.9/1x,20x,\002emin               \002,f15.9/1x,20x,\002emax  "
	    "             \002,f15.9/)";

    /* System generated locals */
    integer i__1;
    doublereal d__1, d__2;

    /* Builtin functions */
    double sqrt(doublereal), pow_di(doublereal *, integer *), pow_dd(
	    doublereal *, doublereal *);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static integer i__, n;
    static doublereal t1, qa, rq, qt, uu, xx, yy, top;
    static integer kode;
    static doublereal rnrm, rnrm1, eminp, emaxp;
    static integer istar;
    static doublereal rnrmq, emaxpp;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___1587 = { 0, 0, 0, fmt_20, 0 };
    static cilist io___1591 = { 0, 0, 0, fmt_30, 0 };



/* ... chgsi adapts on the iteration parameters. */

/* ... parameters -- */

/*         n         order of system (= nn) */
/*         z         current pseudo-residual vector */
/*         wksp      workspace vector of length n */
/*         icode     output indicator of parameter changes */
/*                    = 0    estimates of emax, emin not changed */
/*                    = 1    estimates of emax, emin changed */
/*         ier       error code */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --wksp;
    --z__;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;

    istar = 3;
    *icode = 0;
    if (itcom1_1.is == 0) {
	return 0;
    }
    rnrm = sqrt(itcom9_1.rzdot);
    rnrmq = sqrt(itcom3_1.dkq);
    rnrm1 = sqrt(itcom3_1.dkm1);
    qa = rnrm / rnrmq;
    t1 = pow_di(&itcom3_1.rr, &itcom1_1.is);
    qt = sqrt(t1) * 2. / (t1 + 1.);
    if (qa <= pow_dd(&qt, &itcom3_1.ff)) {
	return 0;
    }
    if (qa <= 1. && itcom1_1.is <= istar) {
	return 0;
    }
    *icode = 1;

/* ... compute rayleigh quotient. */
/* ...        rq = (z,a*z)/(r,z) */

    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &z__[1], &wksp[1]);
    top = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	top += z__[i__] * wksp[i__];
    }
    if (top >= 0.) {
	goto L15;
    }
    *ier = -6;
    ershow_(ier, "chgsi", (ftnlen)5);
    return 0;
L15:
    rq = top / itcom9_1.rzdot;
    kode = 0;
    if (rq > itcom3_1.rqmax) {
	kode = 1;
    }
    itcom3_1.rqmin = min(rq,itcom3_1.rqmin);
    itcom3_1.rqmax = max(rq,itcom3_1.rqmax);
    yy = (t1 + 1.) * (qa + sqrt(qa * qa - qt * qt)) / 2.;
    d__1 = 1. / (doublereal) itcom1_1.is;
    xx = pow_dd(&yy, &d__1);
    if (qa > 1.) {
	goto L25;
    }
    if (kode == 1) {
	goto L25;
    }

/* ... emin adjustment. */

    eminp = (itcom3_1.emax + itcom3_1.emin) * (1. - xx) * (xx - itcom3_1.rr) /
	     (xx * 2. * (itcom3_1.rr + 1.));
    if (itcom2_1.minadp) {
/* Computing MIN */
	d__1 = min(itcom3_1.emin,eminp);
	itcom3_1.emin = min(d__1,itcom3_1.rqmin);
    }
    if (itcom2_1.maxadp) {
	itcom3_1.emax = max(itcom3_1.emax,itcom3_1.rqmax);
    }
    if (itcom1_1.level >= 2) {
	io___1587.ciunit = itcom1_1.nout;
	s_wsfe(&io___1587);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&rq, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&eminp, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&itcom3_1.emin, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&itcom3_1.emax, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    return 0;

/* ... emax adjustment. */

L25:
    emaxp = (itcom3_1.emax + itcom3_1.emin) * (xx + 1.) * (xx + itcom3_1.rr) /
	     (xx * 2. * (itcom3_1.rr + 1.));
    i__1 = itcom1_1.is - 1;
    uu = (t1 + 1.) / (pow_di(&itcom3_1.rr, &i__1) + 1.) * (rnrm / rnrm1);
    emaxpp = (itcom3_1.emax + itcom3_1.emin) * (uu + 1.) * (uu + itcom3_1.rr)
	    / (uu * 2. * (itcom3_1.rr + 1.));
    if (itcom2_1.maxadp) {
/* Computing MAX */
	d__1 = itcom3_1.emax, d__2 = emaxp * 1.1, d__1 = max(d__1,d__2), d__2
		= emaxpp * 1.1, d__1 = max(d__1,d__2), d__2 = itcom3_1.rqmax *
		 1.1;
	itcom3_1.emax = max(d__1,d__2);
    }
    if (itcom2_1.minadp) {
	itcom3_1.emin = itcom3_1.rqmin;
    }
    if (itcom1_1.level >= 2) {
	io___1591.ciunit = itcom1_1.nout;
	s_wsfe(&io___1591);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&rq, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&emaxp, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&emaxpp, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&itcom3_1.emin, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&itcom3_1.emax, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    return 0;
} /* chgsi_ */

/* Subroutine */ int color_(integer *nxp, integer *nyp, integer *nzp, integer
	*nx, integer *ny, integer *nz, integer *pp, integer *p)
{
    /* System generated locals */
    integer pp_dim1, pp_dim2, pp_offset, p_dim1, p_dim2, p_offset, i__1, i__2,
	     i__3;

    /* Local variables */
    static integer i__, j, k, ip, jp, kp;


/* ... routine color reproduces a color pattern given by array */
/*     pp of dimensions nxp x nyp x nzp into the grid color */
/*     array p of dimensions nx x ny x nz. */

/* ... parameters -- */

/*       nxp,    integer variables giving the x, y, and z dimensions */
/*        nyp,    of the pattern array, respectively. */
/*        nzp */
/*       nx,ny,  integer variables giving the x, y, and z dimensions */
/*        nz      of the grid, respectively. */
/*       pp      integer vector of length  nxp*nyp*nzp */
/*                giving the color pattern to be repeated */
/*       p       integer vector of length  nxg*nyg*nzg */
/*                which contains upon output the grid coloring */

/* ... specifications for parameters */


    /* Parameter adjustments */
    pp_dim1 = *nxp;
    pp_dim2 = *nyp;
    pp_offset = 1 + pp_dim1 * (1 + pp_dim2);
    pp -= pp_offset;
    p_dim1 = *nx;
    p_dim2 = *ny;
    p_offset = 1 + p_dim1 * (1 + p_dim2);
    p -= p_offset;

    /* Function Body */
    i__1 = *nz;
    for (k = 1; k <= i__1; ++k) {
	kp = (k - 1) % *nzp + 1;
	i__2 = *ny;
	for (j = 1; j <= i__2; ++j) {
	    jp = (j - 1) % *nyp + 1;
	    i__3 = *nx;
	    for (i__ = 1; i__ <= i__3; ++i__) {
		ip = (i__ - 1) % *nxp + 1;
		p[i__ + (j + k * p_dim2) * p_dim1] = pp[ip + (jp + kp *
			pp_dim2) * pp_dim1];
/* L10: */
	    }
/* L20: */
	}
/* L30: */
    }
    return 0;
} /* color_ */

/* Subroutine */ int defcon_(integer *ndim, integer *nn, integer *maxnz,
	integer *jcoef, doublereal *coef, integer *kblsz, integer *iblock,
	integer *lbhb)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, n, ib, jb, id, jd, ipt, jcol, jlim;


/* ... define defines block constants for block-structured matrices. */
/*     (diagonal data structure, constant block size) */

/* ... parameters -- */

/*         ndim     row dimension of coef array in defining routine */
/*         nn       size of system */
/*         maxnz    number of diagonals in coef */
/*         jcoef    integer vector of size maxnz giving the diagonal */
/*                   numbers */
/*         coef     matrix representation array */
/*         kblsz    constant block size */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants upon output */
/*         lbhb     integer giving the number of diagonal blocks */
/*                   upon output. */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;
    iblock -= 4;

    /* Function Body */
    n = *nn;
    ipt = 2;
    iblock[4] = 0;
    iblock[7] = 0;
    iblock[5] = 1;
    iblock[6] = 0;
    iblock[9] = 0;
    i__1 = *maxnz;
    for (j = 1; j <= i__1; ++j) {
	jd = jcoef[j];
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    if (coef[i__ + j * coef_dim1] != 0.) {
		goto L15;
	    }
/* L10: */
	}
	goto L25;
L15:
	jcol = i__ + jd;

/* ... find block for jcol. */

	ib = (i__ - 1) / *kblsz + 1;
	jb = (jcol - 1) / *kblsz + 1;
	id = jb - ib;
	if (id == iblock[ipt * 3 + 1]) {
	    goto L20;
	}
	++ipt;
	iblock[ipt * 3 + 1] = id;
	iblock[ipt * 3 + 3] = 0;
L20:
	++iblock[ipt * 3 + 3];
L25:
	;
    }
    *lbhb = ipt;

/* ... split zero diagonal block into super and sub diagonals. */

    jlim = iblock[9];
    i__1 = jlim;
    for (j = 1; j <= i__1; ++j) {
	jd = jcoef[j];
	if (jd < 0) {
	    goto L35;
	}
	++iblock[6];
	--iblock[9];
/* L30: */
    }
    j = jlim + 1;
L35:
    iblock[8] = j;

/* ... form starting positions. */

    if (*lbhb <= 2) {
	return 0;
    }
    iblock[11] = 1;
    if (*lbhb <= 3) {
	return 0;
    }
    i__1 = *lbhb;
    for (j = 4; j <= i__1; ++j) {
/* L40: */
	iblock[j * 3 + 2] = iblock[(j - 1) * 3 + 2] + iblock[(j - 1) * 3 + 3];
    }
    return 0;
} /* defcon_ */

/* Subroutine */ int define_(integer *ndim, integer *maxnew, integer *jcnew,
	doublereal *coef, integer *ncol, integer *nc, integer *iblock,
	integer *lbhb)
{
    /* System generated locals */
    integer jcnew_dim1, jcnew_offset, iblock_dim2, iblock_offset, coef_dim1,
	    coef_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, ib, jb, id, jd, ij, js, ied, ncc, ipt, ist,
	    jcol, jlim, maxnz, ncolor;


/* ... define defines block constants for block-structured matrices. */
/*     (diagonal data structure, nonconstant block size) */

/* ... parameters -- */

/*         ndim     row dimension of coef array in defining routine */
/*         maxnew   integer vector giving the number of diagonals */
/*                   for each distinct block size. */
/*         jcnew    integer array of size ncolor*max(maxnew(i)) */
/*                   giving the diagonal numbers for each distinct */
/*                   block size. */
/*         coef     matrix representation array */
/*         ncolor   number of distinct block sizes */
/*         nc       integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants upon output */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size */
/*                   upon output. */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --lbhb;
    iblock_dim2 = *ncol;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nc;
    jcnew_dim1 = *ncol;
    jcnew_offset = 1 + jcnew_dim1;
    jcnew -= jcnew_offset;
    --maxnew;

    /* Function Body */
    ncolor = *ncol;
    ist = 1;
    i__1 = ncolor;
    for (k = 1; k <= i__1; ++k) {
	ncc = nc[k];
	maxnz = maxnew[k];
	ied = ist + ncc - 1;
	ipt = 2;
	iblock[(k + iblock_dim2) * 3 + 1] = 0;
	iblock[(k + (iblock_dim2 << 1)) * 3 + 1] = 0;
	iblock[(k + iblock_dim2) * 3 + 2] = 1;
	iblock[(k + iblock_dim2) * 3 + 3] = 0;
	iblock[(k + (iblock_dim2 << 1)) * 3 + 3] = 0;
	i__2 = maxnz;
	for (j = 1; j <= i__2; ++j) {
	    jd = jcnew[k + j * jcnew_dim1];
	    i__3 = ied;
	    for (i__ = ist; i__ <= i__3; ++i__) {
		if (coef[i__ + j * coef_dim1] != 0.) {
		    goto L15;
		}
/* L10: */
	    }
	    goto L35;
L15:
	    jcol = i__ + jd;

/* ... find block for jcol. */

	    ib = k;
	    js = 0;
	    i__3 = ncolor;
	    for (ij = 1; ij <= i__3; ++ij) {
		js += nc[ij];
		if (js >= jcol) {
		    goto L25;
		}
/* L20: */
	    }
L25:
	    jb = ij;
	    id = jb - ib;
	    if (id == iblock[(k + ipt * iblock_dim2) * 3 + 1]) {
		goto L30;
	    }
	    ++ipt;
	    iblock[(k + ipt * iblock_dim2) * 3 + 1] = id;
	    iblock[(k + ipt * iblock_dim2) * 3 + 3] = 0;
L30:
	    ++iblock[(k + ipt * iblock_dim2) * 3 + 3];
L35:
	    ;
	}
	lbhb[k] = ipt;

/* ... split zero diagonal block into super and sub diagonals. */

	jlim = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	i__2 = jlim;
	for (j = 1; j <= i__2; ++j) {
	    jd = jcnew[k + j * jcnew_dim1];
	    if (jd < 0) {
		goto L45;
	    }
	    ++iblock[(k + iblock_dim2) * 3 + 3];
	    --iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
/* L40: */
	}
	j = jlim + 1;
L45:
	iblock[(k + (iblock_dim2 << 1)) * 3 + 2] = j;

/* ... form starting positions. */

	jlim = lbhb[k];
	if (jlim <= 2) {
	    goto L55;
	}
	iblock[(k + iblock_dim2 * 3) * 3 + 2] = 1;
	if (jlim <= 3) {
	    goto L55;
	}
	i__2 = jlim;
	for (j = 4; j <= i__2; ++j) {
/* L50: */
	    iblock[(k + j * iblock_dim2) * 3 + 2] = iblock[(k + (j - 1) *
		    iblock_dim2) * 3 + 2] + iblock[(k + (j - 1) * iblock_dim2)
		     * 3 + 3];
	}
L55:
	ist = ied + 1;
/* L60: */
    }
    return 0;
} /* define_ */

doublereal determ_(integer *n, doublereal *tri, doublereal *xlmda)
{
    /* System generated locals */
    doublereal ret_val;

    /* Local variables */
    static integer l;
    static doublereal d1, d2, d3;
    static integer nm1;


/*     determ computes the determinant of a symmetric */
/*     tridiagonal matrix given by tri. det(tri - xlmda*i) = 0 */

/* ... parameters -- */

/*          n      order of tridiagonal system */
/*          tri    symmetric tridiagonal matrix of order n */
/*          xlmda  argument for characteristic equation */

/* ... specifications for parameters */


    /* Parameter adjustments */
    tri -= 3;

    /* Function Body */
    nm1 = *n - 1;
    d2 = tri[(*n << 1) + 1] - *xlmda;
    d1 = d2 * (tri[(nm1 << 1) + 1] - *xlmda) - tri[(*n << 1) + 2];
    if (*n == 2) {
	goto L20;
    }

/* ... beginning of loop */

    for (l = nm1; l >= 2; --l) {
	d3 = d2;
	d2 = d1;
	d1 = (tri[(l - 1 << 1) + 1] - *xlmda) * d2 - d3 * tri[(l << 1) + 2];
/* L10: */
    }

/* ... determinant computed */

L20:
    ret_val = d1;

    return ret_val;
} /* determ_ */

/* Subroutine */ int detsym_(integer *ndim, integer *maxnzz, doublereal *coef,
	 integer *jcoef, integer *nn, integer *isymm)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, jcoef_dim1, jcoef_offset, i__1, i__2,
	    i__3;

    /* Local variables */
    static integer i__, j, n, jj;
    static doublereal val, val1;
    static integer jcol, jcol1, maxnz;


/* ... detsym determines if the matrix is symmetric. */
/*     (purdue storage format) */

/* ... parameters -- */

/*         ndim     row dimension of coef in defining routine */
/*         maxnz    number of columns in coef */
/*         coef     array of matrix nonzeros */
/*         jcoef    array of matrix column numbers */
/*         n        order of matrix (= nn) */
/*         isymm    symmetry switch.  upon output, */
/*                   isymm = 0  if matrix is symmetric */
/*                         = 1  if matrix is nonsymmetric */

/* ... specifications for parameters */


    /* Parameter adjustments */
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;
    *isymm = 0;
    if (maxnz <= 1) {
	return 0;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = maxnz;
	for (j = 2; j <= i__2; ++j) {
	    jcol = jcoef[i__ + j * jcoef_dim1];
	    if (jcol == i__) {
		goto L15;
	    }
	    val = coef[i__ + j * coef_dim1];
	    i__3 = maxnz;
	    for (jj = 2; jj <= i__3; ++jj) {
		jcol1 = jcoef[jcol + jj * jcoef_dim1];
		if (jcol1 != i__) {
		    goto L10;
		}
		val1 = coef[jcol + jj * coef_dim1];
		if (val1 == val) {
		    goto L15;
		}
		*isymm = 1;
		return 0;
L10:
		;
	    }
	    *isymm = 1;
	    return 0;
L15:
	    ;
	}
/* L20: */
    }
    return 0;
} /* detsym_ */

/* Subroutine */ int echall_(integer *n, integer *iparm, doublereal *rparm,
	integer *icall, integer *icallr, integer *ier)
{
    /* Initialized data */

    static integer naiprm = 11;
    static integer narprm = 12;
    static char inames[6*25] = "ntest " "itmax " "level " "nout  " "idgts "
	    "maxadp" "minadp" "iomgad" "ns1   " "ns2   " "ns3   " "nstore"
	    "iscale" "iperm " "ifact " "lvfill" "ltrunc" "ipropa" "kblsz "
	    "nbl2d " "ifctv " "iqlr  " "isymm " "ielim " "ndeg  ";
    static char rnames[6*16] = "zeta  " "emax  " "emin  " "ff    " "fff   "
	    "timit " "digit1" "digit2" "omega " "alphab" "betab " "specr "
	    "timfac" "timtot" "tol   " "ainf  ";

    /* Format strings */
    static char fmt_15[] = "(/5x,\002initial iterative parameters\002)";
    static char fmt_25[] = "(/5x,\002final iterative parameters\002)";
    static char fmt_301[] = "(5x,\002preprocessor and preconditioner paramet"
	    "ers\002)";
    static char fmt_302[] = "(5x,\002general and acceleration parameters\002)"
	    ;
    static char fmt_35[] = "(10x,\002iparm(\002,i2,\002) =\002,i15,4x,\002"
	    "(\002,a6,\002)\002)";
    static char fmt_40[] = "(10x,\002rparm(\002,i2,\002) =\002,d15.8,4x"
	    ",\002(\002,a6,\002)\002)";

    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__, ibip, ieip, ibrp, ierp;
    static doublereal temp;
    static integer minad, maxad;
    static doublereal timit, digit1, digit2;
    static logical erflag;
    static integer iomgad;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___1651 = { 0, 0, 0, fmt_15, 0 };
    static cilist io___1652 = { 0, 0, 0, fmt_25, 0 };
    static cilist io___1653 = { 0, 0, 0, fmt_301, 0 };
    static cilist io___1658 = { 0, 0, 0, fmt_302, 0 };
    static cilist io___1659 = { 0, 0, 0, fmt_35, 0 };
    static cilist io___1661 = { 0, 0, 0, fmt_40, 0 };



/* ... echall initializes the package common blocks from the */
/* ... information contained in iparm and rparm.  echall also */
/* ... prints the values of all parameters in iparm and rparm. */

/* ... parameters -- */

/*          iparm */
/*           and */
/*          rparm  arrays of parameters specifying options and */
/*                    tolerances */
/*          icall  indicator of which parameters are being printed */
/*                    icall = 1,  initial parameters */
/*                          = 2,  final parameters */
/*          icallr  indicator of calling routine */
/*                          = 1,  called from nspcg */
/*                          = 2,  called from accelerator */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --rparm;
    --iparm;

    /* Function Body */

    if (*icall != 1) {
	goto L20;
    }

/* handle accelerator parameters ... */

    itcom1_1.ntest = iparm[1];
    itcom1_1.itmax = iparm[2];
    itcom1_1.level = iparm[3];
    itcom1_1.nout = iparm[4];
    itcom1_1.idgts = iparm[5];
    maxad = iparm[6];
    itcom2_1.maxadd = maxad == 1;
    minad = iparm[7];
    itcom2_1.minadd = minad == 1;
    itcom2_1.maxadp = itcom2_1.maxadd;
    itcom2_1.minadp = itcom2_1.minadd;
    iomgad = iparm[8];
    itcom5_1.omgadp = iomgad == 1;
    itcom1_1.ns1 = iparm[9];
    itcom1_1.ns2 = iparm[10];
    itcom1_1.ns3 = iparm[11];
    itcom1_1.iqlr = iparm[22];
    itcom1_1.iplr = itcom1_1.iqlr;

    itcom3_1.zeta = rparm[1];
    itcom3_1.emax = rparm[2];
    itcom3_1.emin = rparm[3];
    itcom3_1.ff = rparm[4];
    itcom5_1.fff = rparm[5];
    timit = rparm[6];
    digit1 = rparm[7];
    digit2 = rparm[8];
    itcom5_1.omega = rparm[9];
    itcom5_1.alphab = rparm[10];
    itcom5_1.betab = rparm[11];
    itcom5_1.specr = rparm[12];

    erflag = FALSE_;
    erflag = erflag || itcom1_1.ntest < 1 || itcom1_1.ntest > 10;
    erflag = erflag || itcom1_1.itmax <= 0;
    erflag = erflag || maxad < 0 || maxad > 1;
    erflag = erflag || minad < 0 || minad > 1;
    erflag = erflag || itcom1_1.ns1 < 0;
    erflag = erflag || itcom1_1.ns2 < 0;
    erflag = erflag || itcom3_1.emax < 0.;
    erflag = erflag || itcom3_1.emin < 0.;
    erflag = erflag || itcom3_1.ff <= 0. || itcom3_1.ff > 1.;
    if (erflag) {
	goto L999;
    }

/* ... test if eps is too small */

    temp = itcom4_1.srelpr * 500.;
    if (itcom3_1.zeta >= temp) {
	goto L150;
    }
    *ier = 2;
    ershow_(ier, "echall", (ftnlen)6);
    itcom3_1.zeta = temp;
    rparm[1] = temp;

/* ... verify n */

L150:
    if (*n > 0) {
	goto L200;
    }
    *ier = -1;
    ershow_(ier, "echall", (ftnlen)6);
    return 0;

/* now handle preconditioner parameters ... */

L200:
    if (*icallr == 2) {
	goto L50;
    }
    itcom6_1.nstore = iparm[12];
    itcom6_1.iscale = iparm[13];
    itcom6_1.iperm = iparm[14];
    itcom6_1.ifact = iparm[15];
    itcom6_1.lvfill = iparm[16];
    itcom6_1.ltrunc = iparm[17];
    itcom6_1.ipropa = iparm[18];
    itcom1_1.nbl1d = iparm[19];
    itcom1_1.nbl2d = iparm[20];
    itcom6_1.ifctv = iparm[21];
    itcom1_1.iqlr = iparm[22];
    itcom6_1.isymm = iparm[23];
    itcom6_1.ndeg = iparm[25];
    itcom8_1.ainf = rparm[16];

    if (itcom1_1.nbl1d == -1) {
	itcom1_1.nbl1d = *n;
    }
    if (itcom1_1.nbl2d == -1) {
	itcom1_1.nbl2d = *n;
    }
    itcom6_1.kblsz = itcom1_1.nbl1d;
    erflag = FALSE_;
    erflag = erflag || itcom1_1.iqlr < 0 || itcom1_1.iqlr > 3;
    erflag = erflag || itcom6_1.ipropa < 0 || itcom6_1.ipropa > 3;
    if (erflag) {
	goto L999;
    }


/* ... initialize rest of common variables */

L50:
    itcom2_1.halt = FALSE_;
    itcom3_1.stptst = 0.;
    itcom3_1.udnm = 1.;
    itcom1_1.in = 0;

/* prepare to do output ... */

    if (itcom1_1.level <= 2) {
	return 0;
    }
    io___1651.ciunit = itcom1_1.nout;
    s_wsfe(&io___1651);
    e_wsfe();
    goto L30;

L20:
    if (itcom1_1.level <= 2) {
	return 0;
    }
    io___1652.ciunit = itcom1_1.nout;
    s_wsfe(&io___1652);
    e_wsfe();

L30:
    if (*icallr == 2) {
	goto L305;
    }
    io___1653.ciunit = itcom1_1.nout;
    s_wsfe(&io___1653);
    e_wsfe();
    ibip = naiprm + 1;
    ieip = 25;
    ibrp = narprm + 1;
    ierp = 16;
    goto L300;
L305:
    io___1658.ciunit = itcom1_1.nout;
    s_wsfe(&io___1658);
    e_wsfe();
    ibip = 1;
    ieip = naiprm;
    ibrp = 1;
    ierp = narprm;

L300:
    io___1659.ciunit = itcom1_1.nout;
    s_wsfe(&io___1659);
    i__1 = ieip;
    for (i__ = ibip; i__ <= i__1; ++i__) {
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&iparm[i__], (ftnlen)sizeof(integer));
	do_fio(&c__1, inames + (i__ - 1) * 6, (ftnlen)6);
    }
    e_wsfe();
    io___1661.ciunit = itcom1_1.nout;
    s_wsfe(&io___1661);
    i__1 = ierp;
    for (i__ = ibrp; i__ <= i__1; ++i__) {
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&rparm[i__], (ftnlen)sizeof(doublereal));
	do_fio(&c__1, rnames + (i__ - 1) * 6, (ftnlen)6);
    }
    e_wsfe();
    return 0;

/* error returns ... */

/* inadmissible option ... */
L999:
    *ier = -10;
    ershow_(ier, "echall", (ftnlen)6);
    return 0;
} /* echall_ */

doublereal eigvss_(integer *n, doublereal *tri, doublereal *start, doublereal
	*end, integer *icode, integer *ier)
{
    /* System generated locals */
    doublereal ret_val, d__1;

    /* Builtin functions */
    double d_lg10(doublereal *);

    /* Local variables */
    static doublereal a, b, eps;
    static integer nsig, itmp, maxfn;
    extern /* Subroutine */ int zbrent_(integer *, doublereal *, doublereal *,
	     integer *, doublereal *, doublereal *, integer *, integer *);


/* ... eigvss computes a selected eigenvalue of a symmetric */
/*     tridiagonal matrix for conjugate gradient acceleration. */
/*     modified imsl routine zbrent used. */

/* ... parameters -- */

/*          n      order of tridiagonal system */
/*          tri    symmetric tridiagonal matrix of order n */
/*          start  initial lower bound of interval containing root */
/*          end    initial upper bound of interval containing root */
/*          icode  operation key */
/*                   = 1   minimum eigenvalue sought */
/*                   = 2   maximum eigenvalue sought */
/*          ier    error flag */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    tri -= 3;

    /* Function Body */
    ret_val = 0.;
    d__1 = abs(itcom3_1.zeta);
    itmp = (integer) (-d_lg10(&d__1));
    nsig = max(itmp,4);
    maxfn = max(itcom1_1.itmax,50);
    eps = 0.;
    a = *start;
    b = *end;
    zbrent_(n, &tri[3], &eps, &nsig, &a, &b, &maxfn, ier);
    if (*icode == 1) {
	ret_val = max(a,b);
    }
    if (*icode == 2) {
	ret_val = min(a,b);
    }

    return ret_val;
} /* eigvss_ */

/* Subroutine */ int elim1_(integer *nn, integer *ndim, integer *maxnzz,
	integer *jcoef, doublereal *coef, doublereal *rhs, doublereal *wksp,
	doublereal *toll)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, coef_dim1, coef_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, n;
    static doublereal tol;
    static integer jcol, maxnz;


/* ... elim1 removes rows of the matrix for which the ratio of the */
/*     sum of off-diagonal elements to the diagonal element is */
/*     small (less than tol) in absolute value. */
/*     this is to take care of matrices arising from finite */
/*     element discretizations of partial differential equations */
/*     with dirichlet boundary conditions implemented by penalty */
/*     methods.  any such rows and corresponding columns are then */
/*     eliminated (set to the identity after correcting the rhs). */
/*     purdue format. */

/* ... parameter list -- */

/*         n       dimension of matrix ( = nn) */
/*         ndim    row dimension of arrays jcoef and coef in the */
/*                    calling program */
/*         maxnz   maximum number of nonzero entries per row (=maxnzz) */
/*         jcoef   integer array of matrix representation */
/*         coef    array of sparse matrix representation */
/*         rhs     right hand side of matrix problem */
/*         wksp    wksp array of length n */
/*         tol     tolerance factor  (= toll) */

/* ... specifications for arguments */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    --rhs;
    --wksp;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;
    tol = *toll;
    if (n <= 0 || maxnz < 2) {
	return 0;
    }

/* ... find maximum off-diagonal elements in absolute value. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	wksp[i__] = 0.;
    }
    i__1 = maxnz;
    for (j = 2; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L15: */
	    wksp[i__] += (d__1 = coef[i__ + j * coef_dim1], abs(d__1));
	}
/* L20: */
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	wksp[i__] /= (d__1 = coef[i__ + coef_dim1], abs(d__1));
    }

/* ... eliminate desired rows and columns. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (wksp[i__] > tol) {
	    goto L35;
	}
	rhs[i__] /= coef[i__ + coef_dim1];
	coef[i__ + coef_dim1] = 1.;
	i__2 = maxnz;
	for (j = 2; j <= i__2; ++j) {
	    coef[i__ + j * coef_dim1] = 0.;
	    jcoef[i__ + j * jcoef_dim1] = i__;
/* L30: */
	}
L35:
	;
    }
    i__1 = maxnz;
    for (j = 2; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    jcol = jcoef[i__ + j * jcoef_dim1];
	    if (wksp[jcol] > tol) {
		goto L40;
	    }
	    rhs[i__] -= coef[i__ + j * coef_dim1] * rhs[jcol];
	    coef[i__ + j * coef_dim1] = 0.;
	    jcoef[i__ + j * jcoef_dim1] = i__;
L40:
	    ;
	}
/* L45: */
    }
    return 0;
} /* elim1_ */

/* Subroutine */ int elim2_(integer *nn, integer *ndim, integer *maxnzz,
	integer *jcoef, doublereal *coef, doublereal *rhs, doublereal *wksp,
	doublereal *toll)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, n, ind, len;
    static doublereal tol;
    static integer jcol, iback, iforw, maxnz;


/* ... elim2 removes rows of the matrix for which the ratio of the */
/*     sum of off-diagonal elements to the diagonal element is */
/*     small (less than tol) in absolute value. */
/*     this is to take care of matrices arising from finite */
/*     element discretizations of partial differential equations */
/*     with dirichlet boundary conditions implemented by penalty */
/*     methods.  any such rows and corresponding columns are then */
/*     eliminated (set to the identity after correcting the rhs). */
/*     symmetric diagonal format. */

/* ... parameter list -- */

/*         n       dimension of matrix ( = nn) */
/*         ndim    row dimension of array coef in the */
/*                    calling program */
/*         maxnz   number of diagonals stored */
/*         jcoef   integer vector of diagonal numbers */
/*         coef    array of sparse matrix representation */
/*         rhs     right hand side of matrix problem */
/*         wksp    wksp array of length n */
/*         tol     tolerance factor  (= toll) */

/* ... specifications for arguments */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;
    --rhs;
    --wksp;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;
    tol = *toll;
    if (n <= 0 || maxnz < 2) {
	return 0;
    }

/* ... find maximum off-diagonal elements in absolute value. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	wksp[i__] = 0.;
    }
    i__1 = maxnz;
    for (j = 2; j <= i__1; ++j) {
	ind = jcoef[j];
	len = n - ind;
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L15: */
	    wksp[i__] += (d__1 = coef[i__ + j * coef_dim1], abs(d__1));
	}
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L20: */
	    wksp[i__ + ind] += (d__1 = coef[i__ + j * coef_dim1], abs(d__1));
	}
/* L25: */
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	wksp[i__] /= (d__1 = coef[i__ + coef_dim1], abs(d__1));
    }

/* ... eliminate desired rows and columns. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (wksp[i__] > tol) {
	    goto L50;
	}
	rhs[i__] /= coef[i__ + coef_dim1];
	coef[i__ + coef_dim1] = 1.;
	i__2 = maxnz;
	for (j = 2; j <= i__2; ++j) {
	    jcol = jcoef[j];
	    iback = i__ - jcol;
	    iforw = i__ + jcol;
	    if (iforw > n) {
		goto L35;
	    }
	    if (wksp[iforw] <= tol) {
		goto L35;
	    }
	    rhs[iforw] -= coef[i__ + j * coef_dim1] * rhs[i__];
L35:
	    if (iback < 1) {
		goto L40;
	    }
	    rhs[iback] -= coef[iback + j * coef_dim1] * rhs[i__];
	    coef[iback + j * coef_dim1] = 0.;
L40:
	    ;
	}
	i__2 = maxnz;
	for (j = 2; j <= i__2; ++j) {
/* L45: */
	    coef[i__ + j * coef_dim1] = 0.;
	}
L50:
	;
    }
    return 0;
} /* elim2_ */

/* Subroutine */ int elim3_(integer *nn, integer *ndim, integer *maxnzz,
	integer *jcoef, doublereal *coef, doublereal *rhs, doublereal *wksp,
	doublereal *toll)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1, i__2, i__3;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, n, ind;
    static doublereal tol;
    static integer ist1, ist2, inew, maxnz;


/* ... elim3 removes rows of the matrix for which the ratio of the */
/*     sum of off-diagonal elements to the diagonal element is */
/*     small (less than tol) in absolute value. */
/*     this is to take care of matrices arising from finite */
/*     element discretizations of partial differential equations */
/*     with dirichlet boundary conditions implemented by penalty */
/*     methods.  any such rows and corresponding columns are then */
/*     eliminated (set to the identity after correcting the rhs). */
/*     nonsymmetric diagonal format. */

/* ... parameter list -- */

/*         n       dimension of matrix ( = nn) */
/*         ndim    row dimension of array coef in the */
/*                    calling program */
/*         maxnz   number of diagonals stored */
/*         jcoef   integer vector of diagonal numbers */
/*         coef    array of sparse matrix representation */
/*         rhs     right hand side of matrix problem */
/*         wksp    wksp array of length n */
/*         tol     tolerance factor  (= toll) */

/* ... specifications for arguments */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;
    --rhs;
    --wksp;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;
    tol = *toll;
    if (n <= 0 || maxnz < 2) {
	return 0;
    }

/* ... find maximum off-diagonal elements in absolute value. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	wksp[i__] = 0.;
    }
    i__1 = maxnz;
    for (j = 2; j <= i__1; ++j) {
	ind = jcoef[j];
/* Computing MAX */
	i__2 = 1, i__3 = 1 - ind;
	ist1 = max(i__2,i__3);
/* Computing MIN */
	i__2 = n, i__3 = n - ind;
	ist2 = min(i__2,i__3);
	i__2 = ist2;
	for (i__ = ist1; i__ <= i__2; ++i__) {
/* L15: */
	    wksp[i__] += (d__1 = coef[i__ + j * coef_dim1], abs(d__1));
	}
/* L20: */
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	wksp[i__] /= (d__1 = coef[i__ + coef_dim1], abs(d__1));
    }

/* ... eliminate desired rows and columns. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (wksp[i__] > tol) {
	    goto L35;
	}
	rhs[i__] /= coef[i__ + coef_dim1];
	coef[i__ + coef_dim1] = 1.;
	i__2 = maxnz;
	for (j = 2; j <= i__2; ++j) {
/* L30: */
	    coef[i__ + j * coef_dim1] = 0.;
	}
L35:
	;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (wksp[i__] > tol) {
	    goto L45;
	}
	i__2 = maxnz;
	for (j = 2; j <= i__2; ++j) {
	    inew = i__ - jcoef[j];
	    if (inew < 1 || inew > n) {
		goto L40;
	    }
	    rhs[inew] -= coef[inew + j * coef_dim1] * rhs[i__];
	    coef[inew + j * coef_dim1] = 0.;
L40:
	    ;
	}
L45:
	;
    }
    return 0;
} /* elim3_ */

/* Subroutine */ int elim4_(integer *mm, integer *np, integer *ia, integer *
	ja, doublereal *a, doublereal *rhs, doublereal *wksp, doublereal *
	toll)
{
    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, k, l, m, n, nz, np1, ied, len;
    static doublereal tol;
    static integer ist;
    extern /* Subroutine */ int vgathr_(integer *, doublereal *, integer *,
	    doublereal *), vscatr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... elim4 removes rows of the matrix for which the ratio of the */
/*     sum of off-diagonal elements to the diagonal element is */
/*     small (less than tol) in absolute value. */
/*     this is to take care of matrices arising from finite */
/*     element discretizations of partial differential equations */
/*     with dirichlet boundary conditions implemented by penalty */
/*     methods.  any such rows and corresponding columns are then */
/*     eliminated (set to the identity after correcting the rhs). */
/*     symmetric sparse format. */

/* ... parameter list -- */

/*         m       number of partitions */
/*         np      pointer vector to partitions */
/*         ia      vector of i values */
/*         ja      vector of j values */
/*         a       vector of coefficients */
/*         rhs     right hand side of matrix problem */
/*         wksp    wksp vector of length n (2n if keygs = 1) */
/*         tol     tolerance factor  (= toll) */

/* ... specifications for arguments */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --wksp;
    --rhs;
    --a;
    --ja;
    --ia;
    --np;

    /* Function Body */
    m = *mm;
    n = np[2] - 1;
    nz = np[m + 1] - 1;
    tol = *toll;
    np1 = n + 1;

/* ... find sum of absolute values of off-diagonal coefficients. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	wksp[i__] = 0.;
    }
    if (itcom4_1.keygs == 1) {
	goto L30;
    }
    i__1 = m;
    for (k = 2; k <= i__1; ++k) {
	ist = np[k];
	ied = np[k + 1] - 1;
/* dir$ ivdep */
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L15: */
	    wksp[ia[i__]] += (d__1 = a[i__], abs(d__1));
	}
/* dir$ ivdep */
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L20: */
	    wksp[ja[i__]] += (d__1 = a[i__], abs(d__1));
	}
/* L25: */
    }
    goto L50;
L30:
    i__1 = m;
    for (k = 2; k <= i__1; ++k) {
	ist = np[k];
	ied = np[k + 1] - 1;
	len = ied - ist + 1;
	vgathr_(&len, &wksp[1], &ia[ist], &wksp[n + 1]);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L35: */
	    wksp[i__ - ist + 1 + n] += (d__1 = a[i__], abs(d__1));
	}
	vscatr_(&len, &wksp[n + 1], &ia[ist], &wksp[1]);
	vgathr_(&len, &wksp[1], &ja[ist], &wksp[n + 1]);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L40: */
	    wksp[i__ - ist + 1 + n] += (d__1 = a[i__], abs(d__1));
	}
	vscatr_(&len, &wksp[n + 1], &ja[ist], &wksp[1]);
/* L45: */
    }
L50:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L55: */
	wksp[i__] /= (d__1 = a[i__], abs(d__1));
    }

/* ... eliminate desired rows and columns. */

    i__1 = n;
    for (l = 1; l <= i__1; ++l) {
	if (wksp[l] > tol) {
	    goto L70;
	}
	rhs[l] /= a[l];
	a[l] = 1.;
	i__2 = nz;
	for (k = np1; k <= i__2; ++k) {
	    i__ = ia[k];
	    j = ja[k];
	    if (i__ == l && wksp[j] > tol) {
		rhs[j] -= a[k] * rhs[i__];
	    }
	    if (j != l) {
		goto L60;
	    }
	    rhs[i__] -= a[k] * rhs[j];
	    a[k] = 0.;
L60:
	    ;
	}
	i__2 = nz;
	for (k = np1; k <= i__2; ++k) {
	    if (ia[k] == l) {
		a[k] = 0.;
	    }
/* L65: */
	}
L70:
	;
    }
    return 0;
} /* elim4_ */

/* Subroutine */ int elim5_(integer *mm, integer *np, integer *ia, integer *
	ja, doublereal *a, doublereal *rhs, doublereal *wksp, doublereal *
	toll)
{
    /* System generated locals */
    integer i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, k, m, n, nz, np1, ied, len;
    static doublereal tol;
    static integer ist;
    extern /* Subroutine */ int vgathr_(integer *, doublereal *, integer *,
	    doublereal *), vscatr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... elim5 removes rows of the matrix for which the ratio of the */
/*     sum of off-diagonal elements to the diagonal element is */
/*     small (less than tol) in absolute value. */
/*     this is to take care of matrices arising from finite */
/*     element discretizations of partial differential equations */
/*     with dirichlet boundary conditions implemented by penalty */
/*     methods.  any such rows and corresponding columns are then */
/*     eliminated (set to the identity after correcting the rhs). */
/*     nonsymmetric sparse format. */

/* ... parameter list -- */

/*         m       number of partitions */
/*         np      pointer vector to partitions */
/*         ia      vector of i values */
/*         ja      vector of j values */
/*         a       vector of coefficients */
/*         rhs     right hand side of matrix problem */
/*         wksp    wksp vector of length n (2n if keygs = 1) */
/*         tol     tolerance factor  (= toll) */

/* ... specifications for arguments */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --wksp;
    --rhs;
    --a;
    --ja;
    --ia;
    --np;

    /* Function Body */
    m = *mm;
    n = np[2] - 1;
    nz = np[m + 1] - 1;
    tol = *toll;

/* ... find sum of absolute values of off-diagonal coefficients. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	wksp[i__] = 0.;
    }
    if (itcom4_1.keygs == 1) {
	goto L25;
    }
    i__1 = m;
    for (k = 2; k <= i__1; ++k) {
	ist = np[k];
	ied = np[k + 1] - 1;
/* dir$ ivdep */
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L15: */
	    wksp[ia[i__]] += (d__1 = a[i__], abs(d__1));
	}
/* L20: */
    }
    goto L40;
L25:
    i__1 = m;
    for (k = 2; k <= i__1; ++k) {
	ist = np[k];
	ied = np[k + 1] - 1;
	len = ied - ist + 1;
	vgathr_(&len, &wksp[1], &ia[ist], &wksp[n + 1]);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L30: */
	    wksp[i__ - ist + 1 + n] += (d__1 = a[i__], abs(d__1));
	}
	vscatr_(&len, &wksp[n + 1], &ia[ist], &wksp[1]);
/* L35: */
    }
L40:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L45: */
	wksp[i__] /= (d__1 = a[i__], abs(d__1));
    }

/* ... eliminate desired rows and columns. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (wksp[i__] > tol) {
	    goto L50;
	}
	rhs[i__] /= a[i__];
	a[i__] = 1.;
L50:
	;
    }
    np1 = n + 1;
    i__1 = nz;
    for (k = np1; k <= i__1; ++k) {
	if (wksp[ia[k]] <= tol) {
	    a[k] = 0.;
	}
/* L55: */
    }
    i__1 = nz;
    for (k = np1; k <= i__1; ++k) {
	j = ja[k];
	if (wksp[j] > tol) {
	    goto L60;
	}
	i__ = ia[k];
	rhs[i__] -= a[k] * rhs[j];
	a[k] = 0.;
L60:
	;
    }
    return 0;
} /* elim5_ */

/* Subroutine */ int ershow_(integer *ierr, char *iname, ftnlen iname_len)
{
    /* Initialized data */

    static char fmess[80*20] = "nonpositive matrix size n                   "
	    "                                    " "insufficient floating poi"
	    "nt workspace                                           " "insuff"
	    "icient integer workspace                                        "
	    "          " "nonpositive diagonal element                       "
	    "                             " "nonexistent diagonal element    "
	    "                                                " "a is not posi"
	    "tive definite                                                   "
	    "   " "q is not positive definite                                "
	    "                      " "unable to permute matrix as requested  "
	    "                                         " "mdim not large enoug"
	    "h to expand matrix                                          "
	    "inadmissible parameter encountered                             "
	    "                 " "incorrect storage mode for block method     "
	    "                                    " "zero pivot encountered du"
	    "ring factorization                                     " "breakd"
	    "own in direction vector calculation                             "
	    "          " "breakdown in attempt to perform rotation           "
	    "                             " "breakdown in iterate calculation"
	    "                                                " "unimplemented"
	    " combination of parameters                                      "
	    "   " "error in computing preconditioning polynomial             "
	    "                      " "unable to perform eigenvalue estimation"
	    "                                         " "iterative method has"
	    " gone to sleep                                              "
	    "unknown error                                                  "
	    "                 ";
    static char wmess[80*6] = "failure to converge in itmax iterations      "
	    "                                   " "zeta too small            "
	    "                                                      " "no conv"
	    "ergence in maxfn iterations in zbrent                           "
	    "         " "f(a) and f(b) have the same sign in zbrent          "
	    "                            " "negative pivot encountered in fac"
	    "torization                                     " "unknown warnin"
	    "g                                                               "
	    "  ";

    /* Format strings */
    static char fmt_10[] = "(//1x,60(\002*\002)/1x,18(\002*\002),\002 f a t "
	    "a l    e r r o r \002,18(\002*\002)/1x,60(\002*\002)/)";
    static char fmt_20[] = "(//1x,60(\002*\002)/1x,16(\002*\002),\002 w a r "
	    "n i n g    e r r o r \002,16(\002*\002)/1x,60(\002*\002)/)";
    static char fmt_23[] = "(1x,\002routine \002,a10)";
    static char fmt_25[] = "(1x,a80)";
    static char fmt_35[] = "(1x,\002rparm(1) =\002,d10.3,\002 (zeta)\002/1x"
	    ",\002a value this small may hinder convergence\002/1x,\002since "
	    "machine precision srelpr = \002,d10.3/1x,\002zeta reset to \002,"
	    "d10.3)";
    static char fmt_1000[] = "(/1x,60(\002*\002)/)";

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer ier;
    static doublereal temp;
    static integer inum;

    /* Fortran I/O blocks */
    static cilist io___1719 = { 0, 0, 0, fmt_10, 0 };
    static cilist io___1720 = { 0, 0, 0, fmt_20, 0 };
    static cilist io___1721 = { 0, 0, 0, fmt_23, 0 };
    static cilist io___1723 = { 0, 0, 0, fmt_25, 0 };
    static cilist io___1724 = { 0, 0, 0, fmt_25, 0 };
    static cilist io___1726 = { 0, 0, 0, fmt_35, 0 };
    static cilist io___1727 = { 0, 0, 0, fmt_1000, 0 };



/* ... ershow prints an appropriate error message for the error */
/*     numbered ier. */

/* ... parameters -- */

/*        ier     error number (input) */
/*                 .gt. 0     for warning errors */
/*                 .lt. 0     for fatal errors */
/*        iname   routine name in which error occurred */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */


    ier = *ierr;
    if (ier == 0) {
	return 0;
    }
    if (ier < 0 && itcom1_1.level < 0) {
	return 0;
    }
    if (ier > 0 && itcom1_1.level < 1) {
	return 0;
    }
    if (ier < -19) {
	ier = -20;
    }
    if (ier > 5) {
	ier = 6;
    }
    if (ier < 0) {
	io___1719.ciunit = itcom1_1.nout;
	s_wsfe(&io___1719);
	e_wsfe();
    }
    if (ier > 0) {
	io___1720.ciunit = itcom1_1.nout;
	s_wsfe(&io___1720);
	e_wsfe();
    }
    io___1721.ciunit = itcom1_1.nout;
    s_wsfe(&io___1721);
    do_fio(&c__1, iname, (ftnlen)10);
    e_wsfe();
    inum = abs(ier);
    if (ier > 0) {
	goto L30;
    }

/* ... print out fatal errors. */

    io___1723.ciunit = itcom1_1.nout;
    s_wsfe(&io___1723);
    do_fio(&c__1, fmess + (inum - 1) * 80, (ftnlen)80);
    e_wsfe();
    goto L999;

/* ... print out warning errors. */

L30:
    io___1724.ciunit = itcom1_1.nout;
    s_wsfe(&io___1724);
    do_fio(&c__1, wmess + (inum - 1) * 80, (ftnlen)80);
    e_wsfe();
    if (inum != 2) {
	goto L999;
    }
    temp = itcom4_1.srelpr * 500.;
    io___1726.ciunit = itcom1_1.nout;
    s_wsfe(&io___1726);
    do_fio(&c__1, (char *)&itcom3_1.zeta, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&itcom4_1.srelpr, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&temp, (ftnlen)sizeof(doublereal));
    e_wsfe();

/* ... print ending line. */

L999:
    io___1727.ciunit = itcom1_1.nout;
    s_wsfe(&io___1727);
    e_wsfe();
    return 0;
} /* ershow_ */

/* Subroutine */ int filln_(integer *maxnz, integer *jcoef)
{
    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Local variables */
    static integer j1, j2, j3, jd, maxn;


/* ... filln determines the fill-in diagonals for nonsymmetric */
/*     diagonal storage. */

/* ... parameters -- */

/*        maxnz   upon input, the number of diagonals */
/*                upon output, the number of diagonals with fill-in */
/*        jcoef   upon input, the diagonal numbers */
/*                upon output, the diagonal numbers with fill-in */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --jcoef;

    /* Function Body */
    maxn = *maxnz;
    i__1 = *maxnz;
    for (j1 = 1; j1 <= i__1; ++j1) {
	i__2 = *maxnz;
	for (j2 = 1; j2 <= i__2; ++j2) {
	    jd = jcoef[j1] + jcoef[j2];
	    if (jcoef[j1] * jcoef[j2] >= 0) {
		goto L15;
	    }
	    i__3 = maxn;
	    for (j3 = 1; j3 <= i__3; ++j3) {
		if (jcoef[j3] == jd) {
		    goto L15;
		}
/* L10: */
	    }
	    ++maxn;
	    jcoef[maxn] = jd;
L15:
	    ;
	}
/* L20: */
    }
    *maxnz = maxn;
    return 0;
} /* filln_ */

/* Subroutine */ int fills_(integer *maxt, integer *jt)
{
    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Local variables */
    static integer j1, j2, j3, jd, maxn;


/* ... fills determines the fill-in diagonals for symmetric */
/*     diagonal storage. */

/* ... parameters -- */

/*        maxt    upon input, the number of diagonals in the */
/*                 upper triangle */
/*                upon output, the number of diagonals in the */
/*                 upper triangle with fill-in */
/*        jt      upon input, the diagonal numbers in the upper */
/*                 triangle */
/*                upon output, the diagonal numbers in the upper */
/*                 triangle with fill-in */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --jt;

    /* Function Body */
    maxn = *maxt;
    i__1 = *maxt;
    for (j1 = 1; j1 <= i__1; ++j1) {
	i__2 = *maxt;
	for (j2 = 1; j2 <= i__2; ++j2) {
	    jd = jt[j1] - jt[j2];
	    if (jd <= 0) {
		goto L15;
	    }
	    i__3 = maxn;
	    for (j3 = 1; j3 <= i__3; ++j3) {
		if (jt[j3] == jd) {
		    goto L15;
		}
/* L10: */
	    }
	    ++maxn;
	    jt[maxn] = jd;
L15:
	    ;
	}
/* L20: */
    }
    *maxt = maxn;
    return 0;
} /* fills_ */

/* Subroutine */ int fillnp_(integer *ndim, integer *nn, integer *maxcc,
	integer *jc, doublereal *c__, integer *mwidth, integer *ier)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1, i__2, i__3, i__4,
	    i__5, i__6;

    /* Local variables */
    static integer i__, j, k, n, j1, j2, j3, ii, nm1, kp1, maxc, maxu;


/* ... fillnp determines the fill-in structure. */
/*     (purdue storage, nonsymmetric matrix) */

/* ... parameters -- */

/*          ndim   row dimension of jc and c arrays */
/*          n      order of system (= nn) */
/*          maxc   upon input, maxc is the number of columns in */
/*                  the c array */
/*                 upon output, maxc is the number of columns in */
/*                  the c array with fill-in */
/*          jc     integer array of active size n by maxc giving the */
/*                  column numbers of the corresponding elements in c */
/*          c      array of active size n by maxc giving the */
/*                  coefficients of the off-diagonal elements */
/*          mwidth maximum column width to be allowed for fill-in */
/*          ier    error code */
/*                  =    0  no errors detected */
/*                  =   -2  mwidth too small to accomodate fill-in */

/* ... specifications for parameters */



    /* Parameter adjustments */
    c_dim1 = *ndim;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndim;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;

    /* Function Body */
    n = *nn;
    maxc = *maxcc;
    maxu = maxc;

    if (maxc < 1) {
	return 0;
    }
    nm1 = n - 1;
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	kp1 = k + 1;
	i__2 = maxc;
	for (j1 = 1; j1 <= i__2; ++j1) {
	    i__3 = n;
	    for (i__ = kp1; i__ <= i__3; ++i__) {
		if (jc[i__ + j1 * jc_dim1] != k) {
		    goto L35;
		}
		i__4 = maxc;
		for (j2 = 1; j2 <= i__4; ++j2) {
		    j = jc[k + j2 * jc_dim1];
		    if (j <= k || j == i__) {
			goto L30;
		    }
		    i__5 = maxu;
		    for (j3 = 1; j3 <= i__5; ++j3) {
			if (j == (i__6 = jc[i__ + j3 * jc_dim1], abs(i__6))) {
			    goto L30;
			}
/* L10: */
		    }
		    i__5 = maxu;
		    for (j3 = 1; j3 <= i__5; ++j3) {
			if (jc[i__ + j3 * jc_dim1] != i__) {
			    goto L15;
			}
			jc[i__ + j3 * jc_dim1] = -j;
			goto L30;
L15:
			;
		    }
		    ++maxu;
		    if (maxu <= *mwidth) {
			goto L20;
		    }
		    *ier = -2;
		    return 0;
L20:
		    i__5 = n;
		    for (ii = 1; ii <= i__5; ++ii) {
			jc[ii + maxu * jc_dim1] = ii;
			c__[ii + maxu * c_dim1] = 0.;
/* L25: */
		    }
		    jc[i__ + maxu * jc_dim1] = -j;
L30:
		    ;
		}
L35:
		;
	    }
/* L40: */
	}
/* L45: */
    }

/* ... decode new elements of jt, jb. */

    i__1 = maxu;
    for (j = 1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L50: */
	    jc[i__ + j * jc_dim1] = (i__3 = jc[i__ + j * jc_dim1], abs(i__3));
	}
/* L55: */
    }
    *maxcc = maxu;
    return 0;
} /* fillnp_ */

/* Subroutine */ int fillsp_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *t, integer *mwidth, integer *ier)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1, i__2, i__3, i__4,
	    i__5;

    /* Local variables */
    static integer i__, j, k, n, j1, j2, j3, nm1, maxt, maxu, jcol1, jcol2;


/* ... fillsp determines the fill-in structure. */
/*     (purdue storage, symmetric matrix) */

/* ... parameters -- */

/*          ndim   row dimension of t and jt arrays */
/*          n      order of system (= nn) */
/*          maxt   upon input, maxt is the number of columns in */
/*                  the t array */
/*                 upon output, maxt is the number of columns in */
/*                  the t array with fill-in */
/*          jt     integer array of active size n by maxt giving the */
/*                  column numbers of the corresponding elements in t */
/*          t      array of active size n by maxt giving the */
/*                  coefficients of the upper triangle of the matrix */
/*          mwidth maximum column width of jt and t to be allowed */
/*          ier    error code */
/*                  =   0     no error detected */
/*                  =  -2     mwidth too small to store factor */

/* ... specifications for parameters */



    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndim;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    maxu = maxt;
    *ier = 0;

    if (maxt < 1) {
	return 0;
    }
    nm1 = n - 1;
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	i__2 = maxt;
	for (j1 = 1; j1 <= i__2; ++j1) {
	    jcol1 = jt[k + j1 * jt_dim1];
	    if (jcol1 <= 0 || jcol1 == k) {
		goto L35;
	    }
	    i__3 = maxt;
	    for (j2 = 1; j2 <= i__3; ++j2) {
		jcol2 = jt[k + j2 * jt_dim1];
		if (jcol2 <= 0 || jcol2 == k) {
		    goto L30;
		}
		if (jcol2 <= jcol1) {
		    goto L30;
		}
		i__4 = maxu;
		for (j3 = 1; j3 <= i__4; ++j3) {
		    if (jcol2 == (i__5 = jt[jcol1 + j3 * jt_dim1], abs(i__5)))
			     {
			goto L30;
		    }
/* L10: */
		}
		i__4 = maxu;
		for (j3 = 1; j3 <= i__4; ++j3) {
		    if (jt[jcol1 + j3 * jt_dim1] != jcol1) {
			goto L15;
		    }
		    jt[jcol1 + j3 * jt_dim1] = -jcol2;
		    goto L30;
L15:
		    ;
		}
		++maxu;
		if (maxu <= *mwidth) {
		    goto L20;
		}
		*ier = -2;
		return 0;
L20:
		i__4 = n;
		for (i__ = 1; i__ <= i__4; ++i__) {
		    jt[i__ + maxu * jt_dim1] = i__;
		    t[i__ + maxu * t_dim1] = 0.;
/* L25: */
		}
		jt[jcol1 + maxu * jt_dim1] = -jcol2;
L30:
		;
	    }
L35:
	    ;
	}
/* L40: */
    }

/* ... decode new elements of jt. */

    i__1 = maxu;
    for (j = 1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L45: */
	    jt[i__ + j * jt_dim1] = (i__3 = jt[i__ + j * jt_dim1], abs(i__3));
	}
/* L50: */
    }
    *maxtt = maxu;
    return 0;
} /* fillsp_ */

/* Subroutine */ int ibfcn1_(integer *lddd, integer *ldtt, integer *n,
	integer *jd, integer *jt, doublereal *d__, doublereal *t, integer *
	ncol, integer *nci, integer *iblock, integer *lbhb, integer *iunif,
	integer *ipropa, integer *ipt, doublereal *omega, doublereal *wksp,
	integer *ier)
{
    /* System generated locals */
    integer jd_dim1, jd_offset, jt_dim1, jt_offset, iblock_dim2,
	    iblock_offset, d_dim1, d_offset, t_dim1, t_offset, i__1, i__2,
	    i__3, i__4;

    /* Local variables */
    static integer i__, j, k, l, m, na, nb, nc, ii, ma, mc, mb, kk, md, ldd,
	    ndb, ldt, ndt, ist, incb, incc, incd, jcol, klim, jlim, llim;
    static logical unif;
    static integer istc, jstc, istb, jstb, istd, jstd;
    extern /* Subroutine */ int bdfac_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *);
    static integer jdiff;
    extern /* Subroutine */ int bdinv_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *);
    static logical propa;
    static integer kblsz;
    extern /* Subroutine */ int mcopy_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *), t1prod_(integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *);
    static integer ncolor;


/* ... ibfcn1 does an incomplete block factorization of the matrix */
/*     contained in d and t (version 1, unmodified). */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic (version 1) preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         jd       integer array of size ncolor by whatever */
/*                   giving the diagonal block diagonal numbers for */
/*                   each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         ipropa   property a switch */
/*                   = 0   matrix does not have block property a */
/*                   = 1   matrix has block property a */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0 */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *lddd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldtt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    iblock_dim2 = *ncol;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    jt_dim1 = *ncol;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    jd_dim1 = *ncol;
    jd_offset = 1 + jd_dim1;
    jd -= jd_offset;
    --nci;
    --lbhb;
    --ipt;
    --wksp;

    /* Function Body */
    ldd = *lddd;
    ldt = *ldtt;
    ncolor = *ncol;
    unif = *iunif == 1;
    propa = *ipropa == 1;

/* ... define various constants. */

    if (unif) {
	goto L15;
    }
    klim = ncolor;
    goto L20;
L15:
    kblsz = nci[1];
    na = kblsz;
    nb = kblsz;
    nc = kblsz;
    ii = 1;
    kk = 1;
    jlim = lbhb[1];
    llim = jlim;
    klim = *n / kblsz;
    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    ma = ndt + ndb + 1;

/* ... start factorization. */

L20:
    i__1 = klim;
    for (k = 1; k <= i__1; ++k) {
	if (unif) {
	    goto L25;
	}
	kk = k;
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	ma = ndt + ndb + 1;
	goto L30;
L25:
	ist = (k - 1) * kblsz + 1;
L30:
	bdfac_(&ldd, &na, &na, &ndt, &ndb, &d__[ist + d_dim1], &c__1);
	mcopy_(&ldd, &na, &na, &ma, &d__[ist + d_dim1], &wksp[1]);
	bdinv_(&na, &na, &na, &ndt, &ndb, &wksp[1], &c__1);
	if (k == klim || jlim <= 2) {
	    goto L95;
	}
	i__2 = klim;
	for (i__ = k + 1; i__ <= i__2; ++i__) {
	    if (unif) {
		goto L35;
	    }
	    ii = i__;
	    llim = lbhb[i__];
L35:
	    if (llim <= 2) {
		goto L90;
	    }
	    i__3 = llim;
	    for (l = 3; l <= i__3; ++l) {
		jcol = i__ + iblock[(ii + l * iblock_dim2) * 3 + 1];
		if (jcol == k) {
		    goto L45;
		}
/* L40: */
	    }
	    goto L90;
L45:
	    mc = iblock[(ii + l * iblock_dim2) * 3 + 3];
	    if (unif) {
		goto L50;
	    }
	    nc = ipt[i__ + 1] - ipt[i__];
	    incc = ipt[k] - ipt[i__];
	    goto L55;
L50:
	    incc = (k - i__) * kblsz;
L55:
	    istc = ist - incc;
	    jstc = iblock[(ii + l * iblock_dim2) * 3 + 2];
	    i__3 = jlim;
	    for (j = 3; j <= i__3; ++j) {
		jcol = k + iblock[(kk + j * iblock_dim2) * 3 + 1];
		if (jcol <= k) {
		    goto L85;
		}
		jdiff = jcol - i__;
		if (jdiff != 0 && propa) {
		    goto L85;
		}
		i__4 = llim;
		for (m = 1; m <= i__4; ++m) {
		    if (iblock[(ii + m * iblock_dim2) * 3 + 1] == jdiff) {
			goto L65;
		    }
/* L60: */
		}
		goto L85;
L65:
		mb = iblock[(kk + j * iblock_dim2) * 3 + 3];
		istb = ist;
		jstb = iblock[(kk + j * iblock_dim2) * 3 + 2];
		if (unif) {
		    goto L70;
		}
		nb = ipt[jcol + 1] - ipt[jcol];
		incb = ipt[jcol] - ipt[k];
		goto L75;
L70:
		incb = (jcol - k) * kblsz;
L75:
		incd = incc + incb;
		istd = istc;
		jstd = iblock[(ii + m * iblock_dim2) * 3 + 2];
		md = iblock[(ii + m * iblock_dim2) * 3 + 3];
		if (m == 1) {
		    goto L80;
		}
		t1prod_(&na, &ldt, &ldt, &ldt, &ncolor, &na, &nc, &nb, &ma, &
			mb, &mc, &md, &incb, &incc, &incd, &jd[kk + jd_dim1],
			&jt[kk + jstb * jt_dim1], &jt[ii + jstc * jt_dim1], &
			jt[ii + jstd * jt_dim1], &wksp[1], &t[istb + jstb *
			t_dim1], &t[istc + jstc * t_dim1], &t[istd + jstd *
			t_dim1]);
		goto L85;
L80:
		md += iblock[(ii + (iblock_dim2 << 1)) * 3 + 3];
		t1prod_(&na, &ldt, &ldt, &ldd, &ncolor, &na, &nc, &nb, &ma, &
			mb, &mc, &md, &incb, &incc, &incd, &jd[kk + jd_dim1],
			&jt[kk + jstb * jt_dim1], &jt[ii + jstc * jt_dim1], &
			jd[ii + jstd * jd_dim1], &wksp[1], &t[istb + jstb *
			t_dim1], &t[istc + jstc * t_dim1], &d__[istd + jstd *
			d_dim1]);
L85:
		;
	    }
L90:
	    ;
	}
L95:
	;
    }
    return 0;
} /* ibfcn1_ */

/* Subroutine */ int ibfcn2_(integer *lddd, integer *ldtt, integer *n,
	integer *jd, integer *jt, doublereal *d__, doublereal *t, integer *
	ncol, integer *nci, integer *iblock, integer *lbhb, integer *iunif,
	integer *ipropa, integer *ipt, doublereal *omega, doublereal *wksp,
	integer *ier)
{
    /* System generated locals */
    integer jd_dim1, jd_offset, jt_dim1, jt_offset, iblock_dim2,
	    iblock_offset, d_dim1, d_offset, t_dim1, t_offset, i__1, i__2,
	    i__3, i__4;

    /* Local variables */
    static integer i__, j, k, l, m, na, nb, nc, ii, ma, mc, mb, kk, md, ldd,
	    ndb, ldt, ndt, ist, incb, incc, incd, jcol, klim, jlim, llim;
    static logical unif;
    static integer istc, jstc, istb, jstb, istd, jstd;
    extern /* Subroutine */ int bdfac_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *);
    static integer jdiff;
    extern /* Subroutine */ int bdinv_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *);
    static logical propa;
    static integer kblsz;
    extern /* Subroutine */ int t1prod_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *);
    static integer ncolor;


/* ... ibfcn2 does an incomplete block factorization of the matrix */
/*     contained in d and t (version 2, unmodified). */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic (version 2) preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         jd       integer array of size ncolor by whatever */
/*                   giving the diagonal block diagonal numbers for */
/*                   each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         ipropa   property a switch */
/*                   = 0   matrix does not have block property a */
/*                   = 1   matrix has block property a */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0 */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *lddd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldtt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    iblock_dim2 = *ncol;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    jt_dim1 = *ncol;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    jd_dim1 = *ncol;
    jd_offset = 1 + jd_dim1;
    jd -= jd_offset;
    --nci;
    --lbhb;
    --ipt;
    --wksp;

    /* Function Body */
    ldd = *lddd;
    ldt = *ldtt;
    ncolor = *ncol;
    unif = *iunif == 1;
    propa = *ipropa == 1;

/* ... define various constants. */

    if (unif) {
	goto L15;
    }
    klim = ncolor;
    goto L20;
L15:
    kblsz = nci[1];
    na = kblsz;
    nb = kblsz;
    nc = kblsz;
    ii = 1;
    kk = 1;
    jlim = lbhb[1];
    llim = jlim;
    klim = *n / kblsz;
    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    ma = ndt + ndb + 1;

/* ... start factorization. */

L20:
    i__1 = klim;
    for (k = 1; k <= i__1; ++k) {
	if (unif) {
	    goto L25;
	}
	kk = k;
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	ma = ndt + ndb + 1;
	goto L30;
L25:
	ist = (k - 1) * kblsz + 1;
L30:
	bdfac_(&ldd, &na, &na, &ndt, &ndb, &d__[ist + d_dim1], &c__1);
	bdinv_(&ldd, &na, &na, &ndt, &ndb, &d__[ist + d_dim1], &c__1);
	if (k == klim || jlim <= 2) {
	    goto L95;
	}
	i__2 = klim;
	for (i__ = k + 1; i__ <= i__2; ++i__) {
	    if (unif) {
		goto L35;
	    }
	    ii = i__;
	    llim = lbhb[i__];
L35:
	    if (llim <= 2) {
		goto L90;
	    }
	    i__3 = llim;
	    for (l = 3; l <= i__3; ++l) {
		jcol = i__ + iblock[(ii + l * iblock_dim2) * 3 + 1];
		if (jcol == k) {
		    goto L45;
		}
/* L40: */
	    }
	    goto L90;
L45:
	    mc = iblock[(ii + l * iblock_dim2) * 3 + 3];
	    if (unif) {
		goto L50;
	    }
	    nc = ipt[i__ + 1] - ipt[i__];
	    incc = ipt[k] - ipt[i__];
	    goto L55;
L50:
	    incc = (k - i__) * kblsz;
L55:
	    istc = ist - incc;
	    jstc = iblock[(ii + l * iblock_dim2) * 3 + 2];
	    i__3 = jlim;
	    for (j = 3; j <= i__3; ++j) {
		jcol = k + iblock[(kk + j * iblock_dim2) * 3 + 1];
		if (jcol <= k) {
		    goto L85;
		}
		jdiff = jcol - i__;
		if (jdiff != 0 && propa) {
		    goto L85;
		}
		i__4 = llim;
		for (m = 1; m <= i__4; ++m) {
		    if (iblock[(ii + m * iblock_dim2) * 3 + 1] == jdiff) {
			goto L65;
		    }
/* L60: */
		}
		goto L85;
L65:
		mb = iblock[(kk + j * iblock_dim2) * 3 + 3];
		istb = ist;
		jstb = iblock[(kk + j * iblock_dim2) * 3 + 2];
		if (unif) {
		    goto L70;
		}
		nb = ipt[jcol + 1] - ipt[jcol];
		incb = ipt[jcol] - ipt[k];
		goto L75;
L70:
		incb = (jcol - k) * kblsz;
L75:
		incd = incc + incb;
		istd = istc;
		jstd = iblock[(ii + m * iblock_dim2) * 3 + 2];
		md = iblock[(ii + m * iblock_dim2) * 3 + 3];
		if (m == 1) {
		    goto L80;
		}
		t1prod_(&ldd, &ldt, &ldt, &ldt, &ncolor, &na, &nc, &nb, &ma, &
			mb, &mc, &md, &incb, &incc, &incd, &jd[kk + jd_dim1],
			&jt[kk + jstb * jt_dim1], &jt[ii + jstc * jt_dim1], &
			jt[ii + jstd * jt_dim1], &d__[ist + d_dim1], &t[istb
			+ jstb * t_dim1], &t[istc + jstc * t_dim1], &t[istd +
			jstd * t_dim1]);
		goto L85;
L80:
		md += iblock[(ii + (iblock_dim2 << 1)) * 3 + 3];
		t1prod_(&ldd, &ldt, &ldt, &ldd, &ncolor, &na, &nc, &nb, &ma, &
			mb, &mc, &md, &incb, &incc, &incd, &jd[kk + jd_dim1],
			&jt[kk + jstb * jt_dim1], &jt[ii + jstc * jt_dim1], &
			jd[ii + jstd * jd_dim1], &d__[ist + d_dim1], &t[istb
			+ jstb * t_dim1], &t[istc + jstc * t_dim1], &d__[istd
			+ jstd * d_dim1]);
L85:
		;
	    }
L90:
	    ;
	}
L95:
	;
    }
    return 0;
} /* ibfcn2_ */

/* Subroutine */ int ibfcn3_(integer *lddd, integer *ldtt, integer *n,
	integer *jd, integer *jt, doublereal *d__, doublereal *t, integer *
	ncol, integer *nci, integer *iblock, integer *lbhb, integer *iunif,
	integer *ipropa, integer *ipt, doublereal *omega, doublereal *wksp,
	integer *ier)
{
    /* System generated locals */
    integer jd_dim1, jd_offset, jt_dim1, jt_offset, iblock_dim2,
	    iblock_offset, d_dim1, d_offset, t_dim1, t_offset, i__1, i__2,
	    i__3, i__4;

    /* Local variables */
    static integer i__, j, k, l, m, na, nb, nc, ii, ma, mc, mb, kk, md, ip1,
	    ip2, ldd, ndb, iii, ldt, ndt, ist, incb, incc, incd, jcol, klim,
	    jlim, llim;
    static logical unif;
    static integer istc, jstc, istb, jstb, istd, jstd;
    extern /* Subroutine */ int bdfac_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *);
    static integer jdiff;
    extern /* Subroutine */ int bdinv_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *), bdsol_(integer *,
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, integer *);
    static logical propa;
    extern /* Subroutine */ int vsubd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);
    static integer kblsz;
    extern /* Subroutine */ int mcopy_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *), tsumn_(integer *, integer
	    *, integer *, integer *, integer *, integer *, integer *, integer
	    *, integer *, integer *, integer *, integer *, integer *, integer
	    *, integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *), t1prod_(
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;
    static integer ncolor;
    extern /* Subroutine */ int rowsum_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *);


/* ... ibfcn3 does an incomplete block factorization of the matrix */
/*     contained in d and t (version 1, modified). */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic (version 1) preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         jd       integer array of size ncolor by whatever */
/*                   giving the diagonal block diagonal numbers for */
/*                   each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         ipropa   property a switch */
/*                   = 0   matrix does not have block property a */
/*                   = 1   matrix has block property a */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0 */
/*         omega    relaxation factor between 0 and 1. */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *lddd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldtt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    iblock_dim2 = *ncol;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    jt_dim1 = *ncol;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    jd_dim1 = *ncol;
    jd_offset = 1 + jd_dim1;
    jd -= jd_offset;
    --nci;
    --lbhb;
    --ipt;
    --wksp;

    /* Function Body */
    ldd = *lddd;
    ldt = *ldtt;
    ncolor = *ncol;
    unif = *iunif == 1;
    propa = *ipropa == 1;

/* ... define various constants. */

    if (unif) {
	goto L15;
    }
    klim = ncolor;
    goto L20;
L15:
    kblsz = nci[1];
    na = kblsz;
    nb = kblsz;
    nc = kblsz;
    ii = 1;
    kk = 1;
    jlim = lbhb[1];
    llim = jlim;
    klim = *n / kblsz;
    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    ma = ndt + ndb + 1;

/* ... start factorization. */

L20:
    i__1 = klim;
    for (k = 1; k <= i__1; ++k) {
	if (unif) {
	    goto L25;
	}
	kk = k;
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	ma = ndt + ndb + 1;
	goto L30;
L25:
	ist = (k - 1) * kblsz + 1;
L30:
	bdfac_(&ldd, &na, &na, &ndt, &ndb, &d__[ist + d_dim1], &c__1);
	mcopy_(&ldd, &na, &na, &ma, &d__[ist + d_dim1], &wksp[1]);
	bdinv_(&na, &na, &na, &ndt, &ndb, &wksp[1], &c__1);
	ip1 = na * ma + 1;
	ip2 = ip1 + na - 1;
	if (k == klim || jlim <= 2) {
	    goto L100;
	}
	i__2 = klim;
	for (i__ = k + 1; i__ <= i__2; ++i__) {
	    if (unif) {
		goto L35;
	    }
	    ii = i__;
	    llim = lbhb[i__];
L35:
	    if (llim <= 2) {
		goto L95;
	    }
	    i__3 = llim;
	    for (l = 3; l <= i__3; ++l) {
		jcol = i__ + iblock[(ii + l * iblock_dim2) * 3 + 1];
		if (jcol == k) {
		    goto L45;
		}
/* L40: */
	    }
	    goto L95;
L45:
	    mc = iblock[(ii + l * iblock_dim2) * 3 + 3];
	    if (unif) {
		goto L50;
	    }
	    nc = ipt[i__ + 1] - ipt[i__];
	    incc = ipt[k] - ipt[i__];
	    goto L55;
L50:
	    incc = (k - i__) * kblsz;
L55:
	    istc = ist - incc;
	    jstc = iblock[(ii + l * iblock_dim2) * 3 + 2];
	    i__3 = jlim;
	    for (j = 3; j <= i__3; ++j) {
		jcol = k + iblock[(kk + j * iblock_dim2) * 3 + 1];
		if (jcol <= k) {
		    goto L90;
		}
		mb = iblock[(kk + j * iblock_dim2) * 3 + 3];
		istb = ist;
		jstb = iblock[(kk + j * iblock_dim2) * 3 + 2];
		if (unif) {
		    goto L60;
		}
		nb = ipt[jcol + 1] - ipt[jcol];
		incb = ipt[jcol] - ipt[k];
		goto L65;
L60:
		incb = (jcol - k) * kblsz;
L65:
		incd = incc + incb;
		istd = istc;
		jdiff = jcol - i__;
		if (jdiff != 0 && propa) {
		    goto L85;
		}
		i__4 = llim;
		for (m = 1; m <= i__4; ++m) {
		    if (iblock[(ii + m * iblock_dim2) * 3 + 1] == jdiff) {
			goto L75;
		    }
/* L70: */
		}
		goto L85;
L75:
		jstd = iblock[(ii + m * iblock_dim2) * 3 + 2];
		md = iblock[(ii + m * iblock_dim2) * 3 + 3];
		if (m == 1) {
		    goto L80;
		}
		t1prod_(&na, &ldt, &ldt, &ldt, &ncolor, &na, &nc, &nb, &ma, &
			mb, &mc, &md, &incb, &incc, &incd, &jd[kk + jd_dim1],
			&jt[kk + jstb * jt_dim1], &jt[ii + jstc * jt_dim1], &
			jt[ii + jstd * jt_dim1], &wksp[1], &t[istb + jstb *
			t_dim1], &t[istc + jstc * t_dim1], &t[istd + jstd *
			t_dim1]);
		tsumn_(&na, &nc, &nb, &na, &ldt, &ldt, &ncolor, &ma, &mb, &mc,
			 &md, &incb, &incc, &incd, &jd[kk + jd_dim1], &jt[kk
			+ jstb * jt_dim1], &jt[ii + jstc * jt_dim1], &jt[ii +
			jstd * jt_dim1], &wksp[1], &t[istb + jstb * t_dim1], &
			t[istc + jstc * t_dim1], &d__[istd + d_dim1], omega);
		goto L85;
L80:
		md += iblock[(ii + (iblock_dim2 << 1)) * 3 + 3];
		t1prod_(&na, &ldt, &ldt, &ldd, &ncolor, &na, &nc, &nb, &ma, &
			mb, &mc, &md, &incb, &incc, &incd, &jd[kk + jd_dim1],
			&jt[kk + jstb * jt_dim1], &jt[ii + jstc * jt_dim1], &
			jd[ii + jstd * jd_dim1], &wksp[1], &t[istb + jstb *
			t_dim1], &t[istc + jstc * t_dim1], &d__[istd + jstd *
			d_dim1]);
		tsumn_(&na, &nc, &nb, &na, &ldt, &ldt, &ncolor, &ma, &mb, &mc,
			 &md, &incb, &incc, &incd, &jd[kk + jd_dim1], &jt[kk
			+ jstb * jt_dim1], &jt[ii + jstc * jt_dim1], &jd[ii +
			jstd * jd_dim1], &wksp[1], &t[istb + jstb * t_dim1], &
			t[istc + jstc * t_dim1], &d__[istd + d_dim1], omega);
L85:
		rowsum_(&ldt, &na, &mb, &t[istb + jstb * t_dim1], &wksp[ip1],
			&c__1);
		i__4 = ip2;
		for (iii = ip1; iii <= i__4; ++iii) {
/* L87: */
		    wksp[iii] = *omega * wksp[iii];
		}
		bdsol_(&ldd, &na, &na, &ndt, &ndb, &d__[ist + d_dim1], &wksp[
			ip1], &wksp[ip1], &c__1);
		vsubd_(&ldt, &ncolor, &nc, &na, &mc, &t[istc + jstc * t_dim1],
			 &jt[ii + jstc * jt_dim1], &d__[istd + d_dim1], &wksp[
			ip1], &incc);
L90:
		;
	    }
L95:
	    ;
	}
L100:
	;
    }
    return 0;
} /* ibfcn3_ */

/* Subroutine */ int ibfcn4_(integer *lddd, integer *ldtt, integer *n,
	integer *jd, integer *jt, doublereal *d__, doublereal *t, integer *
	ncol, integer *nci, integer *iblock, integer *lbhb, integer *iunif,
	integer *ipropa, integer *ipt, doublereal *omega, doublereal *wksp,
	integer *ier)
{
    /* System generated locals */
    integer jd_dim1, jd_offset, jt_dim1, jt_offset, iblock_dim2,
	    iblock_offset, d_dim1, d_offset, t_dim1, t_offset, i__1, i__2,
	    i__3, i__4;

    /* Local variables */
    static integer i__, j, k, l, m, na, ma, nb, nc, ii, mc, mb, kk, md, ip1,
	    ip2, ldd, ndb, iii, ldt, ndt, ist, isu, incb, incc, incd, jcol,
	    klim, jlim, llim;
    static logical unif;
    static integer istc, jstc, istb, jstb, istd, jstd;
    extern /* Subroutine */ int bdfac_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *);
    static integer jdiff;
    extern /* Subroutine */ int bdinv_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *), bmuln_(integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *);
    static logical propa;
    extern /* Subroutine */ int vsubd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);
    static integer kblsz;
    extern /* Subroutine */ int tsumn_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *, doublereal *), t1prod_(integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *);
    static integer ncolor;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen), rowsum_(
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    integer *);


/* ... ibfcn4 does an incomplete block factorization of the matrix */
/*     contained in d and t (version 2, modified). */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic (version 2) preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         jd       integer array of size ncolor by whatever */
/*                   giving the diagonal block diagonal numbers for */
/*                   each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         ipropa   property a switch */
/*                   = 0   matrix does not have block property a */
/*                   = 1   matrix has block property a */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0 */
/*         omega    relaxation factor between 0 and 1. */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *lddd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldtt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    iblock_dim2 = *ncol;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    jt_dim1 = *ncol;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    jd_dim1 = *ncol;
    jd_offset = 1 + jd_dim1;
    jd -= jd_offset;
    --nci;
    --lbhb;
    --ipt;
    --wksp;

    /* Function Body */
    ldd = *lddd;
    ldt = *ldtt;
    ncolor = *ncol;
    unif = *iunif == 1;
    propa = *ipropa == 1;

/* ... define various constants. */

    ip1 = *n + 1;
    if (unif) {
	goto L15;
    }
    klim = ncolor;
    i__1 = ncolor;
    for (k = 1; k <= i__1; ++k) {
	ist = ipt[k] + 1;
	na = nci[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	ma = ndt + ndb + 1;
	rowsum_(&ldd, &na, &ma, &d__[ist + d_dim1], &wksp[ist], &c__1);
/* L13: */
    }
    goto L20;
L15:
    kblsz = nci[1];
    na = kblsz;
    nb = kblsz;
    nc = kblsz;
    ii = 1;
    kk = 1;
    jlim = lbhb[1];
    llim = jlim;
    klim = *n / kblsz;
    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    ma = ndt + ndb + 1;
    rowsum_(&ldd, n, &ma, &d__[d_offset], &wksp[1], &c__1);

/* ... start factorization. */

L20:
    i__1 = klim;
    for (k = 1; k <= i__1; ++k) {
	if (unif) {
	    goto L25;
	}
	kk = k;
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	ma = ndt + ndb + 1;
	goto L30;
L25:
	ist = (k - 1) * kblsz + 1;
L30:
	isu = ist + na - 1;
	bdfac_(&ldd, &na, &na, &ndt, &ndb, &d__[ist + d_dim1], &c__1);
	bdinv_(&ldd, &na, &na, &ndt, &ndb, &d__[ist + d_dim1], &c__1);
	bmuln_(&ldd, &na, &ndt, &ndb, &d__[ist + d_dim1], &d__[ist + (d_dim1
		<< 1)], &d__[ist + (ndt + 2) * d_dim1], &wksp[ist], &wksp[ip1]
		);
	i__2 = isu;
	for (iii = ist; iii <= i__2; ++iii) {
	    if (wksp[iii] != 0.) {
		goto L31;
	    }
	    *ier = -12;
	    ershow_(ier, "ibfcn4", (ftnlen)6);
	    return 0;
L31:
	    ;
	}
	i__2 = isu;
	for (iii = ist; iii <= i__2; ++iii) {
/* L33: */
	    d__[iii + d_dim1] += *omega * (1. - wksp[iii - ist + ip1]) / wksp[
		    iii];
	}
	ip2 = ip1 + na;
	if (k == klim || jlim <= 2) {
	    goto L100;
	}
	i__2 = klim;
	for (i__ = k + 1; i__ <= i__2; ++i__) {
	    if (unif) {
		goto L35;
	    }
	    ii = i__;
	    llim = lbhb[i__];
L35:
	    if (llim <= 2) {
		goto L95;
	    }
	    i__3 = llim;
	    for (l = 3; l <= i__3; ++l) {
		jcol = i__ + iblock[(ii + l * iblock_dim2) * 3 + 1];
		if (jcol == k) {
		    goto L45;
		}
/* L40: */
	    }
	    goto L95;
L45:
	    mc = iblock[(ii + l * iblock_dim2) * 3 + 3];
	    if (unif) {
		goto L50;
	    }
	    nc = ipt[i__ + 1] - ipt[i__];
	    incc = ipt[k] - ipt[i__];
	    goto L55;
L50:
	    incc = (k - i__) * kblsz;
L55:
	    istc = ist - incc;
	    jstc = iblock[(ii + l * iblock_dim2) * 3 + 2];
	    i__3 = jlim;
	    for (j = 3; j <= i__3; ++j) {
		jcol = k + iblock[(kk + j * iblock_dim2) * 3 + 1];
		if (jcol <= k) {
		    goto L90;
		}
		mb = iblock[(kk + j * iblock_dim2) * 3 + 3];
		istb = ist;
		jstb = iblock[(kk + j * iblock_dim2) * 3 + 2];
		if (unif) {
		    goto L60;
		}
		nb = ipt[jcol + 1] - ipt[jcol];
		incb = ipt[jcol] - ipt[k];
		goto L65;
L60:
		incb = (jcol - k) * kblsz;
L65:
		incd = incc + incb;
		istd = istc;
		jdiff = jcol - i__;
		if (jdiff != 0 && propa) {
		    goto L85;
		}
		i__4 = llim;
		for (m = 1; m <= i__4; ++m) {
		    if (iblock[(ii + m * iblock_dim2) * 3 + 1] == jdiff) {
			goto L75;
		    }
/* L70: */
		}
		goto L85;
L75:
		jstd = iblock[(ii + m * iblock_dim2) * 3 + 2];
		md = iblock[(ii + m * iblock_dim2) * 3 + 3];
		if (m == 1) {
		    goto L80;
		}
		t1prod_(&ldd, &ldt, &ldt, &ldt, &ncolor, &na, &nc, &nb, &ma, &
			mb, &mc, &md, &incb, &incc, &incd, &jd[kk + jd_dim1],
			&jt[kk + jstb * jt_dim1], &jt[ii + jstc * jt_dim1], &
			jt[ii + jstd * jt_dim1], &d__[ist + d_dim1], &t[istb
			+ jstb * t_dim1], &t[istc + jstc * t_dim1], &t[istd +
			jstd * t_dim1]);
		tsumn_(&na, &nc, &nb, &ldd, &ldt, &ldt, &ncolor, &ma, &mb, &
			mc, &md, &incb, &incc, &incd, &jd[kk + jd_dim1], &jt[
			kk + jstb * jt_dim1], &jt[ii + jstc * jt_dim1], &jt[
			ii + jstd * jt_dim1], &d__[ist + d_dim1], &t[istb +
			jstb * t_dim1], &t[istc + jstc * t_dim1], &wksp[istd],
			 &c_b922);
		goto L85;
L80:
		md += iblock[(ii + (iblock_dim2 << 1)) * 3 + 3];
		t1prod_(&ldd, &ldt, &ldt, &ldd, &ncolor, &na, &nc, &nb, &ma, &
			mb, &mc, &md, &incb, &incc, &incd, &jd[kk + jd_dim1],
			&jt[kk + jstb * jt_dim1], &jt[ii + jstc * jt_dim1], &
			jd[ii + jstd * jd_dim1], &d__[ist + d_dim1], &t[istb
			+ jstb * t_dim1], &t[istc + jstc * t_dim1], &d__[istd
			+ jstd * d_dim1]);
L85:
		rowsum_(&ldt, &na, &mb, &t[istb + jstb * t_dim1], &wksp[ip1],
			&c__1);
		bmuln_(&ldd, &na, &ndt, &ndb, &d__[ist + d_dim1], &d__[ist + (
			d_dim1 << 1)], &d__[ist + (ndt + 2) * d_dim1], &wksp[
			ip1], &wksp[ip2]);
		vsubd_(&ldt, &ncolor, &nc, &na, &mc, &t[istc + jstc * t_dim1],
			 &jt[ii + jstc * jt_dim1], &wksp[istd], &wksp[ip2], &
			incc);
L90:
		;
	    }
L95:
	    ;
	}
L100:
	;
    }
    return 0;
} /* ibfcn4_ */

/* Subroutine */ int ibfcs1_(integer *lddd, integer *ldtt, integer *nn,
	integer *jd, integer *jt, doublereal *d__, doublereal *t, integer *
	kblszz, integer *iblock, integer *lbhb, integer *ipropa, doublereal *
	omega, doublereal *wksp, integer *ier)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer k, n, na, ma, mb, mc, md, ldd, jjb, jjc, jjd, ldt, ndt,
	    ist, incb, incc, incd, klim, jstb, istd, jstc, jstd;
    extern /* Subroutine */ int bdfac_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *);
    static integer jdiff, jblkb, jblkc, jblkd;
    extern /* Subroutine */ int bdinv_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *);
    static integer jjlim;
    static logical propa;
    extern /* Subroutine */ int mcopy_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *), t2prod_(integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *);


/* ... ibfcs1 does an incomplete block factorization of the matrix */
/*     contained in d and t (version 1, unmodified). */
/*     symmetric diagonal data structure, natural ordering. */
/*     block ic (version 1) preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         jd       integer vector giving the diagonal numbers */
/*                   for the diagonal block */
/*         jt       integer vector giving the diagonal numbers */
/*                   for the off-diagonal blocks */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         kblsz    block size */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         lbhb     number of blocks per block row */
/*         ipropa   property a switch */
/*                   = 0   matrix does not have block property a */
/*                   = 1   matrix has block property a */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *lddd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldtt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jd;
    --jt;
    iblock -= 4;
    --wksp;

    /* Function Body */
    n = *nn;
    ldd = *lddd;
    ldt = *ldtt;
    na = *kblszz;
    propa = *ipropa == 1;
    klim = n / na;
    ma = iblock[6];
    ndt = ma - 1;

/* ... block tridiagonal case. */

    if (*lbhb > 3) {
	goto L25;
    }
    jblkb = iblock[10];
    mb = iblock[12];
    incb = jblkb * na;
    i__1 = klim;
    for (k = 1; k <= i__1; ++k) {
	ist = (k - 1) * na + 1;
	istd = ist + incb;
	bdfac_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &c__0);
	if (istd > n) {
	    goto L20;
	}
	mcopy_(&ldd, &na, &na, &ma, &d__[ist + d_dim1], &wksp[1]);
	bdinv_(&na, &na, &na, &ndt, &c__0, &wksp[1], &c__0);
	t2prod_(&na, &na, &ldt, &ldt, &ldd, &ma, &mb, &mb, &ma, &incb, &incb,
		&c__0, &jd[1], &jt[1], &jt[1], &jd[1], &wksp[1], &t[ist +
		t_dim1], &t[ist + t_dim1], &d__[istd + d_dim1]);
L20:
	;
    }
    return 0;

/* ... general block structure. */

L25:
    i__1 = klim;
    for (k = 1; k <= i__1; ++k) {
	ist = (k - 1) * na + 1;
	bdfac_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &c__0);
	if (k == klim) {
	    goto L50;
	}
	mcopy_(&ldd, &na, &na, &ma, &d__[ist + d_dim1], &wksp[1]);
	bdinv_(&na, &na, &na, &ndt, &c__0, &wksp[1], &c__0);
/* Computing MIN */
	i__2 = *lbhb, i__3 = klim - k + 2;
	jjlim = min(i__2,i__3);
	i__2 = jjlim;
	for (jjc = 3; jjc <= i__2; ++jjc) {
	    jblkc = iblock[jjc * 3 + 1];
	    jstc = iblock[jjc * 3 + 2];
	    mc = iblock[jjc * 3 + 3];
	    incc = jblkc * na;
	    istd = ist + incc;
	    if (istd > n) {
		goto L45;
	    }
	    i__3 = jjlim;
	    for (jjb = 3; jjb <= i__3; ++jjb) {
		jblkb = iblock[jjb * 3 + 1];
		jstb = iblock[jjb * 3 + 2];
		mb = iblock[jjb * 3 + 3];
		incb = jblkb * na;
		jdiff = jblkb - jblkc;
		if (jdiff < 0) {
		    goto L40;
		}
		if (jdiff != 0 && propa) {
		    goto L40;
		}
		i__4 = jjlim;
		for (jjd = 1; jjd <= i__4; ++jjd) {
		    if (jdiff == iblock[jjd * 3 + 1]) {
			goto L35;
		    }
/* L30: */
		}
		goto L40;
L35:
		jblkd = iblock[jjd * 3 + 1];
		jstd = iblock[jjd * 3 + 2];
		md = iblock[jjd * 3 + 3];
		incd = jblkd * na;
		if (jjd != 1) {
		    t2prod_(&na, &na, &ldt, &ldt, &ldt, &ma, &mb, &mc, &md, &
			    incb, &incc, &incd, &jd[1], &jt[jstb], &jt[jstc],
			    &jt[jstd], &wksp[1], &t[ist + jstb * t_dim1], &t[
			    ist + jstc * t_dim1], &t[istd + jstd * t_dim1]);
		}
		if (jjd == 1) {
		    t2prod_(&na, &na, &ldt, &ldt, &ldd, &ma, &mb, &mc, &md, &
			    incb, &incc, &incd, &jd[1], &jt[jstb], &jt[jstc],
			    &jd[1], &wksp[1], &t[ist + jstb * t_dim1], &t[ist
			    + jstc * t_dim1], &d__[istd + d_dim1]);
		}
L40:
		;
	    }
L45:
	    ;
	}
L50:
	;
    }
    return 0;
} /* ibfcs1_ */

/* Subroutine */ int ibfcs2_(integer *lddd, integer *ldtt, integer *nn,
	integer *jd, integer *jt, doublereal *d__, doublereal *t, integer *
	kblszz, integer *iblock, integer *lbhb, integer *ipropa, doublereal *
	omega, doublereal *wksp, integer *ier)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer k, n, na, ma, mb, mc, md, ldd, jjb, jjc, jjd, ldt, ndt,
	    ist, incb, incc, incd, klim, jstb, istd, jstc, jstd;
    extern /* Subroutine */ int bdfac_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *);
    static integer jdiff, jblkb, jblkc, jblkd;
    extern /* Subroutine */ int bdinv_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *);
    static integer jjlim;
    static logical propa;
    extern /* Subroutine */ int t2prod_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... ibfcs2 does an incomplete block factorization of the matrix */
/*     contained in d and t (version 2, unmodified). */
/*     symmetric diagonal data structure, natural ordering. */
/*     block ic (version 2) preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         jd       integer vector giving the diagonal numbers */
/*                   for the diagonal block */
/*         jt       integer vector giving the diagonal numbers */
/*                   for the off-diagonal blocks */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         kblsz    block size */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         lbhb     number of blocks per block row */
/*         ipropa   property a switch */
/*                   = 0   matrix does not have block property a */
/*                   = 1   matrix has block property a */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *lddd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldtt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jd;
    --jt;
    iblock -= 4;
    --wksp;

    /* Function Body */
    n = *nn;
    ldd = *lddd;
    ldt = *ldtt;
    na = *kblszz;
    propa = *ipropa == 1;
    klim = n / na;
    ma = iblock[6];
    ndt = ma - 1;

/* ... block tridiagonal case. */

    if (*lbhb > 3) {
	goto L25;
    }
    jblkb = iblock[10];
    mb = iblock[12];
    incb = jblkb * na;
    i__1 = klim;
    for (k = 1; k <= i__1; ++k) {
	ist = (k - 1) * na + 1;
	istd = ist + incb;
	bdfac_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &c__0);
	bdinv_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &c__0);
	if (istd > n) {
	    goto L20;
	}
	t2prod_(&na, &ldd, &ldt, &ldt, &ldd, &ma, &mb, &mb, &ma, &incb, &incb,
		 &c__0, &jd[1], &jt[1], &jt[1], &jd[1], &d__[ist + d_dim1], &
		t[ist + t_dim1], &t[ist + t_dim1], &d__[istd + d_dim1]);
L20:
	;
    }
    return 0;

/* ... general block structure. */

L25:
    i__1 = klim;
    for (k = 1; k <= i__1; ++k) {
	ist = (k - 1) * na + 1;
	bdfac_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &c__0);
	bdinv_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &c__0);
	if (k == klim) {
	    goto L50;
	}
/* Computing MIN */
	i__2 = *lbhb, i__3 = klim - k + 2;
	jjlim = min(i__2,i__3);
	i__2 = jjlim;
	for (jjc = 3; jjc <= i__2; ++jjc) {
	    jblkc = iblock[jjc * 3 + 1];
	    jstc = iblock[jjc * 3 + 2];
	    mc = iblock[jjc * 3 + 3];
	    incc = jblkc * na;
	    istd = ist + incc;
	    if (istd > n) {
		goto L45;
	    }
	    i__3 = jjlim;
	    for (jjb = 3; jjb <= i__3; ++jjb) {
		jblkb = iblock[jjb * 3 + 1];
		jstb = iblock[jjb * 3 + 2];
		mb = iblock[jjb * 3 + 3];
		incb = jblkb * na;
		jdiff = jblkb - jblkc;
		if (jdiff < 0) {
		    goto L40;
		}
		if (jdiff != 0 && propa) {
		    goto L40;
		}
		i__4 = jjlim;
		for (jjd = 1; jjd <= i__4; ++jjd) {
		    if (jdiff == iblock[jjd * 3 + 1]) {
			goto L35;
		    }
/* L30: */
		}
		goto L40;
L35:
		jblkd = iblock[jjd * 3 + 1];
		jstd = iblock[jjd * 3 + 2];
		md = iblock[jjd * 3 + 3];
		incd = jblkd * na;
		if (jjd != 1) {
		    t2prod_(&na, &ldd, &ldt, &ldt, &ldt, &ma, &mb, &mc, &md, &
			    incb, &incc, &incd, &jd[1], &jt[jstb], &jt[jstc],
			    &jt[jstd], &d__[ist + d_dim1], &t[ist + jstb *
			    t_dim1], &t[ist + jstc * t_dim1], &t[istd + jstd *
			     t_dim1]);
		}
		if (jjd == 1) {
		    t2prod_(&na, &ldd, &ldt, &ldt, &ldd, &ma, &mb, &mc, &md, &
			    incb, &incc, &incd, &jd[1], &jt[jstb], &jt[jstc],
			    &jd[1], &d__[ist + d_dim1], &t[ist + jstb *
			    t_dim1], &t[ist + jstc * t_dim1], &d__[istd +
			    d_dim1]);
		}
L40:
		;
	    }
L45:
	    ;
	}
L50:
	;
    }
    return 0;
} /* ibfcs2_ */

/* Subroutine */ int ibfcs3_(integer *lddd, integer *ldtt, integer *nn,
	integer *jd, integer *jt, doublereal *d__, doublereal *t, integer *
	kblszz, integer *iblock, integer *lbhb, integer *ipropa, doublereal *
	omegaa, doublereal *wksp, integer *ier)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer k, n, na, ma, mb, mc, md, ip1, ip2, ldd, jjb, jjc, jjd,
	    iii, ldt, ndt, ist, incb, incc, incd, klim, jstb, istd, jstc,
	    jstd;
    extern /* Subroutine */ int tsum_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *, doublereal *), bdfac_(
	    integer *, integer *, integer *, integer *, integer *, doublereal
	    *, integer *);
    static integer jdiff, jblkb, jblkc, jblkd;
    static doublereal omega;
    extern /* Subroutine */ int bdinv_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *), bdsol_(integer *,
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, integer *);
    static integer jjlim, istdd;
    static logical propa;
    extern /* Subroutine */ int mcopy_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *), t2prod_(integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    doublereal *, doublereal *), vsubdt_(integer *, integer *,
	    integer *, integer *, integer *, doublereal *, integer *,
	    doublereal *, doublereal *, integer *), rowsum_(integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *);


/* ... ibfcs3 does an incomplete block factorization of the matrix */
/*     contained in d and t (version 1, modified). */
/*     symmetric diagonal data structure, natural ordering. */
/*     block ic (version 1) preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         jd       integer vector giving the diagonal numbers */
/*                   for the diagonal block */
/*         jt       integer vector giving the diagonal numbers */
/*                   for the off-diagonal blocks */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         kblsz    block size */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         lbhb     number of blocks per block row */
/*         ipropa   property a switch */
/*                   = 0   matrix does not have block property a */
/*                   = 1   matrix has block property a */
/*         omega    relaxation factor between 0. and 1. */
/*                   = 0   no modification */
/*                   = 1   full modification */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *lddd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldtt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jd;
    --jt;
    iblock -= 4;
    --wksp;

    /* Function Body */
    n = *nn;
    ldd = *lddd;
    ldt = *ldtt;
    na = *kblszz;
    omega = *omegaa;
    propa = *ipropa == 1;
    klim = n / na;
    ma = iblock[6];
    ndt = ma - 1;

/* ... block tridiagonal case. */

    if (*lbhb > 3) {
	goto L25;
    }
    ip1 = na * ma + 1;
    ip2 = ip1 + na - 1;
    jblkb = iblock[10];
    mb = iblock[12];
    incb = jblkb * na;
    i__1 = klim;
    for (k = 1; k <= i__1; ++k) {
	ist = (k - 1) * na + 1;
	istd = ist + incb;
	bdfac_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &c__0);
	if (istd > n) {
	    goto L20;
	}
	mcopy_(&ldd, &na, &na, &ma, &d__[ist + d_dim1], &wksp[1]);
	bdinv_(&na, &na, &na, &ndt, &c__0, &wksp[1], &c__0);
	t2prod_(&na, &na, &ldt, &ldt, &ldd, &ma, &mb, &mb, &ma, &incb, &incb,
		&c__0, &jd[1], &jt[1], &jt[1], &jd[1], &wksp[1], &t[ist +
		t_dim1], &t[ist + t_dim1], &d__[istd + d_dim1]);
	tsum_(&na, &na, &ldt, &ldt, &ma, &mb, &mb, &ma, &incb, &incb, &c__0, &
		jd[1], &jt[1], &jt[1], &jd[1], &wksp[1], &t[ist + t_dim1], &t[
		ist + t_dim1], &d__[istd + d_dim1], &d__[istd + d_dim1], &
		wksp[ip1], &c__1, &omega);
	rowsum_(&ldt, &na, &mb, &t[ist + t_dim1], &wksp[ip1], &c__1);
	i__2 = ip2;
	for (iii = ip1; iii <= i__2; ++iii) {
/* L15: */
	    wksp[iii] = omega * wksp[iii];
	}
	bdsol_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &wksp[ip1], &
		wksp[ip1], &c__0);
	vsubdt_(&ldt, &c__1, &na, &na, &mb, &t[ist + t_dim1], &jt[1], &d__[
		istd + d_dim1], &wksp[ip1], &incb);
L20:
	;
    }
    return 0;

/* ... general block structure. */

L25:
    ip1 = na * ma + 1;
    ip2 = ip1 + na - 1;
    i__1 = klim;
    for (k = 1; k <= i__1; ++k) {
	ist = (k - 1) * na + 1;
	bdfac_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &c__0);
	if (k == klim) {
	    goto L60;
	}
	mcopy_(&ldd, &na, &na, &ma, &d__[ist + d_dim1], &wksp[1]);
	bdinv_(&na, &na, &na, &ndt, &c__0, &wksp[1], &c__0);
/* Computing MIN */
	i__2 = *lbhb, i__3 = klim - k + 2;
	jjlim = min(i__2,i__3);
	i__2 = jjlim;
	for (jjc = 3; jjc <= i__2; ++jjc) {
	    jblkc = iblock[jjc * 3 + 1];
	    jstc = iblock[jjc * 3 + 2];
	    mc = iblock[jjc * 3 + 3];
	    incc = jblkc * na;
	    istd = ist + incc;
	    if (istd > n) {
		goto L55;
	    }
	    i__3 = jjlim;
	    for (jjb = 3; jjb <= i__3; ++jjb) {
		jblkb = iblock[jjb * 3 + 1];
		jstb = iblock[jjb * 3 + 2];
		mb = iblock[jjb * 3 + 3];
		incb = jblkb * na;
		istdd = ist + incb;
		if (istdd > n) {
		    goto L50;
		}
		jdiff = jblkb - jblkc;
		if (jdiff < 0) {
		    goto L50;
		}
		if (jdiff != 0 && propa) {
		    goto L40;
		}
		i__4 = jjlim;
		for (jjd = 1; jjd <= i__4; ++jjd) {
		    if (jdiff == iblock[jjd * 3 + 1]) {
			goto L35;
		    }
/* L30: */
		}
		goto L40;
L35:
		jblkd = iblock[jjd * 3 + 1];
		jstd = iblock[jjd * 3 + 2];
		md = iblock[jjd * 3 + 3];
		incd = jblkd * na;
		if (jjd != 1) {
		    t2prod_(&na, &na, &ldt, &ldt, &ldt, &ma, &mb, &mc, &md, &
			    incb, &incc, &incd, &jd[1], &jt[jstb], &jt[jstc],
			    &jt[jstd], &wksp[1], &t[ist + jstb * t_dim1], &t[
			    ist + jstc * t_dim1], &t[istd + jstd * t_dim1]);
		}
		if (jjd == 1) {
		    t2prod_(&na, &na, &ldt, &ldt, &ldd, &ma, &mb, &mc, &md, &
			    incb, &incc, &incd, &jd[1], &jt[jstb], &jt[jstc],
			    &jd[1], &wksp[1], &t[ist + jstb * t_dim1], &t[ist
			    + jstc * t_dim1], &d__[istd + d_dim1]);
		}
		if (jjd != 1) {
		    tsum_(&na, &na, &ldt, &ldt, &ma, &mb, &mc, &md, &incb, &
			    incc, &incd, &jd[1], &jt[jstb], &jt[jstc], &jt[
			    jstd], &wksp[1], &t[ist + jstb * t_dim1], &t[ist
			    + jstc * t_dim1], &d__[istd + d_dim1], &d__[istdd
			    + d_dim1], &wksp[ip1], &c__0, &omega);
		}
		if (jjd == 1) {
		    tsum_(&na, &na, &ldt, &ldt, &ma, &mb, &mc, &md, &incb, &
			    incc, &incd, &jd[1], &jt[jstb], &jt[jstc], &jd[1],
			     &wksp[1], &t[ist + jstb * t_dim1], &t[ist + jstc
			    * t_dim1], &d__[istd + d_dim1], &d__[istdd +
			    d_dim1], &wksp[ip1], &c__1, &omega);
		}

L40:
		rowsum_(&ldt, &na, &mb, &t[ist + jstb * t_dim1], &wksp[ip1], &
			c__1);
		i__4 = ip2;
		for (iii = ip1; iii <= i__4; ++iii) {
/* L42: */
		    wksp[iii] = omega * wksp[iii];
		}
		bdsol_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &wksp[
			ip1], &wksp[ip1], &c__0);
		vsubdt_(&ldt, &c__1, &na, &na, &mc, &t[ist + jstc * t_dim1], &
			jt[jstc], &d__[istd + d_dim1], &wksp[ip1], &incc);
		if (jdiff == 0) {
		    goto L50;
		}
		rowsum_(&ldt, &na, &mc, &t[ist + jstc * t_dim1], &wksp[ip1], &
			c__1);
		i__4 = ip2;
		for (iii = ip1; iii <= i__4; ++iii) {
/* L45: */
		    wksp[iii] = omega * wksp[iii];
		}
		bdsol_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &wksp[
			ip1], &wksp[ip1], &c__0);
		vsubdt_(&ldt, &c__1, &na, &na, &mb, &t[ist + jstb * t_dim1], &
			jt[jstb], &d__[istdd + d_dim1], &wksp[ip1], &incb);
L50:
		;
	    }
L55:
	    ;
	}
L60:
	;
    }
    return 0;
} /* ibfcs3_ */

/* Subroutine */ int ibfcs4_(integer *lddd, integer *ldtt, integer *nn,
	integer *jd, integer *jt, doublereal *d__, doublereal *t, integer *
	kblszz, integer *iblock, integer *lbhb, integer *ipropa, doublereal *
	omegaa, doublereal *wksp, integer *ier)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer k, n, na, ma, mb, ii, mc, md, ip1, ip2, ldd, jjb, jjc, jjd,
	     ldt, ndt, ist, isu, incb, incc, incd, klim;
    extern /* Subroutine */ int bmul_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *);
    static integer jstb, istd, jstc, jstd;
    extern /* Subroutine */ int tsum_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *, doublereal *, integer *, doublereal *), bdfac_(
	    integer *, integer *, integer *, integer *, integer *, doublereal
	    *, integer *);
    static integer jdiff, jblkb, jblkc, jblkd;
    static doublereal omega;
    extern /* Subroutine */ int bdinv_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *);
    static integer jjlim, istdd;
    static logical propa;
    extern /* Subroutine */ int t2prod_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    , ershow_(integer *, char *, ftnlen), vsubdt_(integer *, integer *
	    , integer *, integer *, integer *, doublereal *, integer *,
	    doublereal *, doublereal *, integer *), rowsum_(integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *);


/* ... ibfcs4 does an incomplete block factorization of the matrix */
/*     contained in d and t (version 2, modified). */
/*     symmetric diagonal data structure, natural ordering. */
/*     block ic (version 2) preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         jd       integer vector giving the diagonal numbers */
/*                   for the diagonal block */
/*         jt       integer vector giving the diagonal numbers */
/*                   for the off-diagonal blocks */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         kblsz    block size */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         lbhb     number of blocks per block row */
/*         ipropa   property a switch */
/*                   = 0   matrix does not have block property a */
/*                   = 1   matrix has block property a */
/*         omega    relaxation factor between 0. and 1. */
/*                   = 0   no modification */
/*                   = 1   full modification */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *lddd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldtt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jd;
    --jt;
    iblock -= 4;
    --wksp;

    /* Function Body */
    n = *nn;
    ldd = *lddd;
    ldt = *ldtt;
    na = *kblszz;
    omega = *omegaa;
    propa = *ipropa == 1;
    klim = n / na;
    ma = iblock[6];
    ndt = ma - 1;

/* ... block tridiagonal case. */

    if (*lbhb > 3) {
	goto L25;
    }
    ip1 = n + 1;
    ip2 = ip1 + na;
    jblkb = iblock[10];
    mb = iblock[12];
    incb = jblkb * na;
    rowsum_(&ldd, &n, &ma, &d__[d_offset], &wksp[1], &c__0);
    i__1 = klim;
    for (k = 1; k <= i__1; ++k) {
	ist = (k - 1) * na + 1;
	isu = k * na;
	istd = ist + incb;
	bdfac_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &c__0);
	bdinv_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &c__0);
	bmul_(&ldd, &na, &ndt, &d__[ist + d_dim1], &d__[ist + (d_dim1 << 1)],
		&wksp[ist], &wksp[ip1]);
	i__2 = isu;
	for (ii = ist; ii <= i__2; ++ii) {
	    if (wksp[ii] != 0.) {
		goto L10;
	    }
	    *ier = -12;
	    ershow_(ier, "ibfcs4", (ftnlen)6);
	    return 0;
L10:
	    ;
	}
	i__2 = isu;
	for (ii = ist; ii <= i__2; ++ii) {
/* L15: */
	    d__[ii + d_dim1] += omega * (1. - wksp[ii - ist + ip1]) / wksp[ii]
		    ;
	}
	if (istd > n) {
	    goto L20;
	}
	t2prod_(&na, &ldd, &ldt, &ldt, &ldd, &ma, &mb, &mb, &ma, &incb, &incb,
		 &c__0, &jd[1], &jt[1], &jt[1], &jd[1], &d__[ist + d_dim1], &
		t[ist + t_dim1], &t[ist + t_dim1], &d__[istd + d_dim1]);
	rowsum_(&ldt, &na, &mb, &t[ist + t_dim1], &wksp[ip1], &c__1);
	bmul_(&ldd, &na, &ndt, &d__[ist + d_dim1], &d__[ist + (d_dim1 << 1)],
		&wksp[ip1], &wksp[ip2]);
	vsubdt_(&ldt, &c__1, &na, &na, &mb, &t[ist + t_dim1], &jt[1], &wksp[
		istd], &wksp[ip2], &incb);
L20:
	;
    }
    return 0;

/* ... general block structure. */

L25:
    ip1 = n + 1;
    ip2 = ip1 + na;
    rowsum_(&ldd, &n, &ma, &d__[d_offset], &wksp[1], &c__0);
    i__1 = klim;
    for (k = 1; k <= i__1; ++k) {
	ist = (k - 1) * na + 1;
	isu = k * na;
	bdfac_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &c__0);
	bdinv_(&ldd, &na, &na, &ndt, &c__0, &d__[ist + d_dim1], &c__0);
	bmul_(&ldd, &na, &ndt, &d__[ist + d_dim1], &d__[ist + (d_dim1 << 1)],
		&wksp[ist], &wksp[ip1]);
	i__2 = isu;
	for (ii = ist; ii <= i__2; ++ii) {
	    if (wksp[ii] != 0.) {
		goto L26;
	    }
	    *ier = -12;
	    ershow_(ier, "ibfcs4", (ftnlen)6);
	    return 0;
L26:
	    ;
	}
	i__2 = isu;
	for (ii = ist; ii <= i__2; ++ii) {
/* L27: */
	    d__[ii + d_dim1] += omega * (1. - wksp[ii - ist + ip1]) / wksp[ii]
		    ;
	}
	if (k == klim) {
	    goto L60;
	}
/* Computing MIN */
	i__2 = *lbhb, i__3 = klim - k + 2;
	jjlim = min(i__2,i__3);
	i__2 = jjlim;
	for (jjc = 3; jjc <= i__2; ++jjc) {
	    jblkc = iblock[jjc * 3 + 1];
	    jstc = iblock[jjc * 3 + 2];
	    mc = iblock[jjc * 3 + 3];
	    incc = jblkc * na;
	    istd = ist + incc;
	    if (istd > n) {
		goto L55;
	    }
	    i__3 = jjlim;
	    for (jjb = 3; jjb <= i__3; ++jjb) {
		jblkb = iblock[jjb * 3 + 1];
		jstb = iblock[jjb * 3 + 2];
		mb = iblock[jjb * 3 + 3];
		incb = jblkb * na;
		istdd = ist + incb;
		if (istdd > n) {
		    goto L50;
		}
		jdiff = jblkb - jblkc;
		if (jdiff < 0) {
		    goto L50;
		}
		if (jdiff != 0 && propa) {
		    goto L40;
		}
		i__4 = jjlim;
		for (jjd = 1; jjd <= i__4; ++jjd) {
		    if (jdiff == iblock[jjd * 3 + 1]) {
			goto L35;
		    }
/* L30: */
		}
		goto L40;
L35:
		jblkd = iblock[jjd * 3 + 1];
		jstd = iblock[jjd * 3 + 2];
		md = iblock[jjd * 3 + 3];
		incd = jblkd * na;
		if (jjd != 1) {
		    t2prod_(&na, &ldd, &ldt, &ldt, &ldt, &ma, &mb, &mc, &md, &
			    incb, &incc, &incd, &jd[1], &jt[jstb], &jt[jstc],
			    &jt[jstd], &d__[ist + d_dim1], &t[ist + jstb *
			    t_dim1], &t[ist + jstc * t_dim1], &t[istd + jstd *
			     t_dim1]);
		}
		if (jjd == 1) {
		    t2prod_(&na, &ldd, &ldt, &ldt, &ldd, &ma, &mb, &mc, &md, &
			    incb, &incc, &incd, &jd[1], &jt[jstb], &jt[jstc],
			    &jd[1], &d__[ist + d_dim1], &t[ist + jstb *
			    t_dim1], &t[ist + jstc * t_dim1], &d__[istd +
			    d_dim1]);
		}
		if (jjd != 1) {
		    tsum_(&na, &ldd, &ldt, &ldt, &ma, &mb, &mc, &md, &incb, &
			    incc, &incd, &jd[1], &jt[jstb], &jt[jstc], &jt[
			    jstd], &d__[ist + d_dim1], &t[ist + jstb * t_dim1]
			    , &t[ist + jstc * t_dim1], &wksp[istd], &wksp[
			    istdd], &wksp[ip1], &c__0, &c_b922);
		}

L40:
		rowsum_(&ldt, &na, &mb, &t[ist + jstb * t_dim1], &wksp[ip1], &
			c__1);
		bmul_(&ldd, &na, &ndt, &d__[ist + d_dim1], &d__[ist + (d_dim1
			<< 1)], &wksp[ip1], &wksp[ip2]);
		vsubdt_(&ldt, &c__1, &na, &na, &mc, &t[ist + jstc * t_dim1], &
			jt[jstc], &wksp[istd], &wksp[ip2], &incc);
		if (jdiff == 0) {
		    goto L50;
		}
		rowsum_(&ldt, &na, &mc, &t[ist + jstc * t_dim1], &wksp[ip1], &
			c__1);
		bmul_(&ldd, &na, &ndt, &d__[ist + d_dim1], &d__[ist + (d_dim1
			<< 1)], &wksp[ip1], &wksp[ip2]);
		vsubdt_(&ldt, &c__1, &na, &na, &mb, &t[ist + jstb * t_dim1], &
			jt[jstb], &wksp[istdd], &wksp[ip2], &incb);
L50:
		;
	    }
L55:
	    ;
	}
L60:
	;
    }
    return 0;
} /* ibfcs4_ */

/* Subroutine */ int ibbs_(integer *ldd, integer *ldt, integer *n, integer *
	kblszz, integer *nsize, integer *lbhb, integer *iblock, doublereal *
	d__, doublereal *t, integer *jt, doublereal *x, integer *ivers,
	doublereal *wksp)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, i__1, i__2;

    /* Local variables */
    static integer i__, k, l, jj, nt, ied, inc, mjj, ist, jst, jblk;
    extern /* Subroutine */ int bmul_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *);
    static integer istf;
    static logical vers2;
    extern /* Subroutine */ int bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *);
    static integer jjlim;
    extern /* Subroutine */ int vsubd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);
    static integer kblsz;


/* ... ibbs does an incomplete block backward pass. */
/*     symmetric diagonal data structure, natural ordering. */
/*     block ic preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         kblsz    block size */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         lbhb     number of blocks per block row */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer vector giving the diagonal numbers */
/*                   for the off-diagonal blocks */
/*         x        input/output vector of length n */
/*         ivers    key for version of factorization */
/*                   = 1   version 1 */
/*                   = 2   version 2 */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    iblock -= 4;
    --jt;
    --x;
    --wksp;

    /* Function Body */
    kblsz = *kblszz;
    l = *n / kblsz;
    nt = iblock[6] - 1;
    vers2 = *ivers == 2;
    for (k = l; k >= 1; --k) {
	ist = (k - 1) * kblsz + 1;
	ied = k * kblsz;
	if (k == l) {
	    goto L15;
	}
/* Computing MIN */
	i__1 = *lbhb, i__2 = l - k + 2;
	jjlim = min(i__1,i__2);
	i__1 = jjlim;
	for (jj = 3; jj <= i__1; ++jj) {
	    jblk = iblock[jj * 3 + 1];
	    jst = iblock[jj * 3 + 2];
	    mjj = iblock[jj * 3 + 3];
	    inc = jblk * kblsz;
	    istf = ist + inc;
	    if (istf > *n) {
		goto L10;
	    }
	    vsubd_(ldt, &c__1, &kblsz, &kblsz, &mjj, &t[ist + jst * t_dim1], &
		    jt[jst], &x[ist], &x[istf], &inc);
L10:
	    ;
	}
L15:
	if (nt >= 1) {
	    goto L25;
	}
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L20: */
	    x[i__] = d__[i__ + d_dim1] * x[i__];
	}
	goto L40;
L25:
	if (vers2) {
	    goto L30;
	}
	bdsol_(ldd, &kblsz, nsize, &nt, &c__0, &d__[ist + d_dim1], &x[ist], &
		x[ist], &c__0);
	goto L40;
L30:
	bmul_(ldd, &kblsz, &nt, &d__[ist + d_dim1], &d__[ist + (d_dim1 << 1)],
		 &x[ist], &wksp[1]);
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L35: */
	    x[i__] = wksp[i__ - ist + 1];
	}
L40:
	;
    }
    return 0;
} /* ibbs_ */

/* Subroutine */ int ibbsn_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *x, integer *ivers, integer *iunif, doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, j, k, l, na, nb, mb, kk, lm1, ied, ndb, inc, ndt, ist,
	     nap1, jcol, jlim;
    static logical unif;
    static integer jstb, istb;
    static logical vers2;
    extern /* Subroutine */ int vaddd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *), bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *), bmuln_(integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *);


/* ... ibbsn does an incomplete block backward solve. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         x        input/output vector of length n */
/*         ivers    key for version number */
/*                   = 1  version 1 */
/*                   = 2  version 2 */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --x;
    --wksp;

    /* Function Body */
    vers2 = *ivers == 2;
    unif = *iunif == 1;

    l = *ncolor;
    if (! unif) {
	goto L10;
    }
    na = nci[1];
    nb = na;
    jlim = lbhb[1];
    l = *n / na;
    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    kk = 1;

/* ... do backward solution. */

L10:
    lm1 = l - 1;
    for (k = lm1; k >= 1; --k) {
	if (unif) {
	    goto L15;
	}
	kk = k;
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	goto L20;
L15:
	ist = (k - 1) * na + 1;
L20:
	ied = ist + na - 1;
	i__1 = na;
	for (i__ = 1; i__ <= i__1; ++i__) {
/* L22: */
	    wksp[i__] = 0.;
	}
	i__1 = jlim;
	for (j = 3; j <= i__1; ++j) {
	    jcol = k + iblock[(kk + j * iblock_dim2) * 3 + 1];
	    if (jcol <= k) {
		goto L25;
	    }
	    jstb = iblock[(kk + j * iblock_dim2) * 3 + 2];
	    mb = iblock[(kk + j * iblock_dim2) * 3 + 3];
	    if (unif) {
		inc = (jcol - k) * na;
	    }
	    if (! unif) {
		inc = ipt[jcol] - ipt[k];
	    }
	    if (! unif) {
		nb = nci[jcol];
	    }
	    istb = ist + inc;
	    if (istb > *n) {
		goto L25;
	    }
	    vaddd_(ldt, ncolor, &na, &nb, &mb, &t[ist + jstb * t_dim1], &jt[
		    kk + jstb * jt_dim1], &wksp[1], &x[istb], &inc);
L25:
	    ;
	}
	if (ndt + ndb >= 1) {
	    goto L35;
	}
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L30: */
	    x[i__] -= d__[i__ + d_dim1] * wksp[i__ - ist + 1];
	}
	goto L50;
L35:
	if (vers2) {
	    goto L40;
	}
	bdsol_(ldd, &na, nsize, &ndt, &ndb, &d__[ist + d_dim1], &wksp[1], &
		wksp[1], &c__1);
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L37: */
	    x[i__] -= wksp[i__ - ist + 1];
	}
	goto L50;
L40:
	nap1 = na + 1;
	bmuln_(ldd, &na, &ndt, &ndb, &d__[ist + d_dim1], &d__[ist + (d_dim1 <<
		 1)], &d__[ist + (ndt + 2) * d_dim1], &wksp[1], &wksp[nap1]);
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L45: */
	    x[i__] -= wksp[i__ - ist + nap1];
	}
L50:
	;
    }
    return 0;
} /* ibbsn_ */

/* Subroutine */ int ibbsnt_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *x, integer *ivers, integer *iunif, doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, j, k, l, na, nb, mb, kk, ied, ndb, inc, ndt, ist,
	    jcol, jlim;
    static logical unif;
    static integer jstb, istb;
    static logical vers1;
    extern /* Subroutine */ int bdsolt_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *),
	    bmulnt_(integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *), vsubdt_(
	    integer *, integer *, integer *, integer *, integer *, doublereal
	    *, integer *, doublereal *, doublereal *, integer *);


/* ... ibbsnt does an incomplete block transpose backward solve. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         x        input/output vector of length n */
/*         ivers    key for version number */
/*                   = 1  version 1 */
/*                   = 2  version 2 */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --x;
    --wksp;

    /* Function Body */
    vers1 = *ivers == 1;
    unif = *iunif == 1;

    l = *ncolor;
    if (! unif) {
	goto L10;
    }
    na = nci[1];
    nb = na;
    jlim = lbhb[1];
    l = *n / na;
    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    kk = 1;

/* ... do backward solution. */

L10:
    for (k = l; k >= 1; --k) {
	if (unif) {
	    goto L15;
	}
	kk = k;
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	goto L20;
L15:
	ist = (k - 1) * na + 1;
L20:
	ied = ist + na - 1;
	if (ndt + ndb >= 1) {
	    goto L30;
	}
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L25: */
	    x[i__] = d__[i__ + d_dim1] * x[i__];
	}
	goto L35;
L30:
	if (vers1) {
	    bdsolt_(ldd, &na, nsize, &ndt, &ndb, &d__[ist + d_dim1], &x[ist],
		    &x[ist]);
	}
	if (vers1) {
	    goto L35;
	}
	bmulnt_(ldd, &na, &ndt, &ndb, &d__[ist + d_dim1], &d__[ist + (d_dim1
		<< 1)], &d__[ist + (ndt + 2) * d_dim1], &x[ist], &wksp[1]);
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L32: */
	    x[i__] = wksp[i__ - ist + 1];
	}
L35:
	i__1 = jlim;
	for (j = 3; j <= i__1; ++j) {
	    jcol = k + iblock[(kk + j * iblock_dim2) * 3 + 1];
	    if (jcol >= k) {
		goto L40;
	    }
	    jstb = iblock[(kk + j * iblock_dim2) * 3 + 2];
	    mb = iblock[(kk + j * iblock_dim2) * 3 + 3];
	    if (unif) {
		inc = (jcol - k) * na;
	    }
	    if (! unif) {
		inc = ipt[jcol] - ipt[k];
	    }
	    if (! unif) {
		nb = nci[jcol];
	    }
	    istb = ist + inc;
	    if (istb < 1) {
		goto L40;
	    }
	    vsubdt_(ldt, ncolor, &na, &nb, &mb, &t[ist + jstb * t_dim1], &jt[
		    kk + jstb * jt_dim1], &x[istb], &x[ist], &inc);
L40:
	    ;
	}
/* L45: */
    }
    return 0;
} /* ibbsnt_ */

/* Subroutine */ int ibfs_(integer *ldd, integer *ldt, integer *n, integer *
	kblszz, integer *nsize, integer *lbhb, integer *iblock, doublereal *
	d__, doublereal *t, integer *jt, doublereal *x, integer *ivers,
	doublereal *wksp)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, k, l, jj, nt, lm1, ied, inc, mjj, ist, jst, jblk;
    extern /* Subroutine */ int bmul_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *);
    static integer istf;
    static logical vers1, vers2;
    extern /* Subroutine */ int bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *);
    static integer jjlim, kblsz;
    extern /* Subroutine */ int vsubdt_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);


/* ... ibfs does an incomplete block forward pass. */
/*     symmetric diagonal data structure, natural ordering. */
/*     block ic preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         kblsz    block size */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         lbhb     number of blocks per block row */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer vector giving the diagonal numbers */
/*                   for the off-diagonal blocks */
/*         x        input/output vector of length n */
/*         ivers    key for version of factorization */
/*                   = 1   version 1 */
/*                   = 2   version 2 */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    iblock -= 4;
    --jt;
    --x;
    --wksp;

    /* Function Body */
    kblsz = *kblszz;
    l = *n / kblsz;
    lm1 = l - 1;
    nt = iblock[6] - 1;
    vers1 = *ivers == 1;
    vers2 = *ivers == 2;
    i__1 = lm1;
    for (k = 1; k <= i__1; ++k) {
	ist = (k - 1) * kblsz + 1;
	ied = k * kblsz;
	if (nt >= 1) {
	    goto L15;
	}
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L10: */
	    wksp[i__ - ist + 1] = d__[i__ + d_dim1] * x[i__];
	}
	goto L20;
L15:
	if (vers1) {
	    bdsol_(ldd, &kblsz, nsize, &nt, &c__0, &d__[ist + d_dim1], &x[ist]
		    , &wksp[1], &c__0);
	}
	if (vers2) {
	    bmul_(ldd, &kblsz, &nt, &d__[ist + d_dim1], &d__[ist + (d_dim1 <<
		    1)], &x[ist], &wksp[1]);
	}
L20:
/* Computing MIN */
	i__2 = *lbhb, i__3 = l - k + 2;
	jjlim = min(i__2,i__3);
	i__2 = jjlim;
	for (jj = 3; jj <= i__2; ++jj) {
	    jblk = iblock[jj * 3 + 1];
	    jst = iblock[jj * 3 + 2];
	    mjj = iblock[jj * 3 + 3];
	    inc = jblk * kblsz;
	    istf = ist + inc;
	    if (istf > *n) {
		goto L25;
	    }
	    vsubdt_(ldt, &c__1, &kblsz, &kblsz, &mjj, &t[ist + jst * t_dim1],
		    &jt[jst], &x[istf], &wksp[1], &inc);
L25:
	    ;
	}
/* L30: */
    }
    return 0;
} /* ibfs_ */

/* Subroutine */ int ibfsn_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *x, integer *ivers, integer *iunif, doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, k, l, na, nb, mb, kk, ied, ndb, inc, ndt, ist,
	    jcol, jlim;
    static logical unif;
    static integer jstb, istb;
    static logical vers2;
    extern /* Subroutine */ int bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *), bmuln_(integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *), vsubd_(integer *, integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    integer *);


/* ... ibfsn does an incomplete block forward solve. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         x        input/output vector of length n */
/*         ivers    key for version number */
/*                   = 1  version 1 */
/*                   = 2  version 2 */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --x;
    --wksp;

    /* Function Body */
    vers2 = *ivers == 2;
    unif = *iunif == 1;

    l = *ncolor;
    if (! unif) {
	goto L10;
    }
    na = nci[1];
    nb = na;
    jlim = lbhb[1];
    l = *n / na;
    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    kk = 1;

/* ... do forward solution. */

L10:
    i__1 = l;
    for (k = 1; k <= i__1; ++k) {
	if (unif) {
	    goto L15;
	}
	kk = k;
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	goto L20;
L15:
	ist = (k - 1) * na + 1;
L20:
	ied = ist + na - 1;
	i__2 = jlim;
	for (j = 3; j <= i__2; ++j) {
	    jcol = k + iblock[(kk + j * iblock_dim2) * 3 + 1];
	    if (jcol >= k) {
		goto L25;
	    }
	    jstb = iblock[(kk + j * iblock_dim2) * 3 + 2];
	    mb = iblock[(kk + j * iblock_dim2) * 3 + 3];
	    if (unif) {
		inc = (jcol - k) * na;
	    }
	    if (! unif) {
		inc = ipt[jcol] - ipt[k];
	    }
	    if (! unif) {
		nb = nci[jcol];
	    }
	    istb = ist + inc;
	    if (istb < 1) {
		goto L25;
	    }
	    vsubd_(ldt, ncolor, &na, &nb, &mb, &t[ist + jstb * t_dim1], &jt[
		    kk + jstb * jt_dim1], &x[ist], &x[istb], &inc);
L25:
	    ;
	}
	if (ndt + ndb >= 1) {
	    goto L35;
	}
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L30: */
	    x[i__] = d__[i__ + d_dim1] * x[i__];
	}
	goto L50;
L35:
	if (vers2) {
	    goto L40;
	}
	bdsol_(ldd, &na, nsize, &ndt, &ndb, &d__[ist + d_dim1], &x[ist], &x[
		ist], &c__1);
	goto L50;
L40:
	bmuln_(ldd, &na, &ndt, &ndb, &d__[ist + d_dim1], &d__[ist + (d_dim1 <<
		 1)], &d__[ist + (ndt + 2) * d_dim1], &x[ist], &wksp[1]);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L45: */
	    x[i__] = wksp[i__ - ist + 1];
	}
L50:
	;
    }
    return 0;
} /* ibfsn_ */

/* Subroutine */ int ibfsnt_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *x, integer *ivers, integer *iunif, doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, k, l, na, nb, mb, kk, lm1, ied, ndb, inc, ndt, ist,
	     jcol, jlim;
    static logical unif;
    static integer jstb, istb;
    static logical vers1, vers2;
    extern /* Subroutine */ int bdsolt_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *),
	    bmulnt_(integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *), vsubdt_(
	    integer *, integer *, integer *, integer *, integer *, doublereal
	    *, integer *, doublereal *, doublereal *, integer *);


/* ... ibfsnt does an incomplete block transpose forward solve. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         x        input/output vector of length n */
/*         ivers    key for version number */
/*                   = 1  version 1 */
/*                   = 2  version 2 */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --x;
    --wksp;

    /* Function Body */
    vers1 = *ivers == 1;
    vers2 = *ivers == 2;
    unif = *iunif == 1;

    l = *ncolor;
    if (! unif) {
	goto L10;
    }
    na = nci[1];
    nb = na;
    jlim = lbhb[1];
    l = *n / na;
    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    kk = 1;

/* ... do forward solution. */

L10:
    lm1 = l - 1;
    i__1 = lm1;
    for (k = 1; k <= i__1; ++k) {
	if (unif) {
	    goto L15;
	}
	kk = k;
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	goto L20;
L15:
	ist = (k - 1) * na + 1;
L20:
	ied = ist + na - 1;
	if (ndt + ndb >= 1) {
	    goto L30;
	}
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L25: */
	    wksp[i__ - ist + 1] = d__[i__ + d_dim1] * x[i__];
	}
	goto L35;
L30:
	if (vers1) {
	    bdsolt_(ldd, &na, nsize, &ndt, &ndb, &d__[ist + d_dim1], &x[ist],
		    &wksp[1]);
	}
	if (vers2) {
	    bmulnt_(ldd, &na, &ndt, &ndb, &d__[ist + d_dim1], &d__[ist + (
		    d_dim1 << 1)], &d__[ist + (ndt + 2) * d_dim1], &x[ist], &
		    wksp[1]);
	}
L35:
	i__2 = jlim;
	for (j = 3; j <= i__2; ++j) {
	    jcol = k + iblock[(kk + j * iblock_dim2) * 3 + 1];
	    if (jcol <= k) {
		goto L40;
	    }
	    jstb = iblock[(kk + j * iblock_dim2) * 3 + 2];
	    mb = iblock[(kk + j * iblock_dim2) * 3 + 3];
	    if (unif) {
		inc = (jcol - k) * na;
	    }
	    if (! unif) {
		inc = ipt[jcol] - ipt[k];
	    }
	    if (! unif) {
		nb = nci[jcol];
	    }
	    istb = ist + inc;
	    if (istb > *n) {
		goto L40;
	    }
	    vsubdt_(ldt, ncolor, &na, &nb, &mb, &t[ist + jstb * t_dim1], &jt[
		    kk + jstb * jt_dim1], &x[istb], &wksp[1], &inc);
L40:
	    ;
	}
/* L45: */
    }
    return 0;
} /* ibfsnt_ */

/* Subroutine */ int ibsl_(integer *ldd, integer *ldt, integer *n, integer *
	kblsz, integer *nsize, integer *lbhb, integer *iblock, doublereal *
	d__, doublereal *t, integer *jt, doublereal *y, doublereal *x,
	integer *ivers, doublereal *wksp)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int ibbs_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, integer *, doublereal *, integer *, doublereal *),
	    ibfs_(integer *, integer *, integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *, integer *, doublereal *);


/* ... ibsl does an incomplete block solution. */
/*     symmetric diagonal data structure, natural ordering. */
/*     block ic preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         kblsz    block size */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         lbhb     number of blocks per block row */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer vector giving the diagonal numbers */
/*                   for the off-diagonal blocks */
/*         y        input vector for the right-hand-side */
/*         x        output vector for the solution to q*x = y */
/*         ivers    key for version of factorization */
/*                   = 1   version 1 */
/*                   = 2   version 2 */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    iblock -= 4;
    --jt;
    --y;
    --x;
    --wksp;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    ibfs_(ldd, ldt, n, kblsz, nsize, lbhb, &iblock[4], &d__[d_offset], &t[
	    t_offset], &jt[1], &x[1], ivers, &wksp[1]);
    ibbs_(ldd, ldt, n, kblsz, nsize, lbhb, &iblock[4], &d__[d_offset], &t[
	    t_offset], &jt[1], &x[1], ivers, &wksp[1]);
    return 0;
} /* ibsl_ */

/* Subroutine */ int ibsln_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *y, doublereal *x, integer *ivers, integer *iunif,
	doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int ibbsn_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, integer *,
	    integer *, doublereal *), ibfsn_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... ibsln does an incomplete block solution. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         y        input vector of length n containing right-hand-side */
/*         x        output vector containing the solution to q*x = y */
/*         ivers    key for version number */
/*                   = 1  version 1 */
/*                   = 2  version 2 */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --y;
    --x;
    --wksp;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    ibfsn_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], ivers, iunif, &wksp[1]);
    ibbsn_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], ivers, iunif, &wksp[1]);
    return 0;
} /* ibsln_ */

/* Subroutine */ int ibslnt_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *y, doublereal *x, integer *ivers, integer *iunif,
	doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int ibbsnt_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, integer *,
	    integer *, doublereal *), ibfsnt_(integer *, integer *, integer *,
	     integer *, integer *, integer *, integer *, integer *, integer *,
	     doublereal *, doublereal *, integer *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... ibslnt does an incomplete block transpose solution. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         y        input vector of length n containing right-hand-side */
/*         x        output vector containing the solution to q*x = y */
/*         ivers    key for version number */
/*                   = 1  version 1 */
/*                   = 2  version 2 */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --y;
    --x;
    --wksp;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    ibfsnt_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], ivers, iunif, &wksp[1]);
    ibbsnt_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], ivers, iunif, &wksp[1]);
    return 0;
} /* ibslnt_ */

/* Subroutine */ int ibsln1_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *y, doublereal *x, integer *ivers, integer *iunif,
	doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int ibfsn_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... ibsln1 does an incomplete block forward pass. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         y        input vector of length n containing right-hand-side */
/*         x        output vector containing the solution to q*x = y */
/*         ivers    key for version number */
/*                   = 1  version 1 */
/*                   = 2  version 2 */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --y;
    --x;
    --wksp;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    ibfsn_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], ivers, iunif, &wksp[1]);
    return 0;
} /* ibsln1_ */

/* Subroutine */ int ibsln2_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *y, doublereal *x, integer *ivers, integer *iunif,
	doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int ibbsn_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... ibsln2 does an incomplete block backward pass. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         y        input vector of length n containing right-hand-side */
/*         x        output vector containing the solution to q*x = y */
/*         ivers    key for version number */
/*                   = 1  version 1 */
/*                   = 2  version 2 */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --y;
    --x;
    --wksp;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    ibbsn_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], ivers, iunif, &wksp[1]);
    return 0;
} /* ibsln2_ */

/* Subroutine */ int ibsln3_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *y, doublereal *x, integer *ivers, integer *iunif,
	doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int ibbsnt_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... ibsln3 does an incomplete block transpose back solve. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         y        input vector of length n containing right-hand-side */
/*         x        output vector containing the solution to q*x = y */
/*         ivers    key for version number */
/*                   = 1  version 1 */
/*                   = 2  version 2 */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --y;
    --x;
    --wksp;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    ibbsnt_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], ivers, iunif, &wksp[1]);
    return 0;
} /* ibsln3_ */

/* Subroutine */ int ibsln4_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *y, doublereal *x, integer *ivers, integer *iunif,
	doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int ibfsnt_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... ibsln4 does an incomplete block transpose forward pass. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ic preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         y        input vector of length n containing right-hand-side */
/*         x        output vector containing the solution to q*x = y */
/*         ivers    key for version number */
/*                   = 1  version 1 */
/*                   = 2  version 2 */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --y;
    --x;
    --wksp;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    ibfsnt_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], ivers, iunif, &wksp[1]);
    return 0;
} /* ibsln4_ */

/* Subroutine */ int icf_(integer *ndim, integer *nn, integer *maxtt, integer
	*jt, doublereal *d__, doublereal *t, integer *meth, integer *ipropa,
	doublereal *omega, doublereal *wksp, integer *iwksp, integer *iflag)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1, i__2, i__3;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, k, n, id, kf, kg, nm1, kff, len, nbig, iloc;
    static doublereal term;
    static integer maxt;
    extern doublereal vmin_(integer *, doublereal *);
    static logical propa;
    static doublereal pivot;


/* ... icf computes an incomplete factorization of the matrix */
/*     stored in d and t and replaces it. */
/*     (symmetric diagonal storage) */

/* ... parameters -- */

/*          ndim   row dimension of t array */
/*          n      order of system (= nn) */
/*          maxt   number of columns in t array */
/*          jt     integer vector giving the diagonal indices of */
/*                  the corresponding columns in t */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          t      array of active size n by maxt giving the */
/*                  super-diagonals of the matrix */
/*          meth   point factorization wanted */
/*                  = 1   ic */
/*                  = 2   mic */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          omega  modification factor between 0.0 and 1.0 */
/*                  = 0     no modification */
/*                  = 1     full modification */
/*          wksp   workspace vector of length n */
/*          iwksp  integer workspace of length maxt**2 */
/*          iflag  indicator of factorization stability */
/*                    iflag = 0    no errors detected */
/*                          = 1    zero pivot encountered */
/*                                 (unsuccessful factorization) */
/*                          = 2    negative pivot encountered */
/*                                 (successful factorization) */

/* ... specifications for parameters */



    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --wksp;
    --iwksp;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    *iflag = 0;
    propa = *ipropa == 1;
    if (maxt < 1) {
	goto L500;
    }
    nm1 = n - 1;
    if (*meth != 1 || ! propa) {
	goto L20;
    }

/* ... ic, propa = t. */

    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	pivot = d__[k];
	if (pivot == 0.) {
	    goto L995;
	}
	i__2 = maxt;
	for (j = 1; j <= i__2; ++j) {
	    kf = k + jt[j];
	    if (kf <= n) {
/* Computing 2nd power */
		d__1 = t[k + j * t_dim1];
		d__[kf] -= d__1 * d__1 / pivot;
	    }
/* L10: */
	}
/* L15: */
    }
    if (d__[n] == 0.) {
	goto L995;
    }
    goto L500;
L20:
    if (*meth != 2 || ! propa) {
	goto L50;
    }

/* ... mic, propa = t. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	wksp[i__] = 0.;
    }
    i__1 = maxt;
    for (j = 1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L30: */
	    wksp[i__] += t[i__ + j * t_dim1];
	}
/* L35: */
    }
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	pivot = d__[k];
	if (pivot == 0.) {
	    goto L995;
	}
	i__2 = maxt;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    kf = k + jt[i__];
	    if (kf > n) {
		goto L40;
	    }
	    term = t[k + i__ * t_dim1] / pivot;
	    d__[kf] -= term * (*omega * wksp[k] - (*omega - 1.) * t[k + i__ *
		    t_dim1]);
L40:
	    ;
	}
/* L45: */
    }
    if (d__[n] == 0.) {
	goto L995;
    }
    goto L500;

/* ... ic, mic for propa = f. */

L50:
    nbig = maxt + 1;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = maxt;
	for (j = i__; j <= i__2; ++j) {
	    if (j == i__) {
		goto L65;
	    }
	    iloc = (j - 1) * maxt + i__;
	    id = (i__3 = jt[j] - jt[i__], abs(i__3));
	    i__3 = maxt;
	    for (k = 1; k <= i__3; ++k) {
		if (jt[k] != id) {
		    goto L60;
		}
		iwksp[iloc] = k;
		goto L65;
L60:
		;
	    }
	    iwksp[iloc] = nbig;
L65:
	    ;
	}
/* L70: */
    }
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	pivot = d__[k];
	if (pivot == 0.) {
	    goto L995;
	}
	i__2 = maxt;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    kf = k + jt[i__];
	    if (kf > n) {
		goto L95;
	    }
	    i__3 = maxt;
	    for (j = i__; j <= i__3; ++j) {
/* L75: */
		wksp[j] = t[k + i__ * t_dim1] * t[k + j * t_dim1] / pivot;
	    }
	    d__[kf] -= wksp[i__];
	    i__3 = maxt;
	    for (j = i__; j <= i__3; ++j) {
		if (j == i__) {
		    goto L90;
		}
		kg = k + jt[j];
		if (kg > n) {
		    goto L90;
		}
		iloc = (j - 1) * maxt + i__;
		id = iwksp[iloc];
		if (id == nbig) {
		    goto L85;
		}
		kff = min(kf,kg);
		t[kff + id * t_dim1] -= wksp[j];
		goto L90;
L85:
		if (*meth == 1) {
		    goto L90;
		}
		d__[kf] -= *omega * wksp[j];
		d__[kg] -= *omega * wksp[j];
L90:
		;
	    }
L95:
	    ;
	}
/* L100: */
    }
    if (d__[n] == 0.) {
	goto L995;
    }

/* ... store reciprocals of pivots. */

L500:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L505: */
	d__[i__] = 1. / d__[i__];
    }
    if (maxt < 1 || propa) {
	goto L990;
    }
    i__1 = maxt;
    for (j = 1; j <= i__1; ++j) {
	len = n - jt[j];
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L510: */
	    t[i__ + j * t_dim1] = d__[i__] * t[i__ + j * t_dim1];
	}
/* L515: */
    }

/* ... check for negative pivots. */

L990:
    if (vmin_(&n, &d__[1]) < 0.) {
	*iflag = 2;
    }
    return 0;

/* ... error - matrix cannot be factored since a pivot is zero */

L995:
    *iflag = 1;
    return 0;
} /* icf_ */

/* Subroutine */ int icfn_(integer *ndim, integer *nn, integer *maxtt,
	integer *maxbb, integer *jt, integer *jb, doublereal *d__, doublereal
	*t, doublereal *b, integer *meth, integer *ipropa, doublereal *omega,
	doublereal *wksp, integer *iwksp, integer *iflag)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, n, i1, i2;
    static doublereal t1;
    static integer id, kf, nm1, mid, ind, len, nbig, iloc, maxb, nval;
    static doublereal term;
    static integer maxt;
    extern doublereal vmin_(integer *, doublereal *);
    static logical propa;
    static doublereal pivot;


/* ... icfn computes an incomplete factorization of the matrix */
/*     stored in d, t, and b and replaces it. */
/*     (nonsymmetric diagonal storage) */

/* ... parameters -- */

/*          ndim   row dimension of t,b arrays */
/*          n      order of system (= nn) */
/*          maxt   number of columns in t array */
/*          maxb   number of columns in b array */
/*          jt     integer vector giving the diagonal indices of */
/*                  the corresponding columns in t */
/*          jb     integer vector giving the diagonal indices of */
/*                  the corresponding columns in b */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          t      array of active size n by maxt giving the */
/*                  super-diagonals of the matrix */
/*          b      array of active size n by maxb giving the */
/*                  sub-diagonals of the matrix */
/*          meth   point factorization wanted */
/*                  = 1   ic */
/*                  = 2   mic */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          omega  modification factor between 0.0 and 1.0 */
/*                  = 0     no modification */
/*                  = 1     full modification */
/*          wksp   workspace vector of length n */
/*          iwksp  integer workspace of length maxb*maxt */
/*          iflag  indicator of factorization stability */
/*                    iflag = 0    no errors detected */
/*                          = 1    zero pivot encountered */
/*                                 (unsuccessful factorization) */
/*                          = 2    negative pivot encountered */
/*                                 (successful factorization) */

/* ... specifications for parameters */



    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --jb;
    --d__;
    --wksp;
    --iwksp;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    maxb = *maxbb;
    *iflag = 0;
    propa = *ipropa == 1;
    if (maxt < 1 || maxb < 1) {
	goto L500;
    }
    nm1 = n - 1;
    if (*meth != 1 || ! propa) {
	goto L30;
    }

/* ... ic, propa = t. */

    nval = 0;
    i__1 = maxb;
    for (j = 1; j <= i__1; ++j) {
	i1 = -jb[j];
	i__2 = maxt;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    i2 = jt[i__];
	    if (i1 != i2) {
		goto L10;
	    }
	    ++nval;
	    iwksp[nval * 3 - 2] = j;
	    iwksp[nval * 3 - 1] = i__;
	    iwksp[nval * 3] = i2;
	    goto L15;
L10:
	    ;
	}
L15:
	;
    }
    if (nval == 0) {
	goto L500;
    }
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	pivot = d__[k];
	if (pivot == 0.) {
	    goto L995;
	}
	i__2 = nval;
	for (j = 1; j <= i__2; ++j) {
	    kf = k + iwksp[j * 3];
	    if (kf > n) {
		goto L20;
	    }
	    i1 = iwksp[j * 3 - 2];
	    i2 = iwksp[j * 3 - 1];
	    d__[kf] -= b[kf + i1 * b_dim1] * t[k + i2 * t_dim1] / pivot;
L20:
	    ;
	}
/* L25: */
    }
    if (d__[n] == 0.) {
	goto L995;
    }
    goto L500;
L30:
    if (*meth != 2 || ! propa) {
	goto L70;
    }

/* ... mic, propa = t. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L35: */
	wksp[i__] = 0.;
    }
    i__1 = maxt;
    for (j = 1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L40: */
	    wksp[i__] += t[i__ + j * t_dim1];
	}
/* L45: */
    }
    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i1 = -jb[i__];
	i__2 = maxt;
	for (j = 1; j <= i__2; ++j) {
	    i2 = jt[j];
	    if (i1 != i2) {
		goto L50;
	    }
	    iwksp[i__] = j;
	    goto L55;
L50:
	    ;
	}
	iwksp[i__] = 0;
L55:
	;
    }
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	pivot = d__[k];
	if (pivot == 0.) {
	    goto L995;
	}
	i__2 = maxb;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    kf = k - jb[i__];
	    if (kf > n) {
		goto L60;
	    }
	    term = b[kf + i__ * b_dim1] / pivot;
	    t1 = 0.;
	    i1 = iwksp[i__];
	    if (i1 != 0) {
		t1 = t[k + i1 * t_dim1];
	    }
	    d__[kf] -= term * (*omega * wksp[k] - (*omega - 1.) * t1);
L60:
	    ;
	}
/* L65: */
    }
    if (d__[n] == 0.) {
	goto L995;
    }
    goto L500;

/* ... ic, mic for propa = f. */

L70:
    nbig = maxt + maxb;
    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = maxt;
	for (j = 1; j <= i__2; ++j) {
	    iloc = (j - 1) * maxb + i__;
	    id = jt[j] + jb[i__];
	    if (id < 0) {
		goto L75;
	    } else if (id == 0) {
		goto L85;
	    } else {
		goto L90;
	    }
L75:
	    i__3 = maxb;
	    for (k = 1; k <= i__3; ++k) {
		if (jb[k] != id) {
		    goto L80;
		}
		iwksp[iloc] = -k;
		goto L100;
L80:
		;
	    }
	    iwksp[iloc] = nbig;
	    goto L100;
L85:
	    iwksp[iloc] = 0;
	    goto L100;
L90:
	    i__3 = maxt;
	    for (k = 1; k <= i__3; ++k) {
		if (jt[k] != id) {
		    goto L95;
		}
		iwksp[iloc] = k;
		goto L100;
L95:
		;
	    }
	    iwksp[iloc] = nbig;
L100:
	    ;
	}
/* L105: */
    }
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	pivot = d__[k];
	if (pivot == 0.) {
	    goto L995;
	}
	i__2 = maxb;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    kf = k - jb[i__];
	    if (kf > n) {
		goto L135;
	    }
	    i__3 = maxt;
	    for (j = 1; j <= i__3; ++j) {
/* L110: */
		wksp[j] = b[kf + i__ * b_dim1] * t[k + j * t_dim1] / pivot;
	    }
	    i__3 = maxt;
	    for (j = 1; j <= i__3; ++j) {
		iloc = (j - 1) * maxb + i__;
		id = iwksp[iloc];
		if (id < 0) {
		    goto L115;
		} else if (id == 0) {
		    goto L120;
		} else {
		    goto L125;
		}
L115:
		mid = -id;
		b[kf + mid * b_dim1] -= wksp[j];
		goto L130;
L120:
		d__[kf] -= wksp[j];
		goto L130;
L125:
		if (id != nbig) {
		    t[kf + id * t_dim1] -= wksp[j];
		}
		if (id == nbig && *meth == 2) {
		    d__[kf] -= *omega * wksp[j];
		}
L130:
		;
	    }
L135:
	    ;
	}
/* L140: */
    }
    if (d__[n] == 0.) {
	goto L995;
    }

/* ... store reciprocals of pivots. */

L500:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L505: */
	d__[i__] = 1. / d__[i__];
    }
    if (maxt < 1 || propa) {
	goto L520;
    }
    i__1 = maxt;
    for (j = 1; j <= i__1; ++j) {
	len = n - jt[j];
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L510: */
	    t[i__ + j * t_dim1] = d__[i__] * t[i__ + j * t_dim1];
	}
/* L515: */
    }
L520:
    if (maxb < 1 || propa) {
	goto L990;
    }
    i__1 = maxb;
    for (j = 1; j <= i__1; ++j) {
	ind = jb[j];
	len = n + ind;
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L525: */
	    b[i__ - ind + j * b_dim1] = d__[i__] * b[i__ - ind + j * b_dim1];
	}
/* L530: */
    }

/* ... check for negative pivots. */

L990:
    if (vmin_(&n, &d__[1]) < 0.) {
	*iflag = 2;
    }
    return 0;

/* ... error - matrix cannot be factored since a pivot is zero */

L995:
    *iflag = 1;
    return 0;
} /* icfn_ */

/* Subroutine */ int icfv_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, integer *meth, integer *
	ipropa, doublereal *omega, doublereal *wksp, integer *iwksp, integer *
	iflag)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1, i__2, i__3;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, k, n, id, nc, nc1, ied, len, ish, ied1, ibeg, nbig,
	     ndel, iloc, jcol, imin, maxt;
    extern doublereal vmin_(integer *, doublereal *);
    static logical propa;
    static integer nterm;


/* ... icfv computes an incomplete factorization of the matrix */
/*     stored in d and t and replaces it. */
/*     (symmetric diagonal storage, vectorized version) */

/* ... parameters -- */

/*          ndim   row dimension of t array */
/*          n      order of system (= nn) */
/*          maxt   number of columns in t array */
/*          jt     integer vector giving the diagonal indices of */
/*                  the corresponding columns in t */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          t      array of active size n by maxt giving the */
/*                  super-diagonals of the matrix */
/*          meth   point factorization wanted */
/*                  = 1   ic */
/*                  = 2   mic */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          omega  modification factor between 0.0 and 1.0 */
/*                  = 0     no modification */
/*                  = 1     full modification */
/*          wksp   workspace vector of length n */
/*          iwksp  integer workspace of length maxt**2 */
/*          iflag  indicator of factorization stability */
/*                    iflag = 0    no errors detected */
/*                          = 1    zero pivot encountered */
/*                                 (unsuccessful factorization) */
/*                          = 2    negative pivot encountered */
/*                                 (successful factorization) */

/* ... specifications for parameters */



    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --wksp;
    --iwksp;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    *iflag = 0;
    propa = *ipropa == 1;
    if (maxt < 1) {
	goto L500;
    }
    if (*meth != 1 || ! propa) {
	goto L45;
    }

/* ... ic, propa = t. */

    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	iwksp[i__] = jt[i__] + 1;
    }

/* ... determine nc, imin. */

L15:
    nc = n;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	nterm = iwksp[i__] - 1;
	if (nterm >= nc) {
	    goto L20;
	}
	nc = nterm;
	imin = i__;
L20:
	;
    }
    if (nc >= n) {
	goto L500;
    }
    ndel = jt[imin];
    ibeg = nc + 1;
    if (ndel > 1) {
	goto L35;
    }

/* ... special case for first super-diagonal. */

    nc1 = n;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ == imin) {
	    goto L25;
	}
	if (iwksp[i__] < nc1) {
	    nc1 = iwksp[i__];
	}
L25:
	;
    }
    iwksp[imin] = nc1 + 1;
    i__1 = nc1;
    for (j = ibeg; j <= i__1; ++j) {
/* L30: */
/* Computing 2nd power */
	d__1 = t[j - 1 + imin * t_dim1];
	d__[j] -= d__1 * d__1 / d__[j - 1];
    }
    goto L15;

/* ... far diagonals. */

L35:
    iwksp[imin] += ndel;
/* Computing MIN */
    i__1 = ibeg + ndel - 1;
    ied = min(i__1,n);
/* dir$ ivdep */
    i__1 = ied;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L40: */
/* Computing 2nd power */
	d__1 = t[i__ - ndel + imin * t_dim1];
	d__[i__] -= d__1 * d__1 / d__[i__ - ndel];
    }
    goto L15;
L45:
    if (*meth != 2 || ! propa) {
	goto L100;
    }

/* ... mic, propa = t. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L50: */
	wksp[i__] = 0.;
    }
    i__1 = maxt;
    for (j = 1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L55: */
	    wksp[i__] += t[i__ + j * t_dim1];
	}
/* L60: */
    }
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L65: */
	iwksp[i__] = jt[i__] + 1;
    }

/* ... determine nc, imin. */

L70:
    nc = n;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	nterm = iwksp[i__] - 1;
	if (nterm >= nc) {
	    goto L75;
	}
	nc = nterm;
	imin = i__;
L75:
	;
    }
    if (nc >= n) {
	goto L500;
    }
    ndel = jt[imin];
    ibeg = nc + 1;
    if (ndel > 1) {
	goto L90;
    }

/* ... special case for first super-diagonal. */

    nc1 = n;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ == imin) {
	    goto L80;
	}
	if (iwksp[i__] < nc1) {
	    nc1 = iwksp[i__];
	}
L80:
	;
    }
    iwksp[imin] = nc1 + 1;
    i__1 = nc1;
    for (j = ibeg; j <= i__1; ++j) {
/* L85: */
	d__[j] -= t[j - 1 + imin * t_dim1] * (*omega * wksp[j - 1] - (*omega
		- 1.) * t[j - 1 + imin * t_dim1]) / d__[j - 1];
    }
    goto L70;

/* ... far diagonals. */

L90:
    iwksp[imin] += ndel;
/* Computing MIN */
    i__1 = ibeg + ndel - 1;
    ied = min(i__1,n);
/* dir$ ivdep */
    i__1 = ied;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L95: */
	d__[i__] -= t[i__ - ndel + imin * t_dim1] * (*omega * wksp[i__ - ndel]
		 - (*omega - 1.) * t[i__ - ndel + imin * t_dim1]) / d__[i__ -
		ndel];
    }
    goto L70;

/* ... set up pointers for propa = f case. */

L100:
    nbig = maxt + 1;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = maxt;
	for (j = 1; j <= i__2; ++j) {
	    iloc = j * maxt + i__;
	    id = (i__3 = jt[j] - jt[i__], abs(i__3));
	    i__3 = maxt;
	    for (k = 1; k <= i__3; ++k) {
		if (jt[k] != id) {
		    goto L105;
		}
		iwksp[iloc] = k;
		goto L110;
L105:
		;
	    }
	    iwksp[iloc] = nbig;
L110:
	    ;
	}
/* L115: */
    }

/* ... ic, mic for propa = f. */

    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L120: */
	iwksp[i__] = jt[i__] + 1;
    }

/* ... determine nc, imin. */

L125:
    nc = n;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	nterm = iwksp[i__] - 1;
	if (nterm >= nc) {
	    goto L130;
	}
	nc = nterm;
	imin = i__;
L130:
	;
    }
    if (nc >= n) {
	goto L500;
    }
    ndel = jt[imin];
    iwksp[imin] += ndel;
    ibeg = nc + 1;
/* Computing MIN */
    i__1 = ibeg + ndel - 1;
    ied = min(i__1,n);
/* dir$ ivdep */
    i__1 = ied;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L135: */
/* Computing 2nd power */
	d__1 = t[i__ - ndel + imin * t_dim1];
	d__[i__] -= d__1 * d__1 / d__[i__ - ndel];
    }
    i__1 = maxt;
    for (j = 1; j <= i__1; ++j) {
	jcol = jt[j];
	if (jcol <= ndel) {
	    goto L160;
	}
	iloc = j * maxt + imin;
	id = iwksp[iloc];
/* Computing MIN */
	i__2 = ied, i__3 = n - jcol + ndel;
	ied1 = min(i__2,i__3);
	if (id == nbig) {
	    goto L145;
	}
/* dir$ ivdep */
	i__2 = ied1;
	for (i__ = ibeg; i__ <= i__2; ++i__) {
/* L140: */
	    t[i__ + id * t_dim1] -= t[i__ - ndel + imin * t_dim1] * t[i__ -
		    ndel + j * t_dim1] / d__[i__ - ndel];
	}
	goto L160;
L145:
	if (*meth == 1) {
	    goto L160;
	}
	i__2 = ied1;
	for (i__ = ibeg; i__ <= i__2; ++i__) {
/* L150: */
	    wksp[i__] = *omega * t[i__ - ndel + imin * t_dim1] * t[i__ - ndel
		    + j * t_dim1] / d__[i__ - ndel];
	}
	ish = jcol - ndel;
	i__2 = ied1;
	for (i__ = ibeg; i__ <= i__2; ++i__) {
	    d__[i__] -= wksp[i__];
	    d__[i__ + ish] -= wksp[i__];
/* L155: */
	}
L160:
	;
    }
    goto L125;

/* ... store reciprocals of pivots. */

L500:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (d__[i__] == 0.) {
	    goto L995;
	}
/* L505: */
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L510: */
	d__[i__] = 1. / d__[i__];
    }
    if (maxt < 1 || propa) {
	goto L990;
    }
    i__1 = maxt;
    for (j = 1; j <= i__1; ++j) {
	len = n - jt[j];
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L515: */
	    t[i__ + j * t_dim1] = d__[i__] * t[i__ + j * t_dim1];
	}
/* L520: */
    }

/* ... check for negative pivots. */

L990:
    if (vmin_(&n, &d__[1]) < 0.) {
	*iflag = 2;
    }
    return 0;

/* ... error - matrix cannot be factored since a pivot is zero */

L995:
    *iflag = 1;
    return 0;
} /* icfv_ */

/* Subroutine */ int icfnp_(integer *ndimr, integer *ndimi, integer *nn,
	integer *maxtt, integer *maxbb, integer *jt, integer *jb, doublereal *
	d__, doublereal *t, doublereal *b, integer *meth, integer *ipropa,
	doublereal *omega, integer *iflag)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, jb_dim1, jb_offset, t_dim1, t_offset, b_dim1,
	    b_offset, i__1, i__2, i__3, i__4, i__5;

    /* Local variables */
    static integer i__, j, k, n, j1, j2, j3, nm1, kp1, maxb, maxt;
    extern doublereal vmin_(integer *, doublereal *);
    static integer jcol1;
    static doublereal term1, term2;
    static integer jdiff;
    static logical propa;
    static doublereal pivot;


/* ... icfnp computes an incomplete factorization of the matrix */
/*     stored in d, t, and b and replaces it. */
/*     (purdue storage, nonsymmetric matrix) */

/* ... parameters -- */

/*          ndimr  row dimension of t and b arrays */
/*          ndimi  row dimension of jt and jb arrays */
/*          n      order of system (= nn) */
/*          maxt   number of columns in t,jt arrays */
/*          maxb   number of columns in b,jb arrays */
/*          jt     integer array giving the column indices of the */
/*                  corresponding elements in t */
/*          jb     integer array giving the column indices of the */
/*                  corresponding elements in b */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          t      array of active size n by maxt giving the */
/*                  upper triangle of the matrix */
/*          b      array of active size n by maxb giving the */
/*                  lower triangle of the matrix */
/*          meth   point factorization wanted */
/*                  = 1   ic */
/*                  = 2   mic */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          omega  modification factor between 0.0 and 1.0 */
/*                  = 0     no modification */
/*                  = 1     full modification */
/*          iflag  indicator of factorization stability */
/*                    iflag = 0    no errors detected */
/*                          = 1    zero pivot encountered */
/*                                 (unsuccessful factorization) */
/*                          = 2    negative pivot encountered */
/*                                 (successful factorization) */

/* ... specifications for parameters */



    /* Parameter adjustments */
    b_dim1 = *ndimr;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndimr;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jb_dim1 = *ndimi;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    jt_dim1 = *ndimi;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    maxb = *maxbb;
    *iflag = 0;
    propa = *ipropa == 1;

    if (maxt < 1 || maxb < 1) {
	goto L50;
    }
    nm1 = n - 1;
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	pivot = d__[k];
	if (pivot == 0.) {
	    goto L995;
	}
	kp1 = k + 1;
	i__2 = maxb;
	for (j1 = 1; j1 <= i__2; ++j1) {
	    i__3 = n;
	    for (i__ = kp1; i__ <= i__3; ++i__) {
		jcol1 = jb[i__ + j1 * jb_dim1];
		if (jcol1 != k) {
		    goto L35;
		}
		term1 = b[i__ + j1 * b_dim1] / pivot;
		i__4 = maxt;
		for (j2 = 1; j2 <= i__4; ++j2) {
		    j = jt[k + j2 * jt_dim1];
		    if (j <= k) {
			goto L30;
		    }
		    term2 = term1 * t[k + j2 * t_dim1];
		    jdiff = j - i__;
		    if (jdiff == 0) {
			goto L27;
		    }
		    if (propa) {
			goto L25;
		    }
		    if (jdiff > 0) {
			goto L15;
		    }
		    i__5 = maxb;
		    for (j3 = 1; j3 <= i__5; ++j3) {
			if (jb[i__ + j3 * jb_dim1] != j) {
			    goto L10;
			}
			b[i__ + j3 * b_dim1] -= term2;
			goto L30;
L10:
			;
		    }
		    goto L25;
L15:
		    i__5 = maxt;
		    for (j3 = 1; j3 <= i__5; ++j3) {
			if (jt[i__ + j3 * jt_dim1] != j) {
			    goto L20;
			}
			t[i__ + j3 * t_dim1] -= term2;
			goto L30;
L20:
			;
		    }
L25:
		    if (*meth == 1) {
			goto L30;
		    }
L27:
		    d__[i__] -= *omega * term2;
L30:
		    ;
		}
L35:
		;
	    }
/* L40: */
	}
/* L45: */
    }
    if (d__[n] == 0.) {
	goto L995;
    }

/* ... store reciprocals of pivots. */

L50:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L55: */
	d__[i__] = 1. / d__[i__];
    }
    if (maxt < 1 || propa) {
	goto L70;
    }
    i__1 = maxt;
    for (j = 1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L60: */
	    t[i__ + j * t_dim1] = d__[i__] * t[i__ + j * t_dim1];
	}
/* L65: */
    }
L70:
    if (maxb < 1 || propa) {
	goto L990;
    }
    i__1 = maxb;
    for (j = 1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L75: */
	    b[i__ + j * b_dim1] *= d__[jb[i__ + j * jb_dim1]];
	}
/* L80: */
    }

/* ... check for negative pivots. */

L990:
    if (vmin_(&n, &d__[1]) < 0.) {
	*iflag = 2;
    }
    return 0;

/* ... error - matrix cannot be factored since a pivot is zero */

L995:
    *iflag = 1;
    return 0;
} /* icfnp_ */

/* Subroutine */ int icfp_(integer *ndimr, integer *ndimi, integer *nn,
	integer *maxtt, integer *jt, doublereal *d__, doublereal *t, integer *
	meth, integer *ipropa, doublereal *omega, doublereal *wksp, integer *
	iflag)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1, i__2, i__3, i__4;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, k, n, j1, j2, j3, nm1, jcol;
    static doublereal term;
    static integer maxt;
    extern doublereal vmin_(integer *, doublereal *);
    static integer jcol1, jcol2;
    static doublereal term1, term2;
    static logical propa;
    static doublereal pivot;


/* ... icfp computes an incomplete factorization of the matrix */
/*     stored in d and t and replaces it. */
/*     (purdue storage, symmetric matrix) */

/* ... parameters -- */

/*          ndimr  row dimension of t array */
/*          ndimi  row dimension of jt array */
/*          n      order of system (= nn) */
/*          maxt   number of columns in t array */
/*          jt     integer array of active size n by maxt giving the */
/*                  column numbers of the corresponding elements in t */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          t      array of active size n by maxt giving the */
/*                  coefficients of the upper triangle of the matrix */
/*          meth   point factorization wanted */
/*                  = 1   ic */
/*                  = 2   mic */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          omega  modification factor between 0.0 and 1.0 */
/*                  = 0     no modification */
/*                  = 1     full modification */
/*          wksp   workspace array of length n */
/*          iflag  indicator of factorization stability */
/*                    iflag = 0    no errors detected */
/*                          = 1    zero pivot encountered */
/*                                 (unsuccessful factorization) */
/*                          = 2    negative pivot encountered */
/*                                 (successful factorization) */

/* ... specifications for parameters */



    /* Parameter adjustments */
    t_dim1 = *ndimr;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndimi;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --wksp;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    *iflag = 0;
    propa = *ipropa == 1;
    if (maxt < 1) {
	goto L500;
    }
    nm1 = n - 1;
    if (*meth != 1 || ! propa) {
	goto L20;
    }

/* ... ic, propa = t. */

    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	pivot = d__[k];
	if (pivot == 0.) {
	    goto L995;
	}
	i__2 = maxt;
	for (j = 1; j <= i__2; ++j) {
	    jcol = jt[k + j * jt_dim1];
/* Computing 2nd power */
	    d__1 = t[k + j * t_dim1];
	    d__[jcol] -= d__1 * d__1 / pivot;
/* L10: */
	}
/* L15: */
    }
    if (d__[n] == 0.) {
	goto L995;
    }
    goto L500;
L20:
    if (*meth != 2 || ! propa) {
	goto L50;
    }

/* ... mic, propa = t. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	wksp[i__] = 0.;
    }
    i__1 = maxt;
    for (j = 1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L30: */
	    wksp[i__] += t[i__ + j * t_dim1];
	}
/* L35: */
    }
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	pivot = d__[k];
	if (pivot == 0.) {
	    goto L995;
	}
	i__2 = maxt;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    jcol = jt[k + i__ * jt_dim1];
	    if (jcol == k) {
		goto L40;
	    }
	    term = t[k + i__ * t_dim1] / pivot;
	    d__[jcol] -= term * (*omega * wksp[k] - (*omega - 1.) * t[k + i__
		    * t_dim1]);
L40:
	    ;
	}
/* L45: */
    }
    if (d__[n] == 0.) {
	goto L995;
    }
    goto L500;

/* ... ic, mic for propa = f. */

L50:
    i__1 = nm1;
    for (k = 1; k <= i__1; ++k) {
	pivot = d__[k];
	if (pivot == 0.) {
	    goto L995;
	}
	i__2 = maxt;
	for (j1 = 1; j1 <= i__2; ++j1) {
	    jcol1 = jt[k + j1 * jt_dim1];
	    if (jcol1 == k) {
		goto L65;
	    }
/* Computing 2nd power */
	    d__1 = t[k + j1 * t_dim1];
	    d__[jcol1] -= d__1 * d__1 / pivot;
	    term1 = t[k + j1 * t_dim1] / pivot;
	    i__3 = maxt;
	    for (j2 = 1; j2 <= i__3; ++j2) {
		jcol2 = jt[k + j2 * jt_dim1];
		if (jcol2 <= jcol1) {
		    goto L60;
		}
		if (jcol2 == k) {
		    goto L60;
		}
		term2 = term1 * t[k + j2 * t_dim1];
		i__4 = maxt;
		for (j3 = 1; j3 <= i__4; ++j3) {
		    if (jcol2 != jt[jcol1 + j3 * jt_dim1]) {
			goto L55;
		    }
		    t[jcol1 + j3 * t_dim1] -= term2;
		    goto L60;
L55:
		    ;
		}
		if (*meth == 1) {
		    goto L60;
		}
		d__[jcol1] -= *omega * term2;
		d__[jcol2] -= *omega * term2;
L60:
		;
	    }
L65:
	    ;
	}
/* L70: */
    }
    if (d__[n] == 0.) {
	goto L995;
    }

/* ... store reciprocals of pivots and scale t. */

L500:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L510: */
	d__[i__] = 1. / d__[i__];
    }
    if (maxt < 1 || propa) {
	goto L990;
    }
    i__1 = maxt;
    for (j = 1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L515: */
	    t[i__ + j * t_dim1] = d__[i__] * t[i__ + j * t_dim1];
	}
/* L520: */
    }

/* ... check for negative pivots. */

L990:
    if (vmin_(&n, &d__[1]) < 0.) {
	*iflag = 2;
    }
    return 0;

/* ... error - matrix cannot be factored since a pivot is zero */

L995:
    *iflag = 1;
    return 0;
} /* icfp_ */

/* Subroutine */ int icfcp_(integer *ndimr, integer *ndimi, integer *nn,
	integer *maxcc, integer *jc, doublereal *d__, doublereal *c__,
	integer *ncolor, integer *nt, integer *nb, integer *meth, integer *
	ipropa, integer *ipt, doublereal *omega, integer *iflag)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1, i__2, i__3, i__4,
	    i__5, i__6, i__7;

    /* Local variables */
    static integer i__, j, k, n, i1, i2, k1, k2, l1, j1, j2, j3, j11, j22,
	    j12, j32, nt2, icol, maxc, ncol;
    extern doublereal vmin_(integer *, doublereal *);
    static integer jcol1;
    static doublereal term1, term2;
    static logical propa;
    static doublereal pivot;


/* ... icfcp computes an incomplete factorization of the matrix */
/*     stored in d and c and replaces it. */
/*     (purdue storage, multicolor) */

/* ... parameters -- */

/*          ndimr  row dimension of c array */
/*          ndimi  row dimension of jc array */
/*          n      order of system (= nn) */
/*          maxc   number of columns in c array */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          meth   point factorization wanted */
/*                  = 1   ic */
/*                  = 2   mic */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          ipt    integer pointer vector of length ncolor + 1 */
/*          omega  modification factor between 0.0 and 1.0 */
/*                  = 0     no modification */
/*                  = 1     full modification */
/*          iflag  indicator of factorization stability */
/*                    iflag = 0    no errors detected */
/*                          = 1    zero pivot encountered */
/*                                 (unsuccessful factorization) */
/*                          = 2    negative pivot encountered */
/*                                 (successful factorization) */

/* ... specifications for parameters */



    /* Parameter adjustments */
    c_dim1 = *ndimr;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndimi;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nt;
    --nb;
    --ipt;

    /* Function Body */
    n = *nn;
    maxc = *maxcc;
    ncol = *ncolor;
    *iflag = 0;
    propa = *ipropa == 1;
    if (maxc < 1) {
	goto L75;
    }

/* ... do factorization. */

    i__1 = ncol - 1;
    for (icol = 1; icol <= i__1; ++icol) {
	k1 = ipt[icol] + 1;
	k2 = ipt[icol + 1];
	j22 = nt[icol];
	if (j22 <= 0) {
	    goto L65;
	}
	i__2 = k2;
	for (k = k1; k <= i__2; ++k) {
	    pivot = d__[k];
	    if (pivot == 0.) {
		goto L995;
	    }
	    i__3 = ncol;
	    for (l1 = icol + 1; l1 <= i__3; ++l1) {
		i1 = ipt[l1] + 1;
		i2 = ipt[l1 + 1];
		j11 = nt[l1] + 1;
		j12 = nt[l1] + nb[l1];
		j32 = nt[l1];
		if (j11 > j12) {
		    goto L55;
		}
		i__4 = j12;
		for (j1 = j11; j1 <= i__4; ++j1) {
		    i__5 = i2;
		    for (i__ = i1; i__ <= i__5; ++i__) {
			jcol1 = jc[i__ + j1 * jc_dim1];
			if (jcol1 != k) {
			    goto L45;
			}
			term1 = c__[i__ + j1 * c_dim1] / pivot;
			i__6 = j22;
			for (j2 = 1; j2 <= i__6; ++j2) {
			    j = jc[k + j2 * jc_dim1];
			    if (j <= k) {
				goto L40;
			    }
			    term2 = term1 * c__[k + j2 * c_dim1];
			    if (j == i__) {
				goto L35;
			    }
			    if (propa) {
				goto L30;
			    }
			    if (j > i__) {
				goto L20;
			    }
			    i__7 = j12;
			    for (j3 = j11; j3 <= i__7; ++j3) {
				if (jc[i__ + j3 * jc_dim1] != j) {
				    goto L15;
				}
				c__[i__ + j3 * c_dim1] -= term2;
				goto L40;
L15:
				;
			    }
			    goto L30;
L20:
			    if (j32 <= 0) {
				goto L30;
			    }
			    i__7 = j32;
			    for (j3 = 1; j3 <= i__7; ++j3) {
				if (jc[i__ + j3 * jc_dim1] != j) {
				    goto L25;
				}
				c__[i__ + j3 * c_dim1] -= term2;
				goto L40;
L25:
				;
			    }
L30:
			    if (*meth == 1) {
				goto L40;
			    }
L35:
			    d__[i__] -= *omega * term2;
L40:
			    ;
			}
L45:
			;
		    }
/* L50: */
		}
L55:
		;
	    }
/* L60: */
	}
L65:
	;
    }
    k1 = ipt[ncol] + 1;
    k2 = ipt[ncol + 1];
    i__1 = k2;
    for (k = k1; k <= i__1; ++k) {
	if (d__[k] == 0.) {
	    goto L995;
	}
/* L70: */
    }

/* ... store reciprocals of pivots. */

L75:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L80: */
	d__[i__] = 1. / d__[i__];
    }
    if (maxc < 1 || propa) {
	goto L990;
    }
    i__1 = ncol;
    for (icol = 1; icol <= i__1; ++icol) {
	nt2 = nt[icol];
	i1 = ipt[icol] + 1;
	i2 = ipt[icol + 1];
	i__2 = maxc;
	for (j = 1; j <= i__2; ++j) {
	    if (j > nt2) {
		goto L90;
	    }
	    i__3 = i2;
	    for (i__ = i1; i__ <= i__3; ++i__) {
/* L85: */
		c__[i__ + j * c_dim1] = d__[i__] * c__[i__ + j * c_dim1];
	    }
	    goto L100;
L90:
	    i__3 = i2;
	    for (i__ = i1; i__ <= i__3; ++i__) {
/* L95: */
		c__[i__ + j * c_dim1] *= d__[jc[i__ + j * jc_dim1]];
	    }
L100:
	    ;
	}
/* L105: */
    }

/* ... check for negative pivots. */

L990:
    if (vmin_(&n, &d__[1]) < 0.) {
	*iflag = 2;
    }
    return 0;

/* ... error - matrix cannot be factored since a pivot is zero */

L995:
    *iflag = 1;
    return 0;
} /* icfcp_ */

/* Subroutine */ int ics_(integer *ndim, integer *nn, integer *maxtt, integer
	*jt, doublereal *d__, doublereal *t, integer *ipropa, integer *irwise,
	 integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int icbs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *);
    static integer maxt;
    extern /* Subroutine */ int icfst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *);


/* ... ics does an ic solution (natural ordering, */
/*     symmetric diagonal storage). */

/*        (i + (t**t))*inv(d)*(i + t)*x = y            propa = .false. */
/*        (i + (t**t)*d)*inv(d)*(i + d*t)*x = y        propa = .true. */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the factorization if not property a */
/*                or the super-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfst_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = d__[i__] * x[i__];
    }
    icbs_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* ics_ */

/* Subroutine */ int ics1_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, integer *ipropa, integer
	*irwise, integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, n, maxt;
    extern /* Subroutine */ int icfst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *);


/* ... ics1 does an ic forward solution (natural ordering, */
/*     symmetric diagonal storage). */

/*        (i + (t**t))*inv(d)*x = y            propa = .false. */
/*        (i + (t**t)*d)*inv(d)*x = y          propa = .true. */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the factorization if not property a */
/*                or the super-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfst_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = sqrt((d__1 = d__[i__], abs(d__1))) * x[i__];
    }
    return 0;
} /* ics1_ */

/* Subroutine */ int ics2_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, integer *ipropa, integer
	*irwise, integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double d_sign(doublereal *, doublereal *), sqrt(doublereal);

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int icbs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *);
    static integer maxt;


/* ... ics2 does an ic back solution (natural ordering, */
/*     symmetric diagonal storage). */

/*        (i + t)*x = y            propa = .false. */
/*        (i + d*t)*x = y          propa = .true. */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the factorization if not property a */
/*                or the super-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__] * d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__],
		abs(d__1)));
    }
    icbs_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* ics2_ */

/* Subroutine */ int ics3_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, integer *ipropa, integer
	*irwise, integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int icbs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *);
    static integer maxt;


/* ... ics3 does an ic transpose backward solution (natural ordering, */
/*     symmetric diagonal storage). */

/*        inv(d)*(i + t)*x = y                 propa = .false. */
/*        inv(d)*(i + d*t)*x = y               propa = .true. */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the factorization if not property a */
/*                or the super-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = sqrt((d__1 = d__[i__], abs(d__1))) * y[i__];
    }
    icbs_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* ics3_ */

/* Subroutine */ int ics4_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, integer *ipropa, integer
	*irwise, integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double d_sign(doublereal *, doublereal *), sqrt(doublereal);

    /* Local variables */
    static integer i__, n, maxt;
    extern /* Subroutine */ int icfst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *);


/* ... ics4 does an ic transpose forward solution (natural ordering, */
/*     symmetric diagonal storage). */

/*        (i + (t**t))*x = y            propa = .false. */
/*        (i + (t**t)*d)*x = y          propa = .true. */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the factorization if not property a */
/*                or the super-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfst_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = x[i__] * d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__],
		abs(d__1)));
    }
    return 0;
} /* ics4_ */

/* Subroutine */ int icsn_(integer *ndim, integer *nn, integer *maxtt,
	integer *maxbb, integer *jt, integer *jb, doublereal *d__, doublereal
	*t, doublereal *b, integer *ipropa, integer *irwise, integer *iwksp,
	doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int icbs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *), icfs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *);
    static integer maxb, maxt;


/* ... icsn does an ic solution (natural ordering, */
/*     nonsymmetric diagonal storage). */

/*        (i + b)*inv(d)*(i + t)*x = y            propa = .false. */
/*        (i + b*d)*inv(d)*(i + d*t)*x = y        propa = .true. */

/* ... parameters -- */

/*        ndim   row dimension of t and b arrays */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        maxb   number of columns in b array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        jb     integer vector of length maxb giving the diagonal */
/*                indices of the corresponding columns in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the factorization if not property a */
/*                or the super-diagonals of the matrix if property a */
/*        b      array of active size n by maxb giving the sub- */
/*                diagonals of the factorization if not property a */
/*                or the sub-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --jb;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    maxb = *maxbb;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfs_(ndim, &n, &maxb, &jb[1], &d__[1], &b[b_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = d__[i__] * x[i__];
    }
    icbs_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* icsn_ */

/* Subroutine */ int icsnt_(integer *ndim, integer *nn, integer *maxtt,
	integer *maxbb, integer *jt, integer *jb, doublereal *d__, doublereal
	*t, doublereal *b, integer *ipropa, integer *irwise, integer *iwksp,
	doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    static integer i__, n, maxb, maxt;
    extern /* Subroutine */ int icbst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *), icfst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *);


/* ... icsnt does an transpose ic solution (natural ordering, */
/*     nonsymmetric diagonal storage). */

/*       (i + (t**t))*inv(d)*(i + (b**t))*x = y        propa = .false. */
/*       (i + (t**t)*d)*inv(d)*(i + d*(b**t))*x = y    propa = .true. */

/* ... parameters -- */

/*        ndim   row dimension of t and b arrays */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        maxb   number of columns in b array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        jb     integer vector of length maxb giving the diagonal */
/*                indices of the corresponding columns in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the factorization if not property a */
/*                or the super-diagonals of the matrix if property a */
/*        b      array of active size n by maxb giving the sub- */
/*                diagonals of the factorization if not property a */
/*                or the sub-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --jb;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    maxb = *maxbb;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfst_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = d__[i__] * x[i__];
    }
    icbst_(ndim, &n, &maxb, &jb[1], &d__[1], &b[b_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* icsnt_ */

/* Subroutine */ int icsn1_(integer *ndim, integer *n, integer *maxb, integer
	*jb, doublereal *d__, doublereal *b, integer *ipropa, integer *irwise,
	 integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int icfs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *);


/* ... icsn1 does an ic forward pass (natural ordering, */
/*     nonsymmetric diagonal storage). */

/*        (i + b)*inv(d)*(i + t)*x = y            propa = .false. */
/*        (i + b*d)*inv(d)*(i + d*t)*x = y        propa = .true. */

/* ... parameters -- */

/*        ndim   row dimension of t and b arrays */
/*        n      order of system (= nn) */
/*        maxb   number of columns in b array */
/*        jb     integer vector of length maxb giving the diagonal */
/*                indices of the corresponding columns in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        b      array of active size n by maxb giving the sub- */
/*                diagonals of the factorization if not property a */
/*                or the sub-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --jb;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfs_(ndim, n, maxb, &jb[1], &d__[1], &b[b_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = sqrt((d__1 = d__[i__], abs(d__1))) * x[i__];
    }
    return 0;
} /* icsn1_ */

/* Subroutine */ int icsn2_(integer *ndim, integer *n, integer *maxt, integer
	*jt, doublereal *d__, doublereal *t, integer *ipropa, integer *irwise,
	 integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double d_sign(doublereal *, doublereal *), sqrt(doublereal);

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int icbs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *);


/* ... icsn2 does an ic back pass (natural ordering, */
/*     nonsymmetric diagonal storage). */

/*        (i + b)*inv(d)*(i + t)*x = y            propa = .false. */
/*        (i + b*d)*inv(d)*(i + d*t)*x = y        propa = .true. */

/* ... parameters -- */

/*        ndim   row dimension of t and b arrays */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the factorization if not property a */
/*                or the super-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__] * d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__],
		abs(d__1)));
    }
    icbs_(ndim, n, maxt, &jt[1], &d__[1], &t[t_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* icsn2_ */

/* Subroutine */ int icsn3_(integer *ndim, integer *n, integer *maxb, integer
	*jb, doublereal *d__, doublereal *b, integer *ipropa, integer *irwise,
	 integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int icbst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *);


/* ... icsn3 does an ic transpose back pass (natural ordering, */
/*     nonsymmetric diagonal storage). */

/*        (i + b)*inv(d)*(i + t)*x = y            propa = .false. */
/*        (i + b*d)*inv(d)*(i + d*t)*x = y        propa = .true. */

/* ... parameters -- */

/*        ndim   row dimension of t and b arrays */
/*        n      order of system (= nn) */
/*        maxb   number of columns in b array */
/*        jb     integer vector of length maxb giving the diagonal */
/*                indices of the corresponding columns in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        b      array of active size n by maxb giving the sub- */
/*                diagonals of the factorization if not property a */
/*                or the sub-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --jb;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = sqrt((d__1 = d__[i__], abs(d__1))) * y[i__];
    }
    icbst_(ndim, n, maxb, &jb[1], &d__[1], &b[b_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* icsn3_ */

/* Subroutine */ int icsn4_(integer *ndim, integer *n, integer *maxt, integer
	*jt, doublereal *d__, doublereal *t, integer *ipropa, integer *irwise,
	 integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double d_sign(doublereal *, doublereal *), sqrt(doublereal);

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int icfst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, doublereal *);


/* ... icsn4 does an ic transpose forward pass (natural ordering, */
/*     nonsymmetric diagonal storage). */

/*        (i + b)*inv(d)*(i + t)*x = y            propa = .false. */
/*        (i + b*d)*inv(d)*(i + d*t)*x = y        propa = .true. */

/* ... parameters -- */

/*        ndim   row dimension of t and b arrays */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the factorization if not property a */
/*                or the super-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfst_(ndim, n, maxt, &jt[1], &d__[1], &t[t_offset], ipropa, irwise, &
	    iwksp[1], &x[1]);
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = x[i__] * d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__],
		abs(d__1)));
    }
    return 0;
} /* icsn4_ */

/* Subroutine */ int icsnp_(integer *ndimr, integer *ndimi, integer *nn,
	integer *maxtt, integer *maxbb, integer *jt, integer *jb, doublereal *
	d__, doublereal *t, doublereal *b, integer *ipropa, doublereal *y,
	doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, jt_dim1, jt_offset, jb_dim1,
	    jb_offset, i__1;

    /* Local variables */
    static integer i__, n, maxb, maxt;
    extern /* Subroutine */ int icbsp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *), icfsp_(integer *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, doublereal *);


/* ... icsnp does an ic solution (natural ordering, */
/*     purdue storage, nonsymmetric matrix). */

/*        (i + b)*d*(i + t)*x = y                  if ipropa = 0 */
/*        (d + b)*inv(d)*(d + t)*x = y             if ipropa = 1 */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        maxb   number of columns in b array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        jb     integer array giving the column numbers of the */
/*                corresponding elements in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the factorization if ipropa = 0 */
/*                or the upper triangle of the matrix if ipropa = 1 */
/*        b      array of active size n by maxb giving the lower */
/*                triangle of the factorization if ipropa = 0 */
/*                or the lower triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndimr;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndimr;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jb_dim1 = *ndimi;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    jt_dim1 = *ndimi;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    maxb = *maxbb;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfsp_(ndimr, ndimi, &n, &maxb, &jb[jb_offset], &d__[1], &b[b_offset],
	    ipropa, &x[1]);
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] *= d__[i__];
    }
    goto L30;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] /= d__[i__];
    }
L30:
    icbsp_(ndimr, ndimi, &n, &maxt, &jt[jt_offset], &d__[1], &t[t_offset],
	    ipropa, &x[1]);
    return 0;
} /* icsnp_ */

/* Subroutine */ int icsntp_(integer *ndimr, integer *ndimi, integer *nn,
	integer *maxtt, integer *maxbb, integer *jt, integer *jb, doublereal *
	d__, doublereal *t, doublereal *b, integer *ipropa, doublereal *y,
	doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, jt_dim1, jt_offset, jb_dim1,
	    jb_offset, i__1;

    /* Local variables */
    static integer i__, n, maxb, maxt;
    extern /* Subroutine */ int icbstp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *), icfstp_(integer *, integer *, integer *, integer *,
	     integer *, doublereal *, doublereal *, integer *, doublereal *);


/* ... icsntp does an transpose ic solution (natural ordering, */
/*     purdue storage, nonsymmetric matrix). */

/*        (i + (t**t))*d*(i + (b**t))*x = y        if ipropa = 0 */
/*        (d + (t**t))*inv(d)*(d + (b**t))*x = y   if ipropa = 1 */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        maxb   number of columns in b array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        jb     integer array giving the column numbers of the */
/*                corresponding elements in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the factorization if ipropa = 0 */
/*                or the upper triangle of the matrix if ipropa = 1 */
/*        b      array of active size n by maxb giving the lower */
/*                triangle of the factorization if ipropa = 0 */
/*                or the lower triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndimr;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndimr;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jb_dim1 = *ndimi;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    jt_dim1 = *ndimi;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    maxb = *maxbb;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfstp_(ndimr, ndimi, &n, &maxt, &jt[jt_offset], &d__[1], &t[t_offset],
	    ipropa, &x[1]);
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] *= d__[i__];
    }
    goto L30;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] /= d__[i__];
    }
L30:
    icbstp_(ndimr, ndimi, &n, &maxb, &jb[jb_offset], &d__[1], &b[b_offset],
	    ipropa, &x[1]);
    return 0;
} /* icsntp_ */

/* Subroutine */ int icsnp1_(integer *ndimr, integer *ndimi, integer *nn,
	integer *maxb, integer *jb, doublereal *d__, doublereal *b, integer *
	ipropa, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, jb_dim1, jb_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int icfsp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *);


/* ... icsnp1 does an ic forward solution (natural ordering, */
/*     purdue storage, nonsymmetric matrix). */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxb   number of columns in b array */
/*        jb     integer array giving the column numbers of the */
/*                corresponding elements in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        b      array of active size n by maxb giving the lower */
/*                triangle of the factorization if ipropa = 0 */
/*                or the lower triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndimr;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    jb_dim1 = *ndimi;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfsp_(ndimr, ndimi, &n, maxb, &jb[jb_offset], &d__[1], &b[b_offset],
	    ipropa, &x[1]);
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] *= sqrt((d__1 = d__[i__], abs(d__1)));
    }
    return 0;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] /= sqrt((d__1 = d__[i__], abs(d__1)));
    }
    return 0;
} /* icsnp1_ */

/* Subroutine */ int icsnp2_(integer *ndimr, integer *ndimi, integer *n,
	integer *maxt, integer *jt, doublereal *d__, doublereal *t, integer *
	ipropa, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double d_sign(doublereal *, doublereal *), sqrt(doublereal);

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int icbsp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *);


/* ... icsnp2 does an ic back solution (natural ordering, */
/*     purdue storage, nonsymmetric matrix). */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the factorization if ipropa = 0 */
/*                or the upper triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndimr;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndimi;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = y[i__] * d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__],
		abs(d__1)));
    }
    goto L30;
L20:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] = y[i__] / (d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__],
		 abs(d__1))));
    }
L30:
    icbsp_(ndimr, ndimi, n, maxt, &jt[jt_offset], &d__[1], &t[t_offset],
	    ipropa, &x[1]);
    return 0;
} /* icsnp2_ */

/* Subroutine */ int icsnp3_(integer *ndimr, integer *ndimi, integer *n,
	integer *maxb, integer *jb, doublereal *d__, doublereal *b, integer *
	ipropa, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, jb_dim1, jb_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int icbstp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *);


/* ... icsnp3 does an transpose ic forward solution (natural ordering, */
/*     purdue storage, nonsymmetric matrix). */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxb   number of columns in b array */
/*        jb     integer array giving the column numbers of the */
/*                corresponding elements in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        b      array of active size n by maxb giving the lower */
/*                triangle of the factorization if ipropa = 0 */
/*                or the lower triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndimr;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    jb_dim1 = *ndimi;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = y[i__] * sqrt((d__1 = d__[i__], abs(d__1)));
    }
    goto L30;
L20:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] = y[i__] / sqrt((d__1 = d__[i__], abs(d__1)));
    }
L30:
    icbstp_(ndimr, ndimi, n, maxb, &jb[jb_offset], &d__[1], &b[b_offset],
	    ipropa, &x[1]);
    return 0;
} /* icsnp3_ */

/* Subroutine */ int icsnp4_(integer *ndimr, integer *ndimi, integer *n,
	integer *maxt, integer *jt, doublereal *d__, doublereal *t, integer *
	ipropa, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double d_sign(doublereal *, doublereal *), sqrt(doublereal);

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int icfstp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *);


/* ... icsnp4 does an transpose ic back solution (natural ordering, */
/*     purdue storage, nonsymmetric matrix). */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the factorization if ipropa = 0 */
/*                or the upper triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndimr;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndimi;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfstp_(ndimr, ndimi, n, maxt, &jt[jt_offset], &d__[1], &t[t_offset],
	    ipropa, &x[1]);
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = x[i__] * d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__],
		abs(d__1)));
    }
    return 0;
L20:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] /= d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__], abs(
		d__1)));
    }
    return 0;
} /* icsnp4_ */

/* Subroutine */ int icsp_(integer *ndimr, integer *ndimi, integer *nn,
	integer *maxtt, integer *jt, doublereal *d__, doublereal *t, integer *
	ipropa, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1;

    /* Local variables */
    static integer i__, n, maxt;
    extern /* Subroutine */ int icbsp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *), icfstp_(integer *, integer *, integer *, integer *,
	     integer *, doublereal *, doublereal *, integer *, doublereal *);


/* ... icsp does an ic solution (natural ordering, */
/*     purdue storage, symmetric matrix). */

/*        (i + (t**t))*d*(i + t)*x = y             if ipropa = 0 */
/*        (d + (t**t))*inv(d)*(d + t)*x = y        if ipropa = 1 */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the factorization if ipropa = 0 */
/*                or the upper triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndimr;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndimi;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfstp_(ndimr, ndimi, &n, &maxt, &jt[jt_offset], &d__[1], &t[t_offset],
	    ipropa, &x[1]);
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] *= d__[i__];
    }
    goto L30;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] /= d__[i__];
    }
L30:
    icbsp_(ndimr, ndimi, &n, &maxt, &jt[jt_offset], &d__[1], &t[t_offset],
	    ipropa, &x[1]);
    return 0;
} /* icsp_ */

/* Subroutine */ int icsp1_(integer *ndimr, integer *ndimi, integer *nn,
	integer *maxt, integer *jt, doublereal *d__, doublereal *t, integer *
	ipropa, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int icfstp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *);


/* ... icsp1 does an ic forward solution (natural ordering, */
/*     purdue storage, symmetric matrix). */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the factorization if ipropa = 0 */
/*                or the upper triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndimr;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndimi;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfstp_(ndimr, ndimi, &n, maxt, &jt[jt_offset], &d__[1], &t[t_offset],
	    ipropa, &x[1]);
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] *= sqrt((d__1 = d__[i__], abs(d__1)));
    }
    return 0;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] /= sqrt((d__1 = d__[i__], abs(d__1)));
    }
    return 0;
} /* icsp1_ */

/* Subroutine */ int icsp2_(integer *ndimr, integer *ndimi, integer *n,
	integer *maxt, integer *jt, doublereal *d__, doublereal *t, integer *
	ipropa, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double d_sign(doublereal *, doublereal *), sqrt(doublereal);

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int icbsp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *);


/* ... icsp2 does an ic back solution (natural ordering, */
/*     purdue storage, symmetric matrix). */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the factorization if ipropa = 0 */
/*                or the upper triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndimr;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndimi;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = y[i__] * d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__],
		abs(d__1)));
    }
    goto L30;
L20:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] = y[i__] / (d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__],
		 abs(d__1))));
    }
L30:
    icbsp_(ndimr, ndimi, n, maxt, &jt[jt_offset], &d__[1], &t[t_offset],
	    ipropa, &x[1]);
    return 0;
} /* icsp2_ */

/* Subroutine */ int icsp3_(integer *ndimr, integer *ndimi, integer *n,
	integer *maxt, integer *jt, doublereal *d__, doublereal *t, integer *
	ipropa, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int icbsp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *);


/* ... icsp3 does an ic transpose forward solution (natural ordering, */
/*     purdue storage, symmetric matrix). */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the factorization if ipropa = 0 */
/*                or the upper triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndimr;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndimi;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = y[i__] * sqrt((d__1 = d__[i__], abs(d__1)));
    }
    goto L30;
L20:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] = y[i__] / sqrt((d__1 = d__[i__], abs(d__1)));
    }
L30:
    icbsp_(ndimr, ndimi, n, maxt, &jt[jt_offset], &d__[1], &t[t_offset],
	    ipropa, &x[1]);
    return 0;
} /* icsp3_ */

/* Subroutine */ int icsp4_(integer *ndimr, integer *ndimi, integer *n,
	integer *maxt, integer *jt, doublereal *d__, doublereal *t, integer *
	ipropa, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double d_sign(doublereal *, doublereal *), sqrt(doublereal);

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int icfstp_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    doublereal *);


/* ... icsp4 does an ic transpose back solution (natural ordering, */
/*     purdue storage, symmetric matrix). */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the factorization if ipropa = 0 */
/*                or the upper triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndimr;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndimi;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfstp_(ndimr, ndimi, n, maxt, &jt[jt_offset], &d__[1], &t[t_offset],
	    ipropa, &x[1]);
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = x[i__] * d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__],
		abs(d__1)));
    }
    return 0;
L20:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] /= d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__], abs(
		d__1)));
    }
    return 0;
} /* icsp4_ */

/* Subroutine */ int icscp_(integer *ndimr, integer *ndimi, integer *nn,
	integer *jc, doublereal *d__, doublereal *c__, integer *ncolor,
	integer *nc, integer *nt, integer *nb, integer *ipropa, doublereal *
	wksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int icbscp_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *), icfscp_(
	    integer *, integer *, integer *, doublereal *, doublereal *,
	    integer *, integer *, integer *, integer *, integer *, doublereal
	    *, doublereal *);


/* ... icscp does an ic solve. */
/*     (purdue storage, multicolor) */

/*      (i + b)*d*(i + t)*x = y         if ipropa = 0 */
/*      (d + b)*inv(d)*(d + t)*x = y    if ipropa = 1 */

/* ... parameters -- */

/*          ndimr  row dimension of c array */
/*          ndimi  row dimension of jc array */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          wksp   workspace vector of length */
/*                  max(nc(i))     if keygs = 1 */
/*                  0              if keygs = 2 */
/*          y      on input, y is the right-hand-side vector */
/*          x      on output, x is the solution to the forward solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndimr;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndimi;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --wksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfscp_(ndimr, ndimi, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor, &
	    nc[1], &nt[1], &nb[1], ipropa, &wksp[1], &x[1]);
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] *= d__[i__];
    }
    goto L30;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] /= d__[i__];
    }
L30:
    icbscp_(ndimr, ndimi, &n, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor,
	     &nc[1], &nt[1], ipropa, &wksp[1], &x[1]);
    return 0;
} /* icscp_ */

/* Subroutine */ int icscpt_(integer *ndimr, integer *ndimi, integer *nn,
	integer *jc, doublereal *d__, doublereal *c__, integer *ncolor,
	integer *nc, integer *nt, integer *nb, integer *ipropa, doublereal *
	wksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int icbsct_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *),
	    icfsct_(integer *, integer *, integer *, doublereal *, doublereal
	    *, integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *);


/* ... icscpt does an transpose ic solve. */
/*     (purdue storage, multicolor) */

/*     (i + (t**t))*d*(i + (b**t))*x = y       if ipropa = 0 */
/*     (d + (t**t))*inv(d)*(d + (b**t))*x = y  if ipropa = 1 */

/* ... parameters -- */

/*          ndimr  row dimension of c array */
/*          ndimi  row dimension of jc array */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          wksp   workspace vector of length max(nc(i)) */
/*          y      on input, y is the right-hand-side vector */
/*          x      on output, x is the solution vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndimr;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndimi;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --wksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfsct_(ndimr, ndimi, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor, &
	    nc[1], &nt[1], ipropa, &wksp[1], &x[1]);
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] *= d__[i__];
    }
    goto L30;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] /= d__[i__];
    }
L30:
    icbsct_(ndimr, ndimi, &n, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor,
	     &nc[1], &nt[1], &nb[1], ipropa, &wksp[1], &x[1]);
    return 0;
} /* icscpt_ */

/* Subroutine */ int icscp1_(integer *ndimr, integer *ndimi, integer *nn,
	integer *jc, doublereal *d__, doublereal *c__, integer *ncolor,
	integer *nc, integer *nt, integer *nb, integer *ipropa, doublereal *
	wksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int icfscp_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *);


/* ... icscp1 does an ic forward solve. */
/*     (purdue storage, multicolor) */


/* ... parameters -- */

/*          ndimr  row dimension of c array */
/*          ndimi  row dimension of jc array */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          wksp   workspace vector of length */
/*                  max(nc(i))     if keygs = 1 */
/*                  0              if keygs = 2 */
/*          y      on input, y is the right-hand-side vector */
/*          x      on output, x is the solution to the forward solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndimr;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndimi;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --wksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfscp_(ndimr, ndimi, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor, &
	    nc[1], &nt[1], &nb[1], ipropa, &wksp[1], &x[1]);
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] *= sqrt((d__1 = d__[i__], abs(d__1)));
    }
    return 0;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] /= sqrt((d__1 = d__[i__], abs(d__1)));
    }
    return 0;
} /* icscp1_ */

/* Subroutine */ int icscp2_(integer *ndimr, integer *ndimi, integer *nn,
	integer *jc, doublereal *d__, doublereal *c__, integer *ncolor,
	integer *nc, integer *nt, integer *ipropa, doublereal *wksp,
	doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double d_sign(doublereal *, doublereal *), sqrt(doublereal);

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int icbscp_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *);


/* ... icscp2 does an ic back solve. */
/*     (purdue storage, multicolor) */


/* ... parameters -- */

/*          ndimr  row dimension of c array */
/*          ndimi  row dimension of jc array */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          wksp   workspace vector of length */
/*                  max(nc(i))     if keygs = 1 */
/*                  0              if keygs = 2 */
/*          y      on input, y is the right-hand-side vector */
/*          x      on output, x is the solution to the forward solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndimr;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndimi;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --wksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;

    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = y[i__] * d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__],
		abs(d__1)));
    }
    goto L30;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] = y[i__] / (d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__],
		 abs(d__1))));
    }
L30:
    icbscp_(ndimr, ndimi, &n, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor,
	     &nc[1], &nt[1], ipropa, &wksp[1], &x[1]);
    return 0;
} /* icscp2_ */

/* Subroutine */ int icscp3_(integer *ndimr, integer *ndimi, integer *nn,
	integer *jc, doublereal *d__, doublereal *c__, integer *ncolor,
	integer *nc, integer *nt, integer *nb, integer *ipropa, doublereal *
	wksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int icbsct_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, integer *, integer *, doublereal *, doublereal *);


/* ... icscp3 does an transpose ic forward solve. */
/*     (purdue storage, multicolor) */


/* ... parameters -- */

/*          ndimr  row dimension of c array */
/*          ndimi  row dimension of jc array */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          wksp   workspace vector of length max(nc(i)) */
/*          y      on input, y is the right-hand-side vector */
/*          x      on output, x is the solution vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndimr;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndimi;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --wksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;

    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = y[i__] * sqrt((d__1 = d__[i__], abs(d__1)));
    }
    goto L30;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] = y[i__] / sqrt((d__1 = d__[i__], abs(d__1)));
    }
L30:
    icbsct_(ndimr, ndimi, &n, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor,
	     &nc[1], &nt[1], &nb[1], ipropa, &wksp[1], &x[1]);
    return 0;
} /* icscp3_ */

/* Subroutine */ int icscp4_(integer *ndimr, integer *ndimi, integer *nn,
	integer *jc, doublereal *d__, doublereal *c__, integer *ncolor,
	integer *nc, integer *nt, integer *ipropa, doublereal *wksp,
	doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;
    doublereal d__1;

    /* Builtin functions */
    double d_sign(doublereal *, doublereal *), sqrt(doublereal);

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int icfsct_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *);


/* ... icscp4 does an transpose ic back solve. */
/*     (purdue storage, multicolor) */


/* ... parameters -- */

/*          ndimr  row dimension of c array */
/*          ndimi  row dimension of jc array */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          wksp   workspace vector of length max(nc(i)) */
/*          y      on input, y is the right-hand-side vector */
/*          x      on output, x is the solution vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndimr;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndimi;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --wksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    icfsct_(ndimr, ndimi, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor, &
	    nc[1], &nt[1], ipropa, &wksp[1], &x[1]);
    if (*ipropa == 1) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = x[i__] * d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__],
		abs(d__1)));
    }
    return 0;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	x[i__] /= d_sign(&c_b922, &d__[i__]) * sqrt((d__1 = d__[i__], abs(
		d__1)));
    }
    return 0;
} /* icscp4_ */

/* Subroutine */ int icbs_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, integer *ipropa, integer
	*irwise, integer *iwksp, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, n, nc, nc1, nm1;
    static doublereal sum;
    static integer ibeg, iend, ndel, imax, maxt;
    static logical propa;
    static integer nterm;


/* ... icbs does an ic back solve (natural ordering, */
/*     diagonal storage). */
/*        (i + t)*x = y    if not property a */
/*        (i + d*t)*x = y  if property a */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the factorization if not property a */
/*                or the super-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        x      on input, x contains y */
/*               on output, x is the solution to back-solve */

/* ... specifications for parameters */




    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    nm1 = n - 1;
    propa = *ipropa == 1;
    if (maxt < 1) {
	return 0;
    }

/* ... select rowwise or diagonal-wise algorithm. */

    if (*irwise == 1) {
	goto L70;
    }

/* ... diagonal-wise algorithm. */

    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	iwksp[i__] = n - jt[i__];
    }

/* ... determine nc, imax. */

L20:
    nc = 1;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	nterm = iwksp[i__] + 1;
	if (nterm <= nc) {
	    goto L25;
	}
	nc = nterm;
	imax = i__;
L25:
	;
    }
    if (nc <= 1) {
	return 0;
    }
    ndel = jt[imax];
    iend = nc - 1;
    if (ndel > 1) {
	goto L50;
    }

/* ... special case for first super diagonal. */

    nc1 = 1;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ == imax) {
	    goto L30;
	}
	if (iwksp[i__] > nc1) {
	    nc1 = iwksp[i__];
	}
L30:
	;
    }
    iwksp[imax] = nc1 - 1;
    if (propa) {
	goto L40;
    }
    i__1 = nc1;
    for (k = iend; k >= i__1; --k) {
/* L35: */
	x[k] -= t[k + imax * t_dim1] * x[k + 1];
    }
    goto L20;
L40:
    i__1 = nc1;
    for (k = iend; k >= i__1; --k) {
/* L45: */
	x[k] -= d__[k] * t[k + imax * t_dim1] * x[k + 1];
    }
    goto L20;

/* ... far diagonals  (do vector computations). */

L50:
    iwksp[imax] -= ndel;
/* Computing MAX */
    i__1 = iend - ndel;
    ibeg = max(i__1,0) + 1;
    if (propa) {
	goto L60;
    }
/* dir$ ivdep */
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L55: */
	x[i__] -= t[i__ + imax * t_dim1] * x[i__ + ndel];
    }
    goto L20;
/* dir$ ivdep */
L60:
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L65: */
	x[i__] -= d__[i__] * t[i__ + imax * t_dim1] * x[i__ + ndel];
    }
    goto L20;

/* ... rowwise algorithm. */

L70:
    for (i__ = nm1; i__ >= 1; --i__) {
	i__1 = maxt;
	for (j = 1; j <= i__1; ++j) {
/* L75: */
/* Computing MIN */
	    i__2 = n, i__3 = i__ + jt[j];
	    iwksp[j] = min(i__2,i__3);
	}
	sum = 0.;
	i__2 = maxt;
	for (j = 1; j <= i__2; ++j) {
/* L80: */
	    sum += t[i__ + j * t_dim1] * x[iwksp[j]];
	}
	if (propa) {
	    sum = d__[i__] * sum;
	}
	x[i__] -= sum;
/* L85: */
    }
    return 0;
} /* icbs_ */

/* Subroutine */ int icbst_(integer *ndim, integer *nn, integer *maxbb,
	integer *jb, doublereal *d__, doublereal *b, integer *ipropa, integer
	*irwise, integer *iwksp, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, n, nc, nc1, ibeg, iend, ndel, maxb, imax;
    static doublereal term;
    static logical propa;
    static integer nterm;


/* ... icbst does an ic back solve (natural ordering, */
/*     diagonal storage). */
/*        (i + (b**t))*x = y    if not property a */
/*        (i + d*(b**t))*x = y  if property a */

/* ... parameters -- */

/*        ndim   row dimension of b array */
/*        n      order of system (= nn) */
/*        maxb   number of columns in b array */
/*        jb     integer vector of length maxb giving the diagonal */
/*                indices of the corresponding columns in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        b      array of active size n by maxb giving the sub- */
/*                diagonals of the factorization if not property a */
/*                or the sub-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxb */
/*        x      on input, x contains y */
/*               on output, x is the solution to back-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --jb;
    --d__;
    --iwksp;
    --x;

    /* Function Body */
    n = *nn;
    maxb = *maxbb;
    propa = *ipropa == 1;
    if (maxb < 1) {
	return 0;
    }

/* ... select rowwise or diagonal-wise algorithm. */

    if (*irwise == 1) {
	goto L70;
    }

/* ... diagonal-wise algorithm. */

    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	iwksp[i__] = n + jb[i__];
    }

/* ... determine nc, imax. */

L20:
    nc = 1;
    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
	nterm = iwksp[i__] + 1;
	if (nterm <= nc) {
	    goto L25;
	}
	nc = nterm;
	imax = i__;
L25:
	;
    }
    if (nc <= 1) {
	return 0;
    }
    ndel = -jb[imax];
    iend = nc - 1;
    if (ndel > 1) {
	goto L50;
    }

/* ... special case for first sub diagonal. */

    nc1 = 1;
    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ == imax) {
	    goto L30;
	}
	if (iwksp[i__] > nc1) {
	    nc1 = iwksp[i__];
	}
L30:
	;
    }
    iwksp[imax] = nc1 - 1;
    if (propa) {
	goto L40;
    }
    i__1 = nc1;
    for (k = iend; k >= i__1; --k) {
/* L35: */
	x[k] -= b[k + 1 + imax * b_dim1] * x[k + 1];
    }
    goto L20;
L40:
    i__1 = nc1;
    for (k = iend; k >= i__1; --k) {
/* L45: */
	x[k] -= d__[k] * b[k + 1 + imax * b_dim1] * x[k + 1];
    }
    goto L20;

/* ... far diagonals  (do vector computations). */

L50:
    iwksp[imax] -= ndel;
/* Computing MAX */
    i__1 = iend - ndel;
    ibeg = max(i__1,0) + 1;
    if (propa) {
	goto L60;
    }
/* dir$ ivdep */
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L55: */
	x[i__] -= b[i__ + ndel + imax * b_dim1] * x[i__ + ndel];
    }
    goto L20;
/* dir$ ivdep */
L60:
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L65: */
	x[i__] -= d__[i__] * b[i__ + ndel + imax * b_dim1] * x[i__ + ndel];
    }
    goto L20;

/* ... rowwise algorithm. */

L70:
    if (propa) {
	goto L90;
    }
    for (i__ = n; i__ >= 2; --i__) {
	i__1 = maxb;
	for (j = 1; j <= i__1; ++j) {
/* L75: */
/* Computing MAX */
	    i__2 = 1, i__3 = i__ + jb[j];
	    iwksp[j] = max(i__2,i__3);
	}
	term = x[i__];
	i__2 = maxb;
	for (j = 1; j <= i__2; ++j) {
/* L80: */
	    x[iwksp[j]] -= b[i__ + j * b_dim1] * term;
	}
/* L85: */
    }
    return 0;
L90:
    for (i__ = n; i__ >= 2; --i__) {
	i__2 = maxb;
	for (j = 1; j <= i__2; ++j) {
/* L95: */
/* Computing MAX */
	    i__3 = 1, i__1 = i__ + jb[j];
	    iwksp[j] = max(i__3,i__1);
	}
	term = x[i__];
	i__3 = maxb;
	for (j = 1; j <= i__3; ++j) {
/* L100: */
	    x[iwksp[j]] -= d__[iwksp[j]] * b[i__ + j * b_dim1] * term;
	}
/* L105: */
    }
    return 0;
} /* icbst_ */

/* Subroutine */ int icfs_(integer *ndim, integer *nn, integer *maxbb,
	integer *jb, doublereal *d__, doublereal *b, integer *ipropa, integer
	*irwise, integer *iwksp, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, n, nc, nc1;
    static doublereal sum;
    static integer ibeg, iend, ndel, maxb, imin;
    static logical propa;
    static integer nterm;


/* ... icfs does an ic forward solve (natural ordering, */
/*     diagonal storage). */
/*        (i + b)*x = y    if not property a */
/*        (i + b*d)*x = y  if property a */

/* ... parameters -- */

/*        ndim   row dimension of b array */
/*        n      order of system (= nn) */
/*        maxb   number of columns in b array */
/*        jb     integer vector of length maxb giving the diagonal */
/*                indices of the corresponding columns in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        b      array of active size n by maxb giving the super- */
/*                diagonals of the factorization if not property a */
/*                or the super-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxb */
/*        x      on input, x contains y */
/*               on output, x is the solution to forward-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --jb;
    --d__;
    --iwksp;
    --x;

    /* Function Body */
    n = *nn;
    maxb = *maxbb;
    propa = *ipropa == 1;
    if (maxb < 1) {
	return 0;
    }

/* ... select rowwise or diagonal-wise algorithm. */

    if (*irwise == 1) {
	goto L70;
    }

/* ... diagonal-wise algorithm. */

    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	iwksp[i__] = 1 - jb[i__];
    }

/* ... determine nc, imin. */

L20:
    nc = n;
    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
	nterm = iwksp[i__] - 1;
	if (nterm >= nc) {
	    goto L25;
	}
	nc = nterm;
	imin = i__;
L25:
	;
    }
    if (nc >= n) {
	return 0;
    }
    ndel = -jb[imin];
    ibeg = nc + 1;
    if (ndel > 1) {
	goto L50;
    }

/* ... special case for first minor subdiagonal. */

    nc1 = n;
    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ == imin) {
	    goto L30;
	}
	if (iwksp[i__] < nc1) {
	    nc1 = iwksp[i__];
	}
L30:
	;
    }
    iwksp[imin] = nc1 + 1;
    if (propa) {
	goto L40;
    }
    i__1 = nc1;
    for (j = ibeg; j <= i__1; ++j) {
/* L35: */
	x[j] -= b[j + imin * b_dim1] * x[j - 1];
    }
    goto L20;
L40:
    i__1 = nc1;
    for (j = ibeg; j <= i__1; ++j) {
/* L45: */
	x[j] -= d__[j - 1] * b[j + imin * b_dim1] * x[j - 1];
    }
    goto L20;

/* ... far diagonals  (do vector computations). */

L50:
    iwksp[imin] += ndel;
/* Computing MIN */
    i__1 = ibeg + ndel - 1;
    iend = min(i__1,n);
    if (propa) {
	goto L60;
    }
/* dir$ ivdep */
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L55: */
	x[i__] -= b[i__ + imin * b_dim1] * x[i__ - ndel];
    }
    goto L20;
/* dir$ ivdep */
L60:
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L65: */
	x[i__] -= d__[i__ - ndel] * b[i__ + imin * b_dim1] * x[i__ - ndel];
    }
    goto L20;

/* ... rowwise algorithm. */

L70:
    if (propa) {
	goto L90;
    }
    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
	i__2 = maxb;
	for (j = 1; j <= i__2; ++j) {
/* L75: */
/* Computing MAX */
	    i__3 = 1, i__4 = i__ + jb[j];
	    iwksp[j] = max(i__3,i__4);
	}
	sum = x[i__];
	i__3 = maxb;
	for (j = 1; j <= i__3; ++j) {
/* L80: */
	    sum -= b[i__ + j * b_dim1] * x[iwksp[j]];
	}
	x[i__] = sum;
/* L85: */
    }
    return 0;
L90:
    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
	i__3 = maxb;
	for (j = 1; j <= i__3; ++j) {
/* L95: */
/* Computing MAX */
	    i__4 = 1, i__2 = i__ + jb[j];
	    iwksp[j] = max(i__4,i__2);
	}
	sum = x[i__];
	i__4 = maxb;
	for (j = 1; j <= i__4; ++j) {
/* L100: */
	    sum -= d__[iwksp[j]] * b[i__ + j * b_dim1] * x[iwksp[j]];
	}
	x[i__] = sum;
/* L105: */
    }
    return 0;
} /* icfs_ */

/* Subroutine */ int icfst_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, integer *ipropa, integer
	*irwise, integer *iwksp, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, n, nc, nc1, nm1, ibeg, iend, ndel, imin;
    static doublereal term;
    static integer maxt;
    static logical propa;
    static integer nterm;


/* ... icfst does an ic forward solve (natural ordering, */
/*     diagonal storage). */
/*        (i + (t**t))*x = y    if not property a */
/*        (i + (t**t)*d)*x = y  if property a */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the factorization if not property a */
/*                or the super-diagonals of the matrix if property a */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        x      on input, x contains y */
/*               on output, x is the solution to forward-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    nm1 = n - 1;
    propa = *ipropa == 1;
    if (maxt < 1) {
	return 0;
    }

/* ... select rowwise or diagonal-wise algorithm. */

    if (*irwise == 1) {
	goto L70;
    }

/* ... diagonal-wise algorithm. */

    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	iwksp[i__] = jt[i__] + 1;
    }

/* ... determine nc, imin. */

L20:
    nc = n;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	nterm = iwksp[i__] - 1;
	if (nterm >= nc) {
	    goto L25;
	}
	nc = nterm;
	imin = i__;
L25:
	;
    }
    if (nc >= n) {
	return 0;
    }
    ndel = jt[imin];
    ibeg = nc + 1;
    if (ndel > 1) {
	goto L50;
    }

/* ... special case for first minor subdiagonal. */

    nc1 = n;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ == imin) {
	    goto L30;
	}
	if (iwksp[i__] < nc1) {
	    nc1 = iwksp[i__];
	}
L30:
	;
    }
    iwksp[imin] = nc1 + 1;
    if (propa) {
	goto L40;
    }
    i__1 = nc1;
    for (j = ibeg; j <= i__1; ++j) {
/* L35: */
	x[j] -= t[j - 1 + imin * t_dim1] * x[j - 1];
    }
    goto L20;
L40:
    i__1 = nc1;
    for (j = ibeg; j <= i__1; ++j) {
/* L45: */
	x[j] -= d__[j - 1] * t[j - 1 + imin * t_dim1] * x[j - 1];
    }
    goto L20;

/* ... far diagonals  (do vector computations). */

L50:
    iwksp[imin] += ndel;
/* Computing MIN */
    i__1 = ibeg + ndel - 1;
    iend = min(i__1,n);
    if (propa) {
	goto L60;
    }
/* dir$ ivdep */
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L55: */
	x[i__] -= t[i__ - ndel + imin * t_dim1] * x[i__ - ndel];
    }
    goto L20;
/* dir$ ivdep */
L60:
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L65: */
	x[i__] -= d__[i__ - ndel] * t[i__ - ndel + imin * t_dim1] * x[i__ -
		ndel];
    }
    goto L20;

/* ... rowwise algorithm. */

L70:
    i__1 = nm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = maxt;
	for (j = 1; j <= i__2; ++j) {
/* L75: */
/* Computing MIN */
	    i__3 = n, i__4 = i__ + jt[j];
	    iwksp[j] = min(i__3,i__4);
	}
	term = x[i__];
	if (propa) {
	    term *= d__[i__];
	}
	i__3 = maxt;
	for (j = 1; j <= i__3; ++j) {
/* L80: */
	    x[iwksp[j]] -= t[i__ + j * t_dim1] * term;
	}
/* L85: */
    }
    return 0;
} /* icfst_ */

/* Subroutine */ int icbsp_(integer *ndimr, integer *ndimi, integer *n,
	integer *maxt, integer *jt, doublereal *d__, doublereal *t, integer *
	ipropa, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1;

    /* Local variables */
    static integer i__, j;
    static doublereal sum;
    static logical propa;


/* ... icbsp does an ic back solve (natural ordering, */
/*     purdue storage). */

/*        (i + t)*x = y    if ipropa = 0 */
/*        (d + t)*x = y    if ipropa = 1 */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the factorization if ipropa = 0 */
/*                or the upper triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        x      on input, x contains y */
/*               on output, x is the solution to back-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndimr;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndimi;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --x;

    /* Function Body */
    propa = *ipropa == 1;
    if (*maxt >= 1) {
	goto L15;
    }
    if (! propa) {
	return 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] *= d__[i__];
    }
    return 0;
L15:
    for (i__ = *n; i__ >= 1; --i__) {
	sum = x[i__];
	i__1 = *maxt;
	for (j = 1; j <= i__1; ++j) {
	    sum -= t[i__ + j * t_dim1] * x[jt[i__ + j * jt_dim1]];
/* L20: */
	}
	if (propa) {
	    sum *= d__[i__];
	}
	x[i__] = sum;
/* L25: */
    }
    return 0;
} /* icbsp_ */

/* Subroutine */ int icbstp_(integer *ndimr, integer *ndimi, integer *n,
	integer *maxb, integer *jb, doublereal *d__, doublereal *b, integer *
	ipropa, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, jb_dim1, jb_offset, i__1;

    /* Local variables */
    static integer i__, j;
    static doublereal term;
    static logical propa;


/* ... icbstp does an transpose ic back solve (natural ordering, */
/*     purdue storage). */

/*        (i + (b**t))*x = y    if ipropa = 0 */
/*        (d + (b**t))*x = y    if ipropa = 1 */

/* ... parameters -- */

/*        n      order of system */
/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        maxb   number of columns in b array */
/*        jb     integer array giving the column numbers of the */
/*                corresponding elements in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        b      array of active size n by maxb giving the lower */
/*                triangle of the factorization if ipropa = 0 */
/*                or the lower triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        x      on input, x contains y */
/*               on output, x is the solution to back-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndimr;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    jb_dim1 = *ndimi;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    --d__;
    --x;

    /* Function Body */
    propa = *ipropa == 1;
    if (*maxb >= 1) {
	goto L15;
    }
    if (! propa) {
	return 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] *= d__[i__];
    }
    return 0;
L15:
    for (i__ = *n; i__ >= 1; --i__) {
	if (propa) {
	    x[i__] *= d__[i__];
	}
	term = x[i__];
	i__1 = *maxb;
	for (j = 1; j <= i__1; ++j) {
	    x[jb[i__ + j * jb_dim1]] -= b[i__ + j * b_dim1] * term;
/* L20: */
	}
/* L25: */
    }
    return 0;
} /* icbstp_ */

/* Subroutine */ int icfsp_(integer *ndimr, integer *ndimi, integer *n,
	integer *maxb, integer *jb, doublereal *d__, doublereal *b, integer *
	ipropa, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, jb_dim1, jb_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j;
    static doublereal sum;
    static logical propa;


/* ... icfsp does an ic forward solve (natural ordering, */
/*     purdue storage). */

/*        (i + b)*x = y    if ipropa = 0 */
/*        (d + b)*x = y    if ipropa = 1 */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxb   number of columns in b array */
/*        jb     integer array giving the column numbers of the */
/*                corresponding elements in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        b      array of active size n by maxb giving the lower */
/*                triangle of the factorization if ipropa = 0 */
/*                or the lower triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        x      on input, x contains y */
/*               on output, x is the solution to forward-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndimr;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    jb_dim1 = *ndimi;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    --d__;
    --x;

    /* Function Body */
    propa = *ipropa == 1;
    if (*maxb >= 1) {
	goto L15;
    }
    if (! propa) {
	return 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] *= d__[i__];
    }
    return 0;
L15:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	sum = x[i__];
	i__2 = *maxb;
	for (j = 1; j <= i__2; ++j) {
	    sum -= b[i__ + j * b_dim1] * x[jb[i__ + j * jb_dim1]];
/* L20: */
	}
	if (propa) {
	    sum *= d__[i__];
	}
	x[i__] = sum;
/* L25: */
    }
    return 0;
} /* icfsp_ */

/* Subroutine */ int icfstp_(integer *ndimr, integer *ndimi, integer *n,
	integer *maxt, integer *jt, doublereal *d__, doublereal *t, integer *
	ipropa, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j;
    static doublereal term;
    static logical propa;


/* ... icfstp does an transpose ic forward solve (natural ordering, */
/*     purdue storage). */

/*        (i + (t**t))*x = y    if ipropa = 0 */
/*        (d + (t**t))*x = y    if ipropa = 1 */

/* ... parameters -- */

/*        ndimr  row dimension of floating point arrays */
/*        ndimi  row dimension of integer arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the factorization */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the factorization if ipropa = 0 */
/*                or the upper triangle of the matrix if ipropa = 1 */
/*        ipropa property a switch */
/*                = 0  matrix does not have property a */
/*                = 1  matrix does have property a */
/*        x      on input, x contains y */
/*               on output, x is the solution to forward-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndimr;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndimi;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --x;

    /* Function Body */
    propa = *ipropa == 1;
    if (*maxt >= 1) {
	goto L15;
    }
    if (! propa) {
	return 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] *= d__[i__];
    }
    return 0;
L15:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (propa) {
	    x[i__] *= d__[i__];
	}
	term = x[i__];
	i__2 = *maxt;
	for (j = 1; j <= i__2; ++j) {
	    x[jt[i__ + j * jt_dim1]] -= t[i__ + j * t_dim1] * term;
/* L20: */
	}
/* L25: */
    }
    return 0;
} /* icfstp_ */

/* Subroutine */ int icbscp_(integer *ndimr, integer *ndimi, integer *n,
	integer *jc, doublereal *d__, doublereal *c__, integer *ncolor,
	integer *nc, integer *nt, integer *ipropa, doublereal *wksp,
	doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__, j2, ied, ist, npt, icol;
    static logical propa;
    extern /* Subroutine */ int vsubp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... icbscp does a back ic solve. */
/*     (purdue storage, multicolor) */

/*       (i + t)*x = y    if ipropa = 0 */
/*       (d + t)*x = y    if ipropa = 1 */

/* ... parameters -- */

/*          ndimr  row dimension of c array */
/*          ndimi  row dimension of jc array */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          wksp   workspace vector of length */
/*                  max(nc(i))     if keygs = 1 */
/*                  0              if keygs = 2 */
/*          x      on input, x contains y */
/*                 on output, x is the solution to the back solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndimr;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndimi;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --wksp;
    --x;

    /* Function Body */
    propa = *ipropa == 1;

    ied = *n;
    for (icol = *ncolor; icol >= 1; --icol) {
	npt = nc[icol];
	ist = ied - npt + 1;
	j2 = nt[icol];
	vsubp_(ndimr, ndimi, &npt, &j2, &c__[ist + c_dim1], &jc[ist + jc_dim1]
		, &x[ist], &x[1], &wksp[1]);
	if (! propa) {
	    goto L20;
	}
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L15: */
	    x[i__] *= d__[i__];
	}
L20:
	ied -= npt;
/* L25: */
    }
    return 0;
} /* icbscp_ */

/* Subroutine */ int icbsct_(integer *ndimr, integer *ndimi, integer *n,
	integer *jc, doublereal *d__, doublereal *c__, integer *ncolor,
	integer *nc, integer *nt, integer *nb, integer *ipropa, doublereal *
	wksp, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__, j1, mj, ied, ist, npt, icol;
    static logical propa;
    extern /* Subroutine */ int vsubpt_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... icbsct does a transpose back ic solve. */
/*     (purdue storage, multicolor) */

/*     (i + (b**t))*x = y    if ipropa = 0 */
/*     (d + (b**t))*x = y    if ipropa = 1 */

/* ... parameters -- */

/*          ndimr  row dimension of c array */
/*          ndimi  row dimension of jc array */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          wksp   workspace vector of length max(nc(i)) */
/*          x      on input, x contains y */
/*                 on output, x is the solution to the back solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndimr;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndimi;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --wksp;
    --x;

    /* Function Body */
    propa = *ipropa == 1;

    ied = *n;
    for (icol = *ncolor; icol >= 1; --icol) {
	npt = nc[icol];
	ist = ied - npt + 1;
	if (! propa) {
	    goto L20;
	}
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L15: */
	    x[i__] *= d__[i__];
	}
L20:
	j1 = nt[icol] + 1;
	mj = nb[icol];
	vsubpt_(ndimr, ndimi, &npt, &mj, &c__[ist + j1 * c_dim1], &jc[ist +
		j1 * jc_dim1], &x[1], &x[ist], &wksp[1]);
	ied -= npt;
/* L25: */
    }
    return 0;
} /* icbsct_ */

/* Subroutine */ int icfscp_(integer *ndimr, integer *ndimi, integer *jc,
	doublereal *d__, doublereal *c__, integer *ncolor, integer *nc,
	integer *nt, integer *nb, integer *ipropa, doublereal *wksp,
	doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j1, mj, ied, ist, npt, icol;
    static logical propa;
    extern /* Subroutine */ int vsubp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... icfscp does a forward ic solve. */
/*     (purdue storage, multicolor) */

/*       (i + b)*x = y    if ipropa = 0 */
/*       (d + b)*x = y    if ipropa = 1 */

/* ... parameters -- */

/*          ndimr  row dimension of c array */
/*          ndimi  row dimension of jc array */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          wksp   workspace vector of length */
/*                  max(nc(i))     if keygs = 1 */
/*                  0              if keygs = 2 */
/*          x      on input, x contains y */
/*                 on output, x is the solution to the back solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndimr;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndimi;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --wksp;
    --x;

    /* Function Body */
    propa = *ipropa == 1;

    ist = 1;
    i__1 = *ncolor;
    for (icol = 1; icol <= i__1; ++icol) {
	npt = nc[icol];
	ied = ist + npt - 1;
	j1 = nt[icol] + 1;
	mj = nb[icol];
	vsubp_(ndimr, ndimi, &npt, &mj, &c__[ist + j1 * c_dim1], &jc[ist + j1
		* jc_dim1], &x[ist], &x[1], &wksp[1]);
	if (! propa) {
	    goto L20;
	}
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L15: */
	    x[i__] *= d__[i__];
	}
L20:
	ist += npt;
/* L25: */
    }
    return 0;
} /* icfscp_ */

/* Subroutine */ int icfsct_(integer *ndimr, integer *ndimi, integer *jc,
	doublereal *d__, doublereal *c__, integer *ncolor, integer *nc,
	integer *nt, integer *ipropa, doublereal *wksp, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j2, ied, ist, npt, icol;
    static logical propa;
    extern /* Subroutine */ int vsubpt_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... icfsct does a transpose forward ic solve. */
/*     (purdue storage, multicolor) */

/*     (i + (t**t))*x = y    if ipropa = 0 */
/*     (d + (t**t))*x = y    if ipropa = 1 */

/* ... parameters -- */

/*          ndimr  row dimension of c array */
/*          ndimi  row dimension of jc array */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          ipropa property a flag */
/*                  = 0   matrix does not have property a */
/*                  = 1   matrix has property a */
/*          wksp   workspace vector of length max(nc(i)) */
/*          x      on input, x contains y */
/*                 on output, x is the solution to the forward solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndimr;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndimi;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --wksp;
    --x;

    /* Function Body */
    propa = *ipropa == 1;

    ist = 1;
    i__1 = *ncolor;
    for (icol = 1; icol <= i__1; ++icol) {
	npt = nc[icol];
	ied = ist + npt - 1;
	if (! propa) {
	    goto L20;
	}
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L15: */
	    x[i__] *= d__[i__];
	}
L20:
	j2 = nt[icol];
	vsubpt_(ndimr, ndimi, &npt, &j2, &c__[ist + c_dim1], &jc[ist +
		jc_dim1], &x[1], &x[ist], &wksp[1]);
	ist += npt;
/* L25: */
    }
    return 0;
} /* icfsct_ */

integer ipstr_(doublereal *omega)
{
    /* System generated locals */
    integer ret_val;
    doublereal d__1, d__2;

    /* Local variables */
    static integer ip;
    static doublereal wm1, factor;


/*     ipstr finds the smallest integer, ipstr, greater than 5 such */
/*     that    ipstr * (omega-1)**(ipstr-1) .le. 0.50. ipstr will be */
/*          set in loop. */

/* ... parameters -- */

/*          omega  relaxation factor for sor method */

/* ... specifications for parameters */


    wm1 = *omega - 1.;
/* Computing 5th power */
    d__1 = wm1, d__2 = d__1, d__1 *= d__1;
    factor = d__2 * (d__1 * d__1);

    for (ip = 6; ip <= 940; ++ip) {
	if ((doublereal) ip * factor <= .5) {
	    goto L15;
	}
	factor *= wm1;
    }
    ip = 940;
L15:
    ret_val = ip;
    return ret_val;
} /* ipstr_ */

/* Subroutine */ int iptgen_(integer *ncolor, integer *ipt, integer *nc)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer k;


/* ... iptgen generates ipt, the pointer vector to block rows, */
/*     for block structured matrices with nonconstant block size. */

/* ... parameters -- */

/*     ncolor   the number of colors (block rows) */
/*     ipt      upon input, an integer vector of length ncolor+1 */
/*              upon output, the pointer vector */
/*     nc       integer vector of length ncolor giving the */
/*               number of nodes for each color */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --nc;
    --ipt;

    /* Function Body */
    ipt[1] = 0;
    i__1 = *ncolor;
    for (k = 1; k <= i__1; ++k) {
	ipt[k + 1] = ipt[k] + nc[k];
/* L10: */
    }
    return 0;
} /* iptgen_ */

/* Subroutine */ int iterm_(integer *nn, doublereal *u)
{
    /* Format strings */
    static char fmt_10[] = "(/5x,\002intermediate output after each iterat"
	    "ion\002/\002 iteration\002,11x,\002convergence \002,5x,\002ema"
	    "x\002,9x,\002emin\002/7x,\002n\002,7x,\002s\002,8x,\002test\002/)"
	    ;
    static char fmt_12[] = "(////5x,\002intermediate output after each itera"
	    "tion\002//\002 number of\002,11x,\002convergence\002,5x,\002ema"
	    "x\002,8x,\002omega\002,7x,\002spectral\002/\002 iterations\002,1"
	    "3x,\002test\002,34x,\002radius\002//)";
    static char fmt_20[] = "(3x,i5,3x,i5,3x,3d13.5)";
    static char fmt_22[] = "(3x,i5,3x,i5,3x,5d13.5)";
    static char fmt_30[] = "(/1x,2x,\002estimate of solution at iteration"
	    " \002,i5)";
    static char fmt_35[] = "(1x,5g16.7)";
    static char fmt_40[] = "(//)";

    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__, n;

    /* Fortran I/O blocks */
    static cilist io___2442 = { 0, 0, 0, fmt_10, 0 };
    static cilist io___2443 = { 0, 0, 0, fmt_12, 0 };
    static cilist io___2444 = { 0, 0, 0, fmt_20, 0 };
    static cilist io___2445 = { 0, 0, 0, fmt_22, 0 };
    static cilist io___2446 = { 0, 0, 0, fmt_30, 0 };
    static cilist io___2447 = { 0, 0, 0, fmt_35, 0 };
    static cilist io___2449 = { 0, 0, 0, fmt_40, 0 };



/*     iterm produces the iteration summary line at the end */
/*     of each iteration. if level .ge. 4, the latest approximation */
/*     to the solution will be printed. */

/* ... parameters -- */

/*          n      order of system  (= nn) */
/*          u      solution estimate */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --u;

    /* Function Body */
    n = *nn;

/* ... print various parameters after each iteration */

    if (itcom1_1.in > 0) {
	goto L15;
    }

/* ... print header */

    if (itcom1_1.iacel != 3) {
	io___2442.ciunit = itcom1_1.nout;
	s_wsfe(&io___2442);
	e_wsfe();
    }
    if (itcom1_1.iacel == 3) {
	io___2443.ciunit = itcom1_1.nout;
	s_wsfe(&io___2443);
	e_wsfe();
    }

/* ... print summary line */

L15:
    if (itcom1_1.iacel != 3) {
	io___2444.ciunit = itcom1_1.nout;
	s_wsfe(&io___2444);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itcom1_1.is, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itcom3_1.stptst, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&itcom3_1.emax, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&itcom3_1.emin, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    if (itcom1_1.iacel == 3) {
	io___2445.ciunit = itcom1_1.nout;
	s_wsfe(&io___2445);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itcom1_1.is, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itcom3_1.stptst, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&itcom3_1.emax, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&itcom5_1.omega, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&itcom5_1.specr, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    if (itcom1_1.level >= 4) {
	goto L25;
    }
    return 0;

L25:
    io___2446.ciunit = itcom1_1.nout;
    s_wsfe(&io___2446);
    do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
    e_wsfe();
    io___2447.ciunit = itcom1_1.nout;
    s_wsfe(&io___2447);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	do_fio(&c__1, (char *)&u[i__], (ftnlen)sizeof(doublereal));
    }
    e_wsfe();
    io___2449.ciunit = itcom1_1.nout;
    s_wsfe(&io___2449);
    e_wsfe();

    return 0;
} /* iterm_ */

/* Subroutine */ int mcopy_(integer *lda, integer *ldb, integer *n, integer *
	m, doublereal *a, doublereal *b)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j;


/* ... mcopy copies an array a into array b. */

/* ... parameters -- */

/*        lda     leading dimension of array a */
/*        ldb     leading dimension of array b */
/*        n       number of rows in a to be copied */
/*        m       number of columns in a to be copied */
/*        a,b     arrays */

/* ... specifications for parameters */


    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L10: */
	    b[i__ + j * b_dim1] = a[i__ + j * a_dim1];
	}
/* L15: */
    }
    return 0;
} /* mcopy_ */

/* Subroutine */ int move1_(integer *ndim, integer *mdim, integer *nn,
	integer *maxnzz, integer *jcoef, doublereal *coef, integer *nt,
	integer *nb, integer *ier)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, coef_dim1, coef_offset, i__1, i__2,
	    i__3;

    /* Local variables */
    static integer i__, j, n, nb1, nt2, jbc, nbb, jtc, ntt, ndtb;
    static doublereal temp;
    static integer maxz, jtemp, nbrow, maxnz, ntrow;


/* ... move1 moves the data structure to the form d/t/b, where */
/*     d is the main diagonal, the t columns contain only upper */
/*     triangular elements and the b columns contain only lower */
/*     triangular elements.  thus the upper and lower triangle */
/*     elements are segregated into separate columns of coef, */
/*     with the upper elements coming first. */
/*     (purdue data structure, natural ordering, with point */
/*     ic or point ssor preconditionings) */

/* ... parameters -- */

/*         ndim     row dimension of coef array in defining routine */
/*         mdim     column dimension of coef array in defining routine */
/*         n        order of system (= nn) */
/*         maxnz    number of columns in coef array (= maxnzz) */
/*         jcoef    integer matrix representation array */
/*         coef     matrix representation array */
/*         nt       number of columns needed to store t, the upper */
/*                   triangular part of coef */
/*         nb       number of columns needed to store b, the lower */
/*                   triangular part of coef */
/*         ier      error code */
/*                  =  0  no errors detected */
/*                  = -9  mdim .lt. 1+nt+nb.  hence insufficient room */
/*                        to store adjusted matrix */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;

/* ... determine maximum number of nonzeros per row in t and b. */

    ntt = 0;
    nbb = 0;
    if (maxnz <= 1) {
	goto L999;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	ntrow = 0;
	nbrow = 0;
	i__2 = maxnz;
	for (j = 2; j <= i__2; ++j) {
	    if ((i__3 = jcoef[i__ + j * jcoef_dim1] - i__) < 0) {
		goto L10;
	    } else if (i__3 == 0) {
		goto L20;
	    } else {
		goto L15;
	    }
L10:
	    ++nbrow;
	    goto L20;
L15:
	    ++ntrow;
L20:
	    ;
	}
	if (ntrow > ntt) {
	    ntt = ntrow;
	}
	if (nbrow > nbb) {
	    nbb = nbrow;
	}
/* L25: */
    }

/* ... shuffle matrix so that t is first. */

    ndtb = ntt + nbb + 1;
    if (ndtb <= *mdim) {
	goto L30;
    }

/* ... error -- mdim is too small. */

    *ier = -9;
    goto L999;

/* ... permute elements of each row. */

L30:
    if (ntt * nbb == 0) {
	goto L999;
    }
    if (ndtb <= maxnz) {
	goto L40;
    }
    maxz = maxnz + 1;
    i__1 = ndtb;
    for (j = maxz; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    coef[i__ + j * coef_dim1] = 0.;
	    jcoef[i__ + j * jcoef_dim1] = i__;
/* L35: */
	}
    }
    maxnz = ndtb;
L40:
    nt2 = ntt + 1;
    nb1 = nt2 + 1;
    i__2 = n;
    for (i__ = 1; i__ <= i__2; ++i__) {
	jbc = nt2;
	i__1 = nt2;
	for (jtc = 2; jtc <= i__1; ++jtc) {
	    if (jcoef[i__ + jtc * jcoef_dim1] >= i__) {
		goto L50;
	    }
L45:
	    ++jbc;
	    if (jcoef[i__ + jbc * jcoef_dim1] < i__) {
		goto L45;
	    }
	    jtemp = jcoef[i__ + jtc * jcoef_dim1];
	    jcoef[i__ + jtc * jcoef_dim1] = jcoef[i__ + jbc * jcoef_dim1];
	    jcoef[i__ + jbc * jcoef_dim1] = jtemp;
	    temp = coef[i__ + jtc * coef_dim1];
	    coef[i__ + jtc * coef_dim1] = coef[i__ + jbc * coef_dim1];
	    coef[i__ + jbc * coef_dim1] = temp;
L50:
	    ;
	}
	jtc = 1;
	i__1 = maxnz;
	for (jbc = nb1; jbc <= i__1; ++jbc) {
	    if (jcoef[i__ + jbc * jcoef_dim1] <= i__) {
		goto L60;
	    }
L55:
	    ++jtc;
	    if (jcoef[i__ + jtc * jcoef_dim1] > i__) {
		goto L55;
	    }
	    jtemp = jcoef[i__ + jtc * jcoef_dim1];
	    jcoef[i__ + jtc * jcoef_dim1] = jcoef[i__ + jbc * jcoef_dim1];
	    jcoef[i__ + jbc * jcoef_dim1] = jtemp;
	    temp = coef[i__ + jtc * coef_dim1];
	    coef[i__ + jtc * coef_dim1] = coef[i__ + jbc * coef_dim1];
	    coef[i__ + jbc * coef_dim1] = temp;
L60:
	    ;
	}
/* L65: */
    }

/* ... exit. */

L999:
    *nt = ntt;
    *nb = nbb;
    *maxnzz = maxnz;
    return 0;
} /* move1_ */

/* Subroutine */ int move2_(integer *ndim, integer *nn, integer *maxnzz,
	integer *jcoef, doublereal *coef, doublereal *work, integer *iwork,
	integer *nt, integer *nb)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, k, l, n, ii, nbb, ntt, iaux, ndiag, jtemp, ktemp,
	    maxnz;


/* ... move2 moves the data structure to the form d/t/b, where */
/*     d is the main diagonal, the t columns contain only upper */
/*     triangular elements and the b columns contain only lower */
/*     triangular elements.  thus the upper and lower triangle */
/*     elements are segregated into separate columns of coef, */
/*     with the upper elements coming first. */
/*     (diagonal data structure, natural ordering, with point */
/*     ic or point ssor preconditionings) */

/* ... parameters -- */

/*         ndim     row dimension of coef array in defining routine */
/*         n        order of system (= nn) */
/*         maxnz    number of columns in coef array (= maxnzz) */
/*         jcoef    integer matrix representation array */
/*         coef     matrix representation array */
/*         work     floating point workspace array of length n */
/*         iwork    integer work array of length maxnz */
/*         nt       number of columns needed to store t, the upper */
/*                   triangular part of coef */
/*         nb       number of columns needed to store b, the lower */
/*                   triangular part of coef */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;
    --work;
    --iwork;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;
    ntt = 0;
    nbb = 0;
    if (maxnz <= 1) {
	goto L999;
    }

/* ... compute nbb and ntt. */

    i__1 = maxnz;
    for (j = 1; j <= i__1; ++j) {
	ndiag = jcoef[j];
	if (ndiag > 0) {
	    ++ntt;
	}
	if (ndiag < 0) {
	    ++nbb;
	}
/* L10: */
    }

/* ... compute pointers into sorted jcoef. */

/* ... code jcoef. */

    i__1 = maxnz;
    for (j = 1; j <= i__1; ++j) {
	if (jcoef[j] < 0) {
	    jcoef[j] = n - jcoef[j];
	}
/* L15: */
    }
    iwork[1] = 1;
    i__1 = maxnz;
    for (j = 2; j <= i__1; ++j) {
	iaux = jcoef[j];
	i__2 = j - 1;
	for (k = 1; k <= i__2; ++k) {
	    i__ = j - k;
	    ktemp = iwork[i__];
	    if (iaux > jcoef[ktemp]) {
		goto L25;
	    }
	    iwork[i__ + 1] = iwork[i__];
/* L20: */
	}
	i__ = 0;
L25:
	iwork[i__ + 1] = j;
/* L30: */
    }

/* ... decode jcoef. */

    i__1 = maxnz;
    for (j = 1; j <= i__1; ++j) {
	if (jcoef[j] > n) {
	    jcoef[j] = n - jcoef[j];
	}
/* L35: */
    }

/* ... sort coef and jcoef. */

    i__1 = maxnz;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (iwork[i__] == i__) {
	    iwork[i__] = 0;
	}
/* L40: */
    }
    i__1 = maxnz;
    for (ii = 1; ii <= i__1; ++ii) {
	k = iwork[ii];
	if (k == 0) {
	    goto L65;
	}
	i__ = ii;
L45:
	jtemp = jcoef[i__];
	jcoef[i__] = jcoef[k];
	jcoef[k] = jtemp;
	i__2 = n;
	for (l = 1; l <= i__2; ++l) {
	    work[l] = coef[l + i__ * coef_dim1];
	    coef[l + i__ * coef_dim1] = coef[l + k * coef_dim1];
	    coef[l + k * coef_dim1] = work[l];
/* L50: */
	}
	iwork[i__] = 0;
	i__2 = maxnz;
	for (j = ii; j <= i__2; ++j) {
	    if (iwork[j] == i__) {
		goto L60;
	    }
/* L55: */
	}
	goto L65;
L60:
	i__ = j;
	if (i__ != k) {
	    goto L45;
	}
	iwork[k] = 0;
L65:
	;
    }

/* ... exit. */

L999:
    *nt = ntt;
    *nb = nbb;
    return 0;
} /* move2_ */

/* Subroutine */ int move3_(integer *ndim, integer *mdim, integer *nn,
	integer *maxnzz, integer *jcoef, doublereal *coef, integer *nt,
	integer *nb, integer *ncolor, integer *nc, integer *ier)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, coef_dim1, coef_offset, i__1, i__2,
	    i__3, i__4;

    /* Local variables */
    static integer i__, j, n, nb1, nt2, nz1, jbc, ied, nbb, jtc, jzc, ist,
	    ntt, icol, ndtb, ncol;
    static doublereal temp;
    static integer maxz, jtemp, nbrow, maxnz, ntrow;


/* ... move3 moves the data structure to the form d/t/b, where */
/*     d is the main diagonal, the t columns contain only upper */
/*     triangular elements and the b columns contain only lower */
/*     triangular elements.  thus the upper and lower triangle */
/*     elements are segregated into separate columns of coef, */
/*     with the upper elements coming first. */
/*     the above segregation is done for each color. */
/*     (purdue data structure, multi-color ordering, with point */
/*     ic or point ssor preconditionings) */

/* ... parameters -- */

/*         ndim     row dimension of coef array in defining routine */
/*         mdim     column dimension of coef array in defining routine */
/*         n        order of system (= nn) */
/*         maxnz    number of columns in coef array (= maxnzz) */
/*         jcoef    integer matrix representation array */
/*         coef     matrix representation array */
/*         nt       integer vector of length ncolor.  for each color, */
/*                   the number of columns needed to store t, the upper */
/*                   triangular part of the matrix for those rows. */
/*         nb       integer vector of length ncolor.  for each color, */
/*                   the number of columns needed to store b, the lower */
/*                   triangular part of the matrix for those rows. */
/*         ncolor   number of colors */
/*         nc       integer vector of length ncolor, giving the number */
/*                   of nodes for each color. */
/*         ier      error code */
/*                  =  0  no errors detected */
/*                  = -9  mdim .lt. 1+nt+nb.  hence insufficient room */
/*                        to store adjusted matrix */

/* ... specifications for parameters */



    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    --nt;
    --nb;
    --nc;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;

    ist = 1;
    i__1 = *ncolor;
    for (icol = 1; icol <= i__1; ++icol) {
	ncol = nc[icol];
	ied = ist + ncol - 1;

/* ... determine maximum number of nonzeros per row in t and b. */

	ntt = 0;
	nbb = 0;
	if (maxnz <= 1) {
	    goto L80;
	}
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
	    ntrow = 0;
	    nbrow = 0;
	    i__3 = maxnz;
	    for (j = 2; j <= i__3; ++j) {
		if ((i__4 = jcoef[i__ + j * jcoef_dim1] - i__) < 0) {
		    goto L10;
		} else if (i__4 == 0) {
		    goto L20;
		} else {
		    goto L15;
		}
L10:
		++nbrow;
		goto L20;
L15:
		++ntrow;
L20:
		;
	    }
	    if (ntrow > ntt) {
		ntt = ntrow;
	    }
	    if (nbrow > nbb) {
		nbb = nbrow;
	    }
/* L25: */
	}

/* ... shuffle matrix so that t is first. */

	ndtb = ntt + nbb + 1;
	if (ndtb <= *mdim) {
	    goto L30;
	}

/* ... error -- mdim is too small. */

	*ier = -9;
	goto L999;

/* ... permute elements of each row. */

L30:
	if (ndtb <= maxnz) {
	    goto L40;
	}
	maxz = maxnz + 1;
	i__2 = ndtb;
	for (j = maxz; j <= i__2; ++j) {
	    i__3 = n;
	    for (i__ = 1; i__ <= i__3; ++i__) {
		coef[i__ + j * coef_dim1] = 0.;
		jcoef[i__ + j * jcoef_dim1] = i__;
/* L35: */
	    }
	}
	maxnz = ndtb;
L40:
	nt2 = ntt + 1;
	nb1 = ntt + 2;
	nz1 = ntt + 2 + nbb;
	i__3 = ied;
	for (i__ = ist; i__ <= i__3; ++i__) {
	    jbc = nt2;
	    i__2 = nt2;
	    for (jtc = 2; jtc <= i__2; ++jtc) {
		if (jtc > nt2) {
		    goto L50;
		}
		if (jcoef[i__ + jtc * jcoef_dim1] >= i__) {
		    goto L50;
		}
L45:
		++jbc;
		if (jcoef[i__ + jbc * jcoef_dim1] < i__) {
		    goto L45;
		}
		jtemp = jcoef[i__ + jtc * jcoef_dim1];
		jcoef[i__ + jtc * jcoef_dim1] = jcoef[i__ + jbc * jcoef_dim1];
		jcoef[i__ + jbc * jcoef_dim1] = jtemp;
		temp = coef[i__ + jtc * coef_dim1];
		coef[i__ + jtc * coef_dim1] = coef[i__ + jbc * coef_dim1];
		coef[i__ + jbc * coef_dim1] = temp;
L50:
		;
	    }
	    jtc = 1;
	    i__2 = maxnz;
	    for (jbc = nb1; jbc <= i__2; ++jbc) {
		if (jbc > maxnz) {
		    goto L60;
		}
		if (jcoef[i__ + jbc * jcoef_dim1] <= i__) {
		    goto L60;
		}
L55:
		++jtc;
		if (jcoef[i__ + jtc * jcoef_dim1] > i__) {
		    goto L55;
		}
		jtemp = jcoef[i__ + jtc * jcoef_dim1];
		jcoef[i__ + jtc * jcoef_dim1] = jcoef[i__ + jbc * jcoef_dim1];
		jcoef[i__ + jbc * jcoef_dim1] = jtemp;
		temp = coef[i__ + jtc * coef_dim1];
		coef[i__ + jtc * coef_dim1] = coef[i__ + jbc * coef_dim1];
		coef[i__ + jbc * coef_dim1] = temp;
L60:
		;
	    }
	    jbc = nt2;
	    i__2 = maxnz;
	    for (jzc = nz1; jzc <= i__2; ++jzc) {
		if (jzc > maxnz) {
		    goto L70;
		}
		if (jcoef[i__ + jzc * jcoef_dim1] >= i__) {
		    goto L70;
		}
L65:
		++jbc;
		if (jcoef[i__ + jbc * jcoef_dim1] < i__) {
		    goto L65;
		}
		jtemp = jcoef[i__ + jzc * jcoef_dim1];
		jcoef[i__ + jzc * jcoef_dim1] = jcoef[i__ + jbc * jcoef_dim1];
		jcoef[i__ + jbc * jcoef_dim1] = jtemp;
		temp = coef[i__ + jzc * coef_dim1];
		coef[i__ + jzc * coef_dim1] = coef[i__ + jbc * coef_dim1];
		coef[i__ + jbc * coef_dim1] = temp;
L70:
		;
	    }
/* L75: */
	}

L80:
	nt[icol] = ntt;
	nb[icol] = nbb;
	ist += ncol;
/* L85: */
    }

/* ... exit. */

L999:
    *maxnzz = maxnz;
    return 0;
} /* move3_ */

/* Subroutine */ int move4_(integer *ndim, integer *nn, integer *maxnew,
	integer *jcnew, doublereal *coef, integer *ncol, integer *nc,
	doublereal *work, integer *iwork)
{
    /* System generated locals */
    integer jcnew_dim1, jcnew_offset, coef_dim1, coef_offset, i__1, i__2,
	    i__3;

    /* Local variables */
    static integer i__, j, k, l, n, jd, ii, ied, ncc, ist, icol, jcol, iaux,
	    jtemp, ktemp, maxnz, ncolor;


/* ... move4 moves the data structure to the form dc/tc/bc, where */
/*     dc is the main diagonal block, tc is the upper triangular */
/*     block matrices, and db is the lower triangular block */
/*     matrices. */
/*     the above segregation is done for each color. */
/*     (diagonal data structure, multi-color ordering, with */
/*     ic or ssor preconditionings (point or block)) */

/* ... parameters -- */

/*         ndim     row dimension of coef array in defining routine */
/*         n        order of system (= nn) */
/*         maxnew   integer vector giving the number of diagonals */
/*                   created for each color */
/*         jcnew    integer array of size ncolor*max(maxnew(i)) */
/*                   giving the diagonal numbers for each color */
/*         coef     matrix representation array */
/*         ncolor   number of colors */
/*         nc       integer vector of length ncolor, giving the number */
/*                   of nodes for each color. */
/*         work     floating point workspace array of length max (nc(i)) */
/*         iwork    integer work array of length max (maxnew(i)) */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --maxnew;
    jcnew_dim1 = *ncol;
    jcnew_offset = 1 + jcnew_dim1;
    jcnew -= jcnew_offset;
    --nc;
    --work;
    --iwork;

    /* Function Body */
    n = *nn;
    ncolor = *ncol;
    ist = 1;
    i__1 = ncolor;
    for (icol = 1; icol <= i__1; ++icol) {
	ncc = nc[icol];
	ied = ist + ncc - 1;

/* ... compute pointers into sorted jcnew. */

/* ... code jcnew. */

	maxnz = maxnew[icol];
	i__2 = maxnz;
	for (j = 1; j <= i__2; ++j) {
	    i__3 = ied;
	    for (i__ = ist; i__ <= i__3; ++i__) {
		if (coef[i__ + j * coef_dim1] != 0.) {
		    goto L10;
		}
/* L5: */
	    }
	    goto L15;
L10:
	    jd = jcnew[icol + j * jcnew_dim1];
	    jcol = i__ + jd;
	    if (jcol < i__ && jcol >= ist) {
		jcnew[icol + j * jcnew_dim1] = n - jd;
	    }
	    if (jcol > ied) {
		jcnew[icol + j * jcnew_dim1] = (n << 1) + jd;
	    }
	    if (jcol < ist) {
		jcnew[icol + j * jcnew_dim1] = n * 3 - jd;
	    }
L15:
	    ;
	}
	iwork[1] = 1;
	i__2 = maxnz;
	for (j = 2; j <= i__2; ++j) {
	    iaux = jcnew[icol + j * jcnew_dim1];
	    i__3 = j - 1;
	    for (k = 1; k <= i__3; ++k) {
		i__ = j - k;
		ktemp = iwork[i__];
		if (iaux > jcnew[icol + ktemp * jcnew_dim1]) {
		    goto L25;
		}
		iwork[i__ + 1] = iwork[i__];
/* L20: */
	    }
	    i__ = 0;
L25:
	    iwork[i__ + 1] = j;
/* L30: */
	}

/* ... decode jcnew. */

	i__2 = maxnz;
	for (j = 1; j <= i__2; ++j) {
	    jd = jcnew[icol + j * jcnew_dim1];
	    if (jd > n && jd < n << 1) {
		jcnew[icol + j * jcnew_dim1] = n - jd;
	    }
	    if (jd > n << 1 && jd < n * 3) {
		jcnew[icol + j * jcnew_dim1] = jd - (n << 1);
	    }
	    if (jd > n * 3) {
		jcnew[icol + j * jcnew_dim1] = n * 3 - jd;
	    }
/* L35: */
	}

/* ... sort coef and jcnew. */

	i__2 = maxnz;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    if (iwork[i__] == i__) {
		iwork[i__] = 0;
	    }
/* L40: */
	}
	i__2 = maxnz;
	for (ii = 1; ii <= i__2; ++ii) {
	    k = iwork[ii];
	    if (k == 0) {
		goto L65;
	    }
	    i__ = ii;
L45:
	    jtemp = jcnew[icol + i__ * jcnew_dim1];
	    jcnew[icol + i__ * jcnew_dim1] = jcnew[icol + k * jcnew_dim1];
	    jcnew[icol + k * jcnew_dim1] = jtemp;
	    i__3 = ied;
	    for (l = ist; l <= i__3; ++l) {
		work[l - ist + 1] = coef[l + i__ * coef_dim1];
		coef[l + i__ * coef_dim1] = coef[l + k * coef_dim1];
		coef[l + k * coef_dim1] = work[l - ist + 1];
/* L50: */
	    }
	    iwork[i__] = 0;
	    i__3 = maxnz;
	    for (j = ii; j <= i__3; ++j) {
		if (iwork[j] == i__) {
		    goto L60;
		}
/* L55: */
	    }
	    goto L65;
L60:
	    i__ = j;
	    if (i__ != k) {
		goto L45;
	    }
	    iwork[k] = 0;
L65:
	    ;
	}
	ist += ncc;
/* L70: */
    }

/* ... exit. */

    return 0;
} /* move4_ */

/* Subroutine */ int move5_(integer *ndim, integer *n, integer *maxnz,
	integer *jcoef, doublereal *coef)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, j, jd, jsh, jcol, jget;
    static doublereal temp;
    static integer jsml, jtemp, jcolsv;


/* ... move5 moves the data structure to the form dc/tc/bc, where */
/*     dc is the main diagonal block, tc is the upper triangular */
/*     block matrices, and db is the lower triangular block */
/*     matrices. */
/*     (diagonal data structure, with constant block size) */

/* ... parameters -- */

/*         ndim     row dimension of coef array in defining routine */
/*         n        order of system */
/*         maxnz    number of diagonals stored */
/*         jcoef    integer vector of length maxnz giving the */
/*                   diagonal numbers */
/*         coef     matrix representation array */

/* ... specifications for parameters */


/* ... move dc to the first columns. */

    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;

    /* Function Body */
    jsh = 1;
    jcol = 1;
    jget = 0;
L5:
    i__1 = *maxnz;
    for (j = 1; j <= i__1; ++j) {
	jd = jcoef[j];
	if (jd == jget) {
	    goto L15;
	}
/* L10: */
    }
    if (jsh < 0) {
	goto L30;
    }
    jsh = -1;
    jget = -1;
    goto L5;
L15:
    if (j == jcol) {
	goto L25;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	temp = coef[i__ + j * coef_dim1];
	coef[i__ + j * coef_dim1] = coef[i__ + jcol * coef_dim1];
	coef[i__ + jcol * coef_dim1] = temp;
/* L20: */
    }
    jcoef[j] = jcoef[jcol];
    jcoef[jcol] = jd;
L25:
    ++jcol;
    jget += jsh;
    goto L5;

/* ... move tc, bc to the next columns. */

L30:
    if (jcol > *maxnz) {
	return 0;
    }
    i__1 = *maxnz;
    for (j = jcol; j <= i__1; ++j) {
	jd = jcoef[j];
	if (jd < 0) {
	    jcoef[j] = *n - jd;
	}
/* L35: */
    }
    jcolsv = jcol;
L40:
    jsml = jcol;
    i__1 = *maxnz;
    for (j = jcol; j <= i__1; ++j) {
	jd = jcoef[j];
	if (jd < jcoef[jsml]) {
	    jsml = j;
	}
/* L45: */
    }
    if (jsml == jcol) {
	goto L55;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	temp = coef[i__ + jsml * coef_dim1];
	coef[i__ + jsml * coef_dim1] = coef[i__ + jcol * coef_dim1];
	coef[i__ + jcol * coef_dim1] = temp;
/* L50: */
    }
    jtemp = jcoef[jsml];
    jcoef[jsml] = jcoef[jcol];
    jcoef[jcol] = jtemp;
L55:
    ++jcol;
    if (jcol <= *maxnz) {
	goto L40;
    }

/* ... uncode jcoef. */

    i__1 = *maxnz;
    for (j = jcolsv; j <= i__1; ++j) {
	jd = jcoef[j];
	if (jd > *n) {
	    jcoef[j] = *n - jd;
	}
/* L60: */
    }
    return 0;
} /* move5_ */

/* Subroutine */ int muldc_(integer *ndim, integer *nn, doublereal *coef,
	integer *ncolor, integer *nc, integer *maxnew, integer *jcnew,
	doublereal *x, doublereal *y)
{
    /* System generated locals */
    integer jcnew_dim1, jcnew_offset, coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, k, n, i1, ncc, joff, jlim;
    extern /* Subroutine */ int vaddd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);


/* ... muldc computes  y = a*x  for a matrix permuted to an */
/*     ncolor x ncolor block matrix stored in diagonal format. */

/* ... parameters -- */

/*        ndim      row dimension of coef array */
/*        n         order of system */
/*        coef      floating point array of coefficients */
/*        ncolor    number of colors in the permutation (= ncol) */
/*        nc        integer vector of length ncolor giving the */
/*                   number of nodes for each color */
/*        maxnew    integer vector giving the number of diagonals */
/*                   created for each color */
/*        jcnew     integer array of size ncolor*max(maxnew(i)) */
/*                   giving the diagonal numbers for each color */
/*        x         vector of length n to be multiplied by */
/*        y         vector of length n to contain result vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcnew_dim1 = *ncolor;
    jcnew_offset = 1 + jcnew_dim1;
    jcnew -= jcnew_offset;
    --nc;
    --maxnew;
    --x;
    --y;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = coef[i__ + coef_dim1] * x[i__];
    }
    i1 = 1;
    joff = 0;
    i__1 = *ncolor;
    for (k = 1; k <= i__1; ++k) {
	ncc = nc[k];
	jlim = maxnew[k] - 1;
	vaddd_(ndim, ncolor, &ncc, &n, &jlim, &coef[i1 + (coef_dim1 << 1)], &
		jcnew[k + (jcnew_dim1 << 1)], &y[i1], &x[1], &joff);
	i1 += ncc;
	joff -= ncc;
/* L15: */
    }
    return 0;
} /* muldc_ */

/* Subroutine */ int muldct_(integer *ndim, integer *nn, doublereal *coef,
	integer *ncolor, integer *nc, integer *maxnew, integer *jcnew,
	doublereal *x, doublereal *y)
{
    /* System generated locals */
    integer jcnew_dim1, jcnew_offset, coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, k, n, i1, ncc, joff, jlim;
    extern /* Subroutine */ int vadddt_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);


/* ... muldct computes  y = (a**t)*x  for a matrix permuted to an */
/*     ncolor x ncolor block matrix stored in diagonal format. */

/* ... parameters -- */

/*        ndim      row dimension of coef array */
/*        n         order of system */
/*        coef      floating point array of coefficients */
/*        ncolor    number of colors in the permutation (= ncol) */
/*        nc        integer vector of length ncolor giving the */
/*                   number of nodes for each color */
/*        maxnew    integer vector giving the number of diagonals */
/*                   created for each color */
/*        jcnew     integer array of size ncolor*max(maxnew(i)) */
/*                   giving the diagonal numbers for each color */
/*        x         vector of length n to be multiplied by */
/*        y         vector of length n to contain result vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcnew_dim1 = *ncolor;
    jcnew_offset = 1 + jcnew_dim1;
    jcnew -= jcnew_offset;
    --nc;
    --maxnew;
    --x;
    --y;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = coef[i__ + coef_dim1] * x[i__];
    }
    i1 = 1;
    joff = 0;
    i__1 = *ncolor;
    for (k = 1; k <= i__1; ++k) {
	ncc = nc[k];
	jlim = maxnew[k] - 1;
	vadddt_(ndim, ncolor, &ncc, &n, &jlim, &coef[i1 + (coef_dim1 << 1)], &
		jcnew[k + (jcnew_dim1 << 1)], &y[1], &x[i1], &joff);
	i1 += ncc;
	joff -= ncc;
/* L15: */
    }
    return 0;
} /* muldct_ */

/* Subroutine */ int mult1_(integer *ndim, integer *maxnz, doublereal *coef,
	integer *jcoef, doublereal *wksp, integer *nn, doublereal *x,
	doublereal *y)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, jcoef_dim1, jcoef_offset, i__1;

    /* Local variables */
    static integer i__, n, maxm1;
    extern /* Subroutine */ int vaddp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... mult1 computes y = a*x, a matrix-vector product. */
/*     the diagonal is assumed to be in column one. */
/*     (purdue storage format) */

/* ... parameters -- */

/*         ndim     row dimension of coef in defining routine */
/*         maxnz    number of columns in coef */
/*         coef     array of matrix nonzeros */
/*         jcoef    array of matrix column numbers */
/*         wksp     workspace array of length n */
/*         n        order of matrix (= nn) */
/*         x        multiplying vector of length n */
/*         y        product vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --wksp;
    --x;
    --y;

    /* Function Body */
    n = *nn;
    maxm1 = *maxnz - 1;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = coef[i__ + coef_dim1] * x[i__];
    }
    vaddp_(ndim, ndim, &n, &maxm1, &coef[(coef_dim1 << 1) + 1], &jcoef[(
	    jcoef_dim1 << 1) + 1], &y[1], &x[1], &wksp[1]);
    return 0;
} /* mult1_ */

/* Subroutine */ int mult2n_(integer *ndim, integer *maxnz, doublereal *coef,
	integer *jcoef, integer *nn, doublereal *x, doublereal *y)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, n, maxm1;
    extern /* Subroutine */ int vaddd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);


/* ... mult2n computes y = a*x, a matrix-vector product. */
/*     the diagonal is assumed to be in column one.  all diagonals of */
/*     the matrix must be stored. */
/*     (nonsymmetric diagonal storage format) */

/* ... parameters -- */

/*         ndim     row dimension of coef in defining routine */
/*         maxnz    number of columns in coef */
/*         coef     array of matrix diagonals */
/*         jcoef    array of matrix diagonal numbers */
/*         n        dimension of matrix (= nn) */
/*         x        multiplying vector of length n */
/*         y        product vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;
    --x;
    --y;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = coef[i__ + coef_dim1] * x[i__];
    }
    if (*maxnz <= 1) {
	return 0;
    }
    maxm1 = *maxnz - 1;
    vaddd_(ndim, &c__1, &n, &n, &maxm1, &coef[(coef_dim1 << 1) + 1], &jcoef[2]
	    , &y[1], &x[1], &c__0);
    return 0;
} /* mult2n_ */

/* Subroutine */ int mult2s_(integer *ndim, integer *maxnz, doublereal *coef,
	integer *jcoef, integer *nn, doublereal *x, doublereal *y)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, n, ind, len;


/* ... mult2s computes y = a*x, a matrix-vector product. */
/*     the diagonal is assumed to be in column 1.  only the upper */
/*     diagonals and the main diagonal are assumed stored. */
/*     (symmetric diagonal storage format) */

/* ... parameters -- */

/*         ndim     row dimension of coef in defining routine */
/*         maxnz    number of columns in coef */
/*         coef     array of matrix diagonals */
/*         jcoef    array of matrix diagonal numbers */
/*         n        dimension of matrix (= nn) */
/*         x        multiplying vector of length n */
/*         y        product vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;
    --x;
    --y;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = coef[i__ + coef_dim1] * x[i__];
    }
    if (*maxnz <= 1) {
	return 0;
    }

    i__1 = *maxnz;
    for (j = 2; j <= i__1; ++j) {
	ind = jcoef[j];
	len = n - ind;
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L15: */
	    y[i__] += coef[i__ + j * coef_dim1] * x[i__ + ind];
	}
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L20: */
	    y[i__ + ind] += coef[i__ + j * coef_dim1] * x[i__];
	}
/* L25: */
    }
    return 0;
} /* mult2s_ */

/* Subroutine */ int mul1t_(integer *ndim, integer *maxnz, doublereal *coef,
	integer *jcoef, doublereal *wksp, integer *nn, doublereal *x,
	doublereal *y)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, jcoef_dim1, jcoef_offset, i__1;

    /* Local variables */
    static integer i__, n, maxm1;
    extern /* Subroutine */ int vaddpt_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... mul1t computes y = (a**t)*x, a matrix-vector product. */
/*     the diagonal is assumed to be in column one. */
/*     (purdue storage format) */

/* ... parameters -- */

/*         ndim     row dimension of coef in defining routine */
/*         maxnz    number of columns in coef */
/*         coef     array of matrix nonzeros */
/*         jcoef    array of matrix column numbers */
/*         wksp     workspace array of length n */
/*         n        dimension of matrix (= nn) */
/*         x        multiplying vector of length n */
/*         y        product vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --wksp;
    --x;
    --y;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = coef[i__ + coef_dim1] * x[i__];
    }
    if (*maxnz <= 1) {
	return 0;
    }
    maxm1 = *maxnz - 1;
    vaddpt_(ndim, ndim, &n, &maxm1, &coef[(coef_dim1 << 1) + 1], &jcoef[(
	    jcoef_dim1 << 1) + 1], &y[1], &x[1], &wksp[1]);
    return 0;
} /* mul1t_ */

/* Subroutine */ int mul2nt_(integer *ndim, integer *maxnz, doublereal *coef,
	integer *jcoef, integer *nn, doublereal *x, doublereal *y)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, n, maxm1;
    extern /* Subroutine */ int vadddt_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);


/* ... mul2nt computes y = (a**t)*x, a matrix-vector product. */
/*     the diagonal is assumed to be in column one.  all diagonals of */
/*     the matrix must be stored. */
/*     (nonsymmetric diagonal storage format) */

/* ... parameters -- */

/*         ndim     row dimension of coef in defining routine */
/*         maxnz    number of columns in coef */
/*         coef     array of matrix diagonals */
/*         jcoef    array of matrix diagonal numbers */
/*         n        dimension of matrix (= nn) */
/*         x        multiplying vector of length n */
/*         y        product vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;
    --x;
    --y;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = coef[i__ + coef_dim1] * x[i__];
    }
    if (*maxnz <= 1) {
	return 0;
    }
    maxm1 = *maxnz - 1;
    vadddt_(ndim, &c__1, &n, &n, &maxm1, &coef[(coef_dim1 << 1) + 1], &jcoef[
	    2], &y[1], &x[1], &c__0);
    return 0;
} /* mul2nt_ */

/* Subroutine */ int mult3_(integer *mm, integer *np, doublereal *a, integer *
	ia, integer *ja, doublereal *wksp, doublereal *x, doublereal *y)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, m, mm1, ied;
    extern /* Subroutine */ int vadds_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... mult3 computes y = a*x, a matrix-vector product. */
/*     the diagonal is assumed to be in the first partition. */
/*     (symmetric sparse storage format) */

/* ... parameters -- */

/*         m        number of partitions */
/*         np       integer vector of length m+1 giving partition */
/*                    pointers */
/*         a        floating point vector giving matrix coefficients */
/*         ia       integer vector giving i values */
/*         ja       integer vector giving j values */
/*         wksp     workspace vector of length 2*n (keygs = 1 only) */
/*         x        multiplying vector of length n */
/*         y        product vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --y;
    --x;
    --wksp;
    --ja;
    --ia;
    --a;
    --np;

    /* Function Body */
    m = *mm;
    ied = np[2] - 1;
    i__1 = ied;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = a[i__] * x[i__];
    }
    mm1 = m - 1;
    vadds_(&mm1, &np[2], &ia[1], &ja[1], &a[1], &y[1], &x[1], &wksp[1]);
    vadds_(&mm1, &np[2], &ja[1], &ia[1], &a[1], &y[1], &x[1], &wksp[1]);
    return 0;
} /* mult3_ */

/* Subroutine */ int mult3n_(integer *mm, integer *np, doublereal *a, integer
	*ia, integer *ja, doublereal *wksp, doublereal *x, doublereal *y)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, m, mm1, ied;
    extern /* Subroutine */ int vadds_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... mult3n computes y = a*x, a matrix-vector product. */
/*     the diagonal is assumed to be in the first partition. */
/*     (nonsymmetric sparse storage format) */

/* ... parameters -- */

/*         m        number of partitions */
/*         np       integer vector of length m+1 giving partition */
/*                    pointers */
/*         a        floating point vector giving matrix coefficients */
/*         ia       integer vector giving i values */
/*         ja       integer vector giving j values */
/*         wksp     workspace vector of length 2*n (keygs = 1 only) */
/*         x        multiplying vector of length n */
/*         y        product vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --y;
    --x;
    --wksp;
    --ja;
    --ia;
    --a;
    --np;

    /* Function Body */
    m = *mm;
    ied = np[2] - 1;
    i__1 = ied;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = a[i__] * x[i__];
    }
    mm1 = m - 1;
    vadds_(&mm1, &np[2], &ia[1], &ja[1], &a[1], &y[1], &x[1], &wksp[1]);
    return 0;
} /* mult3n_ */

/* Subroutine */ int mul3nt_(integer *mm, integer *np, doublereal *a, integer
	*ia, integer *ja, doublereal *wksp, doublereal *x, doublereal *y)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, m, mm1, ied;
    extern /* Subroutine */ int vadds_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... mul3nt computes y = (a**t)*x, a matrix-vector product. */
/*     the diagonal is assumed to be in the first partition. */
/*     (nonsymmetric sparse storage format) */

/* ... parameters -- */

/*         m        number of partitions */
/*         np       integer vector of length m+1 giving partition */
/*                    pointers */
/*         a        floating point vector giving matrix coefficients */
/*         ia       integer vector giving i values */
/*         ja       integer vector giving j values */
/*         wksp     workspace vector of length 2*n (keygs = 1 only) */
/*         x        multiplying vector of length n */
/*         y        product vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --y;
    --x;
    --wksp;
    --ja;
    --ia;
    --a;
    --np;

    /* Function Body */
    m = *mm;
    ied = np[2] - 1;
    i__1 = ied;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = a[i__] * x[i__];
    }
    mm1 = m - 1;
    vadds_(&mm1, &np[2], &ja[1], &ia[1], &a[1], &y[1], &x[1], &wksp[1]);
    return 0;
} /* mul3nt_ */

/* Subroutine */ int nmcalc_(doublereal *coef, integer *jcoef, doublereal *
	wfac, integer *jwfac, integer *icall, S_fp subq, integer *nn,
	doublereal *rhs, doublereal *ubar, doublereal *wksp, integer *ier)
{
    /* System generated locals */
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer n;
    static doublereal sum;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static integer nteste;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen);


/* ... nmcalc calculates the quantities */

/*       bnorm   = sqrt (rhs,rhs) */
/*       bnorm1  = any other norm of rhs needed for the stopping test */
/*       ubarnm  = sqrt (ubar,ubar) */

/*     which are needed in the stopping tests. */

/*     the stopping tests are -- */

/*    (1)  (emax/emin) * sqrt ( (r ,zt)/(rhs,inv(q)*rhs) ) */
/*    (2)  ( 1.0/emin) * sqrt ( (zt,zt)/(u,u) ) */
/*    (3)  (emax/emin) * sqrt ( (zt,zt)/(inv(q)*rhs,inv(q)*rhs) ) */
/*    (4)                sqrt ( (zt,zt)/(inv(q)*rhs,inv(q)*rhs) ) */
/*    (5)                sqrt ( (r ,r )/(rhs,rhs) ) */
/*    (6)                sqrt ( (u-ubar,u-ubar)/(ubar,ubar) ) */
/*    (7)  (emax/emin) * sqrt ( (r,z)/(rhs,inv(ql)*rhs) ) */
/*    (8)  ( 1.0/emin) * sqrt ( (z,z)/(u,u) ) */
/*    (9)  (emax/emin) * sqrt ( (z,z)/(inv(ql)*rhs,inv(ql)*rhs) ) */
/*   (10)                sqrt ( (z,z)/(inv(ql)*rhs,inv(ql)*rhs) ) */

/* ... parameters -- */

/*        icall      key for initial or secondary call */
/*                    = 1   initial call */
/*                    = 2   later call (needed if q is changed) */
/*        subq       preconditioning routine */
/*        n          order of system */
/*        rhs        right hand side */
/*        ubar       known solution */
/*        wksp       workspace vector of length n */
/*        ier        error code */
/*                    =  0  no error detected */
/*                    = -7  q is not positive definite */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */


    /* Parameter adjustments */
    --wksp;
    --ubar;
    --rhs;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    nteste = itcom1_1.ntest;
    if (itcom1_1.ntest > 6) {
	nteste = itcom1_1.ntest - 6;
    }
    switch (nteste) {
	case 1:  goto L10;
	case 2:  goto L50;
	case 3:  goto L20;
	case 4:  goto L20;
	case 5:  goto L30;
	case 6:  goto L40;
    }

/* ... bnorm1: sqrt(b,q(inv)b). */

L10:
    (*subq)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &rhs[1], &wksp[1]);
    sum = vdot_(&n, &rhs[1], &wksp[1]);
    if (sum >= 0.) {
	goto L15;
    }
    *ier = -7;
    ershow_(ier, "nmcalc", (ftnlen)6);
    return 0;
L15:
/* Computing MAX */
    d__1 = sqrt(sum);
    itcom3_1.bnorm1 = max(d__1,itcom4_1.srelpr);
    return 0;

/* ... bnorm1: sqrt(q(inv)b,q(inv)b). */

L20:
    (*subq)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &rhs[1], &wksp[1]);
    sum = vdot_(&n, &wksp[1], &wksp[1]);
/* Computing MAX */
    d__1 = sqrt(sum);
    itcom3_1.bnorm1 = max(d__1,itcom4_1.srelpr);
    return 0;

/* ... bnorm. */

L30:
    if (*icall == 2) {
	return 0;
    }
    sum = vdot_(&n, &rhs[1], &rhs[1]);
/* Computing MAX */
    d__1 = sqrt(sum);
    itcom3_1.bnorm = max(d__1,itcom4_1.srelpr);
    itcom3_1.bnorm1 = itcom3_1.bnorm;
    return 0;

/* ... ubarnm. */

L40:
    if (*icall == 2) {
	return 0;
    }
    sum = vdot_(&n, &ubar[1], &ubar[1]);
/* Computing MAX */
    d__1 = sqrt(sum);
    itcom3_1.ubarnm = max(d__1,itcom4_1.srelpr);
    return 0;

/* ... exit. */

L50:
    return 0;
} /* nmcalc_ */

/* Subroutine */ int omgchg_(S_fp ssorcp, doublereal *coef, integer *jcoef,
	doublereal *wfac, integer *jwfac, integer *n, doublereal *p,
	doublereal *r__)
{
    /* System generated locals */
    doublereal d__1, d__2;

    /* Local variables */
    static doublereal pdp, pldup;


/* ... omgchg changes alphab and betab for a new estimate of omega. */

/* ... parameters -- */

/*         n       order of system (= nn) */
/*         p       vector from acceleration algorithm */
/*         r       workspace vector from acceleration algorithm */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */


/* ... update alphab and betab. */

    /* Parameter adjustments */
    --r__;
    --p;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    (*ssorcp)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &p[1], &r__[1], &
	    pdp, &pldup);
/* Computing MIN */
    d__1 = itcom5_1.alphab, d__2 = itcom3_1.pap / pdp - 1.;
    itcom5_1.alphab = min(d__1,d__2);
/* Computing MAX */
    d__1 = itcom5_1.betab, d__2 = pldup / pdp;
    itcom5_1.betab = max(d__1,d__2);
    return 0;
} /* omgchg_ */

/* Subroutine */ int out_(integer *nn, doublereal *v, integer *iswt, integer *
	noutt)
{
    /* Format strings */
    static char fmt_10[] = "(//5x,\002residual vector\002)";
    static char fmt_15[] = "(//5x,\002solution vector\002)";
    static char fmt_20[] = "(10x,4i15)";
    static char fmt_25[] = "(10x,65(\002-\002)/)";
    static char fmt_30[] = "(4x,i5,\002+  \002,4d15.5)";

    /* System generated locals */
    integer i__1, i__2;

    /* Builtin functions */
    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);

    /* Local variables */
    static integer i__, j, k, n, jm1, nout, kupper;

    /* Fortran I/O blocks */
    static cilist io___2581 = { 0, 0, 0, fmt_10, 0 };
    static cilist io___2582 = { 0, 0, 0, fmt_15, 0 };
    static cilist io___2583 = { 0, 0, 0, fmt_20, 0 };
    static cilist io___2585 = { 0, 0, 0, fmt_25, 0 };
    static cilist io___2588 = { 0, 0, 0, fmt_30, 0 };



/*     out effects printing of residual and solution */
/*     vectors - called from perror1 */

/* ... parameters -- */

/*          v      vector of length n */
/*          iswt   labelling information */
/*          nout   output device number (= noutt) */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --v;

    /* Function Body */
    n = *nn;
    nout = *noutt;
    if (n <= 0) {
	return 0;
    }

    kupper = min(n,4);
    if (*iswt == 1) {
	io___2581.ciunit = nout;
	s_wsfe(&io___2581);
	e_wsfe();
    }
    if (*iswt == 2) {
	io___2582.ciunit = nout;
	s_wsfe(&io___2582);
	e_wsfe();
    }
    io___2583.ciunit = nout;
    s_wsfe(&io___2583);
    i__1 = kupper;
    for (i__ = 1; i__ <= i__1; ++i__) {
	do_fio(&c__1, (char *)&i__, (ftnlen)sizeof(integer));
    }
    e_wsfe();
    io___2585.ciunit = nout;
    s_wsfe(&io___2585);
    e_wsfe();

    i__1 = n;
    for (j = 1; j <= i__1; j += 4) {
/* Computing MIN */
	i__2 = j + 3;
	kupper = min(i__2,n);
	jm1 = j - 1;
	io___2588.ciunit = nout;
	s_wsfe(&io___2588);
	do_fio(&c__1, (char *)&jm1, (ftnlen)sizeof(integer));
	i__2 = kupper;
	for (k = j; k <= i__2; ++k) {
	    do_fio(&c__1, (char *)&v[k], (ftnlen)sizeof(doublereal));
	}
	e_wsfe();
/* L35: */
    }

    return 0;
} /* out_ */

/* Subroutine */ int pbneu_(S_fp suba, S_fp dsolve, doublereal *coef, integer
	*jcoef, doublereal *wfac, integer *jwfac, integer *nd, doublereal *
	wksp, integer *nn, doublereal *r__, doublereal *z__)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__, k, n, np1;


/* ... pbneu computes the nd-degree block neumann polynomial */
/* ... approximation to the matrix inv(a). */
/*     if a = d - b, where d is a dense banded matrix */
/*     then the output vector is -- */

/*             z = (i + p + p**2 + ... + p**nd)*inv(d) * r */

/*     where   p = inv(d)*b . */

/* ... parameters -- */

/*         suba    matrix-vector multiplication routine */
/*         dsolve  routine for computing inv(d)*vector */
/*         nd      the degree of the polynomial desired */
/*         wksp    workspace of length 2*n */
/*         n       order of system (= nn) */
/*         r       residual */
/*         z       output vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --z__;
    --r__;
    --wksp;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    np1 = n + 1;
    (*dsolve)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &r__[1], &z__[1]);
    if (*nd <= 0) {
	return 0;
    }

    i__1 = *nd;
    for (k = 1; k <= i__1; ++k) {
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &z__[1], &wksp[
		1]);
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L10: */
	    wksp[i__] = r__[i__] - wksp[i__];
	}
	(*dsolve)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &wksp[1], &
		wksp[np1]);
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L15: */
	    z__[i__] += wksp[i__ + n];
	}
/* L20: */
    }
    return 0;
} /* pbneu_ */

/* Subroutine */ int pbpii_(S_fp suba, S_fp dsolve, doublereal *coef, integer
	*jcoef, doublereal *wfac, integer *jwfac, doublereal *ainf,
	doublereal *alpha, doublereal *beta, integer *nd, doublereal *wksp,
	integer *nn, doublereal *r__, doublereal *z__)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__, k, n;
    static doublereal c1, c2, be, al, fk;
    static integer np1;


/* ... pbpii computes the block nd-degree least squares polynomial */
/* ... approximation to the matrix inv(a).  the output vector is -- */

/* ...        z = inv(d)*p  (a*inv(d)) * r */
/* ...                    np */

/* ... parameters -- */

/*         suba    matrix-vector multiplication routine */
/*         dsolve  routine to compute inv(d)*vector */
/*         ainf    the infinity norm of matrix inv(d)*a */
/*         alpha,  the least squares weighting factors */
/*          beta */
/*         nd      the degree of the polynomial desired */
/*         wksp    workspace of length 2*n */
/*         n       order of system (= nn) */
/*         r       residual */
/*         z       output vector */

/* ... specifications for parameters */



    /* Parameter adjustments */
    --z__;
    --r__;
    --wksp;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    np1 = n + 1;
    al = *alpha;
    be = *beta;

    c1 = (al + be + 2.) * (al + be + 3.) / (*ainf * (al + 2.) * (al + be + 2.)
	    );
    (*dsolve)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &r__[1], &z__[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	z__[i__] = c1 * z__[i__];
    }
    if (*nd <= 0) {
	return 0;
    }

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	wksp[i__] = r__[i__];
    }
    i__1 = *nd;
    for (k = 1; k <= i__1; ++k) {
	fk = (doublereal) k;
	c1 = (fk * 2. + al + be + 2.) * (fk * 2. + al + be + 3.) / (*ainf * (
		fk + al + 2.) * (fk + al + be + 2.));
	c2 = fk * (fk + be) * (fk * 2. + al + be) / ((fk + al + 1.) * (fk +
		al + be + 1.) * (fk * 2. + al + be + 2.));
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &z__[1], &wksp[
		np1]);
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L20: */
	    wksp[n + i__] = r__[i__] - wksp[n + i__];
	}
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L25: */
	    wksp[i__] = wksp[i__ + n] + c2 * wksp[i__];
	}
	(*dsolve)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &wksp[1], &
		wksp[np1]);
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L30: */
	    z__[i__] += c1 * wksp[n + i__];
	}
/* L35: */
    }
    return 0;
} /* pbpii_ */

/* Subroutine */ int pneu_(S_fp suba, doublereal *coef, integer *jcoef,
	doublereal *wfac, integer *jwfac, doublereal *d__, integer *nd,
	doublereal *wksp, integer *nn, doublereal *r__, doublereal *z__)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__, k, n;


/* ... pneu computes the nd-degree point neumann polynomial */
/* ... approximation to the matrix inv(a).  the output vector is -- */
/* ...        z = p  (a)*r */
/* ...             np */

/* ... parameters -- */

/*         suba    matrix-vector multiplication routine */
/*         d       vector of length n giving the diagonal elements */
/*                  of the matrix */
/*         nd      the degree of the polynomial desired */
/*         wksp    workspace of length n */
/*         n       order of system (= nn) */
/*         r       residual */
/*         z       output vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --z__;
    --r__;
    --wksp;
    --d__;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	z__[i__] = r__[i__] / d__[i__];
    }
    if (*nd <= 0) {
	return 0;
    }

    i__1 = *nd;
    for (k = 1; k <= i__1; ++k) {
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &z__[1], &wksp[
		1]);
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L15: */
	    z__[i__] += (r__[i__] - wksp[i__]) / d__[i__];
	}
/* L20: */
    }
    return 0;
} /* pneu_ */

/* Subroutine */ int ppii_(S_fp suba, doublereal *coef, integer *jcoef,
	doublereal *wfac, integer *jwfac, doublereal *ainf, doublereal *alpha,
	 doublereal *beta, integer *nd, doublereal *wksp, integer *nn,
	doublereal *r__, doublereal *z__)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__, k, n;
    static doublereal c1, c2, be, al, fk;
    static integer np1;


/* ... ppii computes the nd-degree least squares polynomial */
/* ... approximation to the matrix inv(a).  the output vector is -- */
/* ...        z = p  (a)*r */
/* ...             np */

/* ... parameters -- */

/*         suba    matrix-vector multiplication routine */
/*         ainf    the infinity norm of matrix a */
/*         alpha,  the least squares weighting factors */
/*          beta */
/*         nd      the degree of the polynomial desired */
/*         wksp    workspace of length 2*n */
/*         n       order of system (= nn) */
/*         r       residual */
/*         z       output vector */

/* ... specifications for parameters */



    /* Parameter adjustments */
    --z__;
    --r__;
    --wksp;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    np1 = n + 1;
    al = *alpha;
    be = *beta;

    c1 = (al + be + 2.) * (al + be + 3.) / (*ainf * (al + 2.) * (al + be + 2.)
	    );
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	z__[i__] = c1 * r__[i__];
    }
    if (*nd <= 0) {
	return 0;
    }

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	wksp[i__] = r__[i__];
    }
    i__1 = *nd;
    for (k = 1; k <= i__1; ++k) {
	fk = (doublereal) k;
	c1 = (fk * 2. + al + be + 2.) * (fk * 2. + al + be + 3.) / (*ainf * (
		fk + al + 2.) * (fk + al + be + 2.));
	c2 = fk * (fk + be) * (fk * 2. + al + be) / ((fk + al + 1.) * (fk +
		al + be + 1.) * (fk * 2. + al + be + 2.));
	(*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &z__[1], &wksp[
		np1]);
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L20: */
	    wksp[n + i__] = r__[i__] - wksp[n + i__];
	}
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L25: */
	    wksp[i__] = wksp[i__ + n] + c2 * wksp[i__];
	}
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L30: */
	    z__[i__] += c1 * wksp[i__];
	}
/* L35: */
    }
    return 0;
} /* ppii_ */

/* Subroutine */ int pbs_(integer *n, doublereal *t1, doublereal *t2,
	doublereal *x)
{
    static integer i__;


/* ... pbs does a penta-diagonal back substitution (i+t1+t2)*x = y */
/*     where t1 and t2 are the first and second super diagonals. */

/* ... parameters -- */

/*          n      order of the system */
/*          t1     vector of length n-1 containing the first super- */
/*                  diagonal elements */
/*          t2     vector of length n-2 containing the second super- */
/*                  diagonal elements */
/*          x      on input, x contains y */
/*                 on output, x contains the solution to */
/*                  (i + t1 + t2)*x = y */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --x;
    --t2;
    --t1;

    /* Function Body */
    x[*n - 1] -= t1[*n - 1] * x[*n];
    for (i__ = *n - 2; i__ >= 1; --i__) {
/* L10: */
	x[i__] = x[i__] - t1[i__] * x[i__ + 1] - t2[i__] * x[i__ + 2];
    }
    return 0;
} /* pbs_ */

/* Subroutine */ int pbsm_(integer *nn, integer *nsize, doublereal *t1,
	doublereal *t2, doublereal *x)
{
    /* System generated locals */
    integer t1_dim1, t1_offset, t2_dim1, t2_offset, x_dim1, x_offset, i__1;

    /* Local variables */
    static integer i__, j, n, nsys;


/* ... pbsm does a penta-diagonal back substitution (i+t1+t2)*x = y */
/*     where t1 and t2 are superdiagonals of a system composed of */
/*     independent subsystems of size nsize. */

/* ... parameters -- */

/*          n      order of system */
/*          nsize  order of the individual subsystems */
/*          t1     linear array of length n-1 containing the first */
/*                  super-diagonal elements of the factorizations */
/*          t2     linear array of length n-2 containing the second */
/*                  super-diagonal elements of the factorizations */
/*          x      on input, x contains y */
/*                 the solution to (i + t1 + t2)*x = y */

/* ... specifications for parameters */


    /* Parameter adjustments */
    x_dim1 = *nsize;
    x_offset = 1 + x_dim1;
    x -= x_offset;
    t2_dim1 = *nsize;
    t2_offset = 1 + t2_dim1;
    t2 -= t2_offset;
    t1_dim1 = *nsize;
    t1_offset = 1 + t1_dim1;
    t1 -= t1_offset;

    /* Function Body */
    n = *nn;
    nsys = n / *nsize;
    i__1 = nsys;
    for (j = 1; j <= i__1; ++j) {
/* L10: */
	x[*nsize - 1 + j * x_dim1] -= t1[*nsize - 1 + j * t1_dim1] * x[*nsize
		+ j * x_dim1];
    }
    for (i__ = *nsize - 2; i__ >= 1; --i__) {
	i__1 = nsys;
	for (j = 1; j <= i__1; ++j) {
/* L15: */
	    x[i__ + j * x_dim1] = x[i__ + j * x_dim1] - t1[i__ + j * t1_dim1]
		    * x[i__ + 1 + j * x_dim1] - t2[i__ + j * t2_dim1] * x[i__
		    + 2 + j * x_dim1];
	}
/* L20: */
    }
    return 0;
} /* pbsm_ */

/* Subroutine */ int pfac_(integer *nn, doublereal *d__, doublereal *t1,
	doublereal *t2)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal dii;


/* ... pfac computes a factorization of a single symmetric */
/*     pentadiagonal matrix contained in d, t1, and t2 and */
/*     replaces it. */

/* ... parameters -- */

/*          n      order of system (= nn) */
/*          d      vector of length n containing the diagonal */
/*                  elements of the matrix */
/*          t1     vector of length n-1 containing the first */
/*                  super-diagonal elements of the matrix */
/*          t2     vector of length n-2 containing the second */
/*                  super-diagonal elements of the matrix */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --t2;
    --t1;
    --d__;

    /* Function Body */
    n = *nn;
    i__1 = n - 2;
    for (i__ = 1; i__ <= i__1; ++i__) {
	dii = 1. / d__[i__];
	d__[i__ + 1] -= t1[i__] * t1[i__] * dii;
	d__[i__ + 2] -= t2[i__] * t2[i__] * dii;
	t1[i__ + 1] -= t1[i__] * t2[i__] * dii;
/* L10: */
    }
    d__[n] -= t1[n - 1] * t1[n - 1] / d__[n - 1];
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	d__[i__] = 1. / d__[i__];
    }
    i__1 = n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	t1[i__] = d__[i__] * t1[i__];
    }
    i__1 = n - 2;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	t2[i__] = d__[i__] * t2[i__];
    }
    return 0;
} /* pfac_ */

/* Subroutine */ int pfacm_(integer *nn, integer *nsize, doublereal *d__,
	doublereal *t1, doublereal *t2)
{
    /* System generated locals */
    integer d_dim1, d_offset, t1_dim1, t1_offset, t2_dim1, t2_offset, i__1,
	    i__2;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, n;
    extern /* Subroutine */ int vinv_(integer *, doublereal *);
    static integer nsys;
    extern /* Subroutine */ int vexopy_(integer *, doublereal *, doublereal *,
	     doublereal *, integer *);


/* ... pfacm computes factorizations of multiple independent */
/*     symmetric pentadiagonal matrices contained in d, t1, and t2. */

/* ... parameters -- */

/*          n      order of global system (= nn) */
/*          nsize  size of the individual subsystems */
/*          d      linear array of length n containing the */
/*                  diagonal elements of the systems */
/*          t1     linear array of length n-1 containing the */
/*                  first super-diagonal elements of the systems */
/*          t2     linear array of length n-2 containing the */
/*                  second super-diagonal elements of the systems */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t2_dim1 = *nsize;
    t2_offset = 1 + t2_dim1;
    t2 -= t2_offset;
    t1_dim1 = *nsize;
    t1_offset = 1 + t1_dim1;
    t1 -= t1_offset;
    d_dim1 = *nsize;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;

    /* Function Body */
    n = *nn;
    nsys = n / *nsize;
    i__1 = *nsize - 2;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = nsys;
	for (j = 1; j <= i__2; ++j) {
/* Computing 2nd power */
	    d__1 = t1[i__ + j * t1_dim1];
	    d__[i__ + 1 + j * d_dim1] -= d__1 * d__1 / d__[i__ + j * d_dim1];
/* Computing 2nd power */
	    d__1 = t2[i__ + j * t2_dim1];
	    d__[i__ + 2 + j * d_dim1] -= d__1 * d__1 / d__[i__ + j * d_dim1];
	    t1[i__ + 1 + j * t1_dim1] -= t1[i__ + j * t1_dim1] * t2[i__ + j *
		    t2_dim1] / d__[i__ + j * d_dim1];
/* L10: */
	}
/* L15: */
    }
    i__1 = nsys;
    for (j = 1; j <= i__1; ++j) {
/* L20: */
/* Computing 2nd power */
	d__1 = t1[*nsize - 1 + j * t1_dim1];
	d__[*nsize + j * d_dim1] -= d__1 * d__1 / d__[*nsize - 1 + j * d_dim1]
		;
    }
    vinv_(&n, &d__[d_offset]);
    i__1 = n - 1;
    vexopy_(&i__1, &t1[t1_offset], &d__[d_offset], &t1[t1_offset], &c__3);
    i__1 = n - 2;
    vexopy_(&i__1, &t2[t2_offset], &d__[d_offset], &t2[t2_offset], &c__3);
    return 0;
} /* pfacm_ */

/* Subroutine */ int pfacn_(integer *nn, doublereal *d__, doublereal *t1,
	doublereal *t2, doublereal *b1, doublereal *b2)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal dii;


/* ... pfacn computes a factorization of a single nonsymmetric */
/*     pentadiagonal matrix contained in d,t1,t2,b1, and b2 */
/*     and replaces it. */

/* ... parameters -- */

/*          n      order of system (= nn) */
/*          d      vector of length n containing the diagonal */
/*                  elements of the matrix */
/*          t1     vector of length n-1 containing the first */
/*                  super-diagonal elements of the matrix */
/*          t2     vector of length n-2 containing the second */
/*                  super-diagonal elements of the matrix */
/*          b1     vector of length n-1 containing the first */
/*                  sub-diagonal elements of the matrix */
/*          b2     vector of length n-2 containing the second */
/*                  sub-diagonal elements of the matrix */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --b2;
    --b1;
    --t2;
    --t1;
    --d__;

    /* Function Body */
    n = *nn;
    i__1 = n - 2;
    for (i__ = 1; i__ <= i__1; ++i__) {
	dii = 1. / d__[i__];
	d__[i__ + 1] -= b1[i__] * t1[i__] * dii;
	d__[i__ + 2] -= b2[i__] * t2[i__] * dii;
	t1[i__ + 1] -= b1[i__] * t2[i__] * dii;
	b1[i__ + 1] -= b2[i__] * t1[i__] * dii;
/* L10: */
    }
    d__[n] -= b1[n - 1] * t1[n - 1] / d__[n - 1];
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	d__[i__] = 1. / d__[i__];
    }
    i__1 = n - 1;
    for (i__ = 1; i__ <= i__1; ++i__) {
	t1[i__] = d__[i__] * t1[i__];
	b1[i__] = d__[i__] * b1[i__];
/* L20: */
    }
    i__1 = n - 2;
    for (i__ = 1; i__ <= i__1; ++i__) {
	t2[i__] = d__[i__] * t2[i__];
	b2[i__] = d__[i__] * b2[i__];
/* L25: */
    }
    return 0;
} /* pfacn_ */

/* Subroutine */ int pfacnm_(integer *nn, integer *nsize, doublereal *d__,
	doublereal *t1, doublereal *t2, doublereal *b1, doublereal *b2)
{
    /* System generated locals */
    integer d_dim1, d_offset, t1_dim1, t1_offset, b1_dim1, b1_offset, t2_dim1,
	     t2_offset, b2_dim1, b2_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, n;
    extern /* Subroutine */ int vinv_(integer *, doublereal *);
    static integer nsys;
    extern /* Subroutine */ int vexopy_(integer *, doublereal *, doublereal *,
	     doublereal *, integer *);


/* ... pfacnm computes factorizations of multiple independent */
/*     nonsymmetric pentadiagonal matrices contained in */
/*     d,t1,t2,b1, and b2. */

/* ... parameters -- */

/*          n      order of global system (= nn) */
/*          nsize  order of single subsystem */
/*          d      linear array of length n containing the */
/*                  diagonal elements of the systems */
/*          t1     linear array of length n-1 containing the first */
/*                  super-diagonal elements of the systems */
/*          t2     linear array of length n-2 containing the second */
/*                  super-diagonal elements of the systems */
/*          b1     linear array of length n-1 containing the first */
/*                  sub-diagonal elements of the systems */
/*          b2     linear array of length n-2 containing the second */
/*                  sub-diagonal elements of the systems */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b2_dim1 = *nsize;
    b2_offset = 1 + b2_dim1;
    b2 -= b2_offset;
    b1_dim1 = *nsize;
    b1_offset = 1 + b1_dim1;
    b1 -= b1_offset;
    t2_dim1 = *nsize;
    t2_offset = 1 + t2_dim1;
    t2 -= t2_offset;
    t1_dim1 = *nsize;
    t1_offset = 1 + t1_dim1;
    t1 -= t1_offset;
    d_dim1 = *nsize;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;

    /* Function Body */
    n = *nn;
    nsys = n / *nsize;
    i__1 = *nsize - 2;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = nsys;
	for (j = 1; j <= i__2; ++j) {
	    d__[i__ + 1 + j * d_dim1] -= b1[i__ + j * b1_dim1] * t1[i__ + j *
		    t1_dim1] / d__[i__ + j * d_dim1];
	    d__[i__ + 2 + j * d_dim1] -= b2[i__ + j * b2_dim1] * t2[i__ + j *
		    t2_dim1] / d__[i__ + j * d_dim1];
	    t1[i__ + 1 + j * t1_dim1] -= b1[i__ + j * b1_dim1] * t2[i__ + j *
		    t2_dim1] / d__[i__ + j * d_dim1];
	    b1[i__ + 1 + j * b1_dim1] -= b2[i__ + j * b2_dim1] * t1[i__ + j *
		    t1_dim1] / d__[i__ + j * d_dim1];
/* L10: */
	}
/* L15: */
    }
    i__1 = nsys;
    for (j = 1; j <= i__1; ++j) {
/* L20: */
	d__[*nsize + j * d_dim1] -= b1[*nsize - 1 + j * b1_dim1] * t1[*nsize
		- 1 + j * t1_dim1] / d__[*nsize - 1 + j * d_dim1];
    }
    vinv_(&n, &d__[d_offset]);
    i__1 = n - 1;
    vexopy_(&i__1, &t1[t1_offset], &d__[d_offset], &t1[t1_offset], &c__3);
    i__1 = n - 2;
    vexopy_(&i__1, &t2[t2_offset], &d__[d_offset], &t2[t2_offset], &c__3);
    i__1 = n - 1;
    vexopy_(&i__1, &b1[b1_offset], &d__[d_offset], &b1[b1_offset], &c__3);
    i__1 = n - 2;
    vexopy_(&i__1, &b2[b2_offset], &d__[d_offset], &b2[b2_offset], &c__3);
    return 0;
} /* pfacnm_ */

/* Subroutine */ int pfs_(integer *n, doublereal *b1, doublereal *b2,
	doublereal *x)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;


/* ... pfs does a penta-diagonal forward substitution  (i+b1+b2)*x = y */
/*     where b1 and b2 are the first and second sub-diagonals. */

/* ... parameters -- */

/*          n      order of system */
/*          b1     vector of length n-1 containing the first */
/*                  sub-diagonal elements */
/*          b2     vector of length n-2 containing the second */
/*                  sub-diagonal elements */
/*          x      on input, x contains y */
/*                 on output, x contains the solution to */
/*                  (i + b1 + b2)*x = y */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --x;
    --b2;
    --b1;

    /* Function Body */
    x[2] -= b1[1] * x[1];
    i__1 = *n;
    for (i__ = 3; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = x[i__] - b1[i__ - 1] * x[i__ - 1] - b2[i__ - 2] * x[i__ - 2];
    }
    return 0;
} /* pfs_ */

/* Subroutine */ int pfsm_(integer *nn, integer *nsize, doublereal *b1,
	doublereal *b2, doublereal *x)
{
    /* System generated locals */
    integer b1_dim1, b1_offset, b2_dim1, b2_offset, x_dim1, x_offset, i__1,
	    i__2;

    /* Local variables */
    static integer i__, j, n, nsys;


/* ... pfsm does a penta-diagonal forward substitution (i+b1+b2)*x = y */
/*     where b1 and b2 are subdiagonals of a system composed of */
/*     independent subsystems of size nsize. */

/* ... parameters -- */

/*          n      order of system */
/*          nsize  order of the individual subsystems */
/*          b1     linear array of length n-1 containing the first */
/*                  sub-diagonal elements of the factorizations */
/*          b2     linear array of length n-2 containing the second */
/*                  sub-diagonal elements of the factorizations */
/*          x      on input, x contains y */
/*                 on output, x contains */
/*                 the solution to (i + b1 + b2)*x = y */

/* ... specifications for parameters */


    /* Parameter adjustments */
    x_dim1 = *nsize;
    x_offset = 1 + x_dim1;
    x -= x_offset;
    b2_dim1 = *nsize;
    b2_offset = 1 + b2_dim1;
    b2 -= b2_offset;
    b1_dim1 = *nsize;
    b1_offset = 1 + b1_dim1;
    b1 -= b1_offset;

    /* Function Body */
    n = *nn;
    nsys = n / *nsize;
    i__1 = nsys;
    for (j = 1; j <= i__1; ++j) {
/* L10: */
	x[j * x_dim1 + 2] -= b1[j * b1_dim1 + 1] * x[j * x_dim1 + 1];
    }
    i__1 = *nsize;
    for (i__ = 3; i__ <= i__1; ++i__) {
	i__2 = nsys;
	for (j = 1; j <= i__2; ++j) {
/* L15: */
	    x[i__ + j * x_dim1] = x[i__ + j * x_dim1] - b1[i__ - 1 + j *
		    b1_dim1] * x[i__ - 1 + j * x_dim1] - b2[i__ - 2 + j *
		    b2_dim1] * x[i__ - 2 + j * x_dim1];
	}
/* L20: */
    }
    return 0;
} /* pfsm_ */

/* Subroutine */ int psoln_(integer *nn, doublereal *d__, doublereal *t1,
	doublereal *t2, doublereal *b1, doublereal *b2, doublereal *y,
	doublereal *x)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int pbs_(integer *, doublereal *, doublereal *,
	    doublereal *), pfs_(integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... psoln solves the system ax = y for x, where a is a single */
/*     pentadiagonal system.  d, t1, t2, b1, and b2 contain */
/*     the main, first and second super, and first and second sub */
/*     diagonals, respectively, of the factorization. */

/* ... parameters -- */

/*          n      order of system */
/*          d      vector of length n containing the diagonal */
/*                  elements of the factorization matrix */
/*          t1     vector of length n-1 containing the first */
/*                  super-diagonal elements of the factorization */
/*          t2     vector of length n-2 containing the second */
/*                  super-diagonal elements of the factorization */
/*          b1     vector of length n-1 containing the first */
/*                  sub-diagonal elements of the factorization */
/*          b2     vector of length n-2 containing the second */
/*                  sub-diagonal elements of the factorization */
/*          y      the right-hand side */
/*          x      the solution to ax = y */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --x;
    --y;
    --b2;
    --b1;
    --t2;
    --t1;
    --d__;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    pfs_(&n, &b1[1], &b2[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = d__[i__] * x[i__];
    }
    pbs_(&n, &t1[1], &t2[1], &x[1]);
    return 0;
} /* psoln_ */

/* Subroutine */ int psolnm_(integer *nn, integer *nsize, doublereal *d__,
	doublereal *t1, doublereal *t2, doublereal *b1, doublereal *b2,
	doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int pbsm_(integer *, integer *, doublereal *,
	    doublereal *, doublereal *), pfsm_(integer *, integer *,
	    doublereal *, doublereal *, doublereal *);


/* ... psolnm solves the system ax = y for x, where a contains */
/*     multiple pentadiagonal systems.  d, t1, t2, b1, and b2 are */
/*     the main, first and second super, and the first and second */
/*     sub diagonals, respectively, of the factorization. */

/* ... parameters -- */

/*          n      order of system */
/*          nsize  size of an individual subsystem */
/*          d      vector of length n containing the diagonal */
/*                  elements of the factorization matrix */
/*          t1     vector of length n-1 containing the first */
/*                  super-diagonal elements of the factorization */
/*          t2     vector of length n-2 containing the second */
/*                  super-diagonal elements of the factorization */
/*          b1     vector of length n-1 containing the first */
/*                  sub-diagonal elements of the factorization */
/*          b2     vector of length n-2 containing the second */
/*                  sub-diagonal elements of the factorization */
/*          y      the right-hand side */
/*          x      the solution to ax = y */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --x;
    --y;
    --b2;
    --b1;
    --t2;
    --t1;
    --d__;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    pfsm_(&n, nsize, &b1[1], &b2[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = d__[i__] * x[i__];
    }
    pbsm_(&n, nsize, &t1[1], &t2[1], &x[1]);
    return 0;
} /* psolnm_ */

/* Subroutine */ int parsi_(void)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static doublereal rhol;


/* ... parsi computes the iteration parameters. */


/* *** begin -- package common */


/* *** end   -- package common */

    rhol = itcom3_1.rho;
    if ((i__1 = itcom1_1.is - 1) < 0) {
	goto L10;
    } else if (i__1 == 0) {
	goto L15;
    } else {
	goto L20;
    }
L10:
    itcom3_1.rho = 1.;
    goto L25;
L15:
    itcom3_1.rho = 1. / (1. - itcom3_1.sigma * itcom3_1.sigma / 2.);
    goto L25;
L20:
    itcom3_1.rho = 1. / (1. - itcom3_1.sigma * itcom3_1.sigma * rhol / 4.);

/* ... compute alpha, beta. */

L25:
    itcom3_1.alpha = itcom3_1.rho * itcom3_1.gamma;
    itcom3_1.beta = rhol * (itcom3_1.rho - 1.) / itcom3_1.rho;
    return 0;
} /* parsi_ */

/* Subroutine */ int permas_(integer *isym, integer *nn, integer *nzz,
	integer *ia, integer *ja, doublereal *a, doublereal *wksp, integer *p)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n, nz, np1, idum;
    extern /* Subroutine */ int vgathi_(integer *, integer *, integer *,
	    integer *), vscatr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... permas takes the sparse matrix representation of the */
/*     matrix and permutes both rows and columns, overwriting */
/*     the previous structure.  (sparse data structure) */

/* ... parameters -- */

/*          isym      switch for symmetric storage */
/*                     = 0   matrix is symmetric */
/*                     = 1   matrix is nonsymmetric */
/*          n         size of system */
/*          nz        length of ia, ja, and a vectors */
/*          ia        vector of i values */
/*          ja        vector of j values */
/*          a         vector of matrix coefficients */
/*          wksp      workspace vector of length n */
/*          p         permutation vector */

/* ... it is assumed that the i-th entry of the permutation vector */
/*     p indicates the row the i-th row gets mapped into.  (i.e. */
/*     if ( p(i) = j ) row i gets mapped into row j) */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --p;
    --wksp;
    --a;
    --ja;
    --ia;

    /* Function Body */
    n = *nn;
    nz = *nzz;

/* ... explicit gathers. */

    vgathi_(&nz, &p[1], &ia[1], &ia[1]);
    vgathi_(&nz, &p[1], &ja[1], &ja[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L5: */
	wksp[i__] = a[i__];
    }
    vscatr_(&n, &wksp[1], &p[1], &a[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	ia[i__] = i__;
	ja[i__] = i__;
/* L10: */
    }

/* ... convert to upper triangular elements for symmetric storage */

    if (*isym == 1) {
	return 0;
    }
    np1 = n + 1;
    i__1 = nz;
    for (i__ = np1; i__ <= i__1; ++i__) {
	if (ia[i__] <= ja[i__]) {
	    goto L15;
	}
	idum = ia[i__];
	ia[i__] = ja[i__];
	ja[i__] = idum;
L15:
	;
    }
    return 0;
} /* permas_ */

/* Subroutine */ int permat_(integer *ndim, integer *maxnz, doublereal *coef,
	integer *jcoef, doublereal *wksp, integer *iwksp, integer *nn,
	integer *p)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, jcoef_dim1, jcoef_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, n;
    extern /* Subroutine */ int vgathi_(integer *, integer *, integer *,
	    integer *), vscati_(integer *, integer *, integer *, integer *),
	    vscatr_(integer *, doublereal *, integer *, doublereal *);


/* ... permat takes the sparse matrix representation of the */
/*     matrix and permutes both rows and columns, overwriting */
/*     the previous structure.  (purdue data structure) */

/* ... parameters -- */

/*          ndim      row dimension of coef array in defining routine */
/*          maxnz     number of columns in coef and jcoef arrays */
/*          coef      array of matrix coefficients */
/*          jcoef     array of matrix columns numbers */
/*          wksp      workspace array of length n */
/*          iwksp     integer workspace array of length n */
/*          n         order of system (= nn) */
/*          p         permutation vector */

/* ... it is assumed that the i-th entry of the permutation vector */
/*     p indicates the row the i-th row gets mapped into.  (i.e. */
/*     if ( p(i) = j ) row i gets mapped into row j) */

/* ... specifications for parameters */


    /* Parameter adjustments */
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --wksp;
    --iwksp;
    --p;

    /* Function Body */
    n = *nn;
    if (n <= 0) {
	return 0;
    }
    i__1 = *maxnz;
    for (j = 1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    wksp[i__] = coef[i__ + j * coef_dim1];
	    iwksp[i__] = jcoef[i__ + j * jcoef_dim1];
/* L10: */
	}
	vscatr_(&n, &wksp[1], &p[1], &coef[j * coef_dim1 + 1]);
	vscati_(&n, &iwksp[1], &p[1], &jcoef[j * jcoef_dim1 + 1]);
	vgathi_(&n, &p[1], &jcoef[j * jcoef_dim1 + 1], &jcoef[j * jcoef_dim1
		+ 1]);
/* L20: */
    }
    return 0;
} /* permat_ */

/* Subroutine */ int perror1_(S_fp suba, doublereal *coef, integer *jcoef,
	doublereal *wfac, integer *jwfac, integer *nn, doublereal *u,
	doublereal *rhs, doublereal *wksp, doublereal *digtt1, doublereal *
	digtt2, integer *idgtts)
{
    /* Format strings */
    static char fmt_20[] = "(/10x,\002approx. no. of digits in stopping test"
	    " =\002,f5.1,2x,\002(digit1)\002/10x,\002approx. no. of digits in"
	    " ratio test    =\002,f5.1,2x,\002(digit2)\002)";

    /* System generated locals */
    doublereal d__1;

    /* Builtin functions */
    double d_lg10(doublereal *), sqrt(doublereal);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static integer n;
    static doublereal sum;
    extern /* Subroutine */ int out_(integer *, doublereal *, integer *,
	    integer *);
    static doublereal temp;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static doublereal rnrm, digit1, digit2;
    extern /* Subroutine */ int vexopy_(integer *, doublereal *, doublereal *,
	     doublereal *, integer *);

    /* Fortran I/O blocks */
    static cilist io___2658 = { 0, 0, 0, fmt_20, 0 };



/*     perror1 computes the residual, r = rhs - a*u.  the user */
/*     also has the option of printing the residual and/or the */
/*     unknown vector depending on idgts. */

/* ... parameters -- */

/*          suba   matrix-vector multiplication routine */
/*          n      dimension of matrix (= nn) */
/*          u      latest estimate of solution */
/*          rhs    right hand side of matrix problem */
/*          wksp   workspace vector of length n */
/*          digit1 output - measure of accuracy of stopping test (= digtt1 */
/*          digit2 output - measure of accuracy of solution (= digtt2) */
/*          idgts   parameter controlling level of output (= idgtts) */
/*                    if idgts < 1 or idgts > 4, then no output. */
/*                            = 1, then number of digits is printed, pro- */
/*                                 vided level .ge. 1 */
/*                            = 2, then solution vector is printed, pro- */
/*                                 vided level .ge. 1 */
/*                            = 3, then residual vector is printed, pro- */
/*                                 vided level .ge. 1 */
/*                            = 4, then both vectors are printed, pro- */
/*                                 vided level .ge. 1 */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --wksp;
    --rhs;
    --u;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    n = *nn;
    itcom1_1.idgts = *idgtts;
    digit1 = 0.;
    digit2 = 0.;

    d__1 = abs(itcom4_1.srelpr);
    digit1 = -d_lg10(&d__1);
    if (itcom3_1.stptst > 0.) {
	d__1 = abs(itcom3_1.stptst);
	digit1 = -d_lg10(&d__1);
    }
    (*suba)(&coef[1], &jcoef[1], &wfac[1], &jwfac[1], &n, &u[1], &wksp[1]);
    vexopy_(&n, &wksp[1], &rhs[1], &wksp[1], &c__2);
    rnrm = sqrt(vdot_(&n, &wksp[1], &wksp[1]));
    sum = vdot_(&n, &rhs[1], &rhs[1]);
/* Computing MAX */
    d__1 = sqrt(sum);
    itcom3_1.bnorm = max(d__1,itcom4_1.srelpr);
    temp = rnrm / itcom3_1.bnorm;
    if (temp == 0.) {
	goto L10;
    }
    d__1 = abs(temp);
    digit2 = -d_lg10(&d__1);
    goto L15;

L10:
    d__1 = abs(itcom4_1.srelpr);
    digit2 = -d_lg10(&d__1);

L15:
    if (itcom1_1.idgts < 1 || itcom1_1.level <= 0) {
	goto L25;
    }
    io___2658.ciunit = itcom1_1.nout;
    s_wsfe(&io___2658);
    do_fio(&c__1, (char *)&digit1, (ftnlen)sizeof(doublereal));
    do_fio(&c__1, (char *)&digit2, (ftnlen)sizeof(doublereal));
    e_wsfe();

    if (itcom1_1.idgts <= 1 || itcom1_1.idgts > 4) {
	goto L25;
    }
    if (itcom1_1.idgts >= 3) {
	out_(&n, &wksp[1], &c__1, &itcom1_1.nout);
    }
    if (itcom1_1.idgts != 3) {
	out_(&n, &u[1], &c__2, &itcom1_1.nout);
    }

L25:
    *digtt1 = digit1;
    *digtt2 = digit2;
    return 0;
} /* perror1_ */

/* Subroutine */ int pervec_(integer *nn, integer *p, doublereal *v,
	doublereal *wksp)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int vscatr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... pervec permutes a vector as dictated by the permutation */
/* ... vector p.  if p(i) = j, then v(j) gets v(i). */

/* ... parameters -- */

/*          n       length of vectors p, v, and wksp  (= nn) */
/*          p       integer permutation vector */
/*          v       vector to be permuted */
/*          wksp    workspace vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --wksp;
    --v;
    --p;

    /* Function Body */
    n = *nn;
    if (n <= 0) {
	return 0;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	wksp[i__] = v[i__];
/* L10: */
    }
    vscatr_(&n, &wksp[1], &p[1], &v[1]);
    return 0;
} /* pervec_ */

/* Subroutine */ int pgen_(integer *nn, integer *p, integer *ip, integer *nc,
	integer *ncolor)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, j, n, ic;


/* ... pgen constructs the permutation vector p and its inverse */
/* ... ip for a coloring given by p. */

/* ... parameters -- */

/*         n         order of system (= nn) */
/*         p         vector from prbndx upon input */
/*                   permutation vector upon output */
/*         ip        integer workspace vector upon input */
/*                   inverse permutation vector upon output */
/*         nc        number of points for each color (output) */
/*         ncolor    number of colors */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --nc;
    --ip;
    --p;

    /* Function Body */
    n = *nn;

/* ... determine number of colors and number of elements for each */
/*     color. */

    *ncolor = 0;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L5: */
	nc[i__] = 0;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	ic = p[i__];
	if (*ncolor < ic) {
	    *ncolor = ic;
	}
	++nc[ic];
/* L10: */
    }

/* ... construct permutation vector. */

    ip[1] = 1;
    i__1 = *ncolor;
    for (i__ = 2; i__ <= i__1; ++i__) {
	ip[i__] = ip[i__ - 1] + nc[i__ - 1];
/* L15: */
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	ic = p[i__];
	p[i__] = ip[ic];
	++ip[ic];
/* L20: */
    }

/* ... construct inverse permutation vector. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	j = p[i__];
	ip[j] = i__;
/* L25: */
    }
    return 0;
} /* pgen_ */

/* Subroutine */ int pjac_(doublereal *diag, integer *nn, doublereal *r__,
	doublereal *z__)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;


/* ... pjac does the point jacobi preconditioning. */

/* ... parameters -- */

/*         diag    vector of length n containing the diagonal */
/*                  elements of the coefficient matrix */
/*         n       order of system (= nn) */
/*         r       residual */
/*         z       output vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --z__;
    --r__;
    --diag;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	z__[i__] = r__[i__] / diag[i__];
    }
    return 0;
} /* pjac_ */

/* Subroutine */ int pmdg_(integer *ndim, integer *mdim, integer *nn, integer
	*maxnz, integer *jcoef, doublereal *coef, integer *ncol, integer *nc,
	integer *p, integer *ip, integer *maxd, integer *maxnew, integer *
	jcnew, doublereal *wksp, integer *iwksp, integer *isym, integer *ier)
{
    /* System generated locals */
    integer jcnew_dim1, jcnew_offset, coef_dim1, coef_offset, i__1, i__2,
	    i__3, i__4;

    /* Local variables */
    static integer i__, j, k, l, n, id, jj, ied, ncc, ind, len, lim, iip, ist,
	     jcol, icol;
    extern /* Subroutine */ int vfill_(integer *, doublereal *, doublereal *),
	     vcopy_(integer *, doublereal *, doublereal *), vgathi_(integer *,
	     integer *, integer *, integer *), vscati_(integer *, integer *,
	    integer *, integer *);
    static integer ncolor;
    extern /* Subroutine */ int vscatr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... pmdg permutes the matrix according to index vector p, */
/*     and, if room allows, stores the permuted matrix in */
/*     diagonal format.  there will be enough room if the number */
/*     of diagonals needed does not exceed mdim. */

/* ... parameters -- */

/*        ndim      row dimension of coef and jcoef arrays */
/*                   in defining routine */
/*        mdim      column dimension of coef and jcoef arrays in */
/*                   defining routine */
/*        n         order of system (active row size of coef and jcoef) */
/*        maxnz     active column size of coef and jcoef */
/*        jcoef     integer array of column numbers */
/*        coef      floating point array of coefficients */
/*        ncolor    number of colors in the permutation (= ncol) */
/*        nc        integer vector of length ncolor giving the */
/*                   number of nodes for each color */
/*        p         permutation vector */
/*        ip        inverse permuation vector */
/*        maxd      active columns in permuted matrix */
/*        maxnew    integer vector giving the number of diagonals */
/*                   created for each color */
/*        jcnew     integer array of size ncolor*max(maxnew(i)) */
/*                   giving the diagonal numbers for each color */
/*        wksp      floating point workspace of length n */
/*        iwksp     integer workspace of length 2*n */
/*        isym      symmetric storage switch */
/*                   = 0    symmetric storage */
/*                   = 1    nonsymmetric storage */
/*        ier       error flag */
/*                  =  0   no errors detected */
/*                  = -9   mdim is less than the number of columns */
/*                          needed in coef to store the permuted */
/*                          matrix in diagonal format */

/* ... specifications for parameters */



    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;
    jcnew_dim1 = *ncol;
    jcnew_offset = 1 + jcnew_dim1;
    jcnew -= jcnew_offset;
    --nc;
    --p;
    --ip;
    --maxnew;
    --wksp;
    --iwksp;

    /* Function Body */
    n = *nn;
    ncolor = *ncol;

/* ... fill out rest of matrix if symmetric storage is used. */

    if (*isym != 0) {
	goto L2;
    }
    *maxd = (*maxnz << 1) - 1;
    if (*mdim < *maxd) {
	*ier = -9;
    }
    if (*ier < 0) {
	return 0;
    }

    i__1 = *maxnz;
    for (j = 2; j <= i__1; ++j) {
	ind = jcoef[j];
	len = n - ind;
	jcol = *maxnz + j - 1;
	jcoef[jcol] = -ind;
	vfill_(&ind, &coef[jcol * coef_dim1 + 1], &c_b121);
	vcopy_(&len, &coef[j * coef_dim1 + 1], &coef[ind + 1 + jcol *
		coef_dim1]);
/* L1: */
    }
    *maxnz = *maxd;

/* ... determine the number of created diagonals. */

L2:
    i__1 = ncolor;
    for (i__ = 1; i__ <= i__1; ++i__) {
	maxnew[i__] = 1;
	jcnew[i__ + jcnew_dim1] = 0;
/* L5: */
    }
    i__1 = *maxnz;
    for (j = 2; j <= i__1; ++j) {
	ind = jcoef[j];
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    iwksp[n + i__] = i__ + ind;
	    if (coef[i__ + j * coef_dim1] == 0.) {
		iwksp[n + i__] = i__;
	    }
/* L10: */
	}
	vscati_(&n, &iwksp[n + 1], &p[1], &iwksp[1]);
	vgathi_(&n, &p[1], &iwksp[1], &iwksp[1]);
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L15: */
	    iwksp[i__] -= i__;
	}
	ist = 1;
	i__2 = ncolor;
	for (k = 1; k <= i__2; ++k) {
	    ncc = nc[k];
	    ied = ist + ncc - 1;
	    lim = maxnew[k];
	    i__3 = ied;
	    for (i__ = ist; i__ <= i__3; ++i__) {
		id = iwksp[i__];
		i__4 = lim;
		for (jj = 1; jj <= i__4; ++jj) {
		    if (jcnew[k + jj * jcnew_dim1] == id) {
			goto L25;
		    }
/* L20: */
		}
		++lim;
		maxnew[k] = lim;
		if (lim > *mdim) {
		    goto L40;
		}
		jcnew[k + lim * jcnew_dim1] = id;
L25:
		;
	    }
	    ist += ncc;
/* L30: */
	}
/* L35: */
    }

/* ... determine maxd. */

L40:
    *maxd = -1;
    i__1 = ncolor;
    for (k = 1; k <= i__1; ++k) {
/* L45: */
/* Computing MAX */
	i__2 = *maxd, i__3 = maxnew[k];
	*maxd = max(i__2,i__3);
    }
    if (*mdim < *maxd) {
	*ier = -9;
    }
    if (*ier < 0) {
	return 0;
    }

/* ... permute matrix. */

    i__2 = *maxnz;
    for (j = 1; j <= i__2; ++j) {
	i__3 = n;
	for (i__ = 1; i__ <= i__3; ++i__) {
/* L50: */
	    wksp[i__] = coef[i__ + j * coef_dim1];
	}
	vscatr_(&n, &wksp[1], &p[1], &coef[j * coef_dim1 + 1]);
/* L55: */
    }

/* ... rearrange rows. */

    ist = 1;
    i__2 = ncolor;
    for (k = 1; k <= i__2; ++k) {
	ncc = nc[k];
	ied = ist + ncc - 1;
	lim = maxnew[k];
	i__3 = lim;
	for (l = 1; l <= i__3; ++l) {
	    jcol = jcnew[k + l * jcnew_dim1];
	    iwksp[n + jcol] = l;
/* L62: */
	}
	i__3 = ied;
	for (i__ = ist; i__ <= i__3; ++i__) {
	    iip = ip[i__];
	    i__1 = *maxnz;
	    for (j = 2; j <= i__1; ++j) {
/* L60: */
		wksp[j] = coef[i__ + j * coef_dim1];
	    }
	    i__1 = *maxd;
	    for (j = 2; j <= i__1; ++j) {
/* L63: */
		coef[i__ + j * coef_dim1] = 0.;
	    }
	    i__1 = *maxnz;
	    for (j = 2; j <= i__1; ++j) {
		if (wksp[j] == 0.) {
		    goto L75;
		}
		icol = p[iip + jcoef[j]] - i__;
		l = iwksp[n + icol];
		coef[i__ + l * coef_dim1] = wksp[j];
L75:
		;
	    }
/* L80: */
	}
	ist += ncc;
/* L85: */
    }
    return 0;
} /* pmdg_ */

/* Subroutine */ int prbndx_(integer *nn, integer *ndim, integer *maxnzz,
	integer *jcoef, doublereal *coef, integer *p, integer *ip, logical *
	propa, integer *nstore)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, coef_dim1, coef_offset, i__1, i__2,
	    i__3, i__4;

    /* Builtin functions */
    integer i_sign(integer *, integer *);

    /* Local variables */
    static integer i__, j, k, l, n, old, ibgn, jcol, last, next, type__,
	    first, maxnz, young, curtyp, nxttyp;


/* ************************************************************** */

/*     (purdue, diagonal data structures) */
/*     prbndx determines if the matrix has property a. */
/*     this algorithm assumes all neighbors of a particular node */
/*     are known. */

/*     the algorithm is to mark the first node as red (arbitrary). */
/*     all of its adjacent nodes are marked black and placed in */
/*     a stack.  the remainder of the code pulls the first node */
/*     off the top of the stack and tries to type its adjacent nodes. */
/*     the typing of the adjacent point is a five way case statement */
/*     which is well commented below (see do loop 50). */

/*     the array p is used both to keep track of the color of a node */
/*     (red node is positive, black is negative) but also the father */
/*     node that caused the color marking of that point.  since */
/*     complete information on the adjacency structure is hard to come */
/*     by, this forms a link to enable the color change of a partial */
/*     tree when a recoverable color conflict occurs. */

/*     the array ip is used as a stack to point to the set of nodes */
/*     left to be typed that are known to be adjacent to the current */
/*     father node. */


/* ********************************************************************* */

/* ... input parameters -- */

/*        n      number of nodes.  (integer, scalar) (= nn) */
/*        ndim   row dimension of coef array */
/*        maxnz  maximum number of nonzeros per row */
/*        jcoef  integer data array */
/*        coef   floating point data array */
/*        p,ip   integer workspace vectors of length n */
/*        nstore data structure switch */
/*                = 1  purdue */
/*                = 2  diagonal (symmetric or nonsymmetric) */

/* ... output parameters -- */

/*        p      contains information for constructing the permutation */
/*               array upon output */
/*        propa  a logical variable which is set to .true. if the */
/*               matrix has property a and .false. otherwise */


/* ******************************************************************** */

/* ... specifications for parameters */



/* ... specifications for local variables */


/* ----------------------------------------------------------------------- */

    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    --p;
    --ip;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	p[i__] = 0;
	ip[i__] = 0;
/* L5: */
    }

/* ... handle the first set of points until some adjacent points */
/* ... are found */

    first = 1;

L10:
    p[first] = first;
    if (maxnz > 1) {
	goto L20;
    }

/* ... search for next entry that has not been marked */

    if (first == n) {
	goto L65;
    }
    ibgn = first + 1;
    i__1 = n;
    for (i__ = ibgn; i__ <= i__1; ++i__) {
	if (p[i__] != 0) {
	    goto L15;
	}
	first = i__;
	goto L10;
L15:
	;
    }
    goto L65;

/* ... first set of adjacent points found */

L20:
    next = 1;
    last = 1;
    ip[1] = first;

/* ... loop over labeled points indicated in the stack stored in */
/* ... the array ip */

L25:
    k = ip[next];
    curtyp = p[k];
    nxttyp = -curtyp;
    if (maxnz <= 0) {
	goto L55;
    }
    i__1 = maxnz;
    for (j = 1; j <= i__1; ++j) {
	if (*nstore == 1) {
	    jcol = jcoef[k + j * jcoef_dim1];
	}
	if (*nstore >= 2) {
	    jcol = k + jcoef[j + jcoef_dim1];
	}

/* ... determine if element (k,j) is a diagonal element or zero. */

	if (jcol < 1 || jcol > n || jcol == k) {
	    goto L50;
	}
	if (coef[k + j * coef_dim1] == 0.) {
	    goto L50;
	}

	type__ = p[jcol];

/* ================================================================== */

/*     the following is a five way case statement dealing with the */
/*     labeling of the adjacent node. */

/* ... case i.  if the adjacent node has already been labeled with */
/*              label equal to nxttyp, then skip to the next adjacent */
/*              node. */

	if (type__ == nxttyp) {
	    goto L50;
	}

/* ... case ii.  if the adjacent node has not been labeled yet label */
/*               it with nxttyp and enter it in the stack */

	if (type__ != 0) {
	    goto L30;
	}
	++last;
	ip[last] = jcol;
	p[jcol] = nxttyp;
	goto L50;

/* ... case iii.  if the adjacent node has already been labeled with */
/*                opposite color and the same father seed, then there */
/*                is an irrecoverable color conflict. */

L30:
	if (type__ == curtyp) {
	    goto L999;
	}

/* ... case iv.  if the adjacent node has the right color and a different */
/*               father node, then change all nodes of the youngest fathe */
/*               node to point to the oldest father seed and retain the */
/*               same colors. */

	if (type__ * nxttyp < 1) {
	    goto L40;
	}
/* Computing MIN */
	i__2 = abs(type__), i__3 = abs(nxttyp);
	old = min(i__2,i__3);
/* Computing MAX */
	i__2 = abs(type__), i__3 = abs(nxttyp);
	young = max(i__2,i__3);
	i__2 = n;
	for (l = young; l <= i__2; ++l) {
	    if ((i__3 = p[l], abs(i__3)) == young) {
		p[l] = i_sign(&old, &p[l]);
	    }
/* L35: */
	}
	curtyp = p[k];
	nxttyp = -curtyp;
	goto L50;

/* ... case v.  if the adjacent node has the wrong color and a different */
/*              father node, then change all nodes of the youngest father */
/*              node to point to the oldest father node along with */
/*              changing their colors.  since until this time the */
/*              youngest father node tree has been independent no other */
/*              color conflicts will arise from this change. */

L40:
/* Computing MIN */
	i__2 = abs(type__), i__3 = abs(nxttyp);
	old = min(i__2,i__3);
/* Computing MAX */
	i__2 = abs(type__), i__3 = abs(nxttyp);
	young = max(i__2,i__3);
	i__2 = n;
	for (l = young; l <= i__2; ++l) {
	    if ((i__3 = p[l], abs(i__3)) == young) {
		i__4 = -p[l];
		p[l] = i_sign(&old, &i__4);
	    }
/* L45: */
	}
	curtyp = p[k];
	nxttyp = -curtyp;


/* ... end of case statement */

/* ================================================================== */
L50:
	;
    }

/* ... advance to next node in the stack */

L55:
    ++next;
    if (next <= last) {
	goto L25;
    }

/* ... all nodes in the stack have been removed */

/* ... check for nodes not labeled.  if any are found */
/* ... start the labeling process again at the first */
/* ... node found that is not labeled. */

    ibgn = first + 1;
    i__1 = n;
    for (i__ = ibgn; i__ <= i__1; ++i__) {
	if (p[i__] != 0) {
	    goto L60;
	}
	first = i__;
	goto L10;
L60:
	;
    }


/* =================================================================== */


/* ... all nodes are now typed either red or black. */
/* ... red-black ordering possible. */

L65:
    *propa = TRUE_;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (p[i__] >= 0) {
	    p[i__] = 1;
	}
	if (p[i__] <= 0) {
	    p[i__] = 2;
	}
/* L70: */
    }
    return 0;

/* ...... type conflict */

L999:
    *propa = FALSE_;
    return 0;
} /* prbndx_ */

/* Subroutine */ int prbblk_(integer *ncol, integer *ndis, integer *iblock,
	integer *lbhb, integer *p, integer *ip, logical *propa)
{
    /* System generated locals */
    integer iblock_dim2, iblock_offset, i__1, i__2, i__3, i__4;

    /* Builtin functions */
    integer i_sign(integer *, integer *);

    /* Local variables */
    static integer i__, j, k, l, old, jcol, last, next, type__, index, ndist,
	    first, maxnz, young, ncolor, curtyp, nxttyp;


/* ************************************************************** */

/*     (block structure) */
/*     prbblk determines if the matrix has block property a. */
/*     see routine prbndx for an explanation of the algorithm */

/* ************************************************************** */

/* ... input parameters -- */

/*         ncolor   number of diagonal blocks */
/*         ndis     number of distinct diagonal blocks */
/*         iblock   integer array of size 3 by ndis by max(lbhb(i)) */
/*                   giving block constants */
/*         lbhb     integer vector of size ndis giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*         p,ip     integer workspace vectors of length ncolor */

/* ... output parameters -- */

/*        p      contains information for constructing the permutation */
/*               array upon output */
/*        propa  a logical variable which is set to .true. if the */
/*               matrix has block property a and .false. otherwise */


/* ******************************************************************** */

/* ... specifications for parameters */


/* ... specifications for local variables */



    /* Parameter adjustments */
    iblock_dim2 = *ndis;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --lbhb;
    --p;
    --ip;

    /* Function Body */
    ncolor = *ncol;
    ndist = *ndis;
    index = 1;
    i__1 = ncolor;
    for (i__ = 1; i__ <= i__1; ++i__) {
	p[i__] = 0;
	ip[i__] = 0;
/* L5: */
    }

/* ... handle the first set of points until some adjacent points */
/* ... are found */

    first = 1;

L10:
    p[first] = first;
    if (ndist > 1) {
	index = first;
    }
    maxnz = lbhb[index];
    if (maxnz > 1) {
	goto L20;
    }

/* ... search for next entry that has not been marked */

    if (first == ncolor) {
	goto L65;
    }
    i__1 = ncolor;
    for (i__ = first + 1; i__ <= i__1; ++i__) {
	if (p[i__] != 0) {
	    goto L15;
	}
	first = i__;
	goto L10;
L15:
	;
    }
    goto L65;

/* ... first set of adjacent points found */

L20:
    next = 1;
    last = 1;
    ip[1] = first;

/* ... loop over labeled points indicated in the stack stored in */
/* ... the array ip */

L25:
    k = ip[next];
    curtyp = p[k];
    nxttyp = -curtyp;
    if (ndist > 1) {
	index = k;
    }
    maxnz = lbhb[index];
    if (maxnz <= 0) {
	goto L55;
    }
    i__1 = maxnz;
    for (j = 1; j <= i__1; ++j) {
	jcol = k + iblock[(index + j * iblock_dim2) * 3 + 1];

/* ... determine if element (k,j) is a diagonal element or zero. */

	if (jcol < 1 || jcol > ncolor || jcol == k) {
	    goto L50;
	}
	if (iblock[(index + j * iblock_dim2) * 3 + 3] == 0) {
	    goto L50;
	}

	type__ = p[jcol];

/* ================================================================== */

/*     the following is a five way case statement dealing with the */
/*     labeling of the adjacent node. */

/* ... case i.  if the adjacent node has already been labeled with */
/*              label equal to nxttyp, then skip to the next adjacent */
/*              node. */

	if (type__ == nxttyp) {
	    goto L50;
	}

/* ... case ii.  if the adjacent node has not been labeled yet label */
/*               it with nxttyp and enter it in the stack */

	if (type__ != 0) {
	    goto L30;
	}
	++last;
	ip[last] = jcol;
	p[jcol] = nxttyp;
	goto L50;

/* ... case iii.  if the adjacent node has already been labeled with */
/*                opposite color and the same father seed, then there */
/*                is an irrecoverable color conflict. */

L30:
	if (type__ == curtyp) {
	    goto L999;
	}

/* ... case iv.  if the adjacent node has the right color and a different */
/*               father node, then change all nodes of the youngest fathe */
/*               node to point to the oldest father seed and retain the */
/*               same colors. */

	if (type__ * nxttyp < 1) {
	    goto L40;
	}
/* Computing MIN */
	i__2 = abs(type__), i__3 = abs(nxttyp);
	old = min(i__2,i__3);
/* Computing MAX */
	i__2 = abs(type__), i__3 = abs(nxttyp);
	young = max(i__2,i__3);
	i__2 = ncolor;
	for (l = young; l <= i__2; ++l) {
	    if ((i__3 = p[l], abs(i__3)) == young) {
		p[l] = i_sign(&old, &p[l]);
	    }
/* L35: */
	}
	curtyp = p[k];
	nxttyp = -curtyp;
	goto L50;

/* ... case v.  if the adjacent node has the wrong color and a different */
/*              father node, then change all nodes of the youngest father */
/*              node to point to the oldest father node along with */
/*              changing their colors.  since until this time the */
/*              youngest father node tree has been independent no other */
/*              color conflicts will arise from this change. */

L40:
/* Computing MIN */
	i__2 = abs(type__), i__3 = abs(nxttyp);
	old = min(i__2,i__3);
/* Computing MAX */
	i__2 = abs(type__), i__3 = abs(nxttyp);
	young = max(i__2,i__3);
	i__2 = ncolor;
	for (l = young; l <= i__2; ++l) {
	    if ((i__3 = p[l], abs(i__3)) == young) {
		i__4 = -p[l];
		p[l] = i_sign(&old, &i__4);
	    }
/* L45: */
	}
	curtyp = p[k];
	nxttyp = -curtyp;


/* ... end of case statement */

/* ================================================================== */
L50:
	;
    }

/* ... advance to next node in the stack */

L55:
    ++next;
    if (next <= last) {
	goto L25;
    }

/* ... all nodes in the stack have been removed */

/* ... check for nodes not labeled.  if any are found */
/* ... start the labeling process again at the first */
/* ... node found that is not labeled. */

    i__1 = ncolor;
    for (i__ = first + 1; i__ <= i__1; ++i__) {
	if (p[i__] != 0) {
	    goto L60;
	}
	first = i__;
	goto L10;
L60:
	;
    }


/* =================================================================== */


/* ... all nodes are now typed either red or black. */
/* ... red-black ordering possible. */

L65:
    *propa = TRUE_;
    i__1 = ncolor;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (p[i__] >= 0) {
	    p[i__] = 1;
	}
	if (p[i__] <= 0) {
	    p[i__] = 2;
	}
/* L70: */
    }
    return 0;

/* ...... type conflict */

L999:
    *propa = FALSE_;
    return 0;
} /* prbblk_ */

/* Subroutine */ int prep1_(integer *nn, integer *ndim, integer *maxnzz,
	integer *jcoef, doublereal *coef, integer *ier)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, coef_dim1, coef_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, n;
    static doublereal save;
    static integer maxnz;


/* ... prep1 puts the diagonal elements of the matrix in column one */
/*     of coef  (purdue data structure) */

/* ... parameters -- */

/*         n       dimension of matrix ( = nn) */
/*         ndim    row dimension of coef array in defining routine */
/*         maxnz   number of columns in coef array (= maxnzz) */
/*         jcoef   integer matrix representation array */
/*         coef    matrix representation array */
/*         ier     error flag -- on return, values mean */
/*                      0 -- no errors detected */
/*                     -5 -- nonexistent diagonal element */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = maxnz;
	for (j = 1; j <= i__2; ++j) {
	    if (jcoef[i__ + j * jcoef_dim1] == i__) {
		goto L15;
	    }
/* L10: */
	}

/* ... no diagonal entry for row i. */

	*ier = -5;
	return 0;

/* ... switch entries so that diagonal element is in column 1. */

L15:
	if (j == 1) {
	    goto L20;
	}
	save = coef[i__ + j * coef_dim1];
	coef[i__ + j * coef_dim1] = coef[i__ + coef_dim1];
	jcoef[i__ + j * jcoef_dim1] = jcoef[i__ + jcoef_dim1];
	coef[i__ + coef_dim1] = save;
	jcoef[i__ + jcoef_dim1] = i__;
L20:
	;
    }
    return 0;
} /* prep1_ */

/* Subroutine */ int prep2_(integer *nn, integer *ndim, integer *maxnzz,
	integer *jcoef, doublereal *coef, doublereal *wksp, integer *ier)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, j, n, maxnz;


/* ... prep2 puts the diagonal entries of the matrix into column */
/*     one of coef.  (diagonal data structure) */

/* ... parameters -- */

/*         n       dimension of matrix ( = nn) */
/*         ndim    row dimension of coef array in defining routine */
/*         maxnz   number of columns in coef array (= maxnzz) */
/*         jcoef   integer matrix representation array */
/*         coef    matrix representation array */
/*         wksp    workspace array of size n */
/*         ier     error flag -- on return, values mean */
/*                      0 -- no errors detected */
/*                     -5 -- nonexistent diagonal element */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;
    --wksp;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;

    i__1 = maxnz;
    for (j = 1; j <= i__1; ++j) {
	if (jcoef[j] == 0) {
	    goto L15;
	}
/* L10: */
    }

/* ... no main diagonal. */

    *ier = -5;
    return 0;

/* ... switch diagonals so that main diagonal is in column 1. */

L15:
    if (j == 1) {
	return 0;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	wksp[i__] = coef[i__ + coef_dim1];
	coef[i__ + coef_dim1] = coef[i__ + j * coef_dim1];
	coef[i__ + j * coef_dim1] = wksp[i__];
/* L20: */
    }
    jcoef[j] = jcoef[1];
    jcoef[1] = 0;
    return 0;
} /* prep2_ */

/* Subroutine */ int prep3_(integer *n, integer *nz, integer *ia, integer *ja,
	 doublereal *a, integer *m, integer *np, integer *iwksp)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, j, k, l;
    static doublereal at;
    static integer mm, it, jt;
    static doublereal val;
    static integer kbgn;
    static doublereal aval;
    static integer nval, krep;
    extern /* Subroutine */ int vsrta1_(integer *, integer *, integer *,
	    doublereal *);


/* ... prep3 puts the diagonal elements of the matrix in the */
/*     first n locations of the data structure, adds duplicate */
/*     triples, and defines the partition for matrix-vector */
/*     products. */

/* ... parameters -- */

/*         n       number of equations */
/*         nz      length of ia, ja, and a vectors */
/*         ia      vector of i values */
/*         ja      vector of j values */
/*         a       vector of matrix coefficients */
/*         m       number of partitions (output) */
/*         np      on output, np contains the partition pointers. */
/*                  it must be at least m+1 in length. */
/*         iwksp   integer workspace vector of length n */

/* ... specifications for parameters */


/* ... eliminate duplicates from the vectors by adding their */
/*     values in the a vector.  first, sort the vectors by */
/*     rows first and then by columns within each row. */

    /* Parameter adjustments */
    --iwksp;
    --np;
    --a;
    --ja;
    --ia;

    /* Function Body */
    vsrta1_(nz, &ia[1], &ja[1], &a[1]);

/* ... add duplicates. */

    l = 1;
    i__1 = *nz;
    for (k = 2; k <= i__1; ++k) {
	i__ = ia[k];
	j = ja[k];
	aval = a[k];
	if (i__ == ia[l] && j == ja[l]) {
	    goto L5;
	}
	++l;
	ia[l] = i__;
	ja[l] = j;
	a[l] = aval;
	goto L10;
L5:
	a[l] += aval;
L10:
	;
    }
    *nz = l;

/* ... put main diagonal elements first. */

    i__1 = *nz;
    for (k = 1; k <= i__1; ++k) {
L15:
	i__ = ia[k];
	j = ja[k];
	if (i__ != j) {
	    goto L20;
	}
	if (i__ == k) {
	    goto L20;
	}
	val = a[k];
	ia[k] = ia[i__];
	ja[k] = ja[i__];
	a[k] = a[i__];
	ia[i__] = i__;
	ja[i__] = i__;
	a[i__] = val;
	goto L15;
L20:
	;
    }

/* ... define partitions. */

    kbgn = *n + 1;
    krep = kbgn;
    mm = 1;
    np[1] = 1;
L25:
    ++mm;
    np[mm] = kbgn;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	iwksp[i__] = 0;
    }
    nval = 0;
    if (kbgn > *nz) {
	goto L50;
    }
    i__1 = *nz;
    for (k = kbgn; k <= i__1; ++k) {
	i__ = ia[k];
	j = ja[k];
	if (iwksp[i__] == 1 || iwksp[i__] == 3 || iwksp[j] >= 2) {
	    goto L40;
	}
	++nval;
	++iwksp[i__];
	iwksp[j] += 2;
	if (k == krep) {
	    goto L35;
	}
	at = a[krep];
	it = ia[krep];
	jt = ja[krep];
	a[krep] = a[k];
	ia[krep] = i__;
	ja[krep] = j;
	a[k] = at;
	ia[k] = it;
	ja[k] = jt;
L35:
	++krep;
	if (nval >= *n) {
	    goto L45;
	}
L40:
	;
    }
L45:
    kbgn = krep;
    goto L25;
L50:
    *m = mm - 1;
    return 0;
} /* prep3_ */

/* Subroutine */ int prich_(integer *nn, doublereal *r__, doublereal *z__)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;


/* ... prich does the richardson preconditioning. */

/* ... parameters -- */

/*         n       order of system (= nn) */
/*         r       residual */
/*         z       output vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --z__;
    --r__;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	z__[i__] = r__[i__];
    }
    return 0;
} /* prich_ */

/* Subroutine */ int pstops_(integer *nn, doublereal *r__, doublereal *z__,
	doublereal *u, doublereal *ubar, integer *ier)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, n;
    static logical q1;
    static doublereal tl, tr, sum, uold;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static doublereal tiny, emaxl, eminl;
    static integer nteste;
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen);


/* ... pstops performs a test to see if the iterative method has */
/*     converged to a solution inside the error tolerance, zeta. */
/*     (cg and si routines) */

/*     the stopping tests are -- */

/*    (1)  (emax/emin) * sqrt ( (r ,zt)/(rhs,inv(q)*rhs) ) */
/*    (2)  ( 1.0/emin) * sqrt ( (zt,zt)/(u,u) ) */
/*    (3)  (emax/emin) * sqrt ( (zt,zt)/(inv(q)*rhs,inv(q)*rhs) ) */
/*    (4)                sqrt ( (zt,zt)/(inv(q)*rhs,inv(q)*rhs) ) */
/*    (5)                sqrt ( (r ,r )/(rhs,rhs) ) */
/*    (6)                sqrt ( (u-ubar,u-ubar)/(ubar,ubar) ) */
/*    (7)  (emax/emin) * sqrt ( (r,z)/(rhs,inv(ql)*rhs) ) */
/*    (8)  ( 1.0/emin) * sqrt ( (z,z)/(u,u) ) */
/*    (9)  (emax/emin) * sqrt ( (z,z)/(inv(ql)*rhs,inv(ql)*rhs) ) */
/*   (10)                sqrt ( (z,z)/(inv(ql)*rhs,inv(ql)*rhs) ) */


/* ... parameters -- */

/*         n       order of system */
/*         r       residual vector */
/*         z       pseudo-residual vector */
/*         u       solution estimate */
/*         ier     error flag */
/*                  =  0   no errors detected */
/*                  = -7   splitting matrix is not positive definite */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --ubar;
    --u;
    --z__;
    --r__;

    /* Function Body */
    n = *nn;
    itcom2_1.halt = FALSE_;
    tiny = itcom4_1.srelpr * 500.;
    nteste = itcom1_1.ntest;
    if (itcom1_1.ntest > 6) {
	nteste += -6;
    }

    switch (nteste) {
	case 1:  goto L10;
	case 2:  goto L20;
	case 3:  goto L30;
	case 4:  goto L40;
	case 5:  goto L50;
	case 6:  goto L60;
    }

/* ... test 1 */

L10:
    if (itcom9_1.rzdot >= 0.) {
	goto L15;
    }
    *ier = -7;
    ershow_(ier, "pstops", (ftnlen)6);
    return 0;
L15:
    emaxl = itcom3_1.emax;
    eminl = itcom3_1.emin;
    if (eminl < tiny) {
	eminl = tiny;
    }
    tl = emaxl * sqrt(itcom9_1.rzdot);
    tr = eminl * itcom3_1.bnorm1;
    itcom3_1.stptst = tl / tr;
    if (tl < tr * itcom3_1.zeta) {
	itcom2_1.halt = TRUE_;
    }
    return 0;

/* ... test 2 */

/* ... special procedure for zeroth iteration */

L20:
    if (itcom1_1.in >= 1) {
	goto L25;
    }
    q1 = FALSE_;
    itcom3_1.udnm = 1.;
    itcom3_1.stptst = sqrt(itcom9_1.rzdot);
    if (itcom3_1.stptst < tiny) {
	itcom2_1.halt = TRUE_;
    }
    return 0;

/* ... in .ge. 1 */

/* ... test if udnm needs to be recomputed. */

L25:
    if (q1) {
	goto L28;
    }
    if (itcom1_1.in > 5 && itcom1_1.in % 5 != 0) {
	goto L28;
    }
    uold = itcom3_1.udnm;
    itcom3_1.udnm = sqrt(vdot_(&n, &u[1], &u[1]));
    if (itcom3_1.udnm < tiny) {
	itcom3_1.udnm = 1.;
    }
    if (itcom1_1.in > 5 && (d__1 = itcom3_1.udnm - uold, abs(d__1)) <
	    itcom3_1.udnm * itcom3_1.zeta) {
	q1 = TRUE_;
    }

/* ... compute stopping test. */

L28:
    eminl = itcom3_1.emin;
    if (eminl < tiny) {
	eminl = tiny;
    }
    tl = sqrt(vdot_(&n, &z__[1], &z__[1]));
    tr = itcom3_1.udnm * eminl;
    itcom3_1.stptst = tl / tr;
    if (tl < tr * itcom3_1.zeta) {
	itcom2_1.halt = TRUE_;
    }
    return 0;

/* ... test 3. */

L30:
    emaxl = itcom3_1.emax;
    eminl = itcom3_1.emin;
    if (eminl < tiny) {
	eminl = tiny;
    }
    tl = emaxl * sqrt(vdot_(&n, &z__[1], &z__[1]));
    tr = eminl * itcom3_1.bnorm1;
    itcom3_1.stptst = tl / tr;
    if (tl < tr * itcom3_1.zeta) {
	itcom2_1.halt = TRUE_;
    }
    return 0;

/* ... test 4. */

L40:
    tl = sqrt(vdot_(&n, &z__[1], &z__[1]));
    tr = itcom3_1.bnorm1;
    itcom3_1.stptst = tl / tr;
    if (tl < tr * itcom3_1.zeta) {
	itcom2_1.halt = TRUE_;
    }
    return 0;

/* ... test 5. */

L50:
    tl = sqrt(vdot_(&n, &r__[1], &r__[1]));
    tr = itcom3_1.bnorm;
    itcom3_1.stptst = tl / tr;
    if (tl < tr * itcom3_1.zeta) {
	itcom2_1.halt = TRUE_;
    }
    return 0;

/* ... test 6. */

L60:
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L65: */
/* Computing 2nd power */
	d__1 = u[i__] - ubar[i__];
	sum += d__1 * d__1;
    }
    tl = sqrt(sum);
    tr = itcom3_1.ubarnm;
    itcom3_1.stptst = tl / tr;
    if (tl < tr * itcom3_1.zeta) {
	itcom2_1.halt = TRUE_;
    }
    return 0;
} /* pstops_ */

/* Subroutine */ int rowise_(integer *maxnz, integer *jcoef, integer *irwise)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer j, jcol, maxd;


/* ... rowise determines whether a row-wise or diagonal-wise */
/*     algorithm should be used for ic and ssor splittings with */
/*     diagonal storage.  this routine should be called after */
/*     final factorization is computed. */

/* ... parameters -- */

/*          maxnz  number of number of diagonals stored */
/*          jcoef  vector of diagonal numbers for factorization */
/*                  array or matrix */
/*          irwise has a value upon output of */
/*                  0   if diagonal-wise algorithm should be used */
/*                  1   if row-wise algorithm should be used */

/* ... specifications for parameters */


/* ... use a rowwise algorithm if  2 .le. /jcoef(j)/ .le. maxd */
/*     some j. */

    /* Parameter adjustments */
    --jcoef;

    /* Function Body */
    maxd = 10;

    *irwise = 0;
    i__1 = *maxnz;
    for (j = 1; j <= i__1; ++j) {
	jcol = (i__2 = jcoef[j], abs(i__2));
	if (jcol <= 1 || jcol > maxd) {
	    goto L15;
	}
	*irwise = 1;
	return 0;
L15:
	;
    }
    return 0;
} /* rowise_ */

/* Subroutine */ int rowsum_(integer *lda, integer *n, integer *maxnzz,
	doublereal *a, doublereal *x, integer *isym)
{
    /* System generated locals */
    integer a_dim1, a_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, maxnz;


/* ... rowsum computes the row sum of the matrix a. */

/* ... parameters -- */

/*        lda     leading dimension of array a */
/*        n       active size of array a */
/*        maxnz   number of columns in array a */
/*        a       array of size n by maxnz */
/*        x       vector of length n containing the row */
/*                 sum of a upon output */
/*        isym    symmetry switch */
/*                 = 0  matrix is a banded symmetric matrix */
/*                       with the diagonal in column one */
/*                 = 1  matrix is nonsymmetric */

/* ... specifications for parameters */


    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    --x;

    /* Function Body */
    maxnz = *maxnzz;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = 0.;
    }
    i__1 = maxnz;
    for (j = 1; j <= i__1; ++j) {
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L15: */
	    x[i__] += a[i__ + j * a_dim1];
	}
/* L20: */
    }
    if (*isym == 1 || maxnz <= 1) {
	return 0;
    }
    i__1 = maxnz;
    for (j = 2; j <= i__1; ++j) {
	i__2 = *n;
	for (i__ = j; i__ <= i__2; ++i__) {
/* L25: */
	    x[i__] += a[i__ - j + 1 + j * a_dim1];
	}
/* L30: */
    }
    return 0;
} /* rowsum_ */

/* Subroutine */ int rsad_(integer *nn, integer *nsize, integer *nrr, integer
	*ndim, integer *maxnew, integer *ndtt, integer *ndbb, integer *jcnew,
	doublereal *coef, doublereal *c__, doublereal *b, doublereal *dfac,
	doublereal *wksp)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, n, nb, nr, ndb, ndt, max2, nrp1, maxd, maxz;
    extern /* Subroutine */ int vaddd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *), bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *), bmuln_(integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *), vsubd_(integer *, integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    integer *);


/* ... rsad computes  c = (dr - t*inv(db)*b)*b */

/*       where      a  = ( dr   t ) */
/*                       ( b   db ) */

/*     diagonal storage */

/* ... parameters -- */

/*        n          order of system */
/*        nsize      size of an individual subsystem (if multiple */
/*                    systems) */
/*        nr         order of the red subsystem */
/*        ndim       row dimension of coef array */
/*        maxnew     number of columns in coef array */
/*        ndt        number of upper diagonals in diagonal block */
/*        ndb        number of lower diagonals in diagonal block */
/*        coef       floating point data structure */
/*        b          vector of length n containing bb behind br */
/*        c          vector of length nr containing cr */
/*        dfac       vector of length (1+nt+nb)*n to contain */
/*                    factorization of diagonal block upon output */
/*        wksp       workspace vector of length nb */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --maxnew;
    jcnew -= 3;
    --c__;
    --b;
    --dfac;
    --wksp;

    /* Function Body */
    n = *nn;
    nr = *nrr;
    ndt = *ndtt;
    ndb = *ndbb;
    nrp1 = nr + 1;
    nb = n - nr;
    maxd = ndt + 1 + ndb;
    maxz = maxnew[1] - maxd;
    max2 = maxnew[2] - maxd;

/* ... cr = dr*br. */

    if (ndt + ndb > 0) {
	goto L15;
    }
    i__1 = nr;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	c__[i__] = coef[i__ + coef_dim1] * b[i__];
    }
    goto L20;
L15:
    bmuln_(ndim, &nr, &ndt, &ndb, &coef[coef_offset], &coef[(coef_dim1 << 1)
	    + 1], &coef[(ndt + 2) * coef_dim1 + 1], &b[1], &c__[1]);

/* ... wksp = b*br */

L20:
    if (maxz * max2 == 0) {
	return 0;
    }
    i__1 = nb;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	wksp[i__] = 0.;
    }
    i__1 = -nr;
    vaddd_(ndim, &c__2, &nb, &nr, &max2, &coef[nrp1 + (maxd + 1) * coef_dim1],
	     &jcnew[(maxd + 1 << 1) + 2], &wksp[1], &b[1], &i__1);

/* ... wksp = inv(db)*wksp */

    if (ndt + ndb > 0) {
	goto L35;
    }
    i__1 = nb;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	wksp[i__] *= dfac[i__ + nr];
    }
    goto L40;
L35:
    bdsol_(&n, &nb, nsize, &ndt, &ndb, &dfac[nrp1], &wksp[1], &wksp[1], &c__1)
	    ;

/* ... cr = cr - t*wksp */

L40:
    vsubd_(ndim, &c__2, &nr, &nb, &maxz, &coef[(maxd + 1) * coef_dim1 + 1], &
	    jcnew[(maxd + 1 << 1) + 1], &c__[1], &wksp[1], &nr);
    return 0;
} /* rsad_ */

/* Subroutine */ int rsap_(integer *ndimm, integer *n, integer *nr, integer *
	maxnz, integer *jcoef, doublereal *coef, doublereal *b, doublereal *
	c__, doublereal *wksp)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, nb, np1, nrp1, ndim, maxm1;
    extern /* Subroutine */ int vaddp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *), vsubp_(integer *, integer *, integer *, integer *,
	    doublereal *, integer *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... rsap computes  c = (dr - t*inv(db)*b)*b */

/*       where      a  = ( dr   t ) */
/*                       ( b   db ) */

/*     purdue format */

/* ... parameters -- */

/*        ndim       row dimension of coef,jcoef arrays */
/*        n          order of total system */
/*        nr         order of red subsystem */
/*        maxnz      number of columns in coef,jcoef arrays */
/*        jcoef      integer array of matrix column numbers */
/*        coef       floating point array of matrix coefficients */
/*        b,c        vectors of length nr */
/*        wksp       workspace array of length n + nb */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndimm;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcoef_dim1 = *ndimm;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    --b;
    --c__;
    --wksp;

    /* Function Body */
    ndim = *ndimm;
    i__1 = *nr;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	c__[i__] = coef[i__ + coef_dim1] * b[i__];
    }
    if (*maxnz <= 1) {
	return 0;
    }
    np1 = *n + 1;
    nb = *n - *nr;
    nrp1 = *nr + 1;
    maxm1 = *maxnz - 1;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	wksp[i__] = 0.;
    }
    vaddp_(&ndim, &ndim, &nb, &maxm1, &coef[nrp1 + (coef_dim1 << 1)], &jcoef[
	    nrp1 + (jcoef_dim1 << 1)], &wksp[nrp1], &b[1], &wksp[np1]);
    i__1 = *n;
    for (i__ = nrp1; i__ <= i__1; ++i__) {
/* L20: */
	wksp[i__] /= coef[i__ + coef_dim1];
    }
    vsubp_(&ndim, &ndim, nr, &maxm1, &coef[(coef_dim1 << 1) + 1], &jcoef[(
	    jcoef_dim1 << 1) + 1], &c__[1], &wksp[1], &wksp[1]);
    return 0;
} /* rsap_ */

/* Subroutine */ int rsatd_(integer *nn, integer *nsize, integer *nrr,
	integer *ndim, integer *maxnew, integer *ndtt, integer *ndbb, integer
	*jcnew, doublereal *coef, doublereal *c__, doublereal *b, doublereal *
	dfac, doublereal *wksp)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, n, nb, nr, ndb, ndt, max2, nrp1, maxd, maxz;
    extern /* Subroutine */ int vadddt_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *), bdsolt_(integer *, integer *, integer *,
	     integer *, integer *, doublereal *, doublereal *, doublereal *),
	    bmulnt_(integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *, doublereal *, doublereal *), vsubdt_(
	    integer *, integer *, integer *, integer *, integer *, doublereal
	    *, integer *, doublereal *, doublereal *, integer *);


/* ... rsatd computes  c = ((dr**t) - (b**t)*(db**(-t))*(t**t))*b */

/*       where      a  = ( dr   t ) */
/*                       ( b   db ) */

/*     diagonal storage */

/* ... parameters -- */

/*        n          order of system */
/*        nsize      size of an individual subsystem (if multiple */
/*                    systems) */
/*        nr         order of the red subsystem */
/*        ndim       row dimension of coef array */
/*        maxnew     number of columns in coef array */
/*        ndt        number of upper diagonals in diagonal block */
/*        ndb        number of lower diagonals in diagonal block */
/*        coef       floating point data structure */
/*        b          vector of length n containing bb behind br */
/*        c          vector of length nr containing cr */
/*        dfac       vector of length (1+nt+nb)*n to contain */
/*                    factorization of diagonal block upon output */
/*        wksp       workspace vector of length nb */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --maxnew;
    jcnew -= 3;
    --c__;
    --b;
    --dfac;
    --wksp;

    /* Function Body */
    n = *nn;
    nr = *nrr;
    ndt = *ndtt;
    ndb = *ndbb;
    nrp1 = nr + 1;
    nb = n - nr;
    maxd = ndt + 1 + ndb;
    maxz = maxnew[1] - maxd;
    max2 = maxnew[2] - maxd;

/* ... cr = (dr**t)*br. */

    if (ndt + ndb > 0) {
	goto L15;
    }
    i__1 = nr;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	c__[i__] = coef[i__ + coef_dim1] * b[i__];
    }
    goto L20;
L15:
    bmulnt_(ndim, &nr, &ndt, &ndb, &coef[coef_offset], &coef[(coef_dim1 << 1)
	    + 1], &coef[(ndt + 2) * coef_dim1 + 1], &b[1], &c__[1]);

/* ... wksp = (t**t)*br */

L20:
    if (maxz * max2 == 0) {
	return 0;
    }
    i__1 = nb;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	wksp[i__] = 0.;
    }
    vadddt_(ndim, &c__2, &nr, &nb, &maxz, &coef[(maxd + 1) * coef_dim1 + 1], &
	    jcnew[(maxd + 1 << 1) + 1], &wksp[1], &b[1], &nr);

/* ... wksp = (db**(-t))*wksp */

    if (ndt + ndb > 0) {
	goto L35;
    }
    i__1 = nb;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	wksp[i__] *= dfac[i__ + nr];
    }
    goto L40;
L35:
    bdsolt_(&n, &nb, nsize, &ndt, &ndb, &dfac[nrp1], &wksp[1], &wksp[1]);

/* ... cr = cr - (b**t)*wksp */

L40:
    i__1 = -nr;
    vsubdt_(ndim, &c__2, &nb, &nr, &max2, &coef[nrp1 + (maxd + 1) * coef_dim1]
	    , &jcnew[(maxd + 1 << 1) + 2], &c__[1], &wksp[1], &i__1);
    return 0;
} /* rsatd_ */

/* Subroutine */ int rsatp_(integer *ndimm, integer *n, integer *nr, integer *
	maxnz, integer *jcoef, doublereal *coef, doublereal *b, doublereal *
	c__, doublereal *wksp)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, nb, np1, nrp1, ndim, maxm1;
    extern /* Subroutine */ int vaddpt_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *), vsubpt_(integer *, integer *, integer *, integer *,
	     doublereal *, integer *, doublereal *, doublereal *, doublereal *
	    );


/* ... rsatp computes  c = (dr - (b**t)*inv(db)*(t**t))*b */

/*       where      a  = ( dr   t ) */
/*                       ( b   db ) */

/*     purdue format */

/* ... parameters -- */

/*        ndim       row dimension of coef,jcoef arrays */
/*        n          order of total system */
/*        nr         order of red subsystem */
/*        maxnz      number of columns in coef,jcoef arrays */
/*        jcoef      integer array of matrix column numbers */
/*        coef       floating point array of matrix coefficients */
/*        b,c        vectors of length nr */
/*        wksp       workspace array of length n + nb */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndimm;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcoef_dim1 = *ndimm;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    --b;
    --c__;
    --wksp;

    /* Function Body */
    ndim = *ndimm;
    i__1 = *nr;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	c__[i__] = coef[i__ + coef_dim1] * b[i__];
    }
    if (*maxnz <= 1) {
	return 0;
    }
    np1 = *n + 1;
    nb = *n - *nr;
    nrp1 = *nr + 1;
    maxm1 = *maxnz - 1;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	wksp[i__] = 0.;
    }
    vaddpt_(&ndim, &ndim, nr, &maxm1, &coef[(coef_dim1 << 1) + 1], &jcoef[(
	    jcoef_dim1 << 1) + 1], &wksp[1], &b[1], &wksp[1]);
    i__1 = *n;
    for (i__ = nrp1; i__ <= i__1; ++i__) {
/* L20: */
	wksp[i__] /= coef[i__ + coef_dim1];
    }
    vsubpt_(&ndim, &ndim, &nb, &maxm1, &coef[nrp1 + (coef_dim1 << 1)], &jcoef[
	    nrp1 + (jcoef_dim1 << 1)], &c__[1], &wksp[nrp1], &wksp[np1]);
    return 0;
} /* rsatp_ */

/* Subroutine */ int rsbegd_(integer *nn, integer *nsize, integer *nrr,
	integer *ndim, integer *maxnew, integer *ndtt, integer *ndbb, integer
	*jcnew, doublereal *coef, doublereal *c__, doublereal *b, doublereal *
	dfac, doublereal *wksp)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, n, nb, nr, ndb, ndt, nrp1, maxd, maxm1;
    extern /* Subroutine */ int bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *), vsubd_(integer *, integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    integer *);


/* ... rsbegd computes  cr = br - t*inv(db)*bb. */

/*       where      a  = ( dr   t ) */
/*                       ( b   db ) */

/*     diagonal storage */

/* ... parameters -- */

/*        n          order of system */
/*        nsize      size of an individual subsystem (if multiple */
/*                    systems) */
/*        nr         order of the red subsystem */
/*        ndim       row dimension of coef array */
/*        maxnew     number of columns in coef array */
/*        ndt        number of upper diagonals in diagonal block */
/*        ndb        number of lower diagonals in diagonal block */
/*        coef       floating point data structure */
/*        b          vector of length n containing bb behind br */
/*        c          vector of length nr containing cr */
/*        dfac       vector of length (1+nt+nb)*n containing */
/*                    factorization of diagonal block upon input */
/*        wksp       workspace vector of length nb */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --maxnew;
    jcnew -= 3;
    --c__;
    --b;
    --dfac;
    --wksp;

    /* Function Body */
    n = *nn;
    nr = *nrr;
    ndt = *ndtt;
    ndb = *ndbb;
    nrp1 = nr + 1;
    nb = n - nr;
    maxd = ndt + 1 + ndb;

/* ... compute cr. */

    i__1 = nr;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	c__[i__] = b[i__];
    }
    bdsol_(&n, &nb, nsize, &ndt, &ndb, &dfac[nrp1], &b[nrp1], &wksp[1], &c__1)
	    ;
    maxm1 = maxnew[1] - maxd;
    vsubd_(ndim, &c__2, &nr, &nb, &maxm1, &coef[(maxd + 1) * coef_dim1 + 1], &
	    jcnew[(maxd + 1 << 1) + 1], &c__[1], &wksp[1], &nr);
    return 0;
} /* rsbegd_ */

/* Subroutine */ int rsbegp_(integer *n, integer *nr, integer *ndim, integer *
	maxnz, integer *jcoef, doublereal *coef, doublereal *c__, doublereal *
	b, doublereal *wksp)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, nrp1, maxm1;
    extern /* Subroutine */ int vsubp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... rsbegp computes  cr = br - t*inv(db)*bb. */

/*       where      a  = ( dr   t ) */
/*                       ( b   db ) */

/*     purdue storage */

/* ... parameters -- */

/*        n          order of system */
/*        nr         order of the red subsystem */
/*        ndim       row dimension of coef array */
/*        maxnz      number of columns in coef array */
/*        jcoef      integer data structure */
/*        coef       floating point data structure */
/*        b          vector of length n containing bb behind br */
/*        c          vector of length nr containing cr */
/*        wksp       workspace vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    --c__;
    --b;
    --wksp;

    /* Function Body */
    nrp1 = *nr + 1;
    i__1 = *nr;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	c__[i__] = b[i__];
    }
    if (*maxnz <= 1) {
	return 0;
    }
    i__1 = *n;
    for (i__ = nrp1; i__ <= i__1; ++i__) {
/* L15: */
	wksp[i__] = b[i__] / coef[i__ + coef_dim1];
    }
    maxm1 = *maxnz - 1;
    vsubp_(ndim, ndim, nr, &maxm1, &coef[(coef_dim1 << 1) + 1], &jcoef[(
	    jcoef_dim1 << 1) + 1], &c__[1], &wksp[1], &wksp[1]);
    return 0;
} /* rsbegp_ */

/* Subroutine */ int rsendd_(integer *nn, integer *nsize, integer *nrr,
	integer *ndim, integer *maxnew, integer *ndtt, integer *ndbb, integer
	*jcnew, doublereal *coef, doublereal *x, doublereal *b, doublereal *
	dfac)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, n, nb, nr, ndb, ndt, max2, nrp1, maxd;
    extern /* Subroutine */ int bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *), vsubd_(integer *, integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    integer *);


/* ... rsendd computes  xb = inv(db)*(bb - b*xr) */

/*       where      a  = ( dr   t ) */
/*                       ( b   db ) */

/*     diagonal storage */

/* ... parameters -- */

/*        n          order of system */
/*        nsize      size of an individual subsystem (if multiple */
/*                    systems) */
/*        nr         order of the red subsystem */
/*        ndim       row dimension of coef array */
/*        maxnew     number of columns in coef array */
/*        ndt        number of upper diagonals in diagonal block */
/*        ndb        number of lower diagonals in diagonal block */
/*        coef       floating point data structure */
/*        x          vector of length n containing  xr, xb */
/*        b          vector of length n containing bb in the last */
/*                    nb locations */
/*        dfac       vector of length (1+nt+nb)*n containing */
/*                    factorization of diagonal block upon input */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --maxnew;
    jcnew -= 3;
    --x;
    --b;
    --dfac;

    /* Function Body */
    n = *nn;
    nr = *nrr;
    ndt = *ndtt;
    ndb = *ndbb;
    nrp1 = nr + 1;
    nb = n - nr;
    maxd = ndt + 1 + ndb;

/* ... compute xb. */

    i__1 = n;
    for (i__ = nrp1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = b[i__];
    }
    max2 = maxnew[2] - maxd;
    i__1 = -nr;
    vsubd_(ndim, &c__2, &nb, &nr, &max2, &coef[nrp1 + (maxd + 1) * coef_dim1],
	     &jcnew[(maxd + 1 << 1) + 2], &x[nrp1], &x[1], &i__1);
    bdsol_(&n, &nb, nsize, &ndt, &ndb, &dfac[nrp1], &x[nrp1], &x[nrp1], &c__1)
	    ;
    return 0;
} /* rsendd_ */

/* Subroutine */ int rsendp_(integer *n, integer *nr, integer *ndim, integer *
	maxnz, integer *jcoef, doublereal *coef, doublereal *x, doublereal *b,
	 doublereal *wksp)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, nb, nrp1, maxm1;
    extern /* Subroutine */ int vsubp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... rsendp computes  xb = inv(db)*(bb - b*xr) */

/*       where      a  = ( dr   t ) */
/*                       ( b   db ) */

/*     purdue format */

/* ... parameters -- */

/*        n          order of matrix */
/*        nr         order of red subsystem */
/*        ndim       row dimension of ah and jah arrays */
/*        maxnz      number of columns in coef and jcoef arrays */
/*        jcoef      integer array of column numbers */
/*        coef       floating point array of matrix coefficients */
/*        x          vector of length n containing  xr, xb */
/*        b          vector of length n containing bb in the last */
/*                    nb locations */
/*        wksp       workspace array of length nb */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    --x;
    --b;
    --wksp;

    /* Function Body */
    nrp1 = *nr + 1;
    nb = *n - *nr;
    i__1 = *n;
    for (i__ = nrp1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = b[i__];
    }
    if (*maxnz <= 1) {
	goto L15;
    }
    maxm1 = *maxnz - 1;
    vsubp_(ndim, ndim, &nb, &maxm1, &coef[nrp1 + (coef_dim1 << 1)], &jcoef[
	    nrp1 + (jcoef_dim1 << 1)], &x[nrp1], &x[1], &wksp[1]);
L15:
    i__1 = *n;
    for (i__ = nrp1; i__ <= i__1; ++i__) {
/* L20: */
	x[i__] /= coef[i__ + coef_dim1];
    }
    return 0;
} /* rsendp_ */

/* Subroutine */ int rsmatd_(integer *ndim, integer *nrr, integer *nb,
	integer *maxnew, integer *jcnew, doublereal *dr, doublereal *ah,
	doublereal *ak, doublereal *db, integer *maxrss, integer *jcrs,
	doublereal *rs, integer *maxlim, integer *isym, integer *ier)
{
    /* System generated locals */
    integer ak_dim1, ak_offset, ah_dim1, ah_offset, rs_dim1, rs_offset, i__1,
	    i__2, i__3, i__4;

    /* Local variables */
    static integer i__, k, l, m, ld, ii, lh, lk, nr, ia1, ib1, ied, ist, maxh,
	     maxk, maxrs;


/* ... rsmatd computes  rs = dr - ah*inv(db)*ak  where a has been */
/*     permuted to red-black form -- */

/*                   * dr  ah * */
/*             a =   *        * */
/*                   * ak  db * */

/*     (diagonal storage) */

/*      dr is nr x nr        ah is nr x nb */
/*      ak is nb x nr        db is nb x nb */

/* ... definition of parameters -- */

/*         ndim          row dimension of ah and ak arrays */
/*         nr            number of red points */
/*         nb            number of black points */
/*         maxnew        integer vector of length 2 indicating number */
/*                        of diagonals stored in ah and ak, */
/*                        respectively. */
/*         jcnew         integer array of diagonal numbers */
/*         dr            vector of length nr */
/*         ah            array of size nr by (maxnew(1)-1) */
/*         ak            array of size nb by (maxnew(2)-1) */
/*         db            vector of length nb */
/*         maxrs         number of columns needed to store reduced */
/*                        system (output) */
/*         jcrs          diagonal numbers for rs (output) */
/*         rs            array to contain reduced system */
/*         maxlim        maximum column width to be allowed for rs */
/*         isym          symmetry switch for rs matrix */
/*                        = 0   store only upper half of rs */
/*                        = 1   store all of rs */
/*         ier           error code */
/*                        =  0     no errors detected */
/*                        = -2     maxlim .lt. maxrs */

/* ... specifications for parameters */


    /* Parameter adjustments */
    ak_dim1 = *ndim;
    ak_offset = 1 + ak_dim1;
    ak -= ak_offset;
    ah_dim1 = *ndim;
    ah_offset = 1 + ah_dim1;
    ah -= ah_offset;
    rs_dim1 = *nrr;
    rs_offset = 1 + rs_dim1;
    rs -= rs_offset;
    --maxnew;
    jcnew -= 3;
    --dr;
    --db;
    --jcrs;

    /* Function Body */
    nr = *nrr;
    maxrs = 1;
    jcrs[1] = 0;
    i__1 = nr;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L5: */
	rs[i__ + rs_dim1] = dr[i__];
    }
    maxh = maxnew[1] - 1;
    maxk = maxnew[2] - 1;
    i__1 = maxh;
    for (lh = 1; lh <= i__1; ++lh) {
	i__ = jcnew[(lh + 1 << 1) + 1] - nr;
/* Computing MAX */
	i__2 = 1, i__3 = 1 - i__;
	ia1 = max(i__2,i__3);
/* Computing MIN */
	i__2 = nr, i__3 = *nb - i__;
	ib1 = min(i__2,i__3);
	i__2 = maxk;
	for (lk = 1; lk <= i__2; ++lk) {
	    k = jcnew[(lk + 1 << 1) + 2] + nr;
	    l = i__ + k;
	    if (l < 0 && *isym == 0) {
		goto L30;
	    }
	    i__3 = maxrs;
	    for (ld = 1; ld <= i__3; ++ld) {
		if (jcrs[ld] == l) {
		    goto L20;
		}
/* L10: */
	    }
	    if (maxrs == *maxlim) {
		goto L999;
	    }
	    ++maxrs;
	    ld = maxrs;
	    jcrs[maxrs] = l;
	    i__3 = nr;
	    for (ii = 1; ii <= i__3; ++ii) {
/* L15: */
		rs[ii + maxrs * rs_dim1] = 0.;
	    }
L20:
/* Computing MAX */
	    i__3 = ia1, i__4 = 1 - l;
	    ist = max(i__3,i__4);
/* Computing MIN */
	    i__3 = ib1, i__4 = nr - l;
	    ied = min(i__3,i__4);
	    i__3 = ied;
	    for (m = ist; m <= i__3; ++m) {
/* L25: */
		rs[m + ld * rs_dim1] -= ah[m + lh * ah_dim1] * ak[m + i__ +
			lk * ak_dim1] / db[m + i__];
	    }
L30:
	    ;
	}
/* L35: */
    }
    *maxrss = maxrs;
    return 0;

/* ... error exit -- maxlim too small. */

L999:
    *ier = -2;
    return 0;
} /* rsmatd_ */

/* Subroutine */ int rsmatp_(integer *ndim, integer *nrr, integer *maxnzz,
	integer *jcoef, doublereal *coef, integer *maxrss, integer *jcrs,
	doublereal *rs, integer *maxlim, doublereal *wksp, integer *iwksp,
	integer *ier)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, jcrs_dim1, jcrs_offset, coef_dim1,
	    coef_offset, rs_dim1, rs_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, ii, jj, nr, jjj, jcol;
    static doublereal term;
    static integer maxrs, maxnz;
    extern /* Subroutine */ int vgathi_(integer *, integer *, integer *,
	    integer *), vgathr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... rsmatp computes  rs = dr - ah*inv(db)*ak  where a has been */
/*     permuted to red-black form -- */

/*                   * dr  ah * */
/*             a =   *        * */
/*                   * ak  db * */

/*     (purdue storage) */

/*      dr is nr x nr        ah is nr x nb */
/*      ak is nb x nr        db is nb x nb */

/* ... definition of parameters -- */

/*         ndim          row dimension of coef and jcoef arrays */
/*         nr            number of red points */
/*         maxnz         number of columns in coef and jcoef */
/*         jcoef         array of column indices */
/*         coef          array of matrix coefficients */
/*         maxrs         number of columns needed to store reduced */
/*                        system (output) */
/*         jcrs          column numbers for rs (output) */
/*         rs            array to contain reduced system */
/*         maxlim        maximum column width to be allowed for rs */
/*         wksp          workspace of length 2*nr */
/*         iwksp         integer workspace of length nr */
/*         ier           error code */
/*                        =  0     no errors detected */
/*                        = -2     maxlim .lt. maxrs */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    rs_dim1 = *nrr;
    rs_offset = 1 + rs_dim1;
    rs -= rs_offset;
    jcrs_dim1 = *nrr;
    jcrs_offset = 1 + jcrs_dim1;
    jcrs -= jcrs_offset;
    --wksp;
    --iwksp;

    /* Function Body */
    nr = *nrr;
    maxnz = *maxnzz;
    maxrs = 1;
    i__1 = nr;
    for (i__ = 1; i__ <= i__1; ++i__) {
	rs[i__ + rs_dim1] = coef[i__ + coef_dim1];
	jcrs[i__ + jcrs_dim1] = i__;
/* L5: */
    }
    i__1 = maxnz;
    for (j = 2; j <= i__1; ++j) {
	vgathr_(&nr, &coef[coef_offset], &jcoef[j * jcoef_dim1 + 1], &wksp[1])
		;
	i__2 = nr;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L10: */
	    wksp[i__] = coef[i__ + j * coef_dim1] / wksp[i__];
	}
	i__2 = maxnz;
	for (jj = 2; jj <= i__2; ++jj) {
	    vgathr_(&nr, &coef[jj * coef_dim1 + 1], &jcoef[j * jcoef_dim1 + 1]
		    , &wksp[nr + 1]);
	    vgathi_(&nr, &jcoef[jj * jcoef_dim1 + 1], &jcoef[j * jcoef_dim1 +
		    1], &iwksp[1]);
	    i__3 = nr;
	    for (i__ = 1; i__ <= i__3; ++i__) {
/* L15: */
		wksp[nr + i__] = wksp[i__] * wksp[nr + i__];
	    }
	    i__3 = nr;
	    for (i__ = 1; i__ <= i__3; ++i__) {
		jcol = iwksp[i__];
		term = wksp[nr + i__];
		if (jcol > nr) {
		    goto L40;
		}
		i__4 = maxrs;
		for (jjj = 1; jjj <= i__4; ++jjj) {
		    if (jcrs[i__ + jjj * jcrs_dim1] != jcol) {
			goto L20;
		    }
		    rs[i__ + jjj * rs_dim1] -= term;
		    goto L40;
L20:
		    ;
		}
		if (maxrs == 1) {
		    goto L30;
		}
		i__4 = maxrs;
		for (jjj = 2; jjj <= i__4; ++jjj) {
		    if (jcrs[i__ + jjj * jcrs_dim1] != i__) {
			goto L25;
		    }
		    rs[i__ + jjj * rs_dim1] -= term;
		    jcrs[i__ + jjj * jcrs_dim1] = jcol;
		    goto L40;
L25:
		    ;
		}
L30:
		if (maxrs == *maxlim) {
		    goto L999;
		}
		++maxrs;
		i__4 = nr;
		for (ii = 1; ii <= i__4; ++ii) {
		    jcrs[ii + maxrs * jcrs_dim1] = ii;
		    rs[ii + maxrs * rs_dim1] = 0.;
/* L35: */
		}
		rs[i__ + maxrs * rs_dim1] = -term;
		jcrs[i__ + maxrs * jcrs_dim1] = jcol;
L40:
		;
	    }
/* L45: */
	}
/* L50: */
    }
    *maxrss = maxrs;
    return 0;

/* ... error exit -- maxlim too small. */

L999:
    *ier = -2;
    return 0;
} /* rsmatp_ */

/* Subroutine */ int rsrhsd_(integer *nn, integer *nrr, integer *ndim,
	integer *maxnew, integer *jcnew, doublereal *coef, doublereal *c__,
	doublereal *b, doublereal *wksp)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, n, nb, nr, maxm1;
    extern /* Subroutine */ int vsubd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);


/* ... rsrhsd computes  cr = br - t*inv(db)*bb. */

/*       where      a  = ( dr   t ) */
/*                       ( b   db ) */

/*     diagonal storage */

/* ... parameters -- */

/*        n          order of system */
/*                    systems) */
/*        nr         order of the red subsystem */
/*        ndim       row dimension of coef array */
/*        maxnew     number of columns in coef array */
/*        coef       floating point data structure */
/*        b          vector of length n containing bb behind br */
/*        c          vector of length nr containing cr */
/*        wksp       workspace vector of length nb */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --maxnew;
    jcnew -= 3;
    --c__;
    --b;
    --wksp;

    /* Function Body */
    n = *nn;
    nr = *nrr;
    nb = n - nr;

/* ... compute cr. */

    i__1 = nr;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	c__[i__] = b[i__];
    }
    i__1 = nb;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	wksp[i__] = b[nr + i__] / coef[nr + i__ + coef_dim1];
    }
    maxm1 = maxnew[1] - 1;
    vsubd_(ndim, &c__2, &nr, &nb, &maxm1, &coef[(coef_dim1 << 1) + 1], &jcnew[
	    5], &c__[1], &wksp[1], &nr);
    return 0;
} /* rsrhsd_ */

/* Subroutine */ int rsxbd_(integer *nn, integer *nrr, integer *ndim, integer
	*maxnew, integer *jcnew, doublereal *coef, doublereal *x, doublereal *
	b)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, n, nb, nr, max2, nrp1;
    extern /* Subroutine */ int vsubd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);


/* ... rsxbd computes  xb = inv(db)*(bb - b*xr) */

/*       where      a  = ( dr   t ) */
/*                       ( b   db ) */

/*     diagonal storage */

/* ... parameters -- */

/*        n          order of system */
/*                    systems) */
/*        nr         order of the red subsystem */
/*        ndim       row dimension of coef array */
/*        maxnew     number of columns in coef array */
/*        coef       floating point data structure */
/*        x          vector of length n containing  xr, xb */
/*        b          vector of length n containing bb in the last */
/*                    nb locations */

/* ... specifications for parameters */


    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --maxnew;
    jcnew -= 3;
    --x;
    --b;

    /* Function Body */
    n = *nn;
    nr = *nrr;
    nrp1 = nr + 1;
    nb = n - nr;

/* ... compute xb. */

    i__1 = n;
    for (i__ = nrp1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = b[i__];
    }
    max2 = maxnew[2] - 1;
    i__1 = -nr;
    vsubd_(ndim, &c__2, &nb, &nr, &max2, &coef[nrp1 + (coef_dim1 << 1)], &
	    jcnew[6], &x[nrp1], &x[1], &i__1);
    i__1 = n;
    for (i__ = nrp1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] /= coef[i__ + coef_dim1];
    }
    return 0;
} /* rsxbd_ */

/* Subroutine */ int sbbs_(integer *ldd, integer *ldt, integer *n, integer *
	kblszz, integer *nsize, integer *lbhb, integer *iblock, doublereal *
	d__, doublereal *t, integer *jt, doublereal *x, doublereal *omega)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, i__1, i__2;

    /* Local variables */
    static integer i__, k, l, jj, nt, ied, inc, mjj, ist, jst, jblk, istf;
    extern /* Subroutine */ int bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *);
    static integer jjlim;
    extern /* Subroutine */ int vsubd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);
    static integer kblsz;


/* ... sbbs does an block ssor backward pass. */
/*     symmetric diagonal data structure, natural ordering. */
/*     block ssor preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         kblsz    block size */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         lbhb     number of blocks per block row */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer vector giving the diagonal numbers */
/*                   for the off-diagonal blocks */
/*         x        input/output vector of length n */
/*         omega    over-relaxation factor */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    iblock -= 4;
    --jt;
    --x;

    /* Function Body */
    kblsz = *kblszz;
    l = *n / kblsz;
    nt = iblock[6] - 1;
    for (k = l; k >= 1; --k) {
	ist = (k - 1) * kblsz + 1;
	ied = k * kblsz;
	if (k == l) {
	    goto L15;
	}
/* Computing MIN */
	i__1 = *lbhb, i__2 = l - k + 2;
	jjlim = min(i__1,i__2);
	i__1 = jjlim;
	for (jj = 3; jj <= i__1; ++jj) {
	    jblk = iblock[jj * 3 + 1];
	    jst = iblock[jj * 3 + 2];
	    mjj = iblock[jj * 3 + 3];
	    inc = jblk * kblsz;
	    istf = ist + inc;
	    if (istf > *n) {
		goto L10;
	    }
	    vsubd_(ldt, &c__1, &kblsz, &kblsz, &mjj, &t[ist + jst * t_dim1], &
		    jt[jst], &x[ist], &x[istf], &inc);
L10:
	    ;
	}
L15:
	if (nt >= 1) {
	    goto L25;
	}
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L20: */
	    x[i__] = *omega * d__[i__ + d_dim1] * x[i__];
	}
	goto L35;
L25:
	bdsol_(ldd, &kblsz, nsize, &nt, &c__0, &d__[ist + d_dim1], &x[ist], &
		x[ist], &c__0);
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L30: */
	    x[i__] = *omega * x[i__];
	}
L35:
	;
    }
    return 0;
} /* sbbs_ */

/* Subroutine */ int sbbsn_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *x, doublereal *omega, integer *iunif, doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, j, k, l, na, nb, mb, kk, lm1, ied, ndb, inc, ndt, ist,
	     jcol, jlim;
    static logical unif;
    static integer jstb, istb;
    extern /* Subroutine */ int vaddd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *), bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *);


/* ... sbbsn does an block ssor backward solve. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ssor preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         x        input/output vector of length n */
/*         omega    over-relaxation factor */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --x;
    --wksp;

    /* Function Body */
    unif = *iunif == 1;

    l = *ncolor;
    if (! unif) {
	goto L10;
    }
    na = nci[1];
    nb = na;
    jlim = lbhb[1];
    l = *n / na;
    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    kk = 1;

/* ... do backward solution. */

L10:
    lm1 = l - 1;
    for (k = lm1; k >= 1; --k) {
	if (unif) {
	    goto L15;
	}
	kk = k;
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	goto L20;
L15:
	ist = (k - 1) * na + 1;
L20:
	ied = ist + na - 1;
	i__1 = na;
	for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	    wksp[i__] = 0.;
	}
	i__1 = jlim;
	for (j = 3; j <= i__1; ++j) {
	    jcol = k + iblock[(kk + j * iblock_dim2) * 3 + 1];
	    if (jcol <= k) {
		goto L30;
	    }
	    jstb = iblock[(kk + j * iblock_dim2) * 3 + 2];
	    mb = iblock[(kk + j * iblock_dim2) * 3 + 3];
	    if (unif) {
		inc = (jcol - k) * na;
	    }
	    if (! unif) {
		inc = ipt[jcol] - ipt[k];
	    }
	    if (! unif) {
		nb = nci[jcol];
	    }
	    istb = ist + inc;
	    vaddd_(ldt, ncolor, &na, &nb, &mb, &t[ist + jstb * t_dim1], &jt[
		    kk + jstb * jt_dim1], &wksp[1], &x[istb], &inc);
L30:
	    ;
	}
	if (ndt + ndb >= 1) {
	    goto L40;
	}
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L35: */
	    x[i__] -= *omega * d__[i__ + d_dim1] * wksp[i__ - ist + 1];
	}
	goto L50;
L40:
	bdsol_(ldd, &na, nsize, &ndt, &ndb, &d__[ist + d_dim1], &wksp[1], &
		wksp[1], &c__1);
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L45: */
	    x[i__] -= *omega * wksp[i__ - ist + 1];
	}
L50:
	;
    }
    return 0;
} /* sbbsn_ */

/* Subroutine */ int sbbsnt_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *x, doublereal *omega, integer *iunif)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, j, k, l, na, nb, mb, kk, ied, ndb, inc, ndt, ist,
	    jcol, jlim;
    static logical unif;
    static integer jstb, istb;
    extern /* Subroutine */ int bdsolt_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *),
	    vsubdt_(integer *, integer *, integer *, integer *, integer *,
	    doublereal *, integer *, doublereal *, doublereal *, integer *);


/* ... sbbsnt does an block ssor transpose backward solve. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ssor preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         x        input/output vector of length n */
/*         omega    over-relaxation factor */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --x;

    /* Function Body */
    unif = *iunif == 1;

    l = *ncolor;
    if (! unif) {
	goto L10;
    }
    na = nci[1];
    nb = na;
    jlim = lbhb[1];
    l = *n / na;
    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    kk = 1;

/* ... do backward solution. */

L10:
    for (k = l; k >= 1; --k) {
	if (unif) {
	    goto L15;
	}
	kk = k;
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	goto L20;
L15:
	ist = (k - 1) * na + 1;
L20:
	ied = ist + na - 1;
	if (ndt + ndb >= 1) {
	    goto L30;
	}
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L25: */
	    x[i__] = *omega * d__[i__ + d_dim1] * x[i__];
	}
	goto L40;
L30:
	bdsolt_(ldd, &na, nsize, &ndt, &ndb, &d__[ist + d_dim1], &x[ist], &x[
		ist]);
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L35: */
	    x[i__] = *omega * x[i__];
	}
L40:
	i__1 = jlim;
	for (j = 3; j <= i__1; ++j) {
	    jcol = k + iblock[(kk + j * iblock_dim2) * 3 + 1];
	    if (jcol >= k) {
		goto L45;
	    }
	    jstb = iblock[(kk + j * iblock_dim2) * 3 + 2];
	    mb = iblock[(kk + j * iblock_dim2) * 3 + 3];
	    if (unif) {
		inc = (jcol - k) * na;
	    }
	    if (! unif) {
		inc = ipt[jcol] - ipt[k];
	    }
	    if (! unif) {
		nb = nci[jcol];
	    }
	    istb = ist + inc;
	    vsubdt_(ldt, ncolor, &na, &nb, &mb, &t[ist + jstb * t_dim1], &jt[
		    kk + jstb * jt_dim1], &x[istb], &x[ist], &inc);
L45:
	    ;
	}
/* L50: */
    }
    return 0;
} /* sbbsnt_ */

/* Subroutine */ int sbfs_(integer *ldd, integer *ldt, integer *n, integer *
	kblszz, integer *nsize, integer *lbhb, integer *iblock, doublereal *
	d__, doublereal *t, integer *jt, doublereal *x, doublereal *omega,
	doublereal *wksp)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, k, l, jj, nt, lm1, ied, inc, mjj, ist, jst, jblk,
	    istf;
    extern /* Subroutine */ int bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *);
    static integer jjlim, kblsz;
    extern /* Subroutine */ int vsubdt_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);


/* ... sbfs does an block ssor forward pass. */
/*     symmetric diagonal data structure, natural ordering. */
/*     block ssor preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         kblsz    block size */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         lbhb     number of blocks per block row */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer vector giving the diagonal numbers */
/*                   for the off-diagonal blocks */
/*         x        input/output vector of length n */
/*         omega    over-relaxation factor */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    iblock -= 4;
    --jt;
    --x;
    --wksp;

    /* Function Body */
    kblsz = *kblszz;
    l = *n / kblsz;
    lm1 = l - 1;
    nt = iblock[6] - 1;
    i__1 = lm1;
    for (k = 1; k <= i__1; ++k) {
	ist = (k - 1) * kblsz + 1;
	ied = k * kblsz;
	if (nt >= 1) {
	    goto L15;
	}
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L10: */
	    wksp[i__ - ist + 1] = *omega * d__[i__ + d_dim1] * x[i__];
	}
	goto L25;
L15:
	bdsol_(ldd, &kblsz, nsize, &nt, &c__0, &d__[ist + d_dim1], &x[ist], &
		wksp[1], &c__0);
	i__2 = kblsz;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L20: */
	    wksp[i__] = *omega * wksp[i__];
	}
L25:
/* Computing MIN */
	i__2 = *lbhb, i__3 = l - k + 2;
	jjlim = min(i__2,i__3);
	i__2 = jjlim;
	for (jj = 3; jj <= i__2; ++jj) {
	    jblk = iblock[jj * 3 + 1];
	    jst = iblock[jj * 3 + 2];
	    mjj = iblock[jj * 3 + 3];
	    inc = jblk * kblsz;
	    istf = ist + inc;
	    if (istf > *n) {
		goto L30;
	    }
	    vsubdt_(ldt, &c__1, &kblsz, &kblsz, &mjj, &t[ist + jst * t_dim1],
		    &jt[jst], &x[istf], &wksp[1], &inc);
L30:
	    ;
	}
/* L35: */
    }
    return 0;
} /* sbfs_ */

/* Subroutine */ int sbfsn_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *x, doublereal *omega, integer *iunif)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, k, l, na, nb, mb, kk, ied, ndb, inc, ndt, ist,
	    jcol, jlim;
    static logical unif;
    static integer jstb, istb;
    extern /* Subroutine */ int bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *), vsubd_(integer *, integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    integer *);


/* ... sbfsn does an block ssor forward solve. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ssor preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         x        input/output vector of length n */
/*         omega    over-relaxation factor */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --x;

    /* Function Body */
    unif = *iunif == 1;

    l = *ncolor;
    if (! unif) {
	goto L10;
    }
    na = nci[1];
    nb = na;
    jlim = lbhb[1];
    l = *n / na;
    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    kk = 1;

/* ... do forward solution. */

L10:
    i__1 = l;
    for (k = 1; k <= i__1; ++k) {
	if (unif) {
	    goto L15;
	}
	kk = k;
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	goto L20;
L15:
	ist = (k - 1) * na + 1;
L20:
	ied = ist + na - 1;
	i__2 = jlim;
	for (j = 3; j <= i__2; ++j) {
	    jcol = k + iblock[(kk + j * iblock_dim2) * 3 + 1];
	    if (jcol >= k) {
		goto L25;
	    }
	    jstb = iblock[(kk + j * iblock_dim2) * 3 + 2];
	    mb = iblock[(kk + j * iblock_dim2) * 3 + 3];
	    if (unif) {
		inc = (jcol - k) * na;
	    }
	    if (! unif) {
		inc = ipt[jcol] - ipt[k];
	    }
	    if (! unif) {
		nb = nci[jcol];
	    }
	    istb = ist + inc;
	    vsubd_(ldt, ncolor, &na, &nb, &mb, &t[ist + jstb * t_dim1], &jt[
		    kk + jstb * jt_dim1], &x[ist], &x[istb], &inc);
L25:
	    ;
	}
	if (ndt + ndb >= 1) {
	    goto L35;
	}
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L30: */
	    x[i__] = *omega * d__[i__ + d_dim1] * x[i__];
	}
	goto L45;
L35:
	bdsol_(ldd, &na, nsize, &ndt, &ndb, &d__[ist + d_dim1], &x[ist], &x[
		ist], &c__1);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L40: */
	    x[i__] = *omega * x[i__];
	}
L45:
	;
    }
    return 0;
} /* sbfsn_ */

/* Subroutine */ int sbfsnt_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *x, doublereal *omega, integer *iunif, doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, k, l, na, nb, mb, kk, lm1, ied, ndb, inc, ndt, ist,
	     jcol, jlim;
    static logical unif;
    static integer jstb, istb;
    extern /* Subroutine */ int bdsolt_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *),
	    vsubdt_(integer *, integer *, integer *, integer *, integer *,
	    doublereal *, integer *, doublereal *, doublereal *, integer *);


/* ... sbfsnt does an block ssor transpose forward solve. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ssor preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         x        input/output vector of length n */
/*         omega    over-relaxation factor */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --x;
    --wksp;

    /* Function Body */
    unif = *iunif == 1;

    l = *ncolor;
    if (! unif) {
	goto L10;
    }
    na = nci[1];
    nb = na;
    jlim = lbhb[1];
    l = *n / na;
    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    kk = 1;

/* ... do forward solution. */

L10:
    lm1 = l - 1;
    i__1 = lm1;
    for (k = 1; k <= i__1; ++k) {
	if (unif) {
	    goto L15;
	}
	kk = k;
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	goto L20;
L15:
	ist = (k - 1) * na + 1;
L20:
	ied = ist + na - 1;
	if (ndt + ndb >= 1) {
	    goto L30;
	}
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L25: */
	    wksp[i__ - ist + 1] = *omega * d__[i__ + d_dim1] * x[i__];
	}
	goto L40;
L30:
	bdsolt_(ldd, &na, nsize, &ndt, &ndb, &d__[ist + d_dim1], &x[ist], &
		wksp[1]);
	i__2 = na;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L35: */
	    wksp[i__] = *omega * wksp[i__];
	}
L40:
	i__2 = jlim;
	for (j = 3; j <= i__2; ++j) {
	    jcol = k + iblock[(kk + j * iblock_dim2) * 3 + 1];
	    if (jcol <= k) {
		goto L45;
	    }
	    jstb = iblock[(kk + j * iblock_dim2) * 3 + 2];
	    mb = iblock[(kk + j * iblock_dim2) * 3 + 3];
	    if (unif) {
		inc = (jcol - k) * na;
	    }
	    if (! unif) {
		inc = ipt[jcol] - ipt[k];
	    }
	    if (! unif) {
		nb = nci[jcol];
	    }
	    istb = ist + inc;
	    vsubdt_(ldt, ncolor, &na, &nb, &mb, &t[ist + jstb * t_dim1], &jt[
		    kk + jstb * jt_dim1], &x[istb], &wksp[1], &inc);
L45:
	    ;
	}
/* L50: */
    }
    return 0;
} /* sbfsnt_ */

/* Subroutine */ int sbsl_(integer *ldd, integer *ldt, integer *n, integer *
	kblsz, integer *nsize, integer *lbhb, integer *iblock, doublereal *
	d__, doublereal *t, integer *jt, doublereal *y, doublereal *x,
	doublereal *omega, doublereal *wksp)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int sbbs_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, doublereal *,
	    doublereal *, integer *, doublereal *, doublereal *), sbfs_(
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, integer *, doublereal *,
	    doublereal *, doublereal *);
    static doublereal const__;


/* ... sbsl does an block ssor solution. */
/*     symmetric diagonal data structure, natural ordering. */
/*     block ssor preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         kblsz    block size */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         lbhb     number of blocks per block row */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer vector giving the diagonal numbers */
/*                   for the off-diagonal blocks */
/*         y        input vector for the right-hand-side */
/*         x        output vector for the solution to q*x = y */
/*         omega    over-relaxation factor */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    iblock -= 4;
    --jt;
    --y;
    --x;
    --wksp;

    /* Function Body */
    const__ = 2. - *omega;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = const__ * y[i__];
    }
    sbfs_(ldd, ldt, n, kblsz, nsize, lbhb, &iblock[4], &d__[d_offset], &t[
	    t_offset], &jt[1], &x[1], omega, &wksp[1]);
    sbbs_(ldd, ldt, n, kblsz, nsize, lbhb, &iblock[4], &d__[d_offset], &t[
	    t_offset], &jt[1], &x[1], omega);
    return 0;
} /* sbsl_ */

/* Subroutine */ int sbsln_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *y, doublereal *x, doublereal *omega, integer *iunif,
	doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int sbbsn_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, doublereal *), sbfsn_(integer *, integer *, integer *,
	     integer *, integer *, integer *, integer *, integer *, integer *,
	     doublereal *, doublereal *, integer *, doublereal *, doublereal *
	    , integer *);
    static doublereal const__;


/* ... sbsln does an block ssor solution. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ssor preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         y        input vector of length n containing right-hand-side */
/*         x        output vector containing the solution to q*x = y */
/*         omega    over-relaxation factor */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --y;
    --x;
    --wksp;

    /* Function Body */
    const__ = 2. - *omega;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = const__ * y[i__];
    }
    sbfsn_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], omega, iunif);
    sbbsn_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], omega, iunif, &wksp[1]);
    return 0;
} /* sbsln_ */

/* Subroutine */ int sbslnt_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *y, doublereal *x, doublereal *omega, integer *iunif,
	doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    static doublereal const__;
    extern /* Subroutine */ int sbbsnt_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *), sbfsnt_(integer *, integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, doublereal
	    *, doublereal *, integer *, doublereal *, doublereal *, integer *,
	     doublereal *);


/* ... sbslnt does an block ssor transpose solution. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ssor preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         y        input vector of length n containing right-hand-side */
/*         x        output vector containing the solution to q*x = y */
/*         omega    over-relaxation factor */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --y;
    --x;
    --wksp;

    /* Function Body */
    const__ = 2. - *omega;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = const__ * y[i__];
    }
    sbfsnt_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], omega, iunif, &wksp[1]);
    sbbsnt_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], omega, iunif);
    return 0;
} /* sbslnt_ */

/* Subroutine */ int sbsln1_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *y, doublereal *x, doublereal *omega, integer *iunif)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int sbfsn_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *);
    static doublereal const__;


/* ... sbsln1 does an block ssor forward solution. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ssor preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         y        input vector of length n containing right-hand-side */
/*         x        output vector containing the solution to q*x = y */
/*         omega    over-relaxation factor */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --y;
    --x;

    /* Function Body */
    const__ = 2. - *omega;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = const__ * y[i__];
    }
    sbfsn_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], omega, iunif);
    return 0;
} /* sbsln1_ */

/* Subroutine */ int sbsln2_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *y, doublereal *x, doublereal *omega, integer *iunif,
	doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int sbbsn_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, doublereal *);


/* ... sbsln2 does an block ssor back solution. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ssor preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         y        input vector of length n containing right-hand-side */
/*         x        output vector containing the solution to q*x = y */
/*         omega    over-relaxation factor */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --y;
    --x;
    --wksp;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    sbbsn_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], omega, iunif, &wksp[1]);
    return 0;
} /* sbsln2_ */

/* Subroutine */ int sbsln3_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *y, doublereal *x, doublereal *omega, integer *iunif)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    static doublereal const__;
    extern /* Subroutine */ int sbbsnt_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *);


/* ... sbsln3 does an block ssor transpose forward solution. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ssor preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         y        input vector of length n containing right-hand-side */
/*         x        output vector containing the solution to q*x = y */
/*         omega    over-relaxation factor */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --y;
    --x;

    /* Function Body */
    const__ = 2. - *omega;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = const__ * y[i__];
    }
    sbbsnt_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], omega, iunif);
    return 0;
} /* sbsln3_ */

/* Subroutine */ int sbsln4_(integer *ldd, integer *ldt, integer *n, integer *
	nsize, integer *ncolor, integer *nci, integer *ipt, integer *lbhb,
	integer *iblock, doublereal *d__, doublereal *t, integer *jt,
	doublereal *y, doublereal *x, doublereal *omega, integer *iunif,
	doublereal *wksp)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, iblock_dim2, iblock_offset, d_dim1, d_offset,
	    t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int sbfsnt_(integer *, integer *, integer *,
	    integer *, integer *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, doublereal *, doublereal *,
	     integer *, doublereal *);


/* ... sbsln4 does an block ssor transpose back solution. */
/*     nonsymmetric diagonal data structure, natural or multi-color */
/*     orderings, block ssor preconditioning. */

/* ... parameters -- */

/*         ldd      row dimension of d array */
/*         ldt      row dimension of t array */
/*         n        size of system */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*                   ncolor = 1 if iunif = 1. */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*                   if iunif = 1, nci(1) is the constant block size. */
/*         ipt      integer pointer vector of length ncolor+1 if */
/*                   iunif = 0.  formed in the factorization routine. */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*                   if iunif = 1, lbhb is of length 1. */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         d        array for diagonal block */
/*         t        array for off-diagonal blocks */
/*         jt       integer array of size ncolor by whatever */
/*                   giving the off-diagonal block diagonal numbers */
/*                   for each distinct block size.  jd is 1 by whatever */
/*                   if iunif = 1. */
/*         y        input vector of length n containing right-hand-side */
/*         x        output vector containing the solution to q*x = y */
/*         omega    over-relaxation factor */
/*         iunif    uniform block size switch */
/*                   = 0   diagonal blocks are not of uniform size */
/*                   = 1   diagonal blocks are of uniform size */
/*         wksp     floating point workspace vector */

/* ... specifications for parameters */


    /* Parameter adjustments */
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    t_dim1 = *ldt;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ncolor;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    iblock_dim2 = *ncolor;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --lbhb;
    --y;
    --x;
    --wksp;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    sbfsnt_(ldd, ldt, n, nsize, ncolor, &nci[1], &ipt[1], &lbhb[1], &iblock[
	    iblock_offset], &d__[d_offset], &t[t_offset], &jt[jt_offset], &x[
	    1], omega, iunif, &wksp[1]);
    return 0;
} /* sbsln4_ */

/* Subroutine */ int scal1_(integer *nn, integer *ndim, integer *maxnzz,
	integer *jcoef, doublereal *coef, doublereal *rhs, doublereal *u,
	doublereal *ubar, doublereal *diag, doublereal *work, integer *iflag,
	integer *ier)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, coef_dim1, coef_offset, i__1, i__2;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, j, n;
    static doublereal cmin;
    extern doublereal vmin_(integer *, doublereal *);
    static integer maxnz;
    extern /* Subroutine */ int vgathr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... scal1 scales the original matrix to a unit diagonal matrix. */
/*     (purdue data structure) */
/*     rhs and u vectors are scaled accordingly.  upon output, diag */
/*     contains the reciprocal square roots of the diagonal elements. */
/*     it is assumed that the diagonal of the matrix is in column one */
/*     of coef. */

/* ... parameters -- */

/*         n       dimension of matrix */
/*         ndim    row dimension of coef array in defining routine */
/*         maxnz   number of columns in coef array */
/*         jcoef   integer matrix representation array */
/*         coef    matrix representation array */
/*         rhs     right hand side of matrix problem */
/*         u       latest estimate of solution */
/*         ubar    exact solution (optional) */
/*         diag    work array of length n (nonvolatile) */
/*         work    work array of length n (volatile) */
/*         iflag   flag for ubar */
/*                  = 0  do not scale ubar */
/*                  = 1  scale ubar */
/*         ier     error flag -- on return, values mean */
/*                      0 -- no errors detected */
/*                     -4 -- nonpositive diagonal element */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    --rhs;
    --u;
    --ubar;
    --diag;
    --work;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;

/* ... check for positive diagonal entries for each row. */

    cmin = vmin_(&n, &coef[coef_offset]);
    if (cmin > 0.) {
	goto L10;
    }

/* ... fatal error -- nonpositive diagonal element. */

    *ier = -4;
    return 0;

/* ... scale matrix.  store reciprocal square roots */
/* ... of diagonal entries in diag. */

L10:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	diag[i__] = sqrt(coef[i__ + coef_dim1]);
    }

/* ... scale rhs, u, and ubar. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	u[i__] = diag[i__] * u[i__];
    }
    if (*iflag == 0) {
	goto L30;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	ubar[i__] = diag[i__] * ubar[i__];
    }
L30:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L35: */
	diag[i__] = 1. / diag[i__];
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L40: */
	rhs[i__] = diag[i__] * rhs[i__];
    }
    if (itcom4_1.keygs == 2) {
	goto L55;
    }

/* ... using gathers. */

    i__1 = maxnz;
    for (j = 1; j <= i__1; ++j) {
	vgathr_(&n, &diag[1], &jcoef[j * jcoef_dim1 + 1], &work[1]);
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L45: */
	    coef[i__ + j * coef_dim1] = diag[i__] * coef[i__ + j * coef_dim1]
		    * work[i__];
	}
/* L50: */
    }
    return 0;

/* ... not using gathers. */

L55:
    i__1 = maxnz;
    for (j = 1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L60: */
	    coef[i__ + j * coef_dim1] = diag[i__] * coef[i__ + j * coef_dim1]
		    * diag[jcoef[i__ + j * jcoef_dim1]];
	}
/* L65: */
    }
    return 0;
} /* scal1_ */

/* Subroutine */ int scal2_(integer *nn, integer *ndim, integer *maxnz,
	integer *jcoef, doublereal *coef, doublereal *rhs, doublereal *u,
	doublereal *ubar, doublereal *diag, integer *iflag, integer *ier)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1, i__2;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, j, n, ind, len;
    static doublereal cmin;
    extern doublereal vmin_(integer *, doublereal *);


/* ... scal2 scales the original matrix to a unit diagonal matrix. */
/*     (diagonal data structure) */
/*     rhs and u vectors are scaled accordingly.  upon output, diag */
/*     contains the reciprocal square roots of the diagonal elements. */
/*     it is assumed that the diagonal of the matrix is in column one */
/*     of coef. */

/* ... parameters -- */

/*         n       dimension of matrix */
/*         ndim    row dimension of coef array in defining routine */
/*         maxnz   number of columns in coef array */
/*         jcoef   integer matrix representation array */
/*         coef    matrix representation array */
/*         rhs     right hand side of matrix problem */
/*         u       latest estimate of solution */
/*         ubar    exact solution (optional) */
/*         diag    work array of length n (nonvolatile) */
/*         iflag   flag for ubar */
/*                  = 0  do not scale ubar */
/*                  = 1  scale ubar */
/*         ier     error flag -- on return, values mean */
/*                      0 -- no errors detected */
/*                     -4 -- nonpositive diagonal element */

/* ... specifications for parameters */



    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;
    --rhs;
    --u;
    --ubar;
    --diag;

    /* Function Body */
    n = *nn;

/* ... check for positive diagonal entries for each row. */

    cmin = vmin_(&n, &coef[coef_offset]);
    if (cmin > 0.) {
	goto L10;
    }

/* ... fatal error -- nonpositive diagonal element. */

    *ier = -4;
    return 0;

/* ... scale matrix.  store reciprocal square roots */
/* ... of diagonal entries in diag. */

L10:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	diag[i__] = sqrt(coef[i__ + coef_dim1]);
    }

/* ... scale rhs, u, and ubar. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	u[i__] = diag[i__] * u[i__];
    }
    if (*iflag == 0) {
	goto L30;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	ubar[i__] = diag[i__] * ubar[i__];
    }
L30:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L35: */
	diag[i__] = 1. / diag[i__];
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L40: */
	rhs[i__] = diag[i__] * rhs[i__];
    }

/* ... scale matrix. */

    i__1 = *maxnz;
    for (j = 1; j <= i__1; ++j) {
	ind = jcoef[j];
	len = n - abs(ind);
	if (ind < 0) {
	    goto L50;
	}
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L45: */
	    coef[i__ + j * coef_dim1] = diag[i__] * coef[i__ + j * coef_dim1]
		    * diag[i__ + ind];
	}
	goto L60;
L50:
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L55: */
	    coef[i__ - ind + j * coef_dim1] = diag[i__ - ind] * coef[i__ -
		    ind + j * coef_dim1] * diag[i__];
	}
L60:
	;
    }
    return 0;
} /* scal2_ */

/* Subroutine */ int scal3_(integer *nn, integer *nz, integer *ia, integer *
	ja, doublereal *a, doublereal *rhs, doublereal *u, doublereal *ubar,
	doublereal *diag, doublereal *work, integer *iflag, integer *ier)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, n, ied, len, ist;
    static doublereal cmin;
    extern doublereal vmin_(integer *, doublereal *);
    extern /* Subroutine */ int vgathr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... scal3 scales the original matrix to a unit diagonal matrix. */
/*     (sparse data structure) */
/*     rhs and u vectors are scaled accordingly.  upon output, diag */
/*     contains the reciprocal square roots of the diagonal elements. */
/*     it is assumed that the diagonal of the matrix is in the */
/*     n first locations of a. */

/* ... parameters -- */

/*         n       dimension of matrix */
/*         nz      length of ia, ja, and a vectors */
/*         a       vector containing matrix coefficients */
/*         ia      vector of i values */
/*         ja      vector of j values */
/*         rhs     right hand side of matrix problem */
/*         u       latest estimate of solution */
/*         ubar    exact solution (optional) */
/*         diag    vector of length n containing the reciprocal */
/*                  square roots of the diagonal elements upon */
/*                  output */
/*         work    workspace vector of length n */
/*         iflag   flag for ubar */
/*                  = 0  do not scale ubar */
/*                  = 1  scale ubar */
/*         ier     error flag -- on return, values mean */
/*                      0 -- no errors detected */
/*                     -4 -- nonpositive diagonal element */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --work;
    --diag;
    --ubar;
    --u;
    --rhs;
    --a;
    --ja;
    --ia;

    /* Function Body */
    n = *nn;

/* ... check for positive diagonal entries for each row. */

    cmin = vmin_(&n, &a[1]);
    if (cmin > 0.) {
	goto L10;
    }

/* ... fatal error -- nonpositive diagonal element. */

    *ier = -4;
    return 0;

/* ... scale matrix.  store reciprocal square roots */
/* ... of diagonal entries in diag. */

L10:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	diag[i__] = sqrt(a[i__]);
    }

/* ... scale rhs, u, and ubar. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	u[i__] = diag[i__] * u[i__];
    }
    if (*iflag == 0) {
	goto L30;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	ubar[i__] = diag[i__] * ubar[i__];
    }
L30:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L35: */
	diag[i__] = 1. / diag[i__];
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L40: */
	rhs[i__] = diag[i__] * rhs[i__];
    }
    if (itcom4_1.keygs == 2) {
	goto L60;
    }

/* ... using gathers. */

    ist = 1;
L45:
/* Computing MIN */
    i__1 = ist - 1 + n;
    ied = min(i__1,*nz);
    if (ied < ist) {
	return 0;
    }
    len = ied - ist + 1;
    vgathr_(&len, &diag[1], &ia[ist], &work[1]);
    i__1 = ied;
    for (i__ = ist; i__ <= i__1; ++i__) {
/* L50: */
	a[i__] *= work[i__ - ist + 1];
    }
    vgathr_(&len, &diag[1], &ja[ist], &work[1]);
    i__1 = ied;
    for (i__ = ist; i__ <= i__1; ++i__) {
/* L55: */
	a[i__] *= work[i__ - ist + 1];
    }
    ist = ied + 1;
    goto L45;

/* ... not using gathers. */

L60:
    i__1 = *nz;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L65: */
	a[i__] = a[i__] * diag[ia[i__]] * diag[ja[i__]];
    }
    return 0;
} /* scal3_ */

/* Subroutine */ int sorstp_(integer *n, doublereal *u, doublereal *ubar,
	doublereal *dnrm, doublereal *ccon)
{
    /* System generated locals */
    integer i__1;
    doublereal d__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__;
    static logical q1;
    static doublereal tl, tr, con, sum, uold;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);


/* ... sorstp performs a test to see if the sor */
/*     method has converged to a solution inside the error */
/*     tolerance, zeta. */

/* ... parameters -- */

/*          n      order of system */
/*          u      present solution estimate */
/*          ubar   exact solution */
/*          dnrm   inner product of pseudo-residuals at preceding */
/*                    iteration */
/*          con    stopping test parameter (= ccon) */

/* ... specifications for parameters */


/* *** begin -- itpack common */


/* *** end   -- itpack common */

    /* Parameter adjustments */
    --ubar;
    --u;

    /* Function Body */
    con = *ccon;
    itcom2_1.halt = FALSE_;
    if (itcom1_1.ntest == 6) {
	goto L25;
    }

/* ... special procedure for zeroth iteration. */

    if (itcom1_1.in >= 1) {
	goto L5;
    }
    q1 = FALSE_;
    itcom3_1.udnm = 1.;
    itcom3_1.stptst = 1e3;
    return 0;

/* ... test if udnm needs to be recomputed */

L5:
    if (q1) {
	goto L15;
    }
    if (itcom1_1.in > 5 && itcom1_1.in % 5 != 0) {
	goto L15;
    }
    uold = itcom3_1.udnm;
    itcom3_1.udnm = 0.;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	itcom3_1.udnm += u[i__] * u[i__];
    }
    if (itcom3_1.udnm == 0.) {
	itcom3_1.udnm = 1.;
    }
    if (itcom1_1.in > 5 && (d__1 = itcom3_1.udnm - uold, abs(d__1)) <=
	    itcom3_1.udnm * itcom3_1.zeta) {
	q1 = TRUE_;
    }

/* ... compute stopping test */

L15:
    tr = sqrt(itcom3_1.udnm);
    tl = 1.;
    if (con == 1.) {
	goto L20;
    }
    tl = sqrt(*dnrm);
    tr *= 1. - con;
L20:
    itcom3_1.stptst = tl / tr;
    if (tl >= tr * itcom3_1.zeta) {
	return 0;
    }
    itcom2_1.halt = TRUE_;
    return 0;

/* ... second test. */

L25:
    if (itcom1_1.in == 0) {
	itcom3_1.ubarnm = sqrt(vdot_(n, &ubar[1], &ubar[1]));
    }
    sum = 0.;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
/* Computing 2nd power */
	d__1 = u[i__] - ubar[i__];
	sum += d__1 * d__1;
    }
    tl = sqrt(sum);
    tr = itcom3_1.ubarnm;
    itcom3_1.stptst = tl / tr;
    if (tl < tr * itcom3_1.zeta) {
	itcom2_1.halt = TRUE_;
    }
    return 0;
} /* sorstp_ */

/* Subroutine */ int sords_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, doublereal *omegaa,
	integer *irwise, doublereal *u, doublereal *rhs, doublereal *unew,
	integer *iwksp)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, n, nc, nc1;
    static doublereal con;
    static integer ibeg, iend, ndel, imin;
    static doublereal term;
    static integer maxt;
    static doublereal omega;
    extern /* Subroutine */ int vsubd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);
    static integer nterm;


/* ... sords does an sor solve (natural ordering, */
/*     symmetric diagonal storage). */

/*        unew = inv(d + w*l)*((1-w)*d*un + w*(rhs - u*un)) */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        u      current solution vector */
/*        rhs    right hand side */
/*        unew   updated solution vector */
/*        iwksp  integer workspace of length maxt */

/* ... specifications for parameters */



    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --u;
    --rhs;
    --unew;
    --iwksp;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    omega = *omegaa;

/* ... rhs = (1-w)*d*un + w*(rhs - u*un) */

    vsubd_(ndim, &c__1, &n, &n, &maxt, &t[t_offset], &jt[1], &rhs[1], &u[1], &
	    c__0);
    con = 1. - omega;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	rhs[i__] = con * d__[i__] * u[i__] + omega * rhs[i__];
    }

/* ... rhs = inv(i+w*l*inv(d))*rhs */

/* ... select rowwise or diagonal-wise algorithm. */

    if (*irwise == 1) {
	goto L50;
    }

/* ... diagonal-wise algorithm. */

    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	iwksp[i__] = jt[i__] + 1;
    }

/* ... determine nc, imin. */

L20:
    nc = n;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	nterm = iwksp[i__] - 1;
	if (nterm >= nc) {
	    goto L25;
	}
	nc = nterm;
	imin = i__;
L25:
	;
    }
    if (nc >= n) {
	goto L70;
    }
    ndel = jt[imin];
    ibeg = nc + 1;
    if (ndel > 1) {
	goto L40;
    }

/* ... special case for first minor subdiagonal. */

    nc1 = n;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ == imin) {
	    goto L30;
	}
	if (iwksp[i__] < nc1) {
	    nc1 = iwksp[i__];
	}
L30:
	;
    }
    iwksp[imin] = nc1 + 1;
    i__1 = nc1;
    for (j = ibeg; j <= i__1; ++j) {
/* L35: */
	rhs[j] -= omega * t[j - 1 + imin * t_dim1] * rhs[j - 1] / d__[j - 1];
    }
    goto L20;

/* ... far diagonals  (do vector computations). */

L40:
    iwksp[imin] += ndel;
/* Computing MIN */
    i__1 = ibeg + ndel - 1;
    iend = min(i__1,n);
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L45: */
	rhs[i__] -= omega * t[i__ - ndel + imin * t_dim1] * rhs[i__ - ndel] /
		d__[i__ - ndel];
    }
    goto L20;

/* ... rowwise algorithm. */

L50:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = maxt;
	for (j = 1; j <= i__2; ++j) {
/* L55: */
/* Computing MIN */
	    i__3 = n, i__4 = i__ + jt[j];
	    iwksp[j] = min(i__3,i__4);
	}
	term = omega * rhs[i__] / d__[i__];
	i__3 = maxt;
	for (j = 1; j <= i__3; ++j) {
/* L60: */
	    rhs[iwksp[j]] -= t[i__ + j * t_dim1] * term;
	}
/* L65: */
    }

/* ... unew = inv(d)*rhs */

L70:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L75: */
	unew[i__] = rhs[i__] / d__[i__];
    }
    return 0;
} /* sords_ */

/* Subroutine */ int sordn_(integer *ndim, integer *nn, integer *maxtt,
	integer *maxbb, integer *jt, integer *jb, doublereal *d__, doublereal
	*t, doublereal *b, doublereal *omegaa, integer *irwise, doublereal *u,
	 doublereal *rhs, doublereal *unew, integer *iwksp)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, n, nc, nc1;
    static doublereal con, sum;
    static integer ibeg, iend, ndel, maxb, imin, maxt;
    static doublereal omega;
    extern /* Subroutine */ int vsubd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);
    static integer nterm;


/* ... sordn does an sor solve (natural ordering, */
/*     nonsymmetric diagonal storage). */

/*        unew = inv(d + w*l)*((1-w)*d*un + w*(rhs - u*un)) */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        maxb   number of columns in b array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        jb     integer vector of length maxb giving the diagonal */
/*                indices of the corresponding columns in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the matrix */
/*        b      array of active size n by maxb giving the sub- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        u      current solution vector */
/*        rhs    right hand side */
/*        unew   updated solution vector */
/*        iwksp  integer workspace of length maxt */

/* ... specifications for parameters */



    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --jb;
    --d__;
    --u;
    --rhs;
    --unew;
    --iwksp;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    maxb = *maxbb;
    omega = *omegaa;

/* ... rhs = (1-w)*d*un + w*(rhs - u*un) */

    vsubd_(ndim, &c__1, &n, &n, &maxt, &t[t_offset], &jt[1], &rhs[1], &u[1], &
	    c__0);
    con = 1. - omega;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	rhs[i__] = con * d__[i__] * u[i__] + omega * rhs[i__];
    }

/* ... rhs = inv(i+w*l*inv(d))*rhs */

/* ... select rowwise or diagonal-wise algorithm. */

    if (*irwise == 1) {
	goto L50;
    }

/* ... diagonal-wise algorithm. */

    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	iwksp[i__] = 1 - jb[i__];
    }

/* ... determine nc, imin. */

L20:
    nc = n;
    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
	nterm = iwksp[i__] - 1;
	if (nterm >= nc) {
	    goto L25;
	}
	nc = nterm;
	imin = i__;
L25:
	;
    }
    if (nc >= n) {
	goto L70;
    }
    ndel = -jb[imin];
    ibeg = nc + 1;
    if (ndel > 1) {
	goto L40;
    }

/* ... special case for first minor subdiagonal. */

    nc1 = n;
    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ == imin) {
	    goto L30;
	}
	if (iwksp[i__] < nc1) {
	    nc1 = iwksp[i__];
	}
L30:
	;
    }
    iwksp[imin] = nc1 + 1;
    i__1 = nc1;
    for (j = ibeg; j <= i__1; ++j) {
/* L35: */
	rhs[j] -= omega * b[j + imin * b_dim1] * rhs[j - 1] / d__[j - 1];
    }
    goto L20;

/* ... far diagonals  (do vector computations). */

L40:
    iwksp[imin] += ndel;
/* Computing MIN */
    i__1 = ibeg + ndel - 1;
    iend = min(i__1,n);
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L45: */
	rhs[i__] -= omega * b[i__ + imin * b_dim1] * rhs[i__ - ndel] / d__[
		i__ - ndel];
    }
    goto L20;

/* ... rowwise algorithm. */

L50:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = maxb;
	for (j = 1; j <= i__2; ++j) {
/* L55: */
/* Computing MAX */
	    i__3 = 1, i__4 = i__ + jb[j];
	    iwksp[j] = max(i__3,i__4);
	}
	sum = 0.;
	i__3 = maxb;
	for (j = 1; j <= i__3; ++j) {
/* L60: */
	    sum += b[i__ + j * b_dim1] * rhs[iwksp[j]] / d__[iwksp[j]];
	}
	rhs[i__] -= omega * sum;
/* L65: */
    }

/* ... unew = inv(d)*rhs */

L70:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L75: */
	unew[i__] = rhs[i__] / d__[i__];
    }
    return 0;
} /* sordn_ */

/* Subroutine */ int sorp_(integer *ndim, integer *nn, integer *maxt, integer
	*maxb, integer *jt, integer *jb, doublereal *d__, doublereal *t,
	doublereal *b, doublereal *omega, doublereal *u, doublereal *rhs,
	doublereal *unew)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, jt_dim1, jt_offset, jb_dim1,
	    jb_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, n;
    static doublereal con, sum;
    extern /* Subroutine */ int vsubp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... sorp does an sor solve */
/*     (natural ordering, purdue storage). */

/*        unew = inv((1/w)*d + l)*(((1-w)/w)*d*un + (rhs - u*un)) */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        maxb   number of columns in b array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        jb     integer array giving the column numbers of the */
/*                corresponding elements in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the matrix */
/*        b      array of active size n by maxb giving the lower */
/*                triangle of the matrix */
/*        omega  over-relaxation factor */
/*        u      current solution vector */
/*        rhs    right hand side */
/*        unew   updated solution vector */

/* ... specifications for parameters */

    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jb_dim1 = *ndim;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    jt_dim1 = *ndim;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --u;
    --rhs;
    --unew;

    /* Function Body */
    n = *nn;

/* ... rhs = ((1-w)/w)*d*un + (rhs - u*un) */

    vsubp_(ndim, ndim, &n, maxt, &t[t_offset], &jt[jt_offset], &rhs[1], &u[1],
	     &unew[1]);
    con = (1. - *omega) / *omega;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	unew[i__] = con * d__[i__] * u[i__] + rhs[i__];
    }

/* ... unew = inv((1/w)*d + l)*rhs */

    if (*maxb >= 1) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	unew[i__] = *omega * unew[i__] / d__[i__];
    }
    return 0;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	sum = unew[i__];
	i__2 = *maxb;
	for (j = 1; j <= i__2; ++j) {
	    sum -= b[i__ + j * b_dim1] * unew[jb[i__ + j * jb_dim1]];
/* L25: */
	}
	unew[i__] = *omega * sum / d__[i__];
/* L30: */
    }
    return 0;
} /* sorp_ */

/* Subroutine */ int sorcp_(integer *ndimm, integer *n, integer *jc,
	doublereal *d__, doublereal *c__, integer *ncol, integer *nc, integer
	*nt, integer *nb, doublereal *omega, doublereal *u, doublereal *rhs,
	doublereal *unew)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j1, j2, mj, ied;
    static doublereal con;
    static integer ist, npt, icol, ndim;
    extern /* Subroutine */ int vsubp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);
    static integer ncolor;


/* ... sorcp does an sor solve. */
/*     (purdue storage, multicolor) */

/*        unew = inv((1/w)*d + l)*(((1-w)/w)*d*un + (rhs - u*un)) */

/* ... parameters -- */

/*          ndim   row dimension of c,jc arrays */
/*          n      order of system */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          omega  over-relaxation factor */
/*          u      current solution */
/*          rhs    right-hand-side */
/*          unew   updated solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndimm;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndimm;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --u;
    --rhs;
    --unew;

    /* Function Body */
    ndim = *ndimm;
    ncolor = *ncol;

/* ... rhs = ((1-w)/w)*d*un + (rhs - u*un) */

    ist = 1;
    i__1 = ncolor;
    for (icol = 1; icol <= i__1; ++icol) {
	npt = nc[icol];
	j2 = nt[icol];
	vsubp_(&ndim, &ndim, &npt, &j2, &c__[ist + c_dim1], &jc[ist + jc_dim1]
		, &rhs[ist], &u[1], &unew[1]);
	ist += npt;
/* L10: */
    }
    con = (1. - *omega) / *omega;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	unew[i__] = con * d__[i__] * u[i__] + rhs[i__];
    }

/* ... unew = inv((1/w)*d + l)*rhs */

    ist = 1;
    i__1 = ncolor;
    for (icol = 1; icol <= i__1; ++icol) {
	npt = nc[icol];
	ied = ist + npt - 1;
	j1 = nt[icol] + 1;
	mj = nb[icol];
	vsubp_(&ndim, &ndim, &npt, &mj, &c__[ist + j1 * c_dim1], &jc[ist + j1
		* jc_dim1], &unew[ist], &unew[1], &rhs[1]);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L20: */
	    unew[i__] = *omega * unew[i__] / d__[i__];
	}
	ist += npt;
/* L25: */
    }
    return 0;
} /* sorcp_ */

/* Subroutine */ int sordb_(integer *ldf, integer *ndim, integer *nsize,
	integer *kblszz, integer *iblock, integer *lbhb, doublereal *dfac,
	doublereal *coef, integer *jcoef, integer *nn, doublereal *omega,
	doublereal *u, doublereal *rhs, doublereal *unew)
{
    /* System generated locals */
    integer dfac_dim1, dfac_offset, coef_dim1, coef_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, l, n, jj, nt, ied, inc;
    static doublereal con;
    static integer mjj, ist, jst, jbgn, jblk;
    extern /* Subroutine */ int bmul_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *);
    static integer istf, maxt;
    extern /* Subroutine */ int bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *);
    static integer jjlim;
    extern /* Subroutine */ int vsubd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);
    static integer kblsz, nwdiag;
    extern /* Subroutine */ int vsubdt_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);


/* ... sordb does an sor pass */
/*     (symmetric block diagonal format, constant block size) */

/*        unew = inv((1/w)*d + l)*(((1-w)/w)*d*un + (rhs - u*un)) */

/* ... parameters -- */

/*         ldf      row dimension of dfac */
/*         ndim     row dimension of coef array */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         lbhb     column size of iblock */
/*         dfac     array for diagonal block factorization */
/*         coef     array for matrix coefficients */
/*         jcoef    vector for diagonal numbers */
/*         n        size of system */
/*         omega    relaxation parameter */
/*         u        current solution estimate */
/*         rhs      right-hand-side */
/*         unew     updated solution estimate */

/* ... specifications for parameters */


    /* Parameter adjustments */
    dfac_dim1 = *ldf;
    dfac_offset = 1 + dfac_dim1;
    dfac -= dfac_offset;
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    iblock -= 4;
    --jcoef;
    --u;
    --rhs;
    --unew;

    /* Function Body */
    n = *nn;
    kblsz = *kblszz;

/* ... rhs = ((1-w)/w)*d*un + (rhs - u*un) */

    nwdiag = iblock[6];
    nt = nwdiag - 1;
    maxt = 0;
    if (*lbhb < 3) {
	goto L15;
    }
    i__1 = *lbhb;
    for (j = 3; j <= i__1; ++j) {
	maxt += iblock[j * 3 + 3];
/* L10: */
    }
L15:
    jbgn = nwdiag + 1;
    vsubd_(ndim, &c__1, &n, &n, &maxt, &coef[jbgn * coef_dim1 + 1], &jcoef[
	    jbgn], &rhs[1], &u[1], &c__0);
    bmul_(ndim, &n, &nt, &coef[coef_offset], &coef[(coef_dim1 << 1) + 1], &u[
	    1], &unew[1]);
    con = (1. - *omega) / *omega;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	unew[i__] = con * unew[i__] + rhs[i__];
    }

/* ... unew = inv((1/w)*d + l)*rhs */

    l = n / kblsz;
    i__1 = l;
    for (k = 1; k <= i__1; ++k) {
	ist = (k - 1) * kblsz + 1;
	ied = k * kblsz;
	if (nt >= 1) {
	    goto L30;
	}
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L25: */
	    unew[i__] = *omega * dfac[i__ + dfac_dim1] * unew[i__];
	}
	goto L40;
L30:
	bdsol_(ldf, &kblsz, nsize, &nt, &c__0, &dfac[ist + dfac_dim1], &unew[
		ist], &unew[ist], &c__0);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L35: */
	    unew[i__] = *omega * unew[i__];
	}
L40:
	if (k == l) {
	    goto L50;
	}
/* Computing MIN */
	i__2 = *lbhb, i__3 = l - k + 2;
	jjlim = min(i__2,i__3);
	i__2 = jjlim;
	for (jj = 3; jj <= i__2; ++jj) {
	    jblk = iblock[jj * 3 + 1];
	    jst = iblock[jj * 3 + 2] + nwdiag;
	    mjj = iblock[jj * 3 + 3];
	    inc = jblk * kblsz;
	    istf = ist + inc;
	    if (istf > n) {
		goto L45;
	    }
	    vsubdt_(ndim, &c__1, &kblsz, &kblsz, &mjj, &coef[ist + jst *
		    coef_dim1], &jcoef[jst], &unew[istf], &unew[ist], &inc);
L45:
	    ;
	}
L50:
	;
    }
    return 0;
} /* sordb_ */

/* Subroutine */ int sordnb_(integer *ldf, integer *ndim, integer *nsize,
	integer *kblszz, integer *iblock, integer *lbhbb, doublereal *dfac,
	doublereal *coef, integer *jcoef, integer *nn, doublereal *omega,
	doublereal *u, doublereal *rhs, doublereal *unew)
{
    /* System generated locals */
    integer dfac_dim1, dfac_offset, coef_dim1, coef_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, k, l, n, mb, nb, nt, ied, inc, ind;
    static doublereal con;
    static integer ist, lbhb, jbgn, jcol, istb, jstb, maxt;
    extern /* Subroutine */ int bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *), bmuln_(integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *), vsubd_(integer *, integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    integer *);
    static integer kblsz, nwdiag;


/* ... sordnb does an sor pass */
/*     (nonsymmetric block diagonal format, constant block size) */

/*        unew = inv((1/w)*d + l)*(((1-w)/w)*d*un + (rhs - u*un)) */

/* ... parameters -- */

/*         ldf      row dimension of dfac */
/*         ndim     row dimension of coef array */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         lbhb     column size of iblock */
/*         dfac     array for diagonal block factorization */
/*         coef     array for matrix coefficients */
/*         jcoef    vector for diagonal numbers */
/*         n        size of system */
/*         omega    relaxation parameter */
/*         u        current solution estimate */
/*         rhs      right-hand-side */
/*         unew     updated solution estimate */

/* ... specifications for parameters */


    /* Parameter adjustments */
    dfac_dim1 = *ldf;
    dfac_offset = 1 + dfac_dim1;
    dfac -= dfac_offset;
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    iblock -= 4;
    --jcoef;
    --u;
    --rhs;
    --unew;

    /* Function Body */
    n = *nn;
    kblsz = *kblszz;
    lbhb = *lbhbb;

/* ... rhs = ((1-w)/w)*d*un + (rhs - u*un) */

    nt = iblock[6] - 1;
    nb = iblock[9];
    nwdiag = nt + nb + 1;
    maxt = 0;
    if (lbhb < 3) {
	goto L15;
    }
    i__1 = lbhb;
    for (j = 3; j <= i__1; ++j) {
	ind = iblock[j * 3 + 1];
	if (ind > 0) {
	    maxt += iblock[j * 3 + 3];
	}
/* L10: */
    }
L15:
    jbgn = nwdiag + 1;
    vsubd_(ndim, &c__1, &n, &n, &maxt, &coef[jbgn * coef_dim1 + 1], &jcoef[
	    jbgn], &rhs[1], &u[1], &c__0);
    ind = nt + 2;
    bmuln_(ndim, &n, &nt, &nb, &coef[coef_offset], &coef[(coef_dim1 << 1) + 1]
	    , &coef[ind * coef_dim1 + 1], &u[1], &unew[1]);
    con = (1. - *omega) / *omega;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	unew[i__] = con * unew[i__] + rhs[i__];
    }

/* ... unew = inv((1/w)*d + l)*rhs */

    l = n / kblsz;
    i__1 = l;
    for (k = 1; k <= i__1; ++k) {
	ist = (k - 1) * kblsz + 1;
	ied = k * kblsz;
	i__2 = lbhb;
	for (j = 3; j <= i__2; ++j) {
	    jcol = k + iblock[j * 3 + 1];
	    if (jcol >= k || jcol <= 0) {
		goto L25;
	    }
	    jstb = iblock[j * 3 + 2] + nwdiag;
	    mb = iblock[j * 3 + 3];
	    inc = (jcol - k) * kblsz;
	    istb = ist + inc;
	    vsubd_(ndim, &c__1, &kblsz, &kblsz, &mb, &coef[ist + jstb *
		    coef_dim1], &jcoef[jstb], &unew[ist], &unew[istb], &inc);
L25:
	    ;
	}
	if (nt + nb >= 1) {
	    goto L35;
	}
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L30: */
	    unew[i__] = *omega * dfac[i__ + dfac_dim1] * unew[i__];
	}
	goto L45;
L35:
	bdsol_(ldf, &kblsz, nsize, &nt, &nb, &dfac[ist + dfac_dim1], &unew[
		ist], &unew[ist], &c__1);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L40: */
	    unew[i__] = *omega * unew[i__];
	}
L45:
	;
    }
    return 0;
} /* sordnb_ */

/* Subroutine */ int sordmb_(integer *ldf, integer *ndim, integer *nsize,
	integer *iblock, integer *lbhb, integer *ncol, integer *nc, integer *
	ipt, doublereal *dfac, doublereal *coef, integer *jcnew, integer *nn,
	doublereal *omega, doublereal *u, doublereal *rhs, doublereal *unew)
{
    /* System generated locals */
    integer jcnew_dim1, jcnew_offset, iblock_dim2, iblock_offset, dfac_dim1,
	    dfac_offset, coef_dim1, coef_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, k, n, na, mb, nb, ied, ndb, inc, ind;
    static doublereal con;
    static integer ndt, ist, jcol, jlim, istb, jstb;
    extern /* Subroutine */ int bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *), bmuln_(integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *), vsubd_(integer *, integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    integer *);
    static integer nwdiag, ncolor;


/* ... sordmb does an sor pass */
/*     (nonsymmetric block diagonal format, nonconstant block size) */

/*        unew = inv((1/w)*d + l)*(((1-w)/w)*d*un + (rhs - u*un)) */

/* ... parameters -- */

/*         ldf      row dimension of dfac array */
/*         ndim     row dimension of coef array */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*         ncolor   number of distinct block sizes */
/*         nc       integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*         ipt      integer pointer vector of length ncolor+1 */
/*                   giving the starting locations of new block */
/*                   rows */
/*         dfac     array for diagonal block factorization */
/*         coef     array of matrix coefficients */
/*         jcnew    integer array of row dimension ncolor giving the */
/*                   diagonal numbers for each block */
/*         n        size of system */
/*         omega    relaxation parameter */
/*         u        current solution estimate */
/*         rhs      right-hand-side */
/*         unew     updated solution estimate */

/* ... specifications for parameters */


    /* Parameter adjustments */
    dfac_dim1 = *ldf;
    dfac_offset = 1 + dfac_dim1;
    dfac -= dfac_offset;
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --lbhb;
    jcnew_dim1 = *ncol;
    jcnew_offset = 1 + jcnew_dim1;
    jcnew -= jcnew_offset;
    iblock_dim2 = *ncol;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nc;
    --ipt;
    --u;
    --rhs;
    --unew;

    /* Function Body */
    n = *nn;
    ncolor = *ncol;

/* ... rhs = ((1-w)/w)*d*un + (rhs - u*un) */

    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    nwdiag = ndt + ndb + 1;
    i__1 = ncolor;
    for (k = 1; k <= i__1; ++k) {
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nc[k];
	i__2 = jlim;
	for (j = 3; j <= i__2; ++j) {
	    jcol = k + iblock[(k + j * iblock_dim2) * 3 + 1];
	    if (jcol <= k || jcol > ncolor) {
		goto L10;
	    }
	    jstb = iblock[(k + j * iblock_dim2) * 3 + 2] + nwdiag;
	    mb = iblock[(k + j * iblock_dim2) * 3 + 3];
	    inc = ipt[jcol] - ipt[k];
	    nb = nc[jcol];
	    istb = ist + inc;
	    vsubd_(ndim, &ncolor, &na, &nb, &mb, &coef[ist + jstb * coef_dim1]
		    , &jcnew[k + jstb * jcnew_dim1], &rhs[ist], &u[istb], &
		    inc);
L10:
	    ;
	}
/* L15: */
    }
    ind = ndt + 2;
    bmuln_(ndim, &n, &ndt, &ndb, &coef[coef_offset], &coef[(coef_dim1 << 1) +
	    1], &coef[ind * coef_dim1 + 1], &u[1], &unew[1]);
    con = (1. - *omega) / *omega;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	unew[i__] = con * unew[i__] + rhs[i__];
    }

/* ... unew = inv((1/w)*d + l)*rhs */

    i__1 = ncolor;
    for (k = 1; k <= i__1; ++k) {
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nc[k];
	ndt = iblock[(k + iblock_dim2) * 3 + 3] - 1;
	ndb = iblock[(k + (iblock_dim2 << 1)) * 3 + 3];
	ied = ist + na - 1;
	i__2 = jlim;
	for (j = 3; j <= i__2; ++j) {
	    jcol = k + iblock[(k + j * iblock_dim2) * 3 + 1];
	    if (jcol >= k || jcol <= 0) {
		goto L25;
	    }
	    jstb = iblock[(k + j * iblock_dim2) * 3 + 2] + nwdiag;
	    mb = iblock[(k + j * iblock_dim2) * 3 + 3];
	    inc = ipt[jcol] - ipt[k];
	    nb = nc[jcol];
	    istb = ist + inc;
	    vsubd_(ndim, &ncolor, &na, &nb, &mb, &coef[ist + jstb * coef_dim1]
		    , &jcnew[k + jstb * jcnew_dim1], &unew[ist], &unew[istb],
		    &inc);
L25:
	    ;
	}
	if (ndt + ndb >= 1) {
	    goto L35;
	}
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L30: */
	    unew[i__] = *omega * dfac[i__ + dfac_dim1] * unew[i__];
	}
	goto L45;
L35:
	bdsol_(ldf, &na, nsize, &ndt, &ndb, &dfac[ist + dfac_dim1], &unew[ist]
		, &unew[ist], &c__1);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L40: */
	    unew[i__] = *omega * unew[i__];
	}
L45:
	;
    }
    return 0;
} /* sordmb_ */

/* Subroutine */ int srbs_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, doublereal *omega,
	integer *irwise, integer *iwksp, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, n, nc, nc1;
    static doublereal sum;
    static integer ibeg, iend, ndel, imax, maxt, nterm;


/* ... srbs does an sor back solve (natural ordering, */
/*     diagonal storage). */

/*        (i + omega*inv(d)*t)*x = y */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        x      on input, x contains y */
/*               on output, x is the solution to back-solve */

/* ... specifications for parameters */



    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    if (maxt <= 0) {
	return 0;
    }

/* ... select rowwise or diagonal-wise algorithm. */

    if (*irwise == 1) {
	goto L60;
    }

/* ... diagonal-wise algorithm. */

    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	iwksp[i__] = n - jt[i__];
    }

/* ... determine nc, imax. */

L25:
    nc = 1;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	nterm = iwksp[i__] + 1;
	if (nterm <= nc) {
	    goto L30;
	}
	nc = nterm;
	imax = i__;
L30:
	;
    }
    if (nc <= 1) {
	return 0;
    }
    ndel = jt[imax];
    iend = nc - 1;
    if (ndel > 1) {
	goto L50;
    }

/* ... special case for first super diagonal. */

    nc1 = 1;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ == imax) {
	    goto L40;
	}
	if (iwksp[i__] > nc1) {
	    nc1 = iwksp[i__];
	}
L40:
	;
    }
    iwksp[imax] = nc1 - 1;
    i__1 = nc1;
    for (k = iend; k >= i__1; --k) {
/* L45: */
	x[k] -= *omega * t[k + imax * t_dim1] * x[k + 1] / d__[k];
    }
    goto L25;

/* ... far diagonals  (do vector computations). */

L50:
    iwksp[imax] -= ndel;
/* Computing MAX */
    i__1 = iend - ndel;
    ibeg = max(i__1,0) + 1;
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L55: */
	x[i__] -= *omega * t[i__ + imax * t_dim1] * x[i__ + ndel] / d__[i__];
    }
    goto L25;

/* ... rowwise algorithm. */

L60:
    for (i__ = n; i__ >= 1; --i__) {
	i__1 = maxt;
	for (j = 1; j <= i__1; ++j) {
/* L65: */
/* Computing MIN */
	    i__2 = n, i__3 = i__ + jt[j];
	    iwksp[j] = min(i__2,i__3);
	}
	sum = 0.;
	i__2 = maxt;
	for (j = 1; j <= i__2; ++j) {
/* L70: */
	    sum += t[i__ + j * t_dim1] * x[iwksp[j]];
	}
	x[i__] -= *omega * sum / d__[i__];
/* L75: */
    }
    return 0;
} /* srbs_ */

/* Subroutine */ int srbst_(integer *ndim, integer *nn, integer *maxbb,
	integer *jb, doublereal *d__, doublereal *b, doublereal *omega,
	integer *irwise, integer *iwksp, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, n, nc, nc1, ibeg, iend, ndel, maxb, imax;
    static doublereal term;
    static integer nterm;


/* ... srbst does an sor transpose back solve (natural ordering, */
/*     diagonal storage). */

/*        (i + omega*inv(d)*(b**t))*x = y */

/* ... parameters -- */

/*        ndim   row dimension of b array */
/*        n      order of system (= nn) */
/*        maxb   number of columns in b array */
/*        jb     integer vector of length maxb giving the diagonal */
/*                indices of the corresponding columns in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        b      array of active size n by maxb giving the sub- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxb */
/*        x      on input, x contains y */
/*               on output, x is the solution to back-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --jb;
    --d__;
    --iwksp;
    --x;

    /* Function Body */
    n = *nn;
    maxb = *maxbb;
    if (maxb < 1) {
	return 0;
    }

/* ... select rowwise or diagonal-wise algorithm. */

    if (*irwise == 1) {
	goto L70;
    }

/* ... diagonal-wise algorithm. */

    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	iwksp[i__] = n + jb[i__];
    }

/* ... determine nc, imax. */

L20:
    nc = 1;
    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
	nterm = iwksp[i__] + 1;
	if (nterm <= nc) {
	    goto L25;
	}
	nc = nterm;
	imax = i__;
L25:
	;
    }
    if (nc <= 1) {
	return 0;
    }
    ndel = -jb[imax];
    iend = nc - 1;
    if (ndel > 1) {
	goto L50;
    }

/* ... special case for first sub diagonal. */

    nc1 = 1;
    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ == imax) {
	    goto L30;
	}
	if (iwksp[i__] > nc1) {
	    nc1 = iwksp[i__];
	}
L30:
	;
    }
    iwksp[imax] = nc1 - 1;
    i__1 = nc1;
    for (k = iend; k >= i__1; --k) {
/* L45: */
	x[k] -= *omega * b[k + 1 + imax * b_dim1] * x[k + 1] / d__[k];
    }
    goto L20;

/* ... far diagonals  (do vector computations). */

L50:
    iwksp[imax] -= ndel;
/* Computing MAX */
    i__1 = iend - ndel;
    ibeg = max(i__1,0) + 1;
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L65: */
	x[i__] -= *omega * b[i__ + ndel + imax * b_dim1] * x[i__ + ndel] /
		d__[i__];
    }
    goto L20;

/* ... rowwise algorithm. */

L70:
    for (i__ = n; i__ >= 2; --i__) {
	i__1 = maxb;
	for (j = 1; j <= i__1; ++j) {
/* L75: */
/* Computing MAX */
	    i__2 = 1, i__3 = i__ + jb[j];
	    iwksp[j] = max(i__2,i__3);
	}
	term = *omega * x[i__];
	i__2 = maxb;
	for (j = 1; j <= i__2; ++j) {
/* L80: */
	    x[iwksp[j]] -= b[i__ + j * b_dim1] * term / d__[iwksp[j]];
	}
/* L85: */
    }
    return 0;
} /* srbst_ */

/* Subroutine */ int srfs_(integer *ndim, integer *nn, integer *maxbb,
	integer *jb, doublereal *d__, doublereal *b, doublereal *omega,
	integer *irwise, integer *iwksp, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, n, nc, nc1;
    static doublereal sum;
    static integer ibeg, iend, ndel, maxb, imin, nterm;


/* ... srfs does an sor forward solve (natural ordering, */
/*     diagonal storage). */

/*        (i + omega*b*inv(d))*x = y */

/* ... parameters -- */

/*        ndim   row dimension of b array */
/*        n      order of system (= nn) */
/*        maxb   number of columns in b array */
/*        jb     integer vector of length maxb giving the diagonal */
/*                indices of the corresponding columns in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        b      array of active size n by maxb giving the sub- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxb */
/*        x      on input, x contains y */
/*               on output, x is the solution to forward-solve */

/* ... specifications for parameters */



    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --jb;
    --d__;
    --iwksp;
    --x;

    /* Function Body */
    n = *nn;
    maxb = *maxbb;
    if (maxb <= 0) {
	return 0;
    }

/* ... select rowwise or diagonal-wise algorithm. */

    if (*irwise == 1) {
	goto L60;
    }

/* ... diagonal-wise algorithm. */

    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	iwksp[i__] = 1 - jb[i__];
    }

/* ... determine nc, imin. */

L25:
    nc = n;
    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
	nterm = iwksp[i__] - 1;
	if (nterm >= nc) {
	    goto L30;
	}
	nc = nterm;
	imin = i__;
L30:
	;
    }
    if (nc >= n) {
	return 0;
    }
    ndel = -jb[imin];
    ibeg = nc + 1;
    if (ndel > 1) {
	goto L50;
    }

/* ... special case for first minor subdiagonal. */

    nc1 = n;
    i__1 = maxb;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ == imin) {
	    goto L40;
	}
	if (iwksp[i__] < nc1) {
	    nc1 = iwksp[i__];
	}
L40:
	;
    }
    iwksp[imin] = nc1 + 1;
    i__1 = nc1;
    for (j = ibeg; j <= i__1; ++j) {
/* L45: */
	x[j] -= *omega * b[j + imin * b_dim1] * x[j - 1] / d__[j - 1];
    }
    goto L25;

/* ... far diagonals  (do vector computations). */

L50:
    iwksp[imin] += ndel;
/* Computing MIN */
    i__1 = ibeg + ndel - 1;
    iend = min(i__1,n);
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L55: */
	x[i__] -= *omega * b[i__ + imin * b_dim1] * x[i__ - ndel] / d__[i__ -
		ndel];
    }
    goto L25;

/* ... rowwise algorithm. */

L60:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = maxb;
	for (j = 1; j <= i__2; ++j) {
/* L65: */
/* Computing MAX */
	    i__3 = 1, i__4 = i__ + jb[j];
	    iwksp[j] = max(i__3,i__4);
	}
	sum = 0.;
	i__3 = maxb;
	for (j = 1; j <= i__3; ++j) {
/* L70: */
	    sum += b[i__ + j * b_dim1] * x[iwksp[j]] / d__[iwksp[j]];
	}
	x[i__] -= *omega * sum;
/* L75: */
    }
    return 0;
} /* srfs_ */

/* Subroutine */ int srfst_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, doublereal *omega,
	integer *irwise, integer *iwksp, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1, i__2, i__3, i__4;

    /* Local variables */
    static integer i__, j, n, nc, nc1, ibeg, iend, ndel, imin;
    static doublereal term;
    static integer maxt, nterm;


/* ... srfst does an sor transpose forward solve (natural ordering, */
/*     diagonal storage). */

/*        (i + omega*(t**t)*inv(d))*x = y */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        x      on input, x contains y */
/*               on output, x is the solution to forward-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    if (maxt < 1) {
	return 0;
    }

/* ... select rowwise or diagonal-wise algorithm. */

    if (*irwise == 1) {
	goto L70;
    }

/* ... diagonal-wise algorithm. */

    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	iwksp[i__] = jt[i__] + 1;
    }

/* ... determine nc, imin. */

L20:
    nc = n;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	nterm = iwksp[i__] - 1;
	if (nterm >= nc) {
	    goto L25;
	}
	nc = nterm;
	imin = i__;
L25:
	;
    }
    if (nc >= n) {
	return 0;
    }
    ndel = jt[imin];
    ibeg = nc + 1;
    if (ndel > 1) {
	goto L50;
    }

/* ... special case for first minor subdiagonal. */

    nc1 = n;
    i__1 = maxt;
    for (i__ = 1; i__ <= i__1; ++i__) {
	if (i__ == imin) {
	    goto L30;
	}
	if (iwksp[i__] < nc1) {
	    nc1 = iwksp[i__];
	}
L30:
	;
    }
    iwksp[imin] = nc1 + 1;
    i__1 = nc1;
    for (j = ibeg; j <= i__1; ++j) {
/* L45: */
	x[j] -= *omega * t[j - 1 + imin * t_dim1] * x[j - 1] / d__[j - 1];
    }
    goto L20;

/* ... far diagonals  (do vector computations). */

L50:
    iwksp[imin] += ndel;
/* Computing MIN */
    i__1 = ibeg + ndel - 1;
    iend = min(i__1,n);
    i__1 = iend;
    for (i__ = ibeg; i__ <= i__1; ++i__) {
/* L65: */
	x[i__] -= *omega * t[i__ - ndel + imin * t_dim1] * x[i__ - ndel] /
		d__[i__ - ndel];
    }
    goto L20;

/* ... rowwise algorithm. */

L70:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = maxt;
	for (j = 1; j <= i__2; ++j) {
/* L75: */
/* Computing MIN */
	    i__3 = n, i__4 = i__ + jt[j];
	    iwksp[j] = min(i__3,i__4);
	}
	term = *omega * x[i__] / d__[i__];
	i__3 = maxt;
	for (j = 1; j <= i__3; ++j) {
/* L80: */
	    x[iwksp[j]] -= t[i__ + j * t_dim1] * term;
	}
/* L85: */
    }
    return 0;
} /* srfst_ */

/* Subroutine */ int srbsp_(integer *ndim, integer *nn, integer *maxt,
	integer *jt, doublereal *d__, doublereal *t, doublereal *omega,
	doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1;

    /* Local variables */
    static integer i__, j, n;
    static doublereal sum;


/* ... srbsp does an sor backward solve (natural ordering, */
/*     purdue storage). */
/*        ((1/omega)*d + t)*x = y */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the matrix */
/*        omega  relaxation factor */
/*        x      on input, x contains y */
/*               on output, x is the solution to backward-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndim;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --x;

    /* Function Body */
    n = *nn;
    if (*maxt >= 1) {
	goto L15;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = *omega * x[i__] / d__[i__];
    }
    return 0;
L15:
    for (i__ = n; i__ >= 1; --i__) {
	sum = x[i__];
	i__1 = *maxt;
	for (j = 1; j <= i__1; ++j) {
	    sum -= t[i__ + j * t_dim1] * x[jt[i__ + j * jt_dim1]];
/* L25: */
	}
	x[i__] = *omega * sum / d__[i__];
/* L30: */
    }
    return 0;
} /* srbsp_ */

/* Subroutine */ int srbstp_(integer *ndim, integer *nn, integer *maxb,
	integer *jb, doublereal *d__, doublereal *b, doublereal *omega,
	doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, jb_dim1, jb_offset, i__1;

    /* Local variables */
    static integer i__, j, n;
    static doublereal term;


/* ... srbstp does an sor transpose back solve */
/*     (natural ordering, purdue storage). */
/*        ((1/omega)*d + (b**t))*x = y */

/* ... parameters -- */

/*        ndim   row dimension of b array */
/*        n      order of system */
/*        maxb   number of columns in b array */
/*        jb     integer array giving the column numbers of the */
/*                corresponding elements in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        b      array of active size n by maxb giving the lower */
/*                triangle of the matrix */
/*        omega  over-relaxation factor */
/*        x      on input, x contains y */
/*        x      on output, x is the solution to back-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    jb_dim1 = *ndim;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    --d__;
    --x;

    /* Function Body */
    n = *nn;
    if (*maxb >= 1) {
	goto L15;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = *omega * x[i__] / d__[i__];
    }
    return 0;
L15:
    for (i__ = n; i__ >= 1; --i__) {
	x[i__] = *omega * x[i__] / d__[i__];
	term = x[i__];
	i__1 = *maxb;
	for (j = 1; j <= i__1; ++j) {
	    x[jb[i__ + j * jb_dim1]] -= b[i__ + j * b_dim1] * term;
/* L25: */
	}
/* L30: */
    }
    return 0;
} /* srbstp_ */

/* Subroutine */ int srfsp_(integer *ndim, integer *nn, integer *maxb,
	integer *jb, doublereal *d__, doublereal *b, doublereal *omega,
	doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, jb_dim1, jb_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, n;
    static doublereal sum;


/* ... srfsp does an sor forward solve (natural ordering, */
/*     purdue storage). */
/*        ((1/omega)*d + b)*x = y */

/* ... parameters -- */

/*        ndim   row dimension of b array */
/*        n      order of system */
/*        maxb   number of columns in b array */
/*        jb     integer array giving the column numbers of the */
/*                corresponding elements in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        b      array of active size n by maxb giving the lower */
/*                triangle of the matrix */
/*        omega  relaxation factor */
/*        x      on input, x contains y */
/*               on output, x is the solution to forward-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    jb_dim1 = *ndim;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    --d__;
    --x;

    /* Function Body */
    n = *nn;
    if (*maxb >= 1) {
	goto L15;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = *omega * x[i__] / d__[i__];
    }
    return 0;
L15:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	sum = x[i__];
	i__2 = *maxb;
	for (j = 1; j <= i__2; ++j) {
	    sum -= b[i__ + j * b_dim1] * x[jb[i__ + j * jb_dim1]];
/* L25: */
	}
	x[i__] = *omega * sum / d__[i__];
/* L30: */
    }
    return 0;
} /* srfsp_ */

/* Subroutine */ int srfstp_(integer *ndim, integer *n, integer *maxt,
	integer *jt, doublereal *d__, doublereal *t, doublereal *omega,
	doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j;
    static doublereal term;


/* ... srfstp does an sor transpose forward solve */
/*     (natural ordering, purdue storage). */
/*        ((1/omega)*d + (t**t))*x = y */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the matrix */
/*        omega  over-relaxation factor */
/*        x      on input, x contains y */
/*               on output, x is the solution to forward-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndim;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --x;

    /* Function Body */
    if (*maxt >= 1) {
	goto L15;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = *omega * x[i__] / d__[i__];
    }
    return 0;
L15:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	x[i__] = *omega * x[i__] / d__[i__];
	term = x[i__];
	i__2 = *maxt;
	for (j = 1; j <= i__2; ++j) {
	    x[jt[i__ + j * jt_dim1]] -= t[i__ + j * t_dim1] * term;
/* L25: */
	}
/* L30: */
    }
    return 0;
} /* srfstp_ */

/* Subroutine */ int srs_(integer *ndim, integer *nn, integer *maxtt, integer
	*jt, doublereal *d__, doublereal *t, doublereal *omega, integer *
	irwise, integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal fac;
    static integer maxt;
    extern /* Subroutine */ int srbs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *), srfst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... srs does an ssor solution (natural ordering, */
/*     symmetric diagonal storage). */

/*        con*(i + w*(t**t)*inv(d))*d*(i + w*inv(d)*t)*x = y */
/*         con = 1/(w*(2-w))   and  w = omega */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */



    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    fac = *omega * (2. - *omega);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfst_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], omega, irwise, &
	    iwksp[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * x[i__] / d__[i__];
    }
    srbs_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], omega, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* srs_ */

/* Subroutine */ int srs1_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, doublereal *omega,
	integer *irwise, integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal fac;
    static integer maxt;
    extern /* Subroutine */ int srfst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... srs1 does an ssor forward solve (natural ordering, */
/*     symmetric diagonal storage). */

/*        con*(i + w*(t**t)*inv(d))*d*x = y */
/*         con = 1/(w*(2-w))   and  w = omega */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */



    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    fac = *omega * (2. - *omega);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfst_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], omega, irwise, &
	    iwksp[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * x[i__] / d__[i__];
    }
    return 0;
} /* srs1_ */

/* Subroutine */ int srs2_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, doublereal *omega,
	integer *irwise, integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, n, maxt;
    extern /* Subroutine */ int srbs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... srs2 does an ssor back solve (natural ordering, */
/*     symmetric diagonal storage). */

/*        (i + w*inv(d)*t)*x = y */
/*            w = omega */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */



    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srbs_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], omega, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* srs2_ */

/* Subroutine */ int srs3_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, doublereal *omega,
	integer *irwise, integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal fac;
    static integer maxt;
    extern /* Subroutine */ int srbs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... srs3 does an ssor transpose forward solve (natural ordering, */
/*     symmetric diagonal storage). */

/*        con*d*(i + w*inv(d)*t)*x = y */
/*         con = 1/(w*(2-w))   and  w = omega */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */



    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    fac = *omega * (2. - *omega);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = fac * y[i__] / d__[i__];
    }
    srbs_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], omega, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* srs3_ */

/* Subroutine */ int srs4_(integer *ndim, integer *nn, integer *maxtt,
	integer *jt, doublereal *d__, doublereal *t, doublereal *omega,
	integer *irwise, integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, n, maxt;
    extern /* Subroutine */ int srfst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... srs4 does an ssor transpose back solve (natural ordering, */
/*     symmetric diagonal storage). */

/*        (i + w*(t**t)*inv(d))*x = y */
/*            w = omega */

/* ... parameters -- */

/*        ndim   row dimension of t array */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */



    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfst_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], omega, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* srs4_ */

/* Subroutine */ int srsn_(integer *ndim, integer *nn, integer *maxtt,
	integer *maxbb, integer *jt, integer *jb, doublereal *d__, doublereal
	*t, doublereal *b, doublereal *omega, integer *irwise, integer *iwksp,
	 doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal fac;
    static integer maxb, maxt;
    extern /* Subroutine */ int srbs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *), srfs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... srsn does an ssor solution (natural ordering, */
/*     nonsymmetric diagonal storage). */

/*        con*(i + w*b*inv(d))*d*(i + w*inv(d)*t)*x = y */
/*         where  con = 1/(w*(2-w))  and  w = omega */

/* ... parameters -- */

/*        ndim   row dimension of t and b arrays */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        maxb   number of columns in b array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        jb     integer vector of length maxb giving the diagonal */
/*                indices of the corresponding columns in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the matrix */
/*        b      array of active size n by maxb giving the sub- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */



    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --jb;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    maxb = *maxbb;
    fac = *omega * (2. - *omega);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfs_(ndim, &n, &maxb, &jb[1], &d__[1], &b[b_offset], omega, irwise, &
	    iwksp[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * x[i__] / d__[i__];
    }
    srbs_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], omega, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* srsn_ */

/* Subroutine */ int srsnt_(integer *ndim, integer *nn, integer *maxtt,
	integer *maxbb, integer *jt, integer *jb, doublereal *d__, doublereal
	*t, doublereal *b, doublereal *omega, integer *irwise, integer *iwksp,
	 doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal fac;
    static integer maxb, maxt;
    extern /* Subroutine */ int srbst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *), srfst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... srsnt does a transpose ssor solution (natural ordering, */
/*     nonsymmetric diagonal storage). */

/*       con*(i + w*(t**t)*inv(d))*d*(i + w*inv(d)*(b**t))*x = y */
/*        con = 1/(w*(2-w))  and  w = omega */

/* ... parameters -- */

/*        ndim   row dimension of t and b arrays */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        maxb   number of columns in b array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        jb     integer vector of length maxb giving the diagonal */
/*                indices of the corresponding columns in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the matrix */
/*        b      array of active size n by maxb giving the sub- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */



    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --jb;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    maxb = *maxbb;
    fac = *omega * (2. - *omega);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfst_(ndim, &n, &maxt, &jt[1], &d__[1], &t[t_offset], omega, irwise, &
	    iwksp[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * x[i__] / d__[i__];
    }
    srbst_(ndim, &n, &maxb, &jb[1], &d__[1], &b[b_offset], omega, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* srsnt_ */

/* Subroutine */ int srsn1_(integer *ndim, integer *n, integer *maxb, integer
	*jb, doublereal *d__, doublereal *b, doublereal *omega, integer *
	irwise, integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1;

    /* Local variables */
    static integer i__;
    static doublereal fac;
    extern /* Subroutine */ int srfs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... srsn1 does an ssor forward pass (natural ordering, */
/*     nonsymmetric diagonal storage). */

/*        con*(i + w*b*inv(d))*d*(i + w*inv(d)*t)*x = y */
/*         where  con = 1/(w*(2-w))  and  w = omega */

/* ... parameters -- */

/*        ndim   row dimension of t and b arrays */
/*        n      order of system (= nn) */
/*        maxb   number of columns in b array */
/*        jb     integer vector of length maxb giving the diagonal */
/*                indices of the corresponding columns in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        b      array of active size n by maxb giving the sub- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */



    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --jb;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    fac = *omega * (2. - *omega);
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfs_(ndim, n, maxb, &jb[1], &d__[1], &b[b_offset], omega, irwise, &iwksp[
	    1], &x[1]);
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * x[i__] / d__[i__];
    }
    return 0;
} /* srsn1_ */

/* Subroutine */ int srsn2_(integer *ndim, integer *n, integer *maxt, integer
	*jt, doublereal *d__, doublereal *t, doublereal *omega, integer *
	irwise, integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int srbs_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... srsn2 does an ssor backward pass (natural ordering, */
/*     nonsymmetric diagonal storage). */

/*        con*(i + w*b*inv(d))*d*(i + w*inv(d)*t)*x = y */
/*         where  con = 1/(w*(2-w))  and  w = omega */

/* ... parameters -- */

/*        ndim   row dimension of t and b arrays */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srbs_(ndim, n, maxt, &jt[1], &d__[1], &t[t_offset], omega, irwise, &iwksp[
	    1], &x[1]);
    return 0;
} /* srsn2_ */

/* Subroutine */ int srsn3_(integer *ndim, integer *n, integer *maxb, integer
	*jb, doublereal *d__, doublereal *b, doublereal *omega, integer *
	irwise, integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, i__1;

    /* Local variables */
    static integer i__;
    static doublereal fac;
    extern /* Subroutine */ int srbst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... srsn3 does a transpose ssor back pass (natural ordering, */
/*     nonsymmetric diagonal storage). */

/*       con*(i + w*(t**t)*inv(d))*d*(i + w*inv(d)*(b**t))*x = y */
/*        con = 1/(w*(2-w))  and  w = omega */

/* ... parameters -- */

/*        ndim   row dimension of t and b arrays */
/*        n      order of system (= nn) */
/*        maxb   number of columns in b array */
/*        jb     integer vector of length maxb giving the diagonal */
/*                indices of the corresponding columns in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        b      array of active size n by maxb giving the sub- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */



    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    --jb;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    fac = *omega * (2. - *omega);
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * y[i__] / d__[i__];
    }
    srbst_(ndim, n, maxb, &jb[1], &d__[1], &b[b_offset], omega, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* srsn3_ */

/* Subroutine */ int srsn4_(integer *ndim, integer *n, integer *maxt, integer
	*jt, doublereal *d__, doublereal *t, doublereal *omega, integer *
	irwise, integer *iwksp, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int srfst_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, integer *,
	    integer *, doublereal *);


/* ... srsn4 does a transpose ssor forward pass (natural ordering, */
/*     nonsymmetric diagonal storage). */

/*       con*(i + w*(t**t)*inv(d))*d*(i + w*inv(d)*(b**t))*x = y */
/*        con = 1/(w*(2-w))  and  w = omega */

/* ... parameters -- */

/*        ndim   row dimension of t and b arrays */
/*        n      order of system (= nn) */
/*        maxt   number of columns in t array */
/*        jt     integer vector of length maxt giving the diagonal */
/*                indices of the corresponding columns in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the super- */
/*                diagonals of the matrix */
/*        omega  over-relaxation factor */
/*        irwise rowwise algorithm switch */
/*                = 0  use diagonal algorithm */
/*                = 1  use row-wise algorithm */
/*        iwksp  integer workspace of length maxt */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --iwksp;
    --y;
    --x;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfst_(ndim, n, maxt, &jt[1], &d__[1], &t[t_offset], omega, irwise, &
	    iwksp[1], &x[1]);
    return 0;
} /* srsn4_ */

/* Subroutine */ int srsp_(integer *ndim, integer *nn, integer *maxtt,
	integer *maxbb, integer *jt, integer *jb, doublereal *d__, doublereal
	*t, doublereal *b, doublereal *omega, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, jt_dim1, jt_offset, jb_dim1,
	    jb_offset, i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal fac;
    static integer maxb, maxt;
    extern /* Subroutine */ int srbsp_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    , srfsp_(integer *, integer *, integer *, integer *, doublereal *,
	     doublereal *, doublereal *, doublereal *);


/* ... srsp does an ssor solution (natural ordering, */
/*     purdue storage). */
/*        con*((1/w)*d + b)*inv(d)*((1/w)*d + t)*x = y */
/*        where con = w/(2-w) and w = omega */

/* ... parameters -- */

/*        ndim   row dimension of t,b arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        maxb   number of columns in b array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        jb     integer array giving the column numbers of the */
/*                corresponding elements in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the matrix */
/*        b      array of active size n by maxb giving the lower */
/*                triangle of the matrix */
/*        omega  relaxation factor */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */



    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jb_dim1 = *ndim;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    jt_dim1 = *ndim;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    maxb = *maxbb;
    fac = (2. - *omega) / *omega;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfsp_(ndim, &n, &maxb, &jb[jb_offset], &d__[1], &b[b_offset], omega, &x[
	    1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * d__[i__] * x[i__];
    }
    srbsp_(ndim, &n, &maxt, &jt[jt_offset], &d__[1], &t[t_offset], omega, &x[
	    1]);
    return 0;
} /* srsp_ */

/* Subroutine */ int srsp1_(integer *ndim, integer *n, integer *maxb, integer
	*jb, doublereal *d__, doublereal *b, doublereal *omega, doublereal *y,
	 doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, jb_dim1, jb_offset, i__1;

    /* Local variables */
    static integer i__;
    static doublereal fac;
    extern /* Subroutine */ int srfsp_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... srsp1 does an ssor forward solve (natural ordering, */
/*     purdue storage). */

/* ... parameters -- */

/*        ndim   row dimension of t,b arrays */
/*        n      order of system */
/*        maxb   number of columns in b array */
/*        jb     integer array giving the column numbers of the */
/*                corresponding elements in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        b      array of active size n by maxb giving the lower */
/*                triangle of the matrix */
/*        omega  relaxation factor */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */



    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    jb_dim1 = *ndim;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    fac = (2. - *omega) / *omega;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfsp_(ndim, n, maxb, &jb[jb_offset], &d__[1], &b[b_offset], omega, &x[1])
	    ;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * d__[i__] * x[i__];
    }
    return 0;
} /* srsp1_ */

/* Subroutine */ int srsp2_(integer *ndim, integer *n, integer *maxt, integer
	*jt, doublereal *d__, doublereal *t, doublereal *omega, doublereal *y,
	 doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int srbsp_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... srsp2 does an ssor back solve (natural ordering, */
/*     purdue storage). */

/* ... parameters -- */

/*        ndim   row dimension of t,b arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the matrix */
/*        omega  relaxation factor */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndim;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srbsp_(ndim, n, maxt, &jt[jt_offset], &d__[1], &t[t_offset], omega, &x[1])
	    ;
    return 0;
} /* srsp2_ */

/* Subroutine */ int srsp3_(integer *ndim, integer *n, integer *maxb, integer
	*jb, doublereal *d__, doublereal *b, doublereal *omega, doublereal *y,
	 doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, jb_dim1, jb_offset, i__1;

    /* Local variables */
    static integer i__;
    static doublereal fac;
    extern /* Subroutine */ int srbstp_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... srsp3 does an ssor transpose back solve (natural ordering, */
/*     purdue storage). */

/* ... parameters -- */

/*        ndim   row dimension of t,b arrays */
/*        n      order of system */
/*        maxb   number of columns in b array */
/*        jb     integer array giving the column numbers of the */
/*                corresponding elements in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        b      array of active size n by maxb giving the lower */
/*                triangle of the matrix */
/*        omega  relaxation factor */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */



    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    jb_dim1 = *ndim;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    fac = (2. - *omega) / *omega;
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * d__[i__] * y[i__];
    }
    srbstp_(ndim, n, maxb, &jb[jb_offset], &d__[1], &b[b_offset], omega, &x[1]
	    );
    return 0;
} /* srsp3_ */

/* Subroutine */ int srsp4_(integer *ndim, integer *n, integer *maxt, integer
	*jt, doublereal *d__, doublereal *t, doublereal *omega, doublereal *y,
	 doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, jt_dim1, jt_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int srfstp_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    ;


/* ... srsp4 does an ssor transpose forward solve (natural ordering, */
/*     purdue storage). */

/* ... parameters -- */

/*        ndim   row dimension of t,b arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the matrix */
/*        omega  relaxation factor */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndim;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfstp_(ndim, n, maxt, &jt[jt_offset], &d__[1], &t[t_offset], omega, &x[1]
	    );
    return 0;
} /* srsp4_ */

/* Subroutine */ int srsntp_(integer *ndim, integer *nn, integer *maxtt,
	integer *maxbb, integer *jt, integer *jb, doublereal *d__, doublereal
	*t, doublereal *b, doublereal *omega, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, jt_dim1, jt_offset, jb_dim1,
	    jb_offset, i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal fac;
    static integer maxb, maxt;
    extern /* Subroutine */ int srbstp_(integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *, doublereal *)
	    , srfstp_(integer *, integer *, integer *, integer *, doublereal *
	    , doublereal *, doublereal *, doublereal *);


/* ... srsntp does an ssor transpose solution (natural ordering, */
/*     purdue storage). */
/*        con*((1/w)*d + (t**t))*inv(d)*((1/w)*d + (b**t))*x = y */
/*        where con = w/(2-w) and w = omega */

/* ... parameters -- */

/*        ndim   row dimension of t,b arrays */
/*        n      order of system */
/*        maxt   number of columns in t array */
/*        maxb   number of columns in b array */
/*        jt     integer array giving the column numbers of the */
/*                corresponding elements in t */
/*        jb     integer array giving the column numbers of the */
/*                corresponding elements in b */
/*        d      vector of length n giving the diagonal elements */
/*                of the matrix */
/*        t      array of active size n by maxt giving the upper */
/*                triangle of the matrix */
/*        b      array of active size n by maxb giving the lower */
/*                triangle of the matrix */
/*        omega  relaxation factor */
/*        y      right-hand-side vector */
/*        x      on output, x is the solution */

/* ... specifications for parameters */



    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jb_dim1 = *ndim;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    jt_dim1 = *ndim;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    maxt = *maxtt;
    maxb = *maxbb;
    fac = (2. - *omega) / *omega;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfstp_(ndim, &n, &maxt, &jt[jt_offset], &d__[1], &t[t_offset], omega, &x[
	    1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * d__[i__] * x[i__];
    }
    srbstp_(ndim, &n, &maxb, &jb[jb_offset], &d__[1], &b[b_offset], omega, &x[
	    1]);
    return 0;
} /* srsntp_ */

/* Subroutine */ int ssorad_(S_fp ssorcp, doublereal *coef, integer *jcoef,
	doublereal *wfac, integer *jwfac, integer *n, doublereal *p,
	doublereal *z__, doublereal *r__, integer *icode)
{
    /* Format strings */
    static char fmt_10[] = "(/1x,15x,\002parameters were changed at iterat"
	    "ion\002,i7/1x,20x,\002alphab             \002,f15.9/1x,20x,\002b"
	    "etab              \002,f15.9/1x,20x,\002omega              \002,"
	    "f15.9/)";

    /* System generated locals */
    doublereal d__1, d__2;

    /* Builtin functions */
    double sqrt(doublereal), log(doublereal);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static doublereal tmo;
    extern doublereal vdot_(integer *, doublereal *, doublereal *);
    static doublereal omegab;
    extern /* Subroutine */ int omgchg_(S_fp, doublereal *, integer *,
	    doublereal *, integer *, integer *, doublereal *, doublereal *);

    /* Fortran I/O blocks */
    static cilist io___3214 = { 0, 0, 0, fmt_10, 0 };



/* ... ssorad does the ssor adaptive process. */

/* ... parameters -- */

/*         n       order of system */
/*         p,z,r   vectors from acceleration algorithm */
/*         icode   key for restarting iteration */
/*                  = 0    omega unchanged (no restart) */
/*                  = 1    new omega       (restart needed) */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */


/* ------------------------------------------------------------------ */
/*  parameter estimation formulas */
/* ------------------------------------------------------------------ */






/* ------------------------------------------------------------------ */

    /* Parameter adjustments */
    --r__;
    --z__;
    --p;
    --jwfac;
    --wfac;
    --jcoef;
    --coef;

    /* Function Body */
    *icode = 0;
    if (itcom1_1.is >= 6 && ! itcom2_1.minadp) {
	goto L5;
    }
    tmo = 2. - itcom5_1.omega;
    if (itcom3_1.emin < tmo) {
/* Computing MIN */
	d__1 = itcom5_1.alphab, d__2 = ((1. + itcom5_1.betab * itcom5_1.omega
		* itcom5_1.omega) * itcom3_1.emin - itcom5_1.omega * (2. -
		itcom5_1.omega)) / (itcom5_1.omega * (2. - itcom5_1.omega -
		itcom3_1.emin));
	itcom5_1.alphab = min(d__1,d__2);
    }
L5:
    if (! itcom5_1.omgadp || ! itcom2_1.minadp || itcom1_1.is <= 5) {
	return 0;
    }
/* Computing MAX */
    d__1 = 1., d__2 = 2. / (1. + sqrt(1. + 2. * itcom5_1.alphab + 4. *
	    itcom5_1.betab));
    omegab = max(d__1,d__2);
    if (log((sqrt(1. / ((1. + itcom5_1.alphab) * itcom5_1.omega * (2. -
	    itcom5_1.omega) / (1. + itcom5_1.alphab * itcom5_1.omega +
	    itcom5_1.betab * itcom5_1.omega * itcom5_1.omega))) + 1.) / (sqrt(
	    1. / ((1. + itcom5_1.alphab) * itcom5_1.omega * (2. -
	    itcom5_1.omega) / (1. + itcom5_1.alphab * itcom5_1.omega +
	    itcom5_1.betab * itcom5_1.omega * itcom5_1.omega))) - 1.)) >
	    itcom5_1.fff * log((sqrt(1. / ((1. + itcom5_1.alphab) * omegab * (
	    2. - omegab) / (1. + itcom5_1.alphab * omegab + itcom5_1.betab *
	    omegab * omegab))) + 1.) / (sqrt(1. / ((1. + itcom5_1.alphab) *
	    omegab * (2. - omegab) / (1. + itcom5_1.alphab * omegab +
	    itcom5_1.betab * omegab * omegab))) - 1.))) {
	return 0;
    }
    if (itcom1_1.iacel == 2) {
	itcom3_1.pap = vdot_(n, &p[1], &z__[1]);
    }
    omgchg_((S_fp)ssorcp, &coef[1], &jcoef[1], &wfac[1], &jwfac[1], n, &p[1],
	    &r__[1]);
/* Computing MAX */
    d__1 = 1., d__2 = 2. / (1. + sqrt(1. + 2. * itcom5_1.alphab + 4. *
	    itcom5_1.betab));
    itcom5_1.omega = max(d__1,d__2);
    *icode = 1;
    if (itcom1_1.level >= 2) {
	io___3214.ciunit = itcom1_1.nout;
	s_wsfe(&io___3214);
	do_fio(&c__1, (char *)&itcom1_1.in, (ftnlen)sizeof(integer));
	do_fio(&c__1, (char *)&itcom5_1.alphab, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&itcom5_1.betab, (ftnlen)sizeof(doublereal));
	do_fio(&c__1, (char *)&itcom5_1.omega, (ftnlen)sizeof(doublereal));
	e_wsfe();
    }
    return 0;
} /* ssorad_ */

/* Subroutine */ int ssord_(integer *ndim, integer *maxt, integer *jt,
	doublereal *d__, doublereal *t, integer *nn, doublereal *p,
	doublereal *r__, doublereal *pdp, doublereal *pldup)
{
    /* System generated locals */
    integer t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal sum;
    extern /* Subroutine */ int vaddd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);


/* ... ssord computes  pdp = (p,d*p)  and */
/*                     pldup = (p,l*inv(d)*u*p) */

/*     for symmetric diagonal storage format. */

/* ... parameters -- */

/*         ndim    row dimension of coef array in defining routine */
/*         maxt    number of diagonals in t */
/*         jt      diagonal numbers for upper triangular part */
/*         d       diagonal */
/*         t       upper triangular diagonals */
/*         n       order of system */
/*         p       vector from acceleration algorithm */
/*         r       workspace vector from acceleration algorithm */
/*         pdp     (p,d*p) */
/*         pldup   (p,l*d*u*p) */

/* ... specifications for parameters */


/* ... compute pdp = (p,d*p). */

    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --d__;
    --p;
    --r__;

    /* Function Body */
    n = *nn;
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	sum += p[i__] * d__[i__] * p[i__];
    }
    *pdp = sum;

/* ... compute pldup = (p,l*inv(d)*u*p) = (u*p,inv(d)*u*p) */

    *pldup = 0.;
    if (*maxt <= 0) {
	return 0;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	r__[i__] = 0.;
    }
    vaddd_(ndim, &c__1, &n, &n, maxt, &t[t_offset], &jt[1], &r__[1], &p[1], &
	    c__0);
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	sum += r__[i__] * r__[i__] / d__[i__];
    }
    *pldup = sum;
    return 0;
} /* ssord_ */

/* Subroutine */ int ssordn_(integer *ndim, integer *maxt, integer *maxb,
	integer *jt, integer *jb, doublereal *d__, doublereal *t, doublereal *
	b, integer *nn, doublereal *p, doublereal *r__, doublereal *wksp,
	doublereal *pdp, doublereal *pldup)
{
    /* System generated locals */
    integer t_dim1, t_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal sum;
    extern /* Subroutine */ int vaddd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *);


/* ... ssordn computes  pdp = (p,d*p)  and */
/*                      pldup = (p,l*inv(d)*u*p) */

/*     for nonsymmetric diagonal storage format. */

/* ... parameters -- */

/*         ndim    row dimension of coef array in defining routine */
/*         maxt    number of diagonals in t */
/*         maxb    number of diagonals in b */
/*         jt      diagonal numbers for upper triangular part */
/*         jb      diagonal numbers for lower triangular part */
/*         d       diagonal */
/*         t       upper triangular diagonals */
/*         b       lower triangular diagonals */
/*         n       order of system */
/*         p       vector from acceleration algorithm */
/*         r       workspace vector from acceleration algorithm */
/*         wksp    workspace vector of length n */
/*         pdp     (p,d*p) */
/*         pldup   (p,l*d*u*p) */

/* ... specifications for parameters */


/* ... compute pdp = (p,d*p). */

    /* Parameter adjustments */
    b_dim1 = *ndim;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    --jt;
    --jb;
    --d__;
    --p;
    --r__;
    --wksp;

    /* Function Body */
    n = *nn;
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	sum += p[i__] * d__[i__] * p[i__];
    }
    *pdp = sum;

/* ... compute pldup = (p,l*inv(d)*u*p) */

    *pldup = 0.;
    if (*maxt <= 0 || *maxb <= 0) {
	return 0;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	r__[i__] = 0.;
    }
    vaddd_(ndim, &c__1, &n, &n, maxt, &t[t_offset], &jt[1], &r__[1], &p[1], &
	    c__0);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	r__[i__] /= d__[i__];
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	wksp[i__] = 0.;
    }
    vaddd_(ndim, &c__1, &n, &n, maxb, &b[b_offset], &jb[1], &wksp[1], &r__[1],
	     &c__0);
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	sum += p[i__] * wksp[i__];
    }
    *pldup = sum;
    return 0;
} /* ssordn_ */

/* Subroutine */ int ssorp_(integer *ndim, integer *maxt, integer *jt,
	doublereal *d__, doublereal *t, integer *nn, doublereal *p,
	doublereal *r__, doublereal *wksp, doublereal *pdp, doublereal *pldup)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal sum;
    extern /* Subroutine */ int vaddp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... ssorp computes  pdp = (p,d*p)  and */
/*                     pldup = (p,l*inv(d)*u*p) */

/*     for symmetric purdue storage format. */

/* ... parameters -- */

/*         ndim    row dimension of coef array in defining routine */
/*         maxt    number of columns in t */
/*         jt      column numbers for upper triangular part */
/*         d       diagonal */
/*         t       upper triangular part of a */
/*         n       order of system */
/*         p       vector from acceleration algorithm */
/*         r       workspace vector from acceleration algorithm */
/*         wksp    workspace vector of length n */
/*                  (keygs = 1 only) */
/*         pdp     (p,d*p) */
/*         pldup   (p,l*d*u*p) */

/* ... specifications for parameters */


/* ... compute pdp = (p,d*p). */

    /* Parameter adjustments */
    t_dim1 = *ndim;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jt_dim1 = *ndim;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --p;
    --r__;
    --wksp;

    /* Function Body */
    n = *nn;
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	sum += p[i__] * d__[i__] * p[i__];
    }
    *pdp = sum;

/* ... compute pldup = (p,l*inv(d)*u*p) = (u*p,inv(d)*u*p) */

    *pldup = 0.;
    if (*maxt <= 0) {
	return 0;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	r__[i__] = 0.;
    }
    vaddp_(ndim, ndim, &n, maxt, &t[t_offset], &jt[jt_offset], &r__[1], &p[1],
	     &wksp[1]);
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	sum += r__[i__] * r__[i__] / d__[i__];
    }
    *pldup = sum;
    return 0;
} /* ssorp_ */

/* Subroutine */ int ssorpn_(integer *ndimm, integer *maxt, integer *maxb,
	integer *jt, integer *jb, doublereal *d__, doublereal *t, doublereal *
	b, integer *nn, doublereal *p, doublereal *r__, doublereal *wksp,
	doublereal *pdp, doublereal *pldup)
{
    /* System generated locals */
    integer jt_dim1, jt_offset, jb_dim1, jb_offset, t_dim1, t_offset, b_dim1,
	    b_offset, i__1;

    /* Local variables */
    static integer i__, n, np1;
    static doublereal sum;
    static integer ndim;
    extern /* Subroutine */ int vaddp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... ssorpn computes  pdp = (p,d*p)  and */
/*                      pldup = (p,l*inv(d)*u*p) */

/*     for nonsymmetric purdue storage format. */

/* ... parameters -- */

/*         ndim    row dimension of coef array in defining routine */
/*         maxt    number of columns in t */
/*         maxb    number of columns in b */
/*         jt      column numbers for upper triangular part */
/*         jb      column numbers for lower triangular part */
/*         d       diagonal */
/*         t       upper triangular part */
/*         b       lower triangular part */
/*         n       order of system */
/*         p       vector from acceleration algorithm */
/*         r       workspace vector from acceleration algorithm */
/*         wksp    workspace vector of length n */
/*                  2*n if keygs = 1 */
/*         pdp     (p,d*p) */
/*         pldup   (p,l*d*u*p) */

/* ... specifications for parameters */


/* ... compute pdp = (p,d*p). */

    /* Parameter adjustments */
    b_dim1 = *ndimm;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *ndimm;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    jb_dim1 = *ndimm;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    jt_dim1 = *ndimm;
    jt_offset = 1 + jt_dim1;
    jt -= jt_offset;
    --d__;
    --p;
    --r__;
    --wksp;

    /* Function Body */
    n = *nn;
    ndim = *ndimm;
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	sum += p[i__] * d__[i__] * p[i__];
    }
    *pdp = sum;

/* ... compute pldup = (p,l*inv(d)*u*p) */

    *pldup = 0.;
    if (*maxt <= 0 || *maxb <= 0) {
	return 0;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	r__[i__] = 0.;
    }
    vaddp_(&ndim, &ndim, &n, maxt, &t[t_offset], &jt[jt_offset], &r__[1], &p[
	    1], &wksp[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	r__[i__] /= d__[i__];
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	wksp[i__] = 0.;
    }
    np1 = n + 1;
    vaddp_(&ndim, &ndim, &n, maxb, &b[b_offset], &jb[jb_offset], &wksp[1], &
	    r__[1], &wksp[np1]);
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	sum += p[i__] * wksp[i__];
    }
    *pldup = sum;
    return 0;
} /* ssorpn_ */

/* Subroutine */ int ssrcd_(integer *ldf, integer *ndim, integer *maxnz,
	integer *nsize, integer *iblock, doublereal *dfac, doublereal *coef,
	integer *jcoef, integer *nn, doublereal *p, doublereal *r__,
	doublereal *wksp, doublereal *pdp, doublereal *pldup)
{
    /* System generated locals */
    integer dfac_dim1, dfac_offset, coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, n, nt;
    static doublereal sum;
    static integer jbgn;
    extern /* Subroutine */ int bmul_(integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *);
    static integer mdiag;
    extern /* Subroutine */ int vaddd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *), bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *);
    static integer nwdiag;


/* ... ssrcd computes  pdp = (p,d*p)  and */
/*                     pldup = (p,l*inv(d)*u*p) */

/*     for symmetric block diagonal storage format. */

/* ... parameters -- */

/*         ldf      row dimension of dfac */
/*         ndim     row dimension of coef array */
/*         maxnz    number of diagonals stored in coef */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         dfac     array for diagonal block factorization */
/*         coef     array for matrix coefficients */
/*         jcoef    vector for diagonal numbers */
/*         n        size of system */
/*         p        vector from acceleration algorithm */
/*         r        workspace vector from acceleration algorithm */
/*         wksp     workspace vector of length n */
/*         pdp      (p,d*p) */
/*         pldup    (p,l*d*u*p) */

/* ... specifications for parameters */


/* ... compute pdp = (p,d*p). */

    /* Parameter adjustments */
    dfac_dim1 = *ldf;
    dfac_offset = 1 + dfac_dim1;
    dfac -= dfac_offset;
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    iblock -= 4;
    --jcoef;
    --p;
    --r__;
    --wksp;

    /* Function Body */
    n = *nn;
    nwdiag = iblock[6];
    nt = nwdiag - 1;
    bmul_(ndim, &n, &nt, &coef[coef_offset], &coef[(coef_dim1 << 1) + 1], &p[
	    1], &r__[1]);
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	sum += p[i__] * r__[i__];
    }
    *pdp = sum;

/* ... compute pldup = (p,l*inv(d)*u*p) = (u*p,inv(d)*u*p) */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	r__[i__] = 0.;
    }
    jbgn = nwdiag + 1;
    mdiag = *maxnz - nwdiag;
    vaddd_(ndim, &c__1, &n, &n, &mdiag, &coef[jbgn * coef_dim1 + 1], &jcoef[
	    jbgn], &r__[1], &p[1], &c__0);
    bdsol_(ldf, &n, nsize, &nt, &c__0, &dfac[dfac_offset], &r__[1], &wksp[1],
	    &c__0);
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	sum += r__[i__] * wksp[i__];
    }
    *pldup = sum;
    return 0;
} /* ssrcd_ */

/* Subroutine */ int ssrcdm_(integer *ldf, integer *ndim, integer *lbhb,
	integer *nsize, integer *ncol, integer *nci, integer *ipt, integer *
	iblock, doublereal *dfac, doublereal *coef, integer *jcnew, integer *
	nn, doublereal *p, doublereal *r__, doublereal *wksp, doublereal *pdp,
	 doublereal *pldup)
{
    /* System generated locals */
    integer jcnew_dim1, jcnew_offset, iblock_dim2, iblock_offset, dfac_dim1,
	    dfac_offset, coef_dim1, coef_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, k, n, na, mb, nb, ndb, ind, inc, ndt, ist;
    static doublereal sum;
    static integer jcol, jlim, istb, jstb;
    extern /* Subroutine */ int vaddd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *), bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *), bmuln_(integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *);
    static integer nwdiag, ncolor;


/* ... ssrcdm computes  pdp = (p,d*p)  and */
/*                      pldup = (p,l*inv(d)*u*p) */

/*     for nonsymmetric block diagonal storage format. */
/*     (nonconstant block size) */

/* ... parameters -- */

/*         ldf      row dimension of dfac array */
/*         ndim     row dimension of coef array */
/*         lbhb     integer vector of size ncolor giving the number */
/*                   of diagonal blocks for each distinct block size. */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         ncolor   number of distinct block sizes */
/*         nci      integer vector of length ncolor, giving the number */
/*                   of nodes for each distinct block size. */
/*         ipt      integer pointer vector of length ncolor+1 */
/*                   giving the starting locations of new block */
/*                   rows */
/*         iblock   integer array of size 3 by ncolor by max(lbhb(i)) */
/*                   giving block constants */
/*         dfac     array for diagonal block factorization */
/*         coef     array of matrix coefficients */
/*         jcnew    integer array of row dimension ncolor giving the */
/*                   diagonal numbers for each block */
/*         n        size of system */
/*         p        vector from acceleration algorithm */
/*         r        workspace vector from acceleration algorithm */
/*         wksp     workspace vector of length n */
/*         pdp      (p,d*p) */
/*         pldup    (p,l*d*u*p) */

/* ... specifications for parameters */


/* ... define constants ndt, ndb. */

    /* Parameter adjustments */
    dfac_dim1 = *ldf;
    dfac_offset = 1 + dfac_dim1;
    dfac -= dfac_offset;
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --lbhb;
    jcnew_dim1 = *ncol;
    jcnew_offset = 1 + jcnew_dim1;
    jcnew -= jcnew_offset;
    iblock_dim2 = *ncol;
    iblock_offset = 1 + 3 * (1 + iblock_dim2);
    iblock -= iblock_offset;
    --nci;
    --ipt;
    --p;
    --r__;
    --wksp;

    /* Function Body */
    n = *nn;
    ncolor = *ncol;
    ndt = iblock[(iblock_dim2 + 1) * 3 + 3] - 1;
    ndb = iblock[((iblock_dim2 << 1) + 1) * 3 + 3];
    nwdiag = ndt + ndb + 1;

/* ... compute pdp = (p,d*p). */

    ind = ndt + 2;
    bmuln_(ndim, &n, &ndt, &ndb, &coef[coef_offset], &coef[(coef_dim1 << 1) +
	    1], &coef[ind * coef_dim1 + 1], &p[1], &r__[1]);
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	sum += p[i__] * r__[i__];
    }
    *pdp = sum;

/* ... compute pldup = (p,l*inv(d)*u*p) */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	r__[i__] = 0.;
	wksp[i__] = 0.;
/* L15: */
    }
    i__1 = ncolor;
    for (k = 1; k <= i__1; ++k) {
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	i__2 = jlim;
	for (j = 3; j <= i__2; ++j) {
	    jcol = k + iblock[(k + j * iblock_dim2) * 3 + 1];
	    if (jcol <= k) {
		goto L20;
	    }
	    jstb = iblock[(k + j * iblock_dim2) * 3 + 2] + nwdiag;
	    mb = iblock[(k + j * iblock_dim2) * 3 + 3];
	    inc = ipt[jcol] - ipt[k];
	    nb = nci[jcol];
	    istb = ist + inc;
	    vaddd_(ndim, &ncolor, &na, &nb, &mb, &coef[ist + jstb * coef_dim1]
		    , &jcnew[k + jstb * jcnew_dim1], &r__[ist], &p[istb], &
		    inc);
L20:
	    ;
	}
/* L25: */
    }
    bdsol_(ldf, &n, nsize, &ndt, &ndb, &dfac[dfac_offset], &r__[1], &r__[1], &
	    c__1);
    i__1 = ncolor;
    for (k = 1; k <= i__1; ++k) {
	ist = ipt[k] + 1;
	jlim = lbhb[k];
	na = nci[k];
	i__2 = jlim;
	for (j = 3; j <= i__2; ++j) {
	    jcol = k + iblock[(k + j * iblock_dim2) * 3 + 1];
	    if (jcol >= k) {
		goto L30;
	    }
	    jstb = iblock[(k + j * iblock_dim2) * 3 + 2] + nwdiag;
	    mb = iblock[(k + j * iblock_dim2) * 3 + 3];
	    inc = ipt[jcol] - ipt[k];
	    nb = nci[jcol];
	    istb = ist + inc;
	    vaddd_(ndim, &ncolor, &na, &nb, &mb, &coef[ist + jstb * coef_dim1]
		    , &jcnew[k + jstb * jcnew_dim1], &wksp[ist], &r__[istb], &
		    inc);
L30:
	    ;
	}
/* L35: */
    }
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L40: */
	sum += p[i__] * wksp[i__];
    }
    *pldup = sum;
    return 0;
} /* ssrcdm_ */

/* Subroutine */ int ssrcdn_(integer *ldf, integer *ndim, integer *lbhb,
	integer *nsize, integer *iblock, doublereal *dfac, doublereal *coef,
	integer *jcoef, integer *nn, doublereal *p, doublereal *r__,
	doublereal *wksp, doublereal *pdp, doublereal *pldup)
{
    /* System generated locals */
    integer dfac_dim1, dfac_offset, coef_dim1, coef_offset, i__1;

    /* Local variables */
    static integer i__, j, n, nb, nt, ind;
    static doublereal sum;
    static integer indd, maxb, maxt;
    extern /* Subroutine */ int vaddd_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, integer *, doublereal *,
	    doublereal *, integer *), bdsol_(integer *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *,
	    integer *), bmuln_(integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *, doublereal *,
	    doublereal *);


/* ... ssrcdn computes  pdp = (p,d*p)  and */
/*                      pldup = (p,l*inv(d)*u*p) */

/*     for nonsymmetric block diagonal storage format. */
/*     (constant block size) */

/* ... parameters -- */

/*         ldf      row dimension of dfac */
/*         ndim     row dimension of coef array */
/*         lbhb     number of blocks per block row */
/*         nsize    size of an individual subsystem within a */
/*                   diagonal block */
/*         iblock   integer array of size 3 by lbhb */
/*                   giving block constants */
/*         dfac     array for diagonal block factorization */
/*         coef     array for matrix coefficients */
/*         jcoef    vector for diagonal numbers */
/*         n        size of system */
/*         p        vector from acceleration algorithm */
/*         r        workspace vector from acceleration algorithm */
/*         wksp     workspace vector of length n */
/*         pdp      (p,d*p) */
/*         pldup    (p,l*d*u*p) */

/* ... specifications for parameters */


/* ... compute nt, nb, maxt, maxb */

    /* Parameter adjustments */
    dfac_dim1 = *ldf;
    dfac_offset = 1 + dfac_dim1;
    dfac -= dfac_offset;
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    iblock -= 4;
    --jcoef;
    --p;
    --r__;
    --wksp;

    /* Function Body */
    n = *nn;
    nt = iblock[6] - 1;
    nb = iblock[9];
    maxt = 0;
    maxb = 0;
    if (*lbhb < 3) {
	goto L15;
    }
    i__1 = *lbhb;
    for (j = 3; j <= i__1; ++j) {
	ind = iblock[j * 3 + 1];
	if (ind > 0) {
	    maxt += iblock[j * 3 + 3];
	}
	if (ind < 0) {
	    maxb += iblock[j * 3 + 3];
	}
/* L10: */
    }

/* ... compute pdp = (p,d*p). */

L15:
    ind = nt + 2;
    bmuln_(ndim, &n, &nt, &nb, &coef[coef_offset], &coef[(coef_dim1 << 1) + 1]
	    , &coef[ind * coef_dim1 + 1], &p[1], &r__[1]);
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	sum += p[i__] * r__[i__];
    }
    *pdp = sum;

/* ... compute pldup = (p,l*inv(d)*u*p) */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	wksp[i__] = 0.;
	r__[i__] = 0.;
/* L25: */
    }
    ind = nt + nb + 2;
    indd = ind + maxt;
    vaddd_(ndim, &c__1, &n, &n, &maxt, &coef[ind * coef_dim1 + 1], &jcoef[ind]
	    , &r__[1], &p[1], &c__0);
    bdsol_(ldf, &n, nsize, &nt, &nb, &dfac[dfac_offset], &r__[1], &r__[1], &
	    c__1);
    vaddd_(ndim, &c__1, &n, &n, &maxb, &coef[indd * coef_dim1 + 1], &jcoef[
	    indd], &wksp[1], &r__[1], &c__0);
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	sum += p[i__] * wksp[i__];
    }
    *pldup = sum;
    return 0;
} /* ssrcdn_ */

/* Subroutine */ int srbscp_(integer *ndim, integer *n, integer *jc,
	doublereal *d__, doublereal *c__, integer *ncolor, integer *nc,
	integer *nt, doublereal *omega, doublereal *wksp, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__, j2, ied, ist, npt, icol;
    extern /* Subroutine */ int vsubp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... srbscp does a back sor solve. */
/*     (purdue storage, multicolor) */

/*     ((1/w)*d + t)*x = y */

/* ... parameters -- */

/*          ndim   row dimension of c,jc arrays */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          omega  over-relaxation factor */
/*          wksp   workspace vector of length */
/*                  max(nc(i))     if keygs = 1 */
/*                  0              if keygs = 2 */
/*          x      on input, x contains y */
/*                 on output, x is the solution to back-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndim;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndim;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --wksp;
    --x;

    /* Function Body */
    ied = *n;
    for (icol = *ncolor; icol >= 1; --icol) {
	npt = nc[icol];
	ist = ied - npt + 1;
	j2 = nt[icol];
	vsubp_(ndim, ndim, &npt, &j2, &c__[ist + c_dim1], &jc[ist + jc_dim1],
		&x[ist], &x[1], &wksp[1]);
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L15: */
	    x[i__] = *omega * x[i__] / d__[i__];
	}
	ied -= npt;
/* L20: */
    }
    return 0;
} /* srbscp_ */

/* Subroutine */ int srbsct_(integer *ndim, integer *n, integer *jc,
	doublereal *d__, doublereal *c__, integer *ncolor, integer *nc,
	integer *nt, integer *nb, doublereal *omega, doublereal *wksp,
	doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__, j1, mj, ied, ist, npt, icol;
    extern /* Subroutine */ int vsubpt_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... srbsct does a transpose back sor solve. */
/*     (purdue storage, multicolor) */

/*     ((1/w)*d + (b**t))*x = y */

/* ... parameters -- */

/*          ndim   row dimension of c,jc arrays */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          omega  over-relaxation factor */
/*          wksp   workspace vector of length max(nc(i)) */
/*          x      on input, x contains y */
/*                 on output, x is the solution to back-solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndim;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndim;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --wksp;
    --x;

    /* Function Body */
    ied = *n;
    for (icol = *ncolor; icol >= 1; --icol) {
	npt = nc[icol];
	ist = ied - npt + 1;
	i__1 = ied;
	for (i__ = ist; i__ <= i__1; ++i__) {
/* L15: */
	    x[i__] = *omega * x[i__] / d__[i__];
	}
	j1 = nt[icol] + 1;
	mj = nb[icol];
	vsubpt_(ndim, ndim, &npt, &mj, &c__[ist + j1 * c_dim1], &jc[ist + j1 *
		 jc_dim1], &x[1], &x[ist], &wksp[1]);
	ied -= npt;
/* L20: */
    }
    return 0;
} /* srbsct_ */

/* Subroutine */ int srfscp_(integer *ndim, integer *jc, doublereal *d__,
	doublereal *c__, integer *ncolor, integer *nc, integer *nt, integer *
	nb, doublereal *omega, doublereal *wksp, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j1, mj, ied, ist, npt, icol;
    extern /* Subroutine */ int vsubp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... srfscp does a forward sor solve. */
/*     (purdue storage, multicolor) */

/*     ((1/w)*d + b)*x = y */

/* ... parameters -- */

/*          ndim   row dimension of c,jc arrays */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          omega  over-relaxation factor */
/*          wksp   workspace vector of length */
/*                  max(nc(i))     if keygs = 1 */
/*                  0              if keygs = 2 */
/*          x      on input, x contains y */
/*                 on output, x is the solution to the forward solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndim;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndim;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --wksp;
    --x;

    /* Function Body */
    ist = 1;
    i__1 = *ncolor;
    for (icol = 1; icol <= i__1; ++icol) {
	npt = nc[icol];
	ied = ist + npt - 1;
	j1 = nt[icol] + 1;
	mj = nb[icol];
	vsubp_(ndim, ndim, &npt, &mj, &c__[ist + j1 * c_dim1], &jc[ist + j1 *
		jc_dim1], &x[ist], &x[1], &wksp[1]);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L15: */
	    x[i__] = *omega * x[i__] / d__[i__];
	}
	ist += npt;
/* L20: */
    }
    return 0;
} /* srfscp_ */

/* Subroutine */ int srfsct_(integer *ndim, integer *jc, doublereal *d__,
	doublereal *c__, integer *ncolor, integer *nc, integer *nt,
	doublereal *omega, doublereal *wksp, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j2, ied, ist, npt, icol;
    extern /* Subroutine */ int vsubpt_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... srfsct does a transpose forward sor solve. */
/*     (purdue storage, multicolor) */

/*     ((1/w)*d + (t**t))*x = y */

/* ... parameters -- */

/*          ndim   row dimension of c,jc arrays */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          omega  over-relaxation factor */
/*          wksp   workspace vector of length max(nc(i)) */
/*          x      on input, x contains y */
/*                 on output, x is the solution to the forward solve */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndim;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndim;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --wksp;
    --x;

    /* Function Body */
    ist = 1;
    i__1 = *ncolor;
    for (icol = 1; icol <= i__1; ++icol) {
	npt = nc[icol];
	ied = ist + npt - 1;
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L15: */
	    x[i__] = *omega * x[i__] / d__[i__];
	}
	j2 = nt[icol];
	vsubpt_(ndim, ndim, &npt, &j2, &c__[ist + c_dim1], &jc[ist + jc_dim1],
		 &x[1], &x[ist], &wksp[1]);
	ist += npt;
/* L20: */
    }
    return 0;
} /* srfsct_ */

/* Subroutine */ int srscp_(integer *ndim, integer *nn, integer *jc,
	doublereal *d__, doublereal *c__, integer *ncolor, integer *nc,
	integer *nt, integer *nb, doublereal *omega, doublereal *wksp,
	doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal fac;
    extern /* Subroutine */ int srbscp_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *), srfscp_(integer *,
	    integer *, doublereal *, doublereal *, integer *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *);


/* ... srscp does an ssor solve. */
/*     (purdue storage, multicolor) */
/*        con*((1/w)*d + b)*inv(d)*((1/w)*d + t)*x = y */
/*        where con = w/(2-w) and w = omega */

/* ... parameters -- */

/*          ndim   row dimension of c,jc arrays */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          omega  over-relaxation factor */
/*          wksp   workspace vector of length */
/*                  max(nc(i))     if keygs = 1 */
/*                  0              if keygs = 2 */

/* ... specifications for parameters */



    /* Parameter adjustments */
    c_dim1 = *ndim;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndim;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --wksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    fac = (2. - *omega) / *omega;

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfscp_(ndim, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor, &nc[1], &
	    nt[1], &nb[1], omega, &wksp[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * d__[i__] * x[i__];
    }
    srbscp_(ndim, &n, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor, &nc[1],
	     &nt[1], omega, &wksp[1], &x[1]);
    return 0;
} /* srscp_ */

/* Subroutine */ int srscpt_(integer *ndim, integer *nn, integer *jc,
	doublereal *d__, doublereal *c__, integer *ncolor, integer *nc,
	integer *nt, integer *nb, doublereal *omega, doublereal *wksp,
	doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal fac;
    extern /* Subroutine */ int srbsct_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *), srfsct_(
	    integer *, integer *, doublereal *, doublereal *, integer *,
	    integer *, integer *, doublereal *, doublereal *, doublereal *);


/* ... srscpt does an transpose ssor solve. */
/*     (purdue storage, multicolor) */

/* ... parameters -- */

/*          ndim   row dimension of c,jc arrays */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          omega  over-relaxation factor */
/*          wksp   workspace vector of length max(nc(i)) */

/* ... specifications for parameters */



    /* Parameter adjustments */
    c_dim1 = *ndim;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndim;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --wksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    fac = (2. - *omega) / *omega;

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfsct_(ndim, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor, &nc[1], &
	    nt[1], omega, &wksp[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * d__[i__] * x[i__];
    }
    srbsct_(ndim, &n, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor, &nc[1],
	     &nt[1], &nb[1], omega, &wksp[1], &x[1]);
    return 0;
} /* srscpt_ */

/* Subroutine */ int ssrcp_(integer *ndim, integer *jc, doublereal *d__,
	doublereal *c__, integer *nn, integer *ncolor, integer *nc, integer *
	nt, doublereal *p, doublereal *r__, doublereal *wksp, doublereal *pdp,
	 doublereal *pldup)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__, n, mj, ist, npt;
    static doublereal sum;
    static integer icol;
    extern /* Subroutine */ int vaddp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);


/* ... ssrcp computes  pdp = (p,d*p)  and */
/*                     pldup = (p,l*inv(d)*u*p) */

/*     for symmetric multicolor purdue storage format. */

/* ... parameters -- */

/*         ndim    row dimension of c,jc arrays */
/*         jc      integer array giving the column indices of the */
/*                  corresponding elements in c */
/*         d       vector of length n giving the diagonal elements */
/*                  of the matrix */
/*         c       array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*         n       order of system */
/*         ncolor  number of colors used */
/*         nc      integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*         nt      integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*         p       vector from acceleration algorithm */
/*         r       workspace vector from acceleration algorithm */
/*         wksp    workspace vector of length */
/*                  max(nc(i))     if keygs = 1 */
/*                  0              if keygs = 2 */
/*         pdp     (p,d*p) */
/*         pldup   (p,l*d*u*p) */

/* ... specifications for parameters */


/* ... compute pdp = (p,d*p). */

    /* Parameter adjustments */
    c_dim1 = *ndim;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndim;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --p;
    --r__;
    --wksp;

    /* Function Body */
    n = *nn;
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	sum += p[i__] * d__[i__] * p[i__];
    }
    *pdp = sum;

/* ... compute pldup = (p,l*inv(d)*u*p) = (u*p,inv(d)*u*p) */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	r__[i__] = 0.;
    }
    ist = 1;
    i__1 = *ncolor;
    for (icol = 1; icol <= i__1; ++icol) {
	npt = nc[icol];
	mj = nt[icol];
	vaddp_(ndim, ndim, &npt, &mj, &c__[ist + c_dim1], &jc[ist + jc_dim1],
		&r__[ist], &p[1], &wksp[1]);
	ist += npt;
/* L20: */
    }
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	sum += r__[i__] * r__[i__] / d__[i__];
    }
    *pldup = sum;
    return 0;
} /* ssrcp_ */

/* Subroutine */ int ssrcpn_(integer *ndimm, integer *jc, doublereal *d__,
	doublereal *c__, integer *nn, integer *ncol, integer *nc, integer *nt,
	 integer *nb, doublereal *p, doublereal *r__, doublereal *wksp,
	doublereal *pdp, doublereal *pldup)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__, n, j1, mj, np1, ist, npt;
    static doublereal sum;
    static integer icol, ndim;
    extern /* Subroutine */ int vaddp_(integer *, integer *, integer *,
	    integer *, doublereal *, integer *, doublereal *, doublereal *,
	    doublereal *);
    static integer ncolor;


/* ... ssrcpn computes  pdp = (p,d*p)  and */
/*                      pldup = (p,l*inv(d)*u*p) */

/*     for nonsymmetric multicolor purdue storage format. */

/* ... parameters -- */

/*         ndim    row dimension of c,jc arrays */
/*         jc      integer array giving the column indices of the */
/*                  corresponding elements in c */
/*         d       vector of length n giving the diagonal elements */
/*                  of the matrix */
/*         c       array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*         n       order of system */
/*         ncolor  number of colors used */
/*         nc      integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*         nt      integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*         nb      integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*         p       vector from acceleration algorithm */
/*         r       workspace vector from acceleration algorithm */
/*         wksp    workspace vector of length */
/*                  n + max(nc(i))     if keygs = 1 */
/*                  n                  if keygs = 2 */
/*         pdp     (p,d*p) */
/*         pldup   (p,l*d*u*p) */

/* ... specifications for parameters */


/* ... compute pdp = (p,d*p). */

    /* Parameter adjustments */
    c_dim1 = *ndimm;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndimm;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --p;
    --r__;
    --wksp;

    /* Function Body */
    n = *nn;
    ndim = *ndimm;
    ncolor = *ncol;
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	sum += p[i__] * d__[i__] * p[i__];
    }
    *pdp = sum;

/* ... compute pldup = (p,l*inv(d)*u*p) = (u*p,inv(d)*u*p) */

    np1 = n + 1;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	r__[i__] = 0.;
    }
    ist = 1;
    i__1 = ncolor;
    for (icol = 1; icol <= i__1; ++icol) {
	npt = nc[icol];
	mj = nt[icol];
	vaddp_(&ndim, &ndim, &npt, &mj, &c__[ist + c_dim1], &jc[ist + jc_dim1]
		, &r__[ist], &p[1], &wksp[1]);
	ist += npt;
/* L20: */
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	r__[i__] /= d__[i__];
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	wksp[i__] = 0.;
    }
    ist = 1;
    i__1 = ncolor;
    for (icol = 1; icol <= i__1; ++icol) {
	npt = nc[icol];
	j1 = nt[icol] + 1;
	mj = nb[icol];
	vaddp_(&ndim, &ndim, &npt, &mj, &c__[ist + j1 * c_dim1], &jc[ist + j1
		* jc_dim1], &wksp[ist], &r__[1], &wksp[np1]);
	ist += npt;
/* L35: */
    }
    sum = 0.;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L40: */
	sum += p[i__] * wksp[i__];
    }
    *pldup = sum;
    return 0;
} /* ssrcpn_ */

/* Subroutine */ int srscp1_(integer *ndim, integer *nn, integer *jc,
	doublereal *d__, doublereal *c__, integer *ncolor, integer *nc,
	integer *nt, integer *nb, doublereal *omega, doublereal *wksp,
	doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__, n;
    static doublereal fac;
    extern /* Subroutine */ int srfscp_(integer *, integer *, doublereal *,
	    doublereal *, integer *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *);


/* ... srscp1 does an ssor forward solve. */
/*     (purdue storage, multicolor) */

/* ... parameters -- */

/*          ndim   row dimension of c,jc arrays */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          omega  over-relaxation factor */
/*          wksp   workspace vector of length */
/*                  max(nc(i))     if keygs = 1 */
/*                  0              if keygs = 2 */

/* ... specifications for parameters */



    /* Parameter adjustments */
    c_dim1 = *ndim;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndim;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --wksp;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    fac = (2. - *omega) / *omega;

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfscp_(ndim, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor, &nc[1], &
	    nt[1], &nb[1], omega, &wksp[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * d__[i__] * x[i__];
    }
    return 0;
} /* srscp1_ */

/* Subroutine */ int srscp2_(integer *ndim, integer *n, integer *jc,
	doublereal *d__, doublereal *c__, integer *ncolor, integer *nc,
	integer *nt, doublereal *omega, doublereal *wksp, doublereal *y,
	doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int srbscp_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, integer *, integer *,
	    doublereal *, doublereal *, doublereal *);


/* ... srscp2 does an ssor back solve. */
/*     (purdue storage, multicolor) */

/* ... parameters -- */

/*          ndim   row dimension of c,jc arrays */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          omega  over-relaxation factor */
/*          wksp   workspace vector of length */
/*                  max(nc(i))     if keygs = 1 */
/*                  0              if keygs = 2 */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndim;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndim;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --wksp;
    --y;
    --x;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srbscp_(ndim, n, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor, &nc[1],
	    &nt[1], omega, &wksp[1], &x[1]);
    return 0;
} /* srscp2_ */

/* Subroutine */ int srscp3_(integer *ndim, integer *n, integer *jc,
	doublereal *d__, doublereal *c__, integer *ncolor, integer *nc,
	integer *nt, integer *nb, doublereal *omega, doublereal *wksp,
	doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__;
    static doublereal fac;
    extern /* Subroutine */ int srbsct_(integer *, integer *, integer *,
	    doublereal *, doublereal *, integer *, integer *, integer *,
	    integer *, doublereal *, doublereal *, doublereal *);


/* ... srscp3 does an transpose ssor back solve. */
/*     (purdue storage, multicolor) */

/* ... parameters -- */

/*          ndim   row dimension of c,jc arrays */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          nb     integer vector of length ncolor giving the number */
/*                  of lower columns for each color */
/*          omega  over-relaxation factor */
/*          wksp   workspace vector of length max(nc(i)) */

/* ... specifications for parameters */



    /* Parameter adjustments */
    c_dim1 = *ndim;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndim;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --nb;
    --wksp;
    --y;
    --x;

    /* Function Body */
    fac = (2. - *omega) / *omega;

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = fac * d__[i__] * y[i__];
    }
    srbsct_(ndim, n, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor, &nc[1],
	    &nt[1], &nb[1], omega, &wksp[1], &x[1]);
    return 0;
} /* srscp3_ */

/* Subroutine */ int srscp4_(integer *ndim, integer *n, integer *jc,
	doublereal *d__, doublereal *c__, integer *ncolor, integer *nc,
	integer *nt, doublereal *omega, doublereal *wksp, doublereal *y,
	doublereal *x)
{
    /* System generated locals */
    integer jc_dim1, jc_offset, c_dim1, c_offset, i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int srfsct_(integer *, integer *, doublereal *,
	    doublereal *, integer *, integer *, integer *, doublereal *,
	    doublereal *, doublereal *);


/* ... srscp4 does an transpose ssor forward solve. */
/*     (purdue storage, multicolor) */

/* ... parameters -- */

/*          ndim   row dimension of c,jc arrays */
/*          n      order of system (= nn) */
/*          jc     integer array giving the column indices of the */
/*                  corresponding elements in c */
/*          d      vector of length n giving the diagonal elements */
/*                  of the matrix */
/*          c      array of active size n by maxc giving the */
/*                  off diagonal elements of the matrix. */
/*                  thus, a = d + c */
/*          ncolor number of colors used */
/*          nc     integer vector of length ncolor giving the number */
/*                  of nodes for each color */
/*          nt     integer vector of length ncolor giving the number */
/*                  of upper columns for each color */
/*          omega  over-relaxation factor */
/*          wksp   workspace vector of length max(nc(i)) */

/* ... specifications for parameters */


    /* Parameter adjustments */
    c_dim1 = *ndim;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jc_dim1 = *ndim;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    --d__;
    --nc;
    --nt;
    --wksp;
    --y;
    --x;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    srfsct_(ndim, &jc[jc_offset], &d__[1], &c__[c_offset], ncolor, &nc[1], &
	    nt[1], omega, &wksp[1], &x[1]);
    return 0;
} /* srscp4_ */

doublereal tau_(integer *ii)
{
    /* Initialized data */

    static doublereal t[9] = { 1.5,1.8,1.85,1.9,1.94,1.96,1.975,1.985,1.992 };

    /* System generated locals */
    doublereal ret_val;


/* ... tau sets tau(ii) for the sor method. */

/* ... parameters -- */

/*          ii     number of times parameters have been changed */

/* ... specifications for parameters */




    ret_val = t[8];
    if (*ii <= 8) {
	ret_val = t[*ii - 1];
    }
    return ret_val;
} /* tau_ */

/* Subroutine */ int tbs_(integer *n, doublereal *t, doublereal *x)
{
    static integer i__;


/* ... tbs does a back substitution  (i + t)*x = y  where t is the */
/*     first super-diagonal. */

/* ... parameters -- */

/*          n      order of the system */
/*          t      vector of length n-1 containing the super- */
/*                  diagonal elements */
/*          x      on input, x contains y */
/*                 on output, x contains the solution to (i - t)*x = y */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --x;
    --t;

    /* Function Body */
    for (i__ = *n - 1; i__ >= 1; --i__) {
/* L10: */
	x[i__] -= t[i__] * x[i__ + 1];
    }
    return 0;
} /* tbs_ */

/* Subroutine */ int tbsm_(integer *nn, integer *nsize, doublereal *t,
	doublereal *x)
{
    /* System generated locals */
    integer t_dim1, t_offset, x_dim1, x_offset, i__1;

    /* Local variables */
    static integer i__, j, n, nsys;


/* ... tbsm does a back substitution  (i + t)*x = y  where t */
/*     is a super diagonal composed of independent subsystems of */
/*     size nsize. */

/* ... parameters -- */

/*          n      order of system */
/*          nsize  order of the individual subsystems */
/*          t      linear array of length n-1 containing the super- */
/*                  diagonal elements of the factorizations */
/*          x      on input, x contains y */
/*                 the solution to (i + t)*x = y */

/* ... specifications for parameters */


    /* Parameter adjustments */
    x_dim1 = *nsize;
    x_offset = 1 + x_dim1;
    x -= x_offset;
    t_dim1 = *nsize;
    t_offset = 1 + t_dim1;
    t -= t_offset;

    /* Function Body */
    n = *nn;
    nsys = n / *nsize;
    for (i__ = *nsize - 1; i__ >= 1; --i__) {
	i__1 = nsys;
	for (j = 1; j <= i__1; ++j) {
/* L10: */
	    x[i__ + j * x_dim1] -= t[i__ + j * t_dim1] * x[i__ + 1 + j *
		    x_dim1];
	}
/* L15: */
    }
    return 0;
} /* tbsm_ */

/* Subroutine */ int tfac_(integer *nn, doublereal *d__, doublereal *t)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n, nm1;


/* ... tfac computes a factorization of a single symmetric */
/*     tridiagonal matrix contained in d and t and replaces it. */

/* ... parameters -- */

/*          n      order of system (= nn) */
/*          d      vector of length n containing the diagonal */
/*                  elements of the matrix */
/*          t      vector of length n-1 containing the super- */
/*                  diagonal elements of the matrix */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --t;
    --d__;

    /* Function Body */
    n = *nn;
    nm1 = n - 1;
    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
/* L10: */
	d__[i__] -= t[i__ - 1] * t[i__ - 1] / d__[i__ - 1];
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	d__[i__] = 1. / d__[i__];
    }
    i__1 = nm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	t[i__] = d__[i__] * t[i__];
    }
    return 0;
} /* tfac_ */

/* Subroutine */ int tfacm_(integer *nn, integer *nsize, doublereal *d__,
	doublereal *t)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, i__1, i__2;
    doublereal d__1;

    /* Local variables */
    static integer i__, j, n, nm1;
    extern /* Subroutine */ int vinv_(integer *, doublereal *);
    static integer nsys;
    extern /* Subroutine */ int vexopy_(integer *, doublereal *, doublereal *,
	     doublereal *, integer *);


/* ... tfacm computes factorizations of multiple independent */
/*     symmetric tridiagonal matrices contained in d and t. */

/* ... parameters -- */

/*          n      order of global system (= nn) */
/*          nsize  size of the individual subsystems */
/*          d      linear array of length n containing the */
/*                  diagonal elements of the systems */
/*          t      linear array of length n-1 containing the */
/*                  super-diagonal elements of the systems */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *nsize;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    d_dim1 = *nsize;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;

    /* Function Body */
    n = *nn;
    nm1 = n - 1;
    nsys = n / *nsize;
    i__1 = *nsize;
    for (i__ = 2; i__ <= i__1; ++i__) {
	i__2 = nsys;
	for (j = 1; j <= i__2; ++j) {
/* L5: */
/* Computing 2nd power */
	    d__1 = t[i__ - 1 + j * t_dim1];
	    d__[i__ + j * d_dim1] -= d__1 * d__1 / d__[i__ - 1 + j * d_dim1];
	}
/* L10: */
    }
    vinv_(&n, &d__[d_offset]);
    vexopy_(&nm1, &t[t_offset], &d__[d_offset], &t[t_offset], &c__3);
    return 0;
} /* tfacm_ */

/* Subroutine */ int tfacn_(integer *nn, doublereal *d__, doublereal *t,
	doublereal *b)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n, nm1;


/* ... tfacn computes a factorization of a single nonsymmetric */
/*     tridiagonal matrix contained in d, t, and b and */
/*     replaces it. */

/* ... parameters -- */

/*          n      order of system (= nn) */
/*          d      vector of length n containing the diagonal */
/*                  elements of the matrix */
/*          t      vector of length n-1 containing the super- */
/*                  diagonal elements of the matrix */
/*          b      vector of length n-1 containing the sub- */
/*                  diagonal elements of the matrix */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --b;
    --t;
    --d__;

    /* Function Body */
    n = *nn;
    nm1 = n - 1;
    i__1 = n;
    for (i__ = 2; i__ <= i__1; ++i__) {
/* L10: */
	d__[i__] -= b[i__ - 1] * t[i__ - 1] / d__[i__ - 1];
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	d__[i__] = 1. / d__[i__];
    }
    i__1 = nm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
	t[i__] = d__[i__] * t[i__];
	b[i__] = d__[i__] * b[i__];
/* L20: */
    }
    return 0;
} /* tfacn_ */

/* Subroutine */ int tfacnm_(integer *nn, integer *nsize, doublereal *d__,
	doublereal *t, doublereal *b)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, b_dim1, b_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, n, nm1;
    extern /* Subroutine */ int vinv_(integer *, doublereal *);
    static integer nsys;
    extern /* Subroutine */ int vexopy_(integer *, doublereal *, doublereal *,
	     doublereal *, integer *);


/* ... tfacnm computes factorizations of multiple independent */
/*     nonsymmetric tridiagonal matrices contained in */
/*     d, t, and b. */

/* ... parameters -- */

/*          n      order of global system (= nn) */
/*          nsize  order of single subsystem */
/*          d      linear array of length n containing the */
/*                  diagonal elements of the systems */
/*          t      linear array of length n-1 containing the */
/*                  super-diagonal elements of the systems */
/*          b      linear array of length n-1 containing the */
/*                  sub-diagonal elements of the systems */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *nsize;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *nsize;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    d_dim1 = *nsize;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;

    /* Function Body */
    n = *nn;
    nm1 = n - 1;
    nsys = n / *nsize;
    i__1 = *nsize;
    for (i__ = 2; i__ <= i__1; ++i__) {
	i__2 = nsys;
	for (j = 1; j <= i__2; ++j) {
/* L5: */
	    d__[i__ + j * d_dim1] -= b[i__ - 1 + j * b_dim1] * t[i__ - 1 + j *
		     t_dim1] / d__[i__ - 1 + j * d_dim1];
	}
/* L10: */
    }
    vinv_(&n, &d__[d_offset]);
    vexopy_(&nm1, &t[t_offset], &d__[d_offset], &t[t_offset], &c__3);
    vexopy_(&nm1, &b[b_offset], &d__[d_offset], &b[b_offset], &c__3);
    return 0;
} /* tfacnm_ */

/* Subroutine */ int tfs_(integer *n, doublereal *b, doublereal *x)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;


/* ... tfs does a forward substitution  (i + b)*x = y, */
/*     where b is the first sub-diagonal. */

/* ... parameters -- */

/*          n      order of system */
/*          b      vector of length n-1 containing the sub- */
/*                  diagonal elements */
/*          x      on input, x contains y */
/*                 on output, x contains the solution to (i - b)*x = y */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --x;
    --b;

    /* Function Body */
    i__1 = *n;
    for (i__ = 2; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] -= b[i__ - 1] * x[i__ - 1];
    }
    return 0;
} /* tfs_ */

/* Subroutine */ int tfsm_(integer *nn, integer *nsize, doublereal *b,
	doublereal *x)
{
    /* System generated locals */
    integer b_dim1, b_offset, x_dim1, x_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, n, nsys;


/* ... tfsm does a forward substitution  (i + b)*x = y  where b */
/*     is a sub-diagonal composed of independent subsystems of */
/*     size nsize. */

/* ... parameters -- */

/*          n      order of system */
/*          nsize  order of the individual subsystems */
/*          b      linear array of length n-1 containing the sub- */
/*                  diagonal elements of the factorizations */
/*          x      on input, x contains y */
/*                 on output, x contains the solution to (i + b)*x = y */

/* ... specifications for parameters */


    /* Parameter adjustments */
    x_dim1 = *nsize;
    x_offset = 1 + x_dim1;
    x -= x_offset;
    b_dim1 = *nsize;
    b_offset = 1 + b_dim1;
    b -= b_offset;

    /* Function Body */
    n = *nn;
    nsys = n / *nsize;
    i__1 = *nsize;
    for (i__ = 2; i__ <= i__1; ++i__) {
	i__2 = nsys;
	for (j = 1; j <= i__2; ++j) {
/* L15: */
	    x[i__ + j * x_dim1] -= b[i__ - 1 + j * b_dim1] * x[i__ - 1 + j *
		    x_dim1];
	}
/* L20: */
    }
    return 0;
} /* tfsm_ */

/* Subroutine */ int tinv_(integer *nn, doublereal *d__, doublereal *t)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n, nm1;


/* ... tinv computes an approximate inverse to a single tridiagonal */
/*     symmetric matrix.  d and u must contain upon input the */
/*     output from a factorization routine. */

/* ... parameters -- */

/*          n      order of system (= nn) */
/*          d      vector of length n containing the diagonal */
/*                  elements of the factorization */
/*          t      vector of length n-1 containing the super- */
/*                  diagonal elements of the factorization */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --t;
    --d__;

    /* Function Body */
    n = *nn;
    nm1 = n - 1;

    for (i__ = nm1; i__ >= 1; --i__) {
/* L10: */
	d__[i__] += t[i__] * t[i__] * d__[i__ + 1];
    }
    i__1 = nm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	t[i__] = -d__[i__ + 1] * t[i__];
    }
    return 0;
} /* tinv_ */

/* Subroutine */ int tinvm_(integer *nn, integer *nsize, doublereal *d__,
	doublereal *t)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, i__1;

    /* Local variables */
    static integer i__, l, n, nm1, nsm1, nsys;
    extern /* Subroutine */ int vemxty_(integer *, doublereal *, doublereal *,
	     doublereal *);


/* ... tinvm computes an approximate inverse to multiple tridiagonal */
/*     symmetric matrices.  d and t must contain upon input the */
/*     output from a factorization routine. */

/* ... parameters -- */

/*          n      order of system (= nn) */
/*          nsize  size of a single subsystem */
/*          d      vector of length n containing the diagonal */
/*                  elements of the factorization */
/*          t      vector of length n-1 containing the super- */
/*                  diagonal elements of the factorization */

/* ... specifications for parameters */


    /* Parameter adjustments */
    t_dim1 = *nsize;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    d_dim1 = *nsize;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;

    /* Function Body */
    n = *nn;
    nm1 = n - 1;
    nsys = n / *nsize;
    nsm1 = *nsize - 1;

    for (i__ = nsm1; i__ >= 1; --i__) {
	i__1 = nsys;
	for (l = 1; l <= i__1; ++l) {
/* L15: */
	    d__[i__ + l * d_dim1] += t[i__ + l * t_dim1] * t[i__ + l * t_dim1]
		     * d__[i__ + 1 + l * d_dim1];
	}
/* L20: */
    }
    vemxty_(&nm1, &t[t_offset], &d__[d_dim1 + 2], &t[t_offset]);
    return 0;
} /* tinvm_ */

/* Subroutine */ int tinvn_(integer *nn, doublereal *d__, doublereal *t,
	doublereal *b)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n, nm1;


/* ... tinvn computes an approximate inverse to a single tridiagonal */
/*     nonsymmetric matrix.  d, b, and t must contain upon */
/*     input the output from a factorization routine. */

/* ... parameters -- */

/*          n      order of system (= nn) */
/*          d      vector of length n containing the diagonal */
/*                  elements of the factorization */
/*          t      vector of length n-1 containing the super- */
/*                  diagonal elements of the factorization */
/*          b      vector of length n-1 containing the sub- */
/*                  diagonal elements of the factorization */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --b;
    --t;
    --d__;

    /* Function Body */
    n = *nn;
    nm1 = n - 1;

    for (i__ = nm1; i__ >= 1; --i__) {
/* L10: */
	d__[i__] += b[i__] * t[i__] * d__[i__ + 1];
    }
    i__1 = nm1;
    for (i__ = 1; i__ <= i__1; ++i__) {
	t[i__] = -d__[i__ + 1] * t[i__];
	b[i__] = -d__[i__ + 1] * b[i__];
/* L20: */
    }
    return 0;
} /* tinvn_ */

/* Subroutine */ int tinvnm_(integer *nn, integer *nsize, doublereal *d__,
	doublereal *t, doublereal *b)
{
    /* System generated locals */
    integer d_dim1, d_offset, t_dim1, t_offset, b_dim1, b_offset, i__1;

    /* Local variables */
    static integer i__, l, n, nm1, nsm1, nsys;
    extern /* Subroutine */ int vemxty_(integer *, doublereal *, doublereal *,
	     doublereal *);


/* ... tinvnm computes an approximate inverse to multiple tridiagonal */
/*     nonsymmetric matrices.  d, t, and b must contain upon */
/*     input the output from a factorization routine. */

/* ... parameters -- */

/*          n      order of system (= nn) */
/*          nsize  size of a single subsystem */
/*          d      vector of length n containing the diagonal */
/*                  elements of the factorization */
/*          t      vector of length n-1 containing the super- */
/*                  diagonal elements of the factorization */
/*          b      vector of length n-1 containing the sub- */
/*                  diagonal elements of the factorization */

/* ... specifications for parameters */


    /* Parameter adjustments */
    b_dim1 = *nsize;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    t_dim1 = *nsize;
    t_offset = 1 + t_dim1;
    t -= t_offset;
    d_dim1 = *nsize;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;

    /* Function Body */
    n = *nn;
    nm1 = n - 1;
    nsys = n / *nsize;
    nsm1 = *nsize - 1;

    for (i__ = nsm1; i__ >= 1; --i__) {
	i__1 = nsys;
	for (l = 1; l <= i__1; ++l) {
/* L15: */
	    d__[i__ + l * d_dim1] += b[i__ + l * b_dim1] * t[i__ + l * t_dim1]
		     * d__[i__ + 1 + l * d_dim1];
	}
/* L20: */
    }
    vemxty_(&nm1, &t[t_offset], &d__[d_dim1 + 2], &t[t_offset]);
    vemxty_(&nm1, &b[b_offset], &d__[d_dim1 + 2], &b[b_offset]);
    return 0;
} /* tinvnm_ */

/* Subroutine */ int tsoln_(integer *nn, doublereal *d__, doublereal *t,
	doublereal *b, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int tbs_(integer *, doublereal *, doublereal *),
	    tfs_(integer *, doublereal *, doublereal *);


/* ... tsoln solves the system ax = y for x, where a is a single */
/*     tridiagonal system.  d, t, and b contain */
/*     the main diagonal, the first super-diagonal, and the first */
/*     sub-diagonal, respectively of the factorization. */

/* ... parameters -- */

/*          n      order of system */
/*          d      vector of length n containing the diagonal */
/*                  elements of the factorization matrix */
/*          t      vector of length n-1 containing the super- */
/*                  diagonal elements of the factorization */
/*          b      vector of length n-1 containing the sub- */
/*                  diagonal elements of the factorization */
/*          y      the right-hand side */
/*          x      the solution to ax = y */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --x;
    --y;
    --b;
    --t;
    --d__;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    tfs_(&n, &b[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = d__[i__] * x[i__];
    }
    tbs_(&n, &t[1], &x[1]);
    return 0;
} /* tsoln_ */

/* Subroutine */ int tsolnm_(integer *nn, integer *nsize, doublereal *d__,
	doublereal *t, doublereal *b, doublereal *y, doublereal *x)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;
    extern /* Subroutine */ int tbsm_(integer *, integer *, doublereal *,
	    doublereal *), tfsm_(integer *, integer *, doublereal *,
	    doublereal *);


/* ... tsolnm solves the system ax = y for x, where a contains */
/*     multiple tridiagonal systems.  d, t, and b contain */
/*     the main diagonal, the first super-diagonal, and the first */
/*     sub-diagonal, respectively of the factorization. */

/* ... parameters -- */

/*          n      order of system */
/*          nsize  size of an individual subsystem */
/*          d      vector of length n containing the diagonal */
/*                  elements of the factorization matrix */
/*          t      vector of length n-1 containing the super- */
/*                  diagonal elements of the factorization */
/*          b      vector of length n-1 containing the sub- */
/*                  diagonal elements of the factorization */
/*          y      the right-hand side */
/*          x      the solution to ax = y */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --x;
    --y;
    --b;
    --t;
    --d__;

    /* Function Body */
    n = *nn;
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	x[i__] = y[i__];
    }
    tfsm_(&n, nsize, &b[1], &x[1]);
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	x[i__] = d__[i__] * x[i__];
    }
    tbsm_(&n, nsize, &t[1], &x[1]);
    return 0;
} /* tsolnm_ */

/* Subroutine */ int tsum_(integer *nn, integer *lda, integer *ldb, integer *
	ldc, integer *ma, integer *mbb, integer *mc, integer *mdd, integer *
	incb, integer *incc, integer *incdd, integer *ja, integer *jb,
	integer *jc, integer *jd, doublereal *a, doublereal *b, doublereal *
	c__, doublereal *rows, doublereal *cols, doublereal *wksp, integer *
	icodee, doublereal *omegaa)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, i__1, i__2,
	    i__3, i__4, i__5;

    /* Local variables */
    static integer i__, j, k, l, n, l1, mb, md, lc, la, lb, ld, kk, ia1, ib1,
	    ia2, ib2, ied, ist, incd, icode;
    static doublereal omega;


/* ... tsum computes the row and column sum of (c**t)*a*b restricted */
/* ... to the sparsity pattern of jd.  a is assumed to be symmetric. */

/* ... parameters -- */

/*         n             orders of arrays a,b,c,d */
/*         lda,ldb,ldc   row dimensions of arrays a,b,c */
/*         ma,mb,mc,md   columns (diagonals) in arrays a,b,c,d */
/*         incb,incc,    offsets for diagonal numbers of b,c,d arrays */
/*           incd */
/*         ja,jb,jc,jd   diagonal index arrays for a,b,c,d */
/*         a,b,c         arrays of dimension n x (ma,mb,md) */
/*         rows          row sum of d = (c**t)*a*b upon output */
/*         cols          column sum of d upon output */
/*         wksp          workspace array of length n */
/*         icode         key */
/*                        = 0  if c .ne. b */
/*                        = 1  if c .eq. b */
/*         omega         relaxation factor between 0 and 1 */

/* ... specifications for parameters */


    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    --ja;
    --jb;
    --jc;
    --jd;
    --rows;
    --cols;
    --wksp;

    /* Function Body */
    n = *nn;
    mb = *mbb;
    md = *mdd;
    incd = *incdd;
    icode = *icodee;
    omega = *omegaa;
    i__1 = *mc;
    for (lc = 1; lc <= i__1; ++lc) {
	i__ = jc[lc] - *incc;
/* Computing MAX */
	i__2 = 1, i__3 = i__ + 1;
	ia1 = max(i__2,i__3);
/* Computing MIN */
	i__2 = n, i__3 = n + i__;
	ib1 = min(i__2,i__3);
	i__2 = *ma;
	for (la = 1; la <= i__2; ++la) {
	    j = ja[la];
	    l1 = -i__ + j;
/* Computing MAX */
	    i__3 = ia1, i__4 = 1 - l1;
	    ia2 = max(i__3,i__4);
/* Computing MIN */
	    i__3 = ib1, i__4 = n - l1;
	    ib2 = min(i__3,i__4);
	    i__3 = mb;
	    for (lb = 1; lb <= i__3; ++lb) {
		k = jb[lb] - *incb;
		l = l1 + k;
		i__4 = md;
		for (ld = 1; ld <= i__4; ++ld) {
		    if (jd[ld] - incd == l) {
			goto L15;
		    }
/* L10: */
		}
		goto L45;
L15:
/* Computing MAX */
		i__4 = ia2, i__5 = 1 - l;
		ist = max(i__4,i__5);
/* Computing MIN */
		i__4 = ib2, i__5 = n - l;
		ied = min(i__4,i__5);
		i__4 = ied;
		for (kk = ist; kk <= i__4; ++kk) {
/* L20: */
		    wksp[kk - ist + 1] = c__[kk - i__ + lc * c_dim1] * a[kk -
			    i__ + la * a_dim1] * b[kk + l1 + lb * b_dim1];
		}
		i__4 = ied;
		for (kk = ist; kk <= i__4; ++kk) {
/* L25: */
		    rows[kk] += omega * wksp[kk - ist + 1];
		}
		if (l == 0 || icode != 1) {
		    goto L35;
		}
		i__4 = ied;
		for (kk = ist; kk <= i__4; ++kk) {
/* L30: */
		    rows[kk + l] += omega * wksp[kk - ist + 1];
		}
L35:
		if (icode == 1) {
		    goto L45;
		}
		i__4 = ied;
		for (kk = ist; kk <= i__4; ++kk) {
/* L40: */
		    cols[kk + l] += omega * wksp[kk - ist + 1];
		}
L45:
		;
	    }
	    if (j == 0) {
		goto L90;
	    }
	    l1 = -i__ - j;
/* Computing MAX */
	    i__3 = ia1, i__4 = 1 - l1;
	    ia2 = max(i__3,i__4);
/* Computing MIN */
	    i__3 = ib1, i__4 = n - l1;
	    ib2 = min(i__3,i__4);
	    i__3 = mb;
	    for (lb = 1; lb <= i__3; ++lb) {
		k = jb[lb] - *incb;
		l = l1 + k;
		i__4 = md;
		for (ld = 1; ld <= i__4; ++ld) {
		    if (jd[ld] - incd == l) {
			goto L55;
		    }
/* L50: */
		}
		goto L85;
L55:
/* Computing MAX */
		i__4 = ia2, i__5 = 1 - l;
		ist = max(i__4,i__5);
/* Computing MIN */
		i__4 = ib2, i__5 = n - l;
		ied = min(i__4,i__5);
		i__4 = ied;
		for (kk = ist; kk <= i__4; ++kk) {
/* L60: */
		    wksp[kk - ist + 1] = c__[kk - i__ + lc * c_dim1] * a[kk +
			    l1 + la * a_dim1] * b[kk + l1 + lb * b_dim1];
		}
		i__4 = ied;
		for (kk = ist; kk <= i__4; ++kk) {
/* L65: */
		    rows[kk] += omega * wksp[kk - ist + 1];
		}
		if (l == 0 || icode != 1) {
		    goto L75;
		}
		i__4 = ied;
		for (kk = ist; kk <= i__4; ++kk) {
/* L70: */
		    rows[kk + l] += omega * wksp[kk - ist + 1];
		}
L75:
		if (icode == 1) {
		    goto L85;
		}
		i__4 = ied;
		for (kk = ist; kk <= i__4; ++kk) {
/* L80: */
		    cols[kk + l] += omega * wksp[kk - ist + 1];
		}
L85:
		;
	    }
L90:
	    ;
	}
/* L95: */
    }
    return 0;
} /* tsum_ */

/* Subroutine */ int tsumn_(integer *nn, integer *np, integer *nq, integer *
	lda, integer *ldb, integer *ldc, integer *ldj, integer *ma, integer *
	mb, integer *mc, integer *md, integer *incb, integer *incc, integer *
	incd, integer *ja, integer *jb, integer *jc, integer *jd, doublereal *
	a, doublereal *b, doublereal *c__, doublereal *rows, doublereal *
	omega)
{
    /* System generated locals */
    integer ja_dim1, ja_offset, jb_dim1, jb_offset, jc_dim1, jc_offset,
	    jd_dim1, jd_offset, a_dim1, a_offset, b_dim1, b_offset, c_dim1,
	    c_offset, i__1, i__2, i__3, i__4, i__5;

    /* Local variables */
    static integer i__, j, k, l, m, n, l1, lc, la, lb, ld, ia1, ib1, ia2, ib2,
	     ied, ist;


/* ... tsumn computes the row sum of c*a*b restricted */
/* ... to the sparsity pattern of jd. */

/*      c is np x nn        b is nn x nq */
/*      a is nn x nn        d is np x nq */

/* ... definition of parameters -- */

/*         nn,np,nq      orders of arrays */
/*         lda,ldb,ldc   row dimensions of arrays a,b,c */
/*         ldj           row dimension of ja,jb,jc,jd vectors */
/*         ma,mb,mc,md   columns (diagonals) in arrays a,b,c,d */
/*         incb,incc,    offsets for diagonal numbers of b,c,d arrays */
/*           incd */
/*         ja,jb,jc,jd   diagonal index arrays for a,b,c,d */
/*         a,b,c         arrays of dimension n x (ma,mb,md) */
/*         rows          row sum of d = c*a*b upon output */
/*         omega         relaxation factor between 0 and 1 */

/* ... specifications for parameters */


    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    jd_dim1 = *ldj;
    jd_offset = 1 + jd_dim1;
    jd -= jd_offset;
    jc_dim1 = *ldj;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    jb_dim1 = *ldj;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    ja_dim1 = *ldj;
    ja_offset = 1 + ja_dim1;
    ja -= ja_offset;
    --rows;

    /* Function Body */
    n = *nn;
    i__1 = *mc;
    for (lc = 1; lc <= i__1; ++lc) {
	i__ = jc[lc * jc_dim1 + 1] - *incc;
/* Computing MAX */
	i__2 = 1, i__3 = 1 - i__;
	ia1 = max(i__2,i__3);
/* Computing MIN */
	i__2 = *np, i__3 = n - i__;
	ib1 = min(i__2,i__3);
	i__2 = *ma;
	for (la = 1; la <= i__2; ++la) {
	    j = ja[la * ja_dim1 + 1];
	    l1 = i__ + j;
/* Computing MAX */
	    i__3 = ia1, i__4 = 1 - l1;
	    ia2 = max(i__3,i__4);
/* Computing MIN */
	    i__3 = ib1, i__4 = n - l1;
	    ib2 = min(i__3,i__4);
	    i__3 = *mb;
	    for (lb = 1; lb <= i__3; ++lb) {
		k = jb[lb * jb_dim1 + 1] - *incb;
		l = l1 + k;
		i__4 = *md;
		for (ld = 1; ld <= i__4; ++ld) {
		    if (jd[ld * jd_dim1 + 1] - *incd == l) {
			goto L20;
		    }
/* L15: */
		}
		goto L30;
L20:
/* Computing MAX */
		i__4 = ia2, i__5 = 1 - l;
		ist = max(i__4,i__5);
/* Computing MIN */
		i__4 = ib2, i__5 = *nq - l;
		ied = min(i__4,i__5);
		i__4 = ied;
		for (m = ist; m <= i__4; ++m) {
/* L25: */
		    rows[m] += *omega * c__[m + lc * c_dim1] * a[m + i__ + la
			    * a_dim1] * b[m + l1 + lb * b_dim1];
		}
L30:
		;
	    }
/* L35: */
	}
/* L40: */
    }
    return 0;
} /* tsumn_ */

/* Subroutine */ int t1prod_(integer *lda, integer *ldb, integer *ldc,
	integer *ldd, integer *ldj, integer *nn, integer *np, integer *nq,
	integer *ma, integer *mb, integer *mc, integer *md, integer *incb,
	integer *incc, integer *incd, integer *ja, integer *jb, integer *jc,
	integer *jd, doublereal *a, doublereal *b, doublereal *c__,
	doublereal *d__)
{
    /* System generated locals */
    integer ja_dim1, ja_offset, jb_dim1, jb_offset, jc_dim1, jc_offset,
	    jd_dim1, jd_offset, a_dim1, a_offset, b_dim1, b_offset, c_dim1,
	    c_offset, d_dim1, d_offset, i__1, i__2, i__3, i__4, i__5;

    /* Local variables */
    static integer i__, j, k, l, m, n, l1, lc, la, lb, ld, ia1, ib1, ia2, ib2,
	     ied, ist;


/* ... t1prod computes  d = d - c*a*b */
/* ... */
/* ... but restricted to the sparsity pattern of d.  a is assumed to */
/* ... be in nonsymmetric storage mode. */

/*      c is np x nn        b is nn x nq */
/*      a is nn x nn        d is np x nq */

/* ... definition of parameters -- */

/*         lda,ldb,      row dimension of arrays a,b,c,d */
/*          ldc,ldd */
/*         ldj           row dimension of arrays ja,jb,jc,jd */
/*         nn,np,nq      orders of arrays */
/*         ma,mb,mc,md   columns (diagonals) in arrays a,b,c,d */
/*         incb,incc,    offsets for diagonal numbers of b,c,d arrays */
/*           incd */
/*         ja,jb,jc,jd   diagonal index arrays for a,b,c,d */
/*         a,b,c,d       arrays of dimension n x (ma,mb,mc, or md) */

/* ... specifications for parameters */


    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ldb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    c_dim1 = *ldc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    d_dim1 = *ldd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    jd_dim1 = *ldj;
    jd_offset = 1 + jd_dim1;
    jd -= jd_offset;
    jc_dim1 = *ldj;
    jc_offset = 1 + jc_dim1;
    jc -= jc_offset;
    jb_dim1 = *ldj;
    jb_offset = 1 + jb_dim1;
    jb -= jb_offset;
    ja_dim1 = *ldj;
    ja_offset = 1 + ja_dim1;
    ja -= ja_offset;

    /* Function Body */
    n = *nn;
    i__1 = *mc;
    for (lc = 1; lc <= i__1; ++lc) {
	i__ = jc[lc * jc_dim1 + 1] - *incc;
/* Computing MAX */
	i__2 = 1, i__3 = 1 - i__;
	ia1 = max(i__2,i__3);
/* Computing MIN */
	i__2 = *np, i__3 = n - i__;
	ib1 = min(i__2,i__3);
	i__2 = *ma;
	for (la = 1; la <= i__2; ++la) {
	    j = ja[la * ja_dim1 + 1];
	    l1 = i__ + j;
/* Computing MAX */
	    i__3 = ia1, i__4 = 1 - l1;
	    ia2 = max(i__3,i__4);
/* Computing MIN */
	    i__3 = ib1, i__4 = n - l1;
	    ib2 = min(i__3,i__4);
	    i__3 = *mb;
	    for (lb = 1; lb <= i__3; ++lb) {
		k = jb[lb * jb_dim1 + 1] - *incb;
		l = l1 + k;
		i__4 = *md;
		for (ld = 1; ld <= i__4; ++ld) {
		    if (jd[ld * jd_dim1 + 1] - *incd == l) {
			goto L20;
		    }
/* L15: */
		}
		goto L30;
L20:
/* Computing MAX */
		i__4 = ia2, i__5 = 1 - l;
		ist = max(i__4,i__5);
/* Computing MIN */
		i__4 = ib2, i__5 = *nq - l;
		ied = min(i__4,i__5);
		i__4 = ied;
		for (m = ist; m <= i__4; ++m) {
/* L25: */
		    d__[m + ld * d_dim1] -= c__[m + lc * c_dim1] * a[m + i__
			    + la * a_dim1] * b[m + l1 + lb * b_dim1];
		}
L30:
		;
	    }
/* L35: */
	}
/* L40: */
    }
    return 0;
} /* t1prod_ */

/* Subroutine */ int t2prod_(integer *nn, integer *nda, integer *ndb, integer
	*ndc, integer *ndd, integer *ma, integer *mbb, integer *mc, integer *
	mdd, integer *incb, integer *incc, integer *incd, integer *ja,
	integer *jb, integer *jc, integer *jd, doublereal *a, doublereal *b,
	doublereal *c__, doublereal *d__)
{
    /* System generated locals */
    integer a_dim1, a_offset, b_dim1, b_offset, c_dim1, c_offset, d_dim1,
	    d_offset, i__1, i__2, i__3, i__4, i__5;

    /* Local variables */
    static integer i__, j, k, l, n, l1, mb, md, lc, la, lb, ld, ir, ia1, ib1,
	    ia2, ib2, ied, ist;


/* ... t2prod computes  d = d - (c**t)*a*b  restricted to the */
/* ... sparsity pattern of d.  a is assumed to be symmetric. */

/* ... parameters -- */

/*         n             orders of arrays a,b,c,d */
/*         nda,ndb,ndc,  row dimensions of arrays a,b,c,d */
/*          ndd */
/*         ma,mb,mc,md   columns (diagonals) in arrays a,b,c,d */
/*         incb,incc,    offsets for diagonal numbers of b,c,d arrays */
/*           incd */
/*         ja,jb,jc,jd   diagonal index arrays for a,b,c,d */
/*         a,b,c,d       arrays of dimension n x (ma,mb,mc, or md) */

/* ... specifications for parameters */


    /* Parameter adjustments */
    a_dim1 = *nda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    b_dim1 = *ndb;
    b_offset = 1 + b_dim1;
    b -= b_offset;
    c_dim1 = *ndc;
    c_offset = 1 + c_dim1;
    c__ -= c_offset;
    d_dim1 = *ndd;
    d_offset = 1 + d_dim1;
    d__ -= d_offset;
    --ja;
    --jb;
    --jc;
    --jd;

    /* Function Body */
    n = *nn;
    mb = *mbb;
    md = *mdd;
    i__1 = *mc;
    for (lc = 1; lc <= i__1; ++lc) {
	i__ = jc[lc] - *incc;
/* Computing MAX */
	i__2 = 1, i__3 = i__ + 1;
	ia1 = max(i__2,i__3);
/* Computing MIN */
	i__2 = n, i__3 = n + i__;
	ib1 = min(i__2,i__3);
	i__2 = *ma;
	for (la = 1; la <= i__2; ++la) {
	    j = ja[la];
	    l1 = -i__ + j;
/* Computing MAX */
	    i__3 = ia1, i__4 = 1 - l1;
	    ia2 = max(i__3,i__4);
/* Computing MIN */
	    i__3 = ib1, i__4 = n - l1;
	    ib2 = min(i__3,i__4);
	    i__3 = mb;
	    for (lb = 1; lb <= i__3; ++lb) {
		k = jb[lb] - *incb;
		l = l1 + k;
		i__4 = md;
		for (ld = 1; ld <= i__4; ++ld) {
		    if (jd[ld] - *incd == l) {
			goto L20;
		    }
/* L15: */
		}
		goto L30;
L20:
/* Computing MAX */
		i__4 = ia2, i__5 = 1 - l;
		ist = max(i__4,i__5);
/* Computing MIN */
		i__4 = ib2, i__5 = n - l;
		ied = min(i__4,i__5);
		i__4 = ied;
		for (ir = ist; ir <= i__4; ++ir) {
/* L25: */
		    d__[ir + ld * d_dim1] -= c__[ir - i__ + lc * c_dim1] * a[
			    ir - i__ + la * a_dim1] * b[ir + l1 + lb * b_dim1]
			    ;
		}
L30:
		;
	    }
	    if (j == 0) {
		goto L60;
	    }
	    l1 = -i__ - j;
/* Computing MAX */
	    i__3 = ia1, i__4 = 1 - l1;
	    ia2 = max(i__3,i__4);
/* Computing MIN */
	    i__3 = ib1, i__4 = n - l1;
	    ib2 = min(i__3,i__4);
	    i__3 = mb;
	    for (lb = 1; lb <= i__3; ++lb) {
		k = jb[lb] - *incb;
		l = l1 + k;
		i__4 = md;
		for (ld = 1; ld <= i__4; ++ld) {
		    if (jd[ld] - *incd == l) {
			goto L45;
		    }
/* L40: */
		}
		goto L55;
L45:
/* Computing MAX */
		i__4 = ia2, i__5 = 1 - l;
		ist = max(i__4,i__5);
/* Computing MIN */
		i__4 = ib2, i__5 = n - l;
		ied = min(i__4,i__5);
		i__4 = ied;
		for (ir = ist; ir <= i__4; ++ir) {
/* L50: */
		    d__[ir + ld * d_dim1] -= c__[ir - i__ + lc * c_dim1] * a[
			    ir + l1 + la * a_dim1] * b[ir + l1 + lb * b_dim1];
		}
L55:
		;
	    }
L60:
	    ;
	}
/* L65: */
    }
    return 0;
} /* t2prod_ */

/* Subroutine */ int unpmdg_(integer *ndim, integer *nn, integer *maxnz,
	integer *jcoef, doublereal *coef, integer *ncol, integer *nc, integer
	*p, integer *ip, integer *maxd, integer *maxnew, integer *jcnew,
	doublereal *wksp, integer *iwksp, integer *isym)
{
    /* System generated locals */
    integer jcnew_dim1, jcnew_offset, coef_dim1, coef_offset, i__1, i__2,
	    i__3;

    /* Local variables */
    static integer i__, j, k, l, n, mp1, ied, ncc, lim, iip, ist, jcol,
	    maxold, ncolor;
    extern /* Subroutine */ int vscatr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... unpmdg reverses the permutation done by pmdiag.  it */
/*     permutates the matrix according to index vector ip. */
/*     the permuted matrix is stored in diagonal format. */

/* ... parameters -- */

/*        ndim      row dimension of coef and jcoef arrays */
/*                   in defining routine */
/*        n         order of system (active row size of coef and jcoef) */
/*        maxnz     active column size of coef and jcoef */
/*        jcoef     integer array of column numbers */
/*        coef      floating point array of coefficients */
/*        ncolor    number of colors in the permutation (= ncol) */
/*        nc        integer vector of length ncolor giving the */
/*                   number of nodes for each color */
/*        p         permutation vector */
/*        ip        inverse permuation vector */
/*        maxd      active column size of permuted matrix */
/*        jcnew     integer array of size ncolor*max(maxnew(i)) */
/*                   giving the diagonal numbers for each color */
/*        wksp      floating point workspace of length n */
/*        iwksp     integer workspace of length 2*n */
/*        isym      symmetric storage switch */
/*                   = 0    symmetric storage */
/*                   = 1    nonsymmetric storage */

/* ... specifications for parameters */



    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;
    jcnew_dim1 = *ncol;
    jcnew_offset = 1 + jcnew_dim1;
    jcnew -= jcnew_offset;
    --nc;
    --p;
    --ip;
    --maxnew;
    --wksp;
    --iwksp;

    /* Function Body */
    n = *nn;
    ncolor = *ncol;

/* ... set up pointer vector. */

    i__1 = *maxnz;
    for (j = 1; j <= i__1; ++j) {
	jcol = jcoef[j];
	iwksp[n + jcol] = j;
/* L10: */
    }

/* ... permute rows of matrix first. */

    i__1 = *maxd;
    for (j = 1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L12: */
	    wksp[i__] = coef[i__ + j * coef_dim1];
	}
	vscatr_(&n, &wksp[1], &ip[1], &coef[j * coef_dim1 + 1]);
/* L15: */
    }

/* ... rearrange rows. */

    ist = 1;
    i__1 = ncolor;
    for (k = 1; k <= i__1; ++k) {
	ncc = nc[k];
	ied = ist + ncc - 1;
	lim = maxnew[k];
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
	    iip = ip[i__];
	    i__3 = *maxd;
	    for (j = 2; j <= i__3; ++j) {
		wksp[j] = coef[iip + j * coef_dim1];
		coef[iip + j * coef_dim1] = 0.;
/* L20: */
	    }
	    i__3 = lim;
	    for (j = 2; j <= i__3; ++j) {
		if (wksp[j] == 0.) {
		    goto L25;
		}
		jcol = ip[i__ + jcnew[k + j * jcnew_dim1]] - iip;
		l = iwksp[n + jcol];
		coef[iip + l * coef_dim1] = wksp[j];
L25:
		;
	    }
/* L30: */
	}
	ist += ncc;
/* L35: */
    }

/* ... zero out lower triangular matrix if symmeteric storage used. */

    if (*isym != 0) {
	return 0;
    }
    maxold = (*maxnz + 1) / 2;
    mp1 = maxold + 1;
    i__1 = *maxnz;
    for (j = mp1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L40: */
	    coef[i__ + j * coef_dim1] = 0.;
	}
	jcoef[j] = 0;
/* L45: */
    }
    *maxnz = maxold;
    return 0;
} /* unpmdg_ */

/* Subroutine */ int uscal1_(integer *nn, integer *ndim, integer *maxnzz,
	integer *jcoef, doublereal *coef, doublereal *rhs, doublereal *u,
	doublereal *ubar, doublereal *diag, doublereal *work, integer *iflag)
{
    /* System generated locals */
    integer jcoef_dim1, jcoef_offset, coef_dim1, coef_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, n, maxnz;
    extern /* Subroutine */ int vgathr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... uscal1 reverses the scaling done in routine scal1.  diag must */
/*     contain upon input the output from scal1. */
/*     (purdue data structure) */

/* ... parameters -- */

/*         n       dimension of matrix */
/*         ndim    row dimension of coef array in defining routine */
/*         maxnz   number of columns in coef array */
/*         jcoef   integer matrix representation array */
/*         coef    matrix representation array */
/*         rhs     right hand side of matrix problem */
/*         u       latest estimate of solution */
/*         ubar    exact solution (optional) */
/*         diag    vector of the same name from scal1 routine */
/*         work    work array of length n (volatile) */
/*         iflag   flag for ubar */
/*                  = 0  do not unscale ubar */
/*                  = 1  unscale ubar */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    jcoef_dim1 = *ndim;
    jcoef_offset = 1 + jcoef_dim1;
    jcoef -= jcoef_offset;
    --rhs;
    --u;
    --ubar;
    --diag;
    --work;

    /* Function Body */
    n = *nn;
    maxnz = *maxnzz;

/* ... unscale u and rhs arrays. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	u[i__] = diag[i__] * u[i__];
    }
    if (*iflag == 0) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	ubar[i__] = diag[i__] * ubar[i__];
    }
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	diag[i__] = 1. / diag[i__];
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	rhs[i__] = diag[i__] * rhs[i__];
    }

/* ... unscale matrix. */

    if (itcom4_1.keygs == 2) {
	goto L45;
    }

/* ... using gathers. */

    i__1 = maxnz;
    for (j = 1; j <= i__1; ++j) {
	vgathr_(&n, &diag[1], &jcoef[j * jcoef_dim1 + 1], &work[1]);
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L35: */
	    coef[i__ + j * coef_dim1] = diag[i__] * coef[i__ + j * coef_dim1]
		    * work[i__];
	}
/* L40: */
    }
    return 0;

/* ... not using gathers. */

L45:
    i__1 = maxnz;
    for (j = 1; j <= i__1; ++j) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L50: */
	    coef[i__ + j * coef_dim1] = diag[i__] * coef[i__ + j * coef_dim1]
		    * diag[jcoef[i__ + j * jcoef_dim1]];
	}
/* L55: */
    }
    return 0;
} /* uscal1_ */

/* Subroutine */ int uscal2_(integer *nn, integer *ndim, integer *maxnz,
	integer *jcoef, doublereal *coef, doublereal *rhs, doublereal *u,
	doublereal *ubar, doublereal *diag, integer *iflag)
{
    /* System generated locals */
    integer coef_dim1, coef_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, n, ind, len;


/* ... uscal2 reverses the scaling done in routine scal2.  diag must */
/*     contain upon input the output from scal2. */
/*     (diagonal data structure) */

/* ... parameters -- */

/*         n       dimension of matrix */
/*         ndim    row dimension of coef array in defining routine */
/*         maxnz   number of columns in coef array */
/*         jcoef   integer matrix representation array */
/*         coef    matrix representation array */
/*         rhs     right hand side of matrix problem */
/*         u       latest estimate of solution */
/*         ubar    exact solution (optional) */
/*         diag    vector of the same name from scal2 routine */
/*         iflag   flag for ubar */
/*                  = 0  do not unscale ubar */
/*                  = 1  unscale ubar */

/* ... specifications for parameters */



    /* Parameter adjustments */
    coef_dim1 = *ndim;
    coef_offset = 1 + coef_dim1;
    coef -= coef_offset;
    --jcoef;
    --rhs;
    --u;
    --ubar;
    --diag;

    /* Function Body */
    n = *nn;

/* ... unscale u and rhs arrays. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	u[i__] = diag[i__] * u[i__];
    }
    if (*iflag == 0) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	ubar[i__] = diag[i__] * ubar[i__];
    }
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	diag[i__] = 1. / diag[i__];
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	rhs[i__] = diag[i__] * rhs[i__];
    }

/* ... unscale matrix. */

    i__1 = *maxnz;
    for (j = 1; j <= i__1; ++j) {
	ind = jcoef[j];
	len = n - abs(ind);
	if (ind < 0) {
	    goto L40;
	}
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L35: */
	    coef[i__ + j * coef_dim1] = diag[i__] * coef[i__ + j * coef_dim1]
		    * diag[i__ + ind];
	}
	goto L50;
L40:
	i__2 = len;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L45: */
	    coef[i__ - ind + j * coef_dim1] = diag[i__] * coef[i__ - ind + j *
		     coef_dim1] * diag[i__ - ind];
	}
L50:
	;
    }
    return 0;
} /* uscal2_ */

/* Subroutine */ int uscal3_(integer *nn, integer *nz, integer *ia, integer *
	ja, doublereal *a, doublereal *rhs, doublereal *u, doublereal *ubar,
	doublereal *diag, doublereal *work, integer *iflag)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n, ied, len, ist;
    extern /* Subroutine */ int vgathr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... uscal3 reverses the scaling done in routine scal3.  diag must */
/*     contain upon input the output from scal3. */
/*     (sparse data structure) */

/* ... parameters -- */

/*         n       dimension of matrix */
/*         nz      length of the vectors a, ia, and ja */
/*         a       vector of matrix coefficients */
/*         ia      vector of i values */
/*         ja      vector of j values */
/*         rhs     right hand side of matrix problem */
/*         u       latest estimate of solution */
/*         ubar    exact solution (optional) */
/*         diag    vector of the same name from scal3 routine */
/*         work    work array of length n (volatile) */
/*         iflag   flag for ubar */
/*                  = 0  do not unscale ubar */
/*                  = 1  unscale ubar */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --work;
    --diag;
    --ubar;
    --u;
    --rhs;
    --a;
    --ja;
    --ia;

    /* Function Body */
    n = *nn;

/* ... unscale u and rhs arrays. */

    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	u[i__] = diag[i__] * u[i__];
    }
    if (*iflag == 0) {
	goto L20;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	ubar[i__] = diag[i__] * ubar[i__];
    }
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	diag[i__] = 1. / diag[i__];
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	rhs[i__] = diag[i__] * rhs[i__];
    }

/* ... unscale matrix. */

    if (itcom4_1.keygs == 2) {
	goto L50;
    }

/* ... using gathers. */

    ist = 1;
L35:
/* Computing MIN */
    i__1 = ist - 1 + n;
    ied = min(i__1,*nz);
    if (ied < ist) {
	return 0;
    }
    len = ied - ist + 1;
    vgathr_(&len, &diag[1], &ia[ist], &work[1]);
    i__1 = ied;
    for (i__ = ist; i__ <= i__1; ++i__) {
/* L40: */
	a[i__] *= work[i__ - ist + 1];
    }
    vgathr_(&len, &diag[1], &ja[ist], &work[1]);
    i__1 = ied;
    for (i__ = ist; i__ <= i__1; ++i__) {
/* L45: */
	a[i__] *= work[i__ - ist + 1];
    }
    ist = ied + 1;
    goto L35;

/* ... not using gathers. */

L50:
    i__1 = *nz;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L55: */
	a[i__] = a[i__] * diag[ia[i__]] * diag[ja[i__]];
    }
    return 0;
} /* uscal3_ */

/* Subroutine */ int vaddd_(integer *lda, integer *ldja, integer *nn, integer
	*m, integer *mdiagg, doublereal *a, integer *ja, doublereal *y,
	doublereal *x, integer *jofff)
{
    /* System generated locals */
    integer a_dim1, a_offset, ja_dim1, ja_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, l, n, lp1, ied, ind, ist, joff, mdiag;


/* ... vaddd computes  y = y + a*x */

/*     (diagonal storage) */

/* ... parameters -- */

/*         lda      leading dimension of a array */
/*         ldja     leading dimension of ja array */
/*         n        active row size of matrix */
/*         m        active column size of matrix */
/*         mdiag    number of diagonals in a */
/*         a        array of matrix diagonals */
/*         ja       array of matrix diagonal numbers */
/*         y,x      vectors of length n */
/*         joff     offset for diagonal numbers */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    ja_dim1 = *ldja;
    ja_offset = 1 + ja_dim1;
    ja -= ja_offset;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    mdiag = *mdiagg;
    joff = *jofff;
    if (mdiag < 1) {
	return 0;
    }
    if (itcom4_1.keyzer == 1) {
	goto L20;
    }
    i__1 = mdiag;
    for (j = 1; j <= i__1; ++j) {
	ind = ja[j * ja_dim1 + 1] - joff;
/* Computing MAX */
	i__2 = 1, i__3 = 1 - ind;
	ist = max(i__2,i__3);
/* Computing MIN */
	i__2 = n, i__3 = *m - ind;
	ied = min(i__2,i__3);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L10: */
	    y[i__] += a[i__ + j * a_dim1] * x[i__ + ind];
	}
/* L15: */
    }
    return 0;

/* ... unrolled version (requires memory to be zeroed out). */

L20:
    l = mdiag % 4;
    if (l == 0) {
	goto L60;
    }

/* ... initial short computations */

    switch (l) {
	case 1:  goto L25;
	case 2:  goto L35;
	case 3:  goto L45;
    }
L25:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	y[i__] += a[i__ + a_dim1] * x[i__ + ja[ja_dim1 + 1] - joff];
    }
    goto L55;
L35:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L40: */
	y[i__] = y[i__] + a[i__ + a_dim1] * x[i__ + ja[ja_dim1 + 1] - joff] +
		a[i__ + (a_dim1 << 1)] * x[i__ + ja[(ja_dim1 << 1) + 1] -
		joff];
    }
    goto L55;
L45:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L50: */
	y[i__] = y[i__] + a[i__ + a_dim1] * x[i__ + ja[ja_dim1 + 1] - joff] +
		a[i__ + (a_dim1 << 1)] * x[i__ + ja[(ja_dim1 << 1) + 1] -
		joff] + a[i__ + a_dim1 * 3] * x[i__ + ja[ja_dim1 * 3 + 1] -
		joff];
    }
L55:
    if (mdiag <= 4) {
	return 0;
    }

/* ... loop unrolling to a level of 4. */

L60:
    lp1 = l + 1;
    i__1 = mdiag;
    for (j = lp1; j <= i__1; j += 4) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L65: */
	    y[i__] = y[i__] + a[i__ + j * a_dim1] * x[i__ + ja[j * ja_dim1 +
		    1] - joff] + a[i__ + (j + 1) * a_dim1] * x[i__ + ja[(j +
		    1) * ja_dim1 + 1] - joff] + a[i__ + (j + 2) * a_dim1] * x[
		    i__ + ja[(j + 2) * ja_dim1 + 1] - joff] + a[i__ + (j + 3)
		    * a_dim1] * x[i__ + ja[(j + 3) * ja_dim1 + 1] - joff];
	}
/* L70: */
    }
    return 0;
} /* vaddd_ */

/* Subroutine */ int vadddt_(integer *lda, integer *ldja, integer *nn,
	integer *m, integer *mdiagg, doublereal *a, integer *ja, doublereal *
	y, doublereal *x, integer *jofff)
{
    /* System generated locals */
    integer a_dim1, a_offset, ja_dim1, ja_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, n, ied, ind, ist, joff, mdiag;


/* ... vadddt computes  y = y + (a**t)*x */

/*     (diagonal storage) */

/* ... parameters -- */

/*         lda      leading dimension of a array */
/*         ldja     leading dimension of ja array */
/*         n        active row size of matrix */
/*         m        active column size of matrix */
/*         mdiag    number of diagonals in a */
/*         a        array of matrix diagonals */
/*         ja       array of matrix diagonal numbers */
/*         y,x      vectors of length n */
/*         joff     offset for diagonal numbers */

/* ... specifications for parameters */


    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    ja_dim1 = *ldja;
    ja_offset = 1 + ja_dim1;
    ja -= ja_offset;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    mdiag = *mdiagg;
    joff = *jofff;
    if (mdiag < 1) {
	return 0;
    }
    i__1 = mdiag;
    for (j = 1; j <= i__1; ++j) {
	ind = ja[j * ja_dim1 + 1] - joff;
/* Computing MAX */
	i__2 = 1, i__3 = 1 - ind;
	ist = max(i__2,i__3);
/* Computing MIN */
	i__2 = n, i__3 = *m - ind;
	ied = min(i__2,i__3);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L10: */
	    y[i__ + ind] += a[i__ + j * a_dim1] * x[i__];
	}
/* L15: */
    }
    return 0;
} /* vadddt_ */

/* Subroutine */ int vaddp_(integer *ndimr, integer *ndimi, integer *nn,
	integer *mm, doublereal *a, integer *ja, doublereal *y, doublereal *x,
	 doublereal *wksp)
{
    /* System generated locals */
    integer a_dim1, a_offset, ja_dim1, ja_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, l, m, n, lp1;
    extern /* Subroutine */ int vgathr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... vaddp does  y = y + a*x  (purdue format) */

/* ... parameters -- */

/*       ndimr     row dimension of a array */
/*       ndimi     row dimension of ja array */
/*       n         order of system */
/*       m         number of columns in a and ja arrays */
/*       a         floating point array of active size n by m */
/*       ja        integer array of active size n by m */
/*       y         accumulation vector */
/*       x         right-hand-side vector */
/*       wksp      workspace vector of length n  (keygs = 1 only) */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    a_dim1 = *ndimr;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    ja_dim1 = *ndimi;
    ja_offset = 1 + ja_dim1;
    ja -= ja_offset;
    --y;
    --x;
    --wksp;

    /* Function Body */
    n = *nn;
    m = *mm;
    if (m <= 0) {
	return 0;
    }
    if (itcom4_1.keygs == 1) {
	goto L100;
    }

/* ... implicit gathers. */

    l = m % 4;
    if (l == 0) {
	goto L45;
    }

/* ... initial short computations */

    switch (l) {
	case 1:  goto L10;
	case 2:  goto L20;
	case 3:  goto L30;
    }
L10:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	y[i__] += a[i__ + a_dim1] * x[ja[i__ + ja_dim1]];
    }
    goto L40;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	y[i__] = y[i__] + a[i__ + a_dim1] * x[ja[i__ + ja_dim1]] + a[i__ + (
		a_dim1 << 1)] * x[ja[i__ + (ja_dim1 << 1)]];
    }
    goto L40;
L30:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L35: */
	y[i__] = y[i__] + a[i__ + a_dim1] * x[ja[i__ + ja_dim1]] + a[i__ + (
		a_dim1 << 1)] * x[ja[i__ + (ja_dim1 << 1)]] + a[i__ + a_dim1 *
		 3] * x[ja[i__ + ja_dim1 * 3]];
    }
L40:
    if (m <= 4) {
	return 0;
    }

/* ... loop unrolling to a level of 4. */

L45:
    lp1 = l + 1;
    i__1 = m;
    for (j = lp1; j <= i__1; j += 4) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L50: */
	    y[i__] = y[i__] + a[i__ + j * a_dim1] * x[ja[i__ + j * ja_dim1]]
		    + a[i__ + (j + 1) * a_dim1] * x[ja[i__ + (j + 1) *
		    ja_dim1]] + a[i__ + (j + 2) * a_dim1] * x[ja[i__ + (j + 2)
		     * ja_dim1]] + a[i__ + (j + 3) * a_dim1] * x[ja[i__ + (j
		    + 3) * ja_dim1]];
	}
/* L55: */
    }
    return 0;

/* ... explicit gathers. */

L100:
    i__1 = m;
    for (j = 1; j <= i__1; ++j) {
	vgathr_(&n, &x[1], &ja[j * ja_dim1 + 1], &wksp[1]);
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L105: */
	    y[i__] += a[i__ + j * a_dim1] * wksp[i__];
	}
/* L110: */
    }
    return 0;
} /* vaddp_ */

/* Subroutine */ int vaddpt_(integer *ndimr, integer *ndimi, integer *n,
	integer *m, doublereal *a, integer *ja, doublereal *y, doublereal *x,
	doublereal *wksp)
{
    /* System generated locals */
    integer a_dim1, a_offset, ja_dim1, ja_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j;


/* ... vaddpt does  y = y + (a**t)*x  (purdue format) */

/* ... parameters -- */

/*       ndimr     row dimension of a array */
/*       ndimi     row dimension of ja array */
/*       n         order of system */
/*       m         number of columns in a and ja arrays */
/*       a         floating point array of active size n by m */
/*       ja        integer array of active size n by m */
/*       y         accumulation vector */
/*       x         right-hand-side vector */
/*       wksp      workspace vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    a_dim1 = *ndimr;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    ja_dim1 = *ndimi;
    ja_offset = 1 + ja_dim1;
    ja -= ja_offset;
    --y;
    --x;
    --wksp;

    /* Function Body */
    if (*m <= 0) {
	return 0;
    }

    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    y[ja[i__ + j * ja_dim1]] += a[i__ + j * a_dim1] * x[i__];
/* L15: */
	}
/* L20: */
    }
    return 0;
} /* vaddpt_ */

/* Subroutine */ int vadds_(integer *mm, integer *np, integer *ia, integer *
	ja, doublereal *a, doublereal *y, doublereal *x, doublereal *wksp)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__, k, m, ied, nel, ist;
    extern /* Subroutine */ int vgathr_(integer *, doublereal *, integer *,
	    doublereal *), vscatr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... vadds does  y = y + a*x  (sparse format) */

/* ... parameters -- */

/*       m         number of partitions */
/*       np        partition pointers */
/*       ia        vector of i values */
/*       ja        vector of j values */
/*       a         vector of coefficients */
/*       y         accumulation vector */
/*       x         right-hand-side vector */
/*       wksp      workspace vector of length 2*n  (keygs = 1 only) */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --wksp;
    --x;
    --y;
    --a;
    --ja;
    --ia;
    --np;

    /* Function Body */
    m = *mm;
    if (m <= 0) {
	return 0;
    }
    if (itcom4_1.keygs == 1) {
	goto L20;
    }

/* ... implicit gathers. */

    i__1 = m;
    for (k = 1; k <= i__1; ++k) {
	ist = np[k];
	ied = np[k + 1] - 1;
/* dir$ ivdep */
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L10: */
	    y[ia[i__]] += a[i__] * x[ja[i__]];
	}
/* L15: */
    }
    return 0;

/* ... explicit gathers. */

L20:
    i__1 = m;
    for (k = 1; k <= i__1; ++k) {
	ist = np[k];
	nel = np[k + 1] - ist;
	vgathr_(&nel, &x[1], &ja[ist], &wksp[1]);
	vgathr_(&nel, &y[1], &ia[ist], &wksp[nel + 1]);
	i__2 = nel;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L25: */
	    wksp[i__] = wksp[nel + i__] + a[ist + i__ - 1] * wksp[i__];
	}
	vscatr_(&nel, &wksp[1], &ia[ist], &y[1]);
/* L30: */
    }
    return 0;
} /* vadds_ */

/* Subroutine */ int vcopy_(integer *n, doublereal *x, doublereal *y)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;


/* ... vcopy copies vector x to vector y. */

/* ... parameters -- */

/*          n       length of vectors */
/*          x,y     vectors of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --y;
    --x;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	y[i__] = x[i__];
    }
    return 0;
} /* vcopy_ */

doublereal vdot_(integer *n, doublereal *x, doublereal *y)
{
    /* System generated locals */
    integer i__1;
    doublereal ret_val;

    /* Local variables */
    static integer i__;


/* ... vdot computes the dot product of vectors x and y. */

/* ... parameters -- */

/*          n       length of vectors */
/*          x,y     vectors of length n */

/* ... specifications for parameters */



    /* Parameter adjustments */
    --y;
    --x;

    /* Function Body */
    ret_val = 0.;
    if (*n <= 0) {
	return ret_val;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
	ret_val += x[i__] * y[i__];
    }
    return ret_val;
} /* vdot_ */

/* Subroutine */ int vexopy_(integer *nn, doublereal *v, doublereal *x,
	doublereal *y, integer *icode)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;


/* ... vexopy computes  v = x  op  y  where v, x, and y are vectors */
/* ... and op is one of the operations  + - * / . */

/* ... parameters -- */

/*          n       length of vectors  (= nn) */
/*          v,x,y   vectors of length n */
/*          icode   key indicating operation */
/*            = 1      for addition */
/*            = 2      for subtraction */
/*            = 3      for multiplication */
/*            = 4      for division */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --y;
    --x;
    --v;

    /* Function Body */
    n = *nn;
    if (n <= 0) {
	return 0;
    }
    switch (*icode) {
	case 1:  goto L10;
	case 2:  goto L20;
	case 3:  goto L30;
	case 4:  goto L40;
    }

/* ... compute   v = x + y */

L10:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	v[i__] = x[i__] + y[i__];
    }
    return 0;

/* ... compute   v = x - y */

L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	v[i__] = x[i__] - y[i__];
    }
    return 0;

/* ... compute   v = x * y */

L30:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L35: */
	v[i__] = x[i__] * y[i__];
    }
    return 0;

/* ... compute   v = x / y */

L40:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L45: */
	v[i__] = x[i__] / y[i__];
    }
    return 0;
} /* vexopy_ */

/* Subroutine */ int vfill_(integer *n, doublereal *v, doublereal *val)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;


/*     vfill fills a vector, v, with a constant value, val. */

/* ... parameters -- */

/*          n      integer length of vector v */
/*          v      vector */
/*          val    constant that fills first n locations of v */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --v;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	v[i__] = *val;
    }
    return 0;
} /* vfill_ */

/* Subroutine */ int vgathi_(integer *n, integer *ja, integer *ia, integer *
	jb)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;


/* ... vgathi gathers elements from array ja according to index */
/* ... list ia and places them into consecutive locations in */
/* ... array jb. */

/* ... parameters -- */

/*          n        order of arrays ia and jb */
/*          ja       integer array of source elements */
/*          ia       integer array of length n giving desired */
/*                      elements of array ja */
/*          jb       integer target array of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --jb;
    --ia;
    --ja;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	jb[i__] = ja[ia[i__]];
    }

/* 205  jb(1;n) = q8vgathr (ja(1;n),ia(1;n);jb(1;n)) */
/* ray1 call gather (n,jb,ja,ia) */

    return 0;
} /* vgathi_ */

/* Subroutine */ int vgathr_(integer *n, doublereal *a, integer *ia,
	doublereal *b)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;


/* ... vgathr gathers elements from array a according to index */
/* ... list ia and places them into consecutive locations in */
/* ... array b. */

/* ... parameters -- */

/*          n       order of arrays ia and b */
/*          a       array of source elements */
/*          ia      integer array of length n giving desired */
/*                     elements of array a */
/*          b       target array of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --b;
    --ia;
    --a;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	b[i__] = a[ia[i__]];
    }

/* 205  b(1;n) = q8vgathr (a(1;n),ia(1;n);b(1;n)) */
/* ray1 call gather (n,b,a,ia) */

    return 0;
} /* vgathr_ */

/* Subroutine */ int vinv_(integer *nn, doublereal *v)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;


/* ... vinv computes   v = 1/v */

/* ... parameters -- */

/*        n       length of vector (= nn) */
/*        v       input/output vector of length n. */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --v;

    /* Function Body */
    n = *nn;
    if (n <= 0) {
	return 0;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	v[i__] = 1. / v[i__];
    }
    return 0;
} /* vinv_ */

doublereal vmax_(integer *n, doublereal *v)
{
    /* System generated locals */
    integer i__1;
    doublereal ret_val;

    /* Local variables */
    static integer i__;


/* ... vmax determaxes the maximum algebraic element of vector v. */

/* ... parameters -- */

/*        n     length of vector */
/*        v     floating point vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --v;

    /* Function Body */
    ret_val = v[1];
    if (*n <= 1) {
	return ret_val;
    }
    i__1 = *n;
    for (i__ = 2; i__ <= i__1; ++i__) {
	if (v[i__] > ret_val) {
	    ret_val = v[i__];
	}
    }
    return ret_val;
} /* vmax_ */

doublereal vmin_(integer *n, doublereal *v)
{
    /* System generated locals */
    integer i__1;
    doublereal ret_val;

    /* Local variables */
    static integer i__;


/* ... vmin determines the minimum algebraic element of vector v. */

/* ... parameters -- */

/*        n     length of vector */
/*        v     floating point vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --v;

    /* Function Body */
    ret_val = v[1];
    if (*n <= 1) {
	return ret_val;
    }
    i__1 = *n;
    for (i__ = 2; i__ <= i__1; ++i__) {
	if (v[i__] < ret_val) {
	    ret_val = v[i__];
	}
    }
    return ret_val;
} /* vmin_ */

/* Subroutine */ int vscati_(integer *n, integer *ja, integer *ia, integer *
	jb)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;


/* ... vscati scatters elements from consecutive locations in array */
/* ... ja to positions in array jb according to index list ia. */

/* ... parameters -- */

/*         n       order of arrays ia and ja */
/*         ja      integer array of source elements */
/*         ia      integer array of length n giving new locations */
/*                   in array jb. */
/*         jb      integer target array */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --jb;
    --ia;
    --ja;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	jb[ia[i__]] = ja[i__];
    }

/* 205  jb(1;n) = q8vscatr (ja(1;n),ia(1;n);jb(1;n)) */
/* ray1 call scatter (n,jb,ia,ja) */

    return 0;
} /* vscati_ */

/* Subroutine */ int vscatr_(integer *n, doublereal *a, integer *ia,
	doublereal *b)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;


/* ... vscatr scatters elements from consecutive locations in array a */
/* ... to positions in array b according to index list ia. */

/* ... parameters -- */

/*          n       order of arrays ia and a */
/*          a       array of source elements */
/*          ia      integer array of length n giving new locations */
/*                    in array b */
/*          b       target array */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --b;
    --ia;
    --a;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	b[ia[i__]] = a[i__];
    }

/* 205  b(1;n) = q8vscatr (a(1;n),ia(1;n);b(1;n)) */
/* ray1 call scatter (n,b,ia,a) */

    return 0;
} /* vscatr_ */

/* Subroutine */ int vsubd_(integer *lda, integer *ldja, integer *nn, integer
	*m, integer *mdiagg, doublereal *a, integer *ja, doublereal *y,
	doublereal *x, integer *jofff)
{
    /* System generated locals */
    integer a_dim1, a_offset, ja_dim1, ja_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, l, n, lp1, ied, ind, ist, joff, mdiag;


/* ... vsubd computes  y = y - a*x */

/*     (diagonal storage) */

/* ... parameters -- */

/*         lda      leading dimension of a array */
/*         ldja     leading dimension of ja array */
/*         n        active row size of matrix */
/*         m        active column size of matrix */
/*         mdiag    number of diagonals in a */
/*         a        array of matrix diagonals */
/*         ja       array of matrix diagonal numbers */
/*         y,x      vectors of length n */
/*         joff     offset for diagonal numbers */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    ja_dim1 = *ldja;
    ja_offset = 1 + ja_dim1;
    ja -= ja_offset;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    mdiag = *mdiagg;
    joff = *jofff;
    if (mdiag < 1) {
	return 0;
    }
    if (itcom4_1.keyzer == 1) {
	goto L20;
    }
    i__1 = mdiag;
    for (j = 1; j <= i__1; ++j) {
	ind = ja[j * ja_dim1 + 1] - joff;
/* Computing MAX */
	i__2 = 1, i__3 = 1 - ind;
	ist = max(i__2,i__3);
/* Computing MIN */
	i__2 = n, i__3 = *m - ind;
	ied = min(i__2,i__3);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L10: */
	    y[i__] -= a[i__ + j * a_dim1] * x[i__ + ind];
	}
/* L15: */
    }
    return 0;

/* ... unrolled version (requires memory to be zeroed out). */

L20:
    l = mdiag % 4;
    if (l == 0) {
	goto L60;
    }

/* ... initial short computations */

    switch (l) {
	case 1:  goto L25;
	case 2:  goto L35;
	case 3:  goto L45;
    }
L25:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L30: */
	y[i__] -= a[i__ + a_dim1] * x[i__ + ja[ja_dim1 + 1] - joff];
    }
    goto L55;
L35:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L40: */
	y[i__] = y[i__] - a[i__ + a_dim1] * x[i__ + ja[ja_dim1 + 1] - joff] -
		a[i__ + (a_dim1 << 1)] * x[i__ + ja[(ja_dim1 << 1) + 1] -
		joff];
    }
    goto L55;
L45:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L50: */
	y[i__] = y[i__] - a[i__ + a_dim1] * x[i__ + ja[ja_dim1 + 1] - joff] -
		a[i__ + (a_dim1 << 1)] * x[i__ + ja[(ja_dim1 << 1) + 1] -
		joff] - a[i__ + a_dim1 * 3] * x[i__ + ja[ja_dim1 * 3 + 1] -
		joff];
    }
L55:
    if (mdiag <= 4) {
	return 0;
    }

/* ... loop unrolling to a level of 4. */

L60:
    lp1 = l + 1;
    i__1 = mdiag;
    for (j = lp1; j <= i__1; j += 4) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L65: */
	    y[i__] = y[i__] - a[i__ + j * a_dim1] * x[i__ + ja[j * ja_dim1 +
		    1] - joff] - a[i__ + (j + 1) * a_dim1] * x[i__ + ja[(j +
		    1) * ja_dim1 + 1] - joff] - a[i__ + (j + 2) * a_dim1] * x[
		    i__ + ja[(j + 2) * ja_dim1 + 1] - joff] - a[i__ + (j + 3)
		    * a_dim1] * x[i__ + ja[(j + 3) * ja_dim1 + 1] - joff];
	}
/* L70: */
    }
    return 0;
} /* vsubd_ */

/* Subroutine */ int vsubdt_(integer *lda, integer *ldja, integer *nn,
	integer *m, integer *mdiagg, doublereal *a, integer *ja, doublereal *
	y, doublereal *x, integer *jofff)
{
    /* System generated locals */
    integer a_dim1, a_offset, ja_dim1, ja_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, n, ied, ind, ist, joff, mdiag;


/* ... vsubdt computes  y = y - (a**t)*x */

/*     (diagonal storage) */

/* ... parameters -- */

/*         lda      leading dimension of a array */
/*         ldja     leading dimension of ja array */
/*         n        active row size of matrix */
/*         m        active column size of matrix */
/*         mdiag    number of diagonals in a */
/*         a        array of matrix diagonals */
/*         ja       array of matrix diagonal numbers */
/*         y,x      vectors of length n */
/*         joff     offset for diagonal numbers */

/* ... specifications for parameters */


    /* Parameter adjustments */
    a_dim1 = *lda;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    ja_dim1 = *ldja;
    ja_offset = 1 + ja_dim1;
    ja -= ja_offset;
    --y;
    --x;

    /* Function Body */
    n = *nn;
    mdiag = *mdiagg;
    joff = *jofff;
    if (mdiag < 1) {
	return 0;
    }
    i__1 = mdiag;
    for (j = 1; j <= i__1; ++j) {
	ind = ja[j * ja_dim1 + 1] - joff;
/* Computing MAX */
	i__2 = 1, i__3 = 1 - ind;
	ist = max(i__2,i__3);
/* Computing MIN */
	i__2 = n, i__3 = *m - ind;
	ied = min(i__2,i__3);
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L10: */
	    y[i__ + ind] -= a[i__ + j * a_dim1] * x[i__];
	}
/* L15: */
    }
    return 0;
} /* vsubdt_ */

/* Subroutine */ int vsubp_(integer *ndimr, integer *ndimi, integer *nn,
	integer *mm, doublereal *a, integer *ja, doublereal *y, doublereal *x,
	 doublereal *wksp)
{
    /* System generated locals */
    integer a_dim1, a_offset, ja_dim1, ja_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j, l, m, n, lp1;
    extern /* Subroutine */ int vgathr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... vsubp does  y = y - a*x  (purdue format) */

/* ... parameters -- */

/*       ndimr     row dimension of a array */
/*       ndimi     row dimension of ja array */
/*       n         order of system */
/*       m         number of columns in a and ja arrays */
/*       a         floating point array of active size n by m */
/*       ja        integer array of active size n by m */
/*       y         accumulation vector */
/*       x         right-hand-side vector */
/*       wksp      workspace vector of length n  (keygs = 1 only) */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    a_dim1 = *ndimr;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    ja_dim1 = *ndimi;
    ja_offset = 1 + ja_dim1;
    ja -= ja_offset;
    --y;
    --x;
    --wksp;

    /* Function Body */
    n = *nn;
    m = *mm;
    if (m <= 0) {
	return 0;
    }
    if (itcom4_1.keygs == 1) {
	goto L100;
    }

/* ... implicit gathers. */

    l = m % 4;
    if (l == 0) {
	goto L45;
    }

/* ... initial short computations */

    switch (l) {
	case 1:  goto L10;
	case 2:  goto L20;
	case 3:  goto L30;
    }
L10:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L15: */
	y[i__] -= a[i__ + a_dim1] * x[ja[i__ + ja_dim1]];
    }
    goto L40;
L20:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L25: */
	y[i__] = y[i__] - a[i__ + a_dim1] * x[ja[i__ + ja_dim1]] - a[i__ + (
		a_dim1 << 1)] * x[ja[i__ + (ja_dim1 << 1)]];
    }
    goto L40;
L30:
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L35: */
	y[i__] = y[i__] - a[i__ + a_dim1] * x[ja[i__ + ja_dim1]] - a[i__ + (
		a_dim1 << 1)] * x[ja[i__ + (ja_dim1 << 1)]] - a[i__ + a_dim1 *
		 3] * x[ja[i__ + ja_dim1 * 3]];
    }
L40:
    if (m <= 4) {
	return 0;
    }

/* ... loop unrolling to a level of 4. */

L45:
    lp1 = l + 1;
    i__1 = m;
    for (j = lp1; j <= i__1; j += 4) {
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L50: */
	    y[i__] = y[i__] - a[i__ + j * a_dim1] * x[ja[i__ + j * ja_dim1]]
		    - a[i__ + (j + 1) * a_dim1] * x[ja[i__ + (j + 1) *
		    ja_dim1]] - a[i__ + (j + 2) * a_dim1] * x[ja[i__ + (j + 2)
		     * ja_dim1]] - a[i__ + (j + 3) * a_dim1] * x[ja[i__ + (j
		    + 3) * ja_dim1]];
	}
/* L55: */
    }
    return 0;

/* ... explicit gathers. */

L100:
    i__1 = m;
    for (j = 1; j <= i__1; ++j) {
	vgathr_(&n, &x[1], &ja[j * ja_dim1 + 1], &wksp[1]);
	i__2 = n;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L105: */
	    y[i__] -= a[i__ + j * a_dim1] * wksp[i__];
	}
/* L110: */
    }
    return 0;
} /* vsubp_ */

/* Subroutine */ int vsubpt_(integer *ndimr, integer *ndimi, integer *n,
	integer *m, doublereal *a, integer *ja, doublereal *y, doublereal *x,
	doublereal *wksp)
{
    /* System generated locals */
    integer a_dim1, a_offset, ja_dim1, ja_offset, i__1, i__2;

    /* Local variables */
    static integer i__, j;


/* ... vsubpt does  y = y - (a**t)*x  (purdue format) */

/* ... parameters -- */

/*       ndimr     row dimension of a array */
/*       ndimi     row dimension of ja array */
/*       n         order of system */
/*       m         number of columns in a and ja arrays */
/*       a         floating point array of active size n by m */
/*       ja        integer array of active size n by m */
/*       y         accumulation vector */
/*       x         right-hand-side vector */
/*       wksp      workspace vector of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    a_dim1 = *ndimr;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    ja_dim1 = *ndimi;
    ja_offset = 1 + ja_dim1;
    ja -= ja_offset;
    --y;
    --x;
    --wksp;

    /* Function Body */
    if (*m <= 0) {
	return 0;
    }

    i__1 = *m;
    for (j = 1; j <= i__1; ++j) {
	i__2 = *n;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    y[ja[i__ + j * ja_dim1]] -= a[i__ + j * a_dim1] * x[i__];
/* L15: */
	}
/* L20: */
    }
    return 0;
} /* vsubpt_ */

/* Subroutine */ int vsubs_(integer *mm, integer *np, integer *ia, integer *
	ja, doublereal *a, doublereal *y, doublereal *x, doublereal *wksp)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__, k, m, ied, nel, ist;
    extern /* Subroutine */ int vgathr_(integer *, doublereal *, integer *,
	    doublereal *), vscatr_(integer *, doublereal *, integer *,
	    doublereal *);


/* ... vsubs does  y = y - a*x  (sparse format) */

/* ... parameters -- */

/*       m         number of partitions */
/*       np        partition pointers */
/*       ia        vector of i values */
/*       ja        vector of j values */
/*       a         vector of coefficients */
/*       y         accumulation vector */
/*       x         right-hand-side vector */
/*       wksp      workspace vector of length 2*n  (keygs = 1 only) */

/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

    /* Parameter adjustments */
    --wksp;
    --x;
    --y;
    --a;
    --ja;
    --ia;
    --np;

    /* Function Body */
    m = *mm;
    if (m <= 0) {
	return 0;
    }
    if (itcom4_1.keygs == 1) {
	goto L20;
    }

/* ... implicit gathers. */

    i__1 = m;
    for (k = 1; k <= i__1; ++k) {
	ist = np[k];
	ied = np[k + 1] - 1;
/* dir$ ivdep */
	i__2 = ied;
	for (i__ = ist; i__ <= i__2; ++i__) {
/* L10: */
	    y[ia[i__]] -= a[i__] * x[ja[i__]];
	}
/* L15: */
    }
    return 0;

/* ... explicit gathers. */

L20:
    i__1 = m;
    for (k = 1; k <= i__1; ++k) {
	ist = np[k];
	nel = np[k + 1] - ist;
	vgathr_(&nel, &x[1], &ja[ist], &wksp[1]);
	vgathr_(&nel, &y[1], &ia[ist], &wksp[nel + 1]);
	i__2 = nel;
	for (i__ = 1; i__ <= i__2; ++i__) {
/* L25: */
	    wksp[i__] = wksp[nel + i__] - a[ist + i__ - 1] * wksp[i__];
	}
	vscatr_(&nel, &wksp[1], &ia[ist], &y[1]);
/* L30: */
    }
    return 0;
} /* vsubs_ */

/* Subroutine */ int vtriad_(integer *n, doublereal *c__, doublereal *a,
	doublereal *con, doublereal *b, integer *icode)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;


/* ... vtriad computes    c = a + con*b    if  icode = 1 */
/*                        c = con*b        if  icode = 2 */

/* ... parameters -- */

/*        n         length of vectors */
/*        c,a,b     vectors of length n */
/*        con       multiplicative constant */
/*        icode     switch */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --b;
    --a;
    --c__;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    if (*icode == 2) {
	goto L15;
    }

/* ... compute    c = a + con*b */

    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	c__[i__] = a[i__] + *con * b[i__];
    }
    return 0;

/* ... compute    c = con*b */

L15:
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L20: */
	c__[i__] = *con * b[i__];
    }
    return 0;
} /* vtriad_ */

/* Subroutine */ int vsqrt_(integer *n, doublereal *v, doublereal *w)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static integer i__;


/* routine to compute square root of a matrix,   w = sqrt(v) */


    /* Parameter adjustments */
    --w;
    --v;

    /* Function Body */
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L1: */
	w[i__] = sqrt(v[i__]);
    }
    return 0;
} /* vsqrt_ */

/* Subroutine */ int vifill_(integer *n, integer *iv, integer *ival)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;


/* routine to fill an integer vector with a value. */

    /* Parameter adjustments */
    --iv;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L1: */
	iv[i__] = *ival;
    }
    return 0;
} /* vifill_ */

/* Subroutine */ int vicopy_(integer *n, integer *iv1, integer *iv2)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;


/* routine to copy one integer vector to another. */

    /* Parameter adjustments */
    --iv2;
    --iv1;

    /* Function Body */
    if (*n <= 0) {
	return 0;
    }
    i__1 = *n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L1: */
	iv2[i__] = iv1[i__];
    }
    return 0;
} /* vicopy_ */

/* Subroutine */ int vemxty_(integer *nn, doublereal *v, doublereal *x,
	doublereal *y)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, n;


/* ... vemxty computes  v = -x * y  where v, x, and y are vectors */

/* ... parameters -- */

/*          n       length of vectors  (= nn) */
/*          v,x,y   vectors of length n */

/* ... specifications for parameters */


    /* Parameter adjustments */
    --y;
    --x;
    --v;

    /* Function Body */
    n = *nn;
    if (n <= 0) {
	return 0;
    }
    i__1 = n;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	v[i__] = -x[i__] * y[i__];
    }
    return 0;
} /* vemxty_ */

/* Subroutine */ int vsrta1_(integer *nz, integer *ia, integer *ja,
	doublereal *a)
{
    static integer i__, j, k, l, m;
    static doublereal r__, t;
    static integer ij, il[21], it, iu[21], jt;
    static doublereal tt;
    static integer itt, jtt;


/*   imsl routine name   - vsrta */

/* ----------------------------------------------------------------------- */

/*   purpose             - sorting of the sparse data structure by */
/*                          rows first and then by columns within */
/*                          rows */

/*   usage               - call vsrta1 (nz,ia,ja,a) */

/*   arguments    ia     - on input, ia contains the i values of */
/*                          the array to be sorted. */
/*                         on output, ia contains the i values of */
/*                          the sorted array. */
/*                ja     - on input, ja contains the j values of */
/*                          the array to be sorted. */
/*                         on output, ja contains the j values of */
/*                          the sorted array. */
/*                a      - on input, a contains the coefficients */
/*                          of the array to be sorted. */
/*                         on output, a contains the coefficients */
/*                          of the sorted array. */
/*                nz     - input variable containing the number of */
/*                           elements in the array to be sorted. */

/*   precision/hardware  - single/all */

/*   reqd. imsl routines - none required */

/*   notation            - information on special notation and */
/*                           conventions is available in the manual */
/*                           introduction or through imsl routine uhelp */

/*   copyright           - 1978 by imsl, inc. all rights reserved. */

/*   warranty            - imsl warrants only that imsl testing has been */
/*                           applied to this code.  no other warranty, */
/*                           expressed or implied, is applicable. */

/* ----------------------------------------------------------------------- */
/*                                  specifications for arguments */
/*                                  specifications for local variables */


/*                                  first executable statement */
    /* Parameter adjustments */
    --a;
    --ja;
    --ia;

    /* Function Body */
    m = 1;
    i__ = 1;
    j = *nz;
    r__ = .375;
    if (*nz <= 0) {
	return 0;
    }
L10:
    if (i__ == j) {
	goto L55;
    }
    if (r__ > .5898437) {
	goto L20;
    }
    r__ += .0390625;
    goto L25;
L20:
    r__ += -.21875;
L25:
    k = i__;
/*                                  select a central element of the */
/*                                  array and save it in location t */
    ij = (integer) ((doublereal) i__ + (doublereal) (j - i__) * r__);
    t = a[ij];
    it = ia[ij];
    jt = ja[ij];
/*                                  if first element of array is greater */
/*                                  than t, interchange with t */
    if (ia[i__] < it || ia[i__] == it && ja[i__] <= jt) {
	goto L30;
    }
    ia[ij] = ia[i__];
    ia[i__] = it;
    it = ia[ij];
    ja[ij] = ja[i__];
    ja[i__] = jt;
    jt = ja[ij];
    a[ij] = a[i__];
    a[i__] = t;
    t = a[ij];
L30:
    l = j;
/*                                  if last element of array is less than */
/*                                  t, interchange with t */
    if (! (ia[j] < it || ia[j] == it && ja[j] < jt)) {
	goto L40;
    }
    ia[ij] = ia[j];
    ia[j] = it;
    it = ia[ij];
    ja[ij] = ja[j];
    ja[j] = jt;
    jt = ja[ij];
    a[ij] = a[j];
    a[j] = t;
    t = a[ij];
/*                                  if first element of array is greater */
/*                                  than t, interchange with t */
    if (ia[i__] < it || ia[i__] == it && ja[i__] <= jt) {
	goto L40;
    }
    ia[ij] = ia[i__];
    ia[i__] = it;
    it = ia[ij];
    ja[ij] = ja[i__];
    ja[i__] = jt;
    jt = ja[ij];
    a[ij] = a[i__];
    a[i__] = t;
    t = a[ij];
    goto L40;
L35:
    if (ia[l] == ia[k] && ja[l] == ja[k]) {
	goto L40;
    }
    itt = ia[l];
    ia[l] = ia[k];
    ia[k] = itt;
    jtt = ja[l];
    ja[l] = ja[k];
    ja[k] = jtt;
    tt = a[l];
    a[l] = a[k];
    a[k] = tt;
/*                                  find an element in the second half of */
/*                                  the array which is smaller than t */
L40:
    --l;
    if (! (ia[l] < it || ia[l] == it && ja[l] <= jt)) {
	goto L40;
    }
/*                                  find an element in the first half of */
/*                                  the array which is greater than t */
L45:
    ++k;
    if (ia[k] < it || ia[k] == it && ja[k] < jt) {
	goto L45;
    }
/*                                  interchange these elements */
    if (k <= l) {
	goto L35;
    }
/*                                  save upper and lower subscripts of */
/*                                  the array yet to be sorted */
    if (l - i__ <= j - k) {
	goto L50;
    }
    il[m - 1] = i__;
    iu[m - 1] = l;
    i__ = k;
    ++m;
    goto L60;
L50:
    il[m - 1] = k;
    iu[m - 1] = j;
    j = l;
    ++m;
    goto L60;
/*                                  begin again on another portion of */
/*                                  the unsorted array */
L55:
    --m;
    if (m == 0) {
	return 0;
    }
    i__ = il[m - 1];
    j = iu[m - 1];
L60:
    if (j - i__ >= 11) {
	goto L25;
    }
    if (i__ == 1) {
	goto L10;
    }
    --i__;
L65:
    ++i__;
    if (i__ == j) {
	goto L55;
    }
    it = ia[i__ + 1];
    jt = ja[i__ + 1];
    t = a[i__ + 1];
    if (ia[i__] < it || ia[i__] == it && ja[i__] <= jt) {
	goto L65;
    }
    k = i__;
L70:
    ia[k + 1] = ia[k];
    ja[k + 1] = ja[k];
    a[k + 1] = a[k];
    --k;
    if (it < ia[k] || it == ia[k] && jt < ja[k]) {
	goto L70;
    }
    ia[k + 1] = it;
    ja[k + 1] = jt;
    a[k + 1] = t;
    goto L65;
} /* vsrta1_ */

/* Subroutine */ int zbrent_(integer *n, doublereal *tri, doublereal *eps,
	integer *nsig, doublereal *aa, doublereal *bb, integer *maxfnn,
	integer *ier)
{
    /* System generated locals */
    doublereal d__1;

    /* Builtin functions */
    double pow_di(doublereal *, integer *), d_sign(doublereal *, doublereal *)
	    ;

    /* Local variables */
    static doublereal a, b, c__, d__, e, p, q, r__, s, t, fa, fb, fc;
    static integer ic;
    static doublereal rm, tol, rone, temp;
    static integer maxfn;
    extern doublereal determ_(integer *, doublereal *, doublereal *);
    extern /* Subroutine */ int ershow_(integer *, char *, ftnlen);

/*   modified imsl routine name   - zbrent */

/* ----------------------------------------------------------------------- */

/*   computer            - cdc/single */

/*   latest revision     - january 1, 1978 */

/*   purpose             - zero of a function which changes sign in a */
/*                           given interval (brent algorithm) */

/*   usage               - call zbrent (f,eps,nsig,a,b,maxfn,ier) */

/*   arguments    tri    - a tridiagonal matrix of order n */
/*                eps    - first convergence criterion (input).  a root, */
/*                           b, is accepted if abs(f(b)) is less than or */
/*                           equal to eps.  eps may be set to zero. */
/*                nsig   - second convergence criterion (input).  a root, */
/*                           b, is accepted if the current approximation */
/*                           agrees with the true solution to nsig */
/*                           significant digits. */
/*                a,b    - on input, the user must supply two points, a */
/*                           and b, such that f(a) and f(b) are opposite */
/*                           in sign. (= aa, bb) */
/*                           on output, both a and b are altered.  b */
/*                           will contain the best approximation to the */
/*                           root of f. see remark 1. */
/*                maxfn  - on input, maxfn should contain an upper bound */
/*                           on the number of function evaluations */
/*                           required for convergence.  on output, maxfn */
/*                           will contain the actual number of function */
/*                           evaluations used. (= maxfnn) */
/*                ier    - error parameter. (output) */
/*                         terminal error */
/*                           ier = 3 indicates the algorithm failed to */
/*                             converge in maxfn evaluations. */
/*                           ier = 4 indicates f(a) and f(b) have the */
/*                             same sign. */

/*   precision/hardware  - single and double/h32 */
/*                       - single/h36,h48,h60 */


/*   notation            - information on special notation and */
/*                           conventions is available in the manual */
/*                           introduction or through imsl routine uhelp */

/*   remarks  1.  let f(x) be the characteristic function of the matrix */
/*                tri evaluated at x. function determ evaluates f(x). */
/*                on exit from zbrent, when ier=0, a and b satisfy the */
/*                following, */
/*                f(a)*f(b) .le. 0, */
/*                abs(f(b)) .le. abs(f(a)), and */
/*                either abs(f(b)) .le. eps or */
/*                abs(a-b) .le. max(abs(b),0.1)*10.0**(-nsig). */
/*                the presence of 0.1 in this error criterion causes */
/*                leading zeroes to the right of the decimal point to be */
/*                counted as significant digits. scaling may be required */
/*                in order to accurately determine a zero of small */
/*                magnitude. */
/*            2.  zbrent is guaranteed to reach convergence within */
/*                k = (dlog((b-a)/d)+1.0)**2 function evaluations where */
/*                  d=min(over x in (a,b) of */
/*                    max(abs(x),0.1)*10.0**(-nsig)). */
/*                this is an upper bound on the number of evaluations. */
/*                rarely does the actual number of evaluations used by */
/*                zbrent exceed sqrt(k). d can be computed as follows, */
/*                  p = min (abs(a),abs(b)) */
/*                  p = max (0.1,p) */
/*                  if ((a-0.1)*(b-0.1).lt.0.0) p = 0.1 */
/*                  d = p*10.0**(-nsig) */

/*   copyright           - 1977 by imsl, inc. all rights reserved. */

/*   warranty            - imsl warrants only that imsl testing has been */
/*                           applied to this code. no other warranty, */
/*                           expressed or implied, is applicable. */

/* ----------------------------------------------------------------------- */

/* ... specifications for parameters */



/* ... local package references -- */

/*          determ */
/*                                  first executable statement */
    /* Parameter adjustments */
    tri -= 3;

    /* Function Body */
    a = *aa;
    b = *bb;
    maxfn = *maxfnn;
    t = pow_di(&c_b4207, nsig);
    ic = 2;
    fa = determ_(n, &tri[3], &a);
    fb = determ_(n, &tri[3], &b);
    s = b;
/*                                  test for same sign */
    if (fa * fb > 0.) {
	goto L50;
    }
L5:
    c__ = a;
    fc = fa;
    d__ = b - c__;
    e = d__;
L10:
    if (abs(fc) >= abs(fb)) {
	goto L15;
    }
    a = b;
    b = c__;
    c__ = a;
    fa = fb;
    fb = fc;
    fc = fa;
L15:
/* Computing MAX */
    d__1 = abs(b);
    tol = t * max(d__1,.1);
    rm = (c__ - b) / 2.;
/*                                  test for first convergence criteria */
    if (abs(fb) <= *eps) {
	goto L40;
    }
/*                                  test for second convergence criteria */
    if ((d__1 = c__ - b, abs(d__1)) <= tol) {
	goto L40;
    }
/*                                  check evaluation counter */
    if (ic >= maxfn) {
	goto L45;
    }
/*                                  is bisection forced */
    if (abs(e) < tol) {
	goto L30;
    }
    if (abs(fa) <= abs(fb)) {
	goto L30;
    }
    s = fb / fa;
    if (a != c__) {
	goto L20;
    }
/*                                  linear interpolation */
    p = (c__ - b) * s;
    q = 1. - s;
    goto L25;
/*                                  inverse quadratic interpolation */
L20:
    q = fa / fc;
    r__ = fb / fc;
    rone = r__ - 1.;
    p = s * ((c__ - b) * q * (q - r__) - (b - a) * rone);
    q = (q - 1.) * rone * (s - 1.);
L25:
    if (p > 0.) {
	q = -q;
    }
    if (p < 0.) {
	p = -p;
    }
    s = e;
    e = d__;
/*                                  if abs(p/q).ge.75*abs(c-b) then */
/*                                     force bisection */
    if (p + p >= rm * 3. * q) {
	goto L30;
    }
/*                                  if abs(p/q).ge.0.5d0*abs(s) then force */
/*                                     bisection. s = the value of p/q */
/*                                     on the step before the last one */
    if (p + p >= (d__1 = s * q, abs(d__1))) {
	goto L30;
    }
    d__ = p / q;
    goto L35;
/*                                  bisection */
L30:
    e = rm;
    d__ = e;
/*                                  increment b */
L35:
    a = b;
    fa = fb;
    temp = d__;
    if (abs(temp) <= tol / 2.) {
	d__1 = tol / 2.;
	temp = d_sign(&d__1, &rm);
    }
    b += temp;
    s = b;
    fb = determ_(n, &tri[3], &s);
    ++ic;
    if (fb * fc <= 0.) {
	goto L10;
    }
    goto L5;
/*                                  convergence of b */
L40:
    a = c__;
    maxfn = ic;
    goto L9000;
/*                                  maxfn evaluations */
L45:
    *ier = 3;
    a = c__;
    maxfn = ic;
    ershow_(ier, "zbrent", (ftnlen)6);
    goto L9000;
/*                                  terminal error - f(a) and f(b) have */
/*                                  the same sign */
L50:
    *ier = 4;
    maxfn = ic;
    ershow_(ier, "zbrent", (ftnlen)6);
L9000:
    *aa = a;
    *bb = b;
    *maxfnn = maxfn;
    return 0;
} /* zbrent_ */

/* Subroutine */ int dfault_(integer *iparm, doublereal *rparm)
{

/* ... dfault sets the default values of iparm and rparm. */

/* ... parameters -- */

/*          iparm */
/*           and */
/*          rparm  arrays specifying options and tolerances */


/* ... specifications for parameters */


/* *** begin -- package common */


/* *** end   -- package common */

/*     description of variables in common blocks in main routine */

/*     srelpr  - computer precision (approx.) */
/*     if installer of package does not know srelpr value, */
/*     an approximate value can be determined from a simple */
/*     fortran program such as */

/*     srelpr = 1.0d0 */
/*  2  srelpr = 0.5d0*srelpr */
/*     temp = srelpr + 1.0d0 */
/*     if (temp .gt. 1.0d0) go to 2 */
/*     srelpr = 2.0d0*srelpr */
/*     write (6,3) srelpr */
/*  3  format (1x,'srelpr = ',d20.10) */
/*     stop */
/*     end */


/*     some values are- */

/*     srelpr = 7.1d-15   for cray x-mp  (approx.) 2**-47 */
/*            = 1.49d-8   for dec 10  (approx.) 2**-26 */
/*            = 1.192d-7  for vax 11/780 (approx) 2**-23 */
/*            = 4.768d-7  for ibm 370/158 */

/*             *** should be changed for other machines *** */

/*     to facilitate convergence, rparm(1) should be set to */
/*          500.*srelpr or larger */


    /* Parameter adjustments */
    --rparm;
    --iparm;

    /* Function Body */
    itcom4_1.srelpr = 7.1e-15;

/* ... keygs is a flag to specify how gather/scatter operations */
/*     are performed. */
/*       = 1    gather explicitly into a workspace vector */
/*       = 2    gather implicitly using indirect addressing */


    itcom4_1.keygs = 1;

/* ... keyzer is a flag to specify if memory has been zeroed out. */
/*     i.e., is the operation  0.0 * indefinite = 0.0  legal */
/*       = 0    not legal */
/*       = 1    legal */

    itcom4_1.keyzer = 0;


    iparm[1] = 2;
    iparm[2] = 100;
    iparm[3] = 0;
    iparm[4] = 6;
    iparm[5] = 0;
    iparm[6] = 1;
    iparm[7] = 1;
    iparm[8] = 1;
    iparm[9] = 5;
    iparm[10] = 100000;
    iparm[11] = 0;
    iparm[12] = 2;
    iparm[13] = 0;
    iparm[14] = 0;
    iparm[15] = 1;
    iparm[16] = 0;
    iparm[17] = 0;
    iparm[18] = 2;
    iparm[19] = -1;
    iparm[20] = -1;
    iparm[21] = 1;
    iparm[22] = 1;
    iparm[23] = 2;
    iparm[24] = 0;
    iparm[25] = 1;

    rparm[1] = 1e-6;
    rparm[2] = 2.;
    rparm[3] = 1.;
    rparm[4] = .75;
    rparm[5] = .75;
    rparm[6] = 0.;
    rparm[7] = 0.;
    rparm[8] = 0.;
    rparm[9] = 1.;
    rparm[10] = 0.;
    rparm[11] = .25;
    rparm[12] = 0.;
    rparm[13] = 0.;
    rparm[14] = 0.;
    rparm[15] = itcom4_1.srelpr * 500.;
    rparm[16] = 0.;

    return 0;
} /* dfault_ */

doublereal timer_(doublereal *timdmy)
{
    /* System generated locals */
    doublereal ret_val;

/* ... timer is a routine to return the execution time in */
/* ... seconds.  timer uses the fortran timing routine second. */

/* ... parameters -- */

/*          timdmy   dummy argument */


/*     note -- on many computer systems there is a cpu-time subprogram */
/*             which is more accurate than the fortran routine second. */


/*     use the following when using second */

/*     timer = second (0.0) */


/* ********************************************* */
/* **                                         ** */
/* **   this routine is not portable.         ** */
/* **                                         ** */
/* ********************************************* */

/* ... specifications for parameters */


    ret_val = time(NULL);

/*     real tarray(2) */
/*     time = dble(etime (tarray)) */

/*     call system_clock (count = icount, count_rate = irate) */
/*     timer = dble(icount) / dble(irate) */

    return ret_val;
} /* timer_ */
